{"version":3,"sources":["Lexer.js","../src/Lexer.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","CommonTokenFactory_1","require","IntegerStack_1","Interval_1","IntStream_1","LexerATNSimulator_1","LexerNoViableAltException_1","Decorators_1","Recognizer_1","Token_1","Lexer","input","_factory","CommonTokenFactory","DEFAULT","_tokenStartCharIndex","_tokenStartLine","_tokenStartCharPositionInLine","_hitEOF","_channel","_type","_modeStack","IntegerStack","_mode","DEFAULT_MODE","_input","_tokenFactorySourcePair","source","stream","resetInput","undefined","seek","_token","Token","INVALID_TYPE","DEFAULT_CHANNEL","_text","clear","interpreter","reset","Error","tokenStartMarker","mark","outer","emitEOF","index","charPositionInLine","line","ttype","match","e","LexerNoViableAltException","notifyListeners","recover","SKIP","LA","IntStream","EOF","MORE","emit","release","m","LexerATNSimulator","debug","console","log","push","mode","isEmpty","peek","pop","token","create","charIndex","cpos","eof","tokens","t","nextToken","type","text","getText","Interval","of","msg","getErrorDisplay","listener","getErrorListenerDispatch","syntaxError","s","String","fromCharCode","replace","re","consume","factory","sourceName","channel","HIDDEN_CHANNEL","Recognizer","MIN_CHAR_VALUE","MAX_CHAR_VALUE","Override","prototype"],"mappings":"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","file":"Lexer.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst CommonTokenFactory_1 = require(\"./CommonTokenFactory\");\nconst IntegerStack_1 = require(\"./misc/IntegerStack\");\nconst Interval_1 = require(\"./misc/Interval\");\nconst IntStream_1 = require(\"./IntStream\");\nconst LexerATNSimulator_1 = require(\"./atn/LexerATNSimulator\");\nconst LexerNoViableAltException_1 = require(\"./LexerNoViableAltException\");\nconst Decorators_1 = require(\"./Decorators\");\nconst Recognizer_1 = require(\"./Recognizer\");\nconst Token_1 = require(\"./Token\");\n/** A lexer is recognizer that draws input symbols from a character stream.\n *  lexer grammars result in a subclass of this object. A Lexer object\n *  uses simplified match() and error recovery mechanisms in the interest\n *  of speed.\n */\nclass Lexer extends Recognizer_1.Recognizer {\n    constructor(input) {\n        super();\n        /** How to create token objects */\n        this._factory = CommonTokenFactory_1.CommonTokenFactory.DEFAULT;\n        /** What character index in the stream did the current token start at?\n         *  Needed, for example, to get the text for current token.  Set at\n         *  the start of nextToken.\n         */\n        this._tokenStartCharIndex = -1;\n        /** The line on which the first character of the token resides */\n        this._tokenStartLine = 0;\n        /** The character position of first character within the line */\n        this._tokenStartCharPositionInLine = 0;\n        /** Once we see EOF on char stream, next token will be EOF.\n         *  If you have DONE : EOF ; then you see DONE EOF.\n         */\n        this._hitEOF = false;\n        /** The channel number for the current token */\n        this._channel = 0;\n        /** The token type for the current token */\n        this._type = 0;\n        this._modeStack = new IntegerStack_1.IntegerStack();\n        this._mode = Lexer.DEFAULT_MODE;\n        this._input = input;\n        this._tokenFactorySourcePair = { source: this, stream: input };\n    }\n    static get DEFAULT_TOKEN_CHANNEL() {\n        return Token_1.Token.DEFAULT_CHANNEL;\n    }\n    static get HIDDEN() {\n        return Token_1.Token.HIDDEN_CHANNEL;\n    }\n    reset(resetInput) {\n        // wack Lexer state variables\n        if (resetInput === undefined || resetInput) {\n            this._input.seek(0); // rewind the input\n        }\n        this._token = undefined;\n        this._type = Token_1.Token.INVALID_TYPE;\n        this._channel = Token_1.Token.DEFAULT_CHANNEL;\n        this._tokenStartCharIndex = -1;\n        this._tokenStartCharPositionInLine = -1;\n        this._tokenStartLine = -1;\n        this._text = undefined;\n        this._hitEOF = false;\n        this._mode = Lexer.DEFAULT_MODE;\n        this._modeStack.clear();\n        this.interpreter.reset();\n    }\n    /** Return a token from this source; i.e., match a token on the char\n     *  stream.\n     */\n    nextToken() {\n        if (this._input == null) {\n            throw new Error(\"nextToken requires a non-null input stream.\");\n        }\n        // Mark start location in char stream so unbuffered streams are\n        // guaranteed at least have text of current token\n        let tokenStartMarker = this._input.mark();\n        try {\n            outer: while (true) {\n                if (this._hitEOF) {\n                    return this.emitEOF();\n                }\n                this._token = undefined;\n                this._channel = Token_1.Token.DEFAULT_CHANNEL;\n                this._tokenStartCharIndex = this._input.index;\n                this._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;\n                this._tokenStartLine = this.interpreter.line;\n                this._text = undefined;\n                do {\n                    this._type = Token_1.Token.INVALID_TYPE;\n                    //\t\t\t\tSystem.out.println(\"nextToken line \"+tokenStartLine+\" at \"+((char)input.LA(1))+\n                    //\t\t\t\t\t\t\t\t   \" in mode \"+mode+\n                    //\t\t\t\t\t\t\t\t   \" at index \"+input.index);\n                    let ttype;\n                    try {\n                        ttype = this.interpreter.match(this._input, this._mode);\n                    }\n                    catch (e) {\n                        if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {\n                            this.notifyListeners(e); // report error\n                            this.recover(e);\n                            ttype = Lexer.SKIP;\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                    if (this._input.LA(1) === IntStream_1.IntStream.EOF) {\n                        this._hitEOF = true;\n                    }\n                    if (this._type === Token_1.Token.INVALID_TYPE) {\n                        this._type = ttype;\n                    }\n                    if (this._type === Lexer.SKIP) {\n                        continue outer;\n                    }\n                } while (this._type === Lexer.MORE);\n                if (this._token == null) {\n                    return this.emit();\n                }\n                return this._token;\n            }\n        }\n        finally {\n            // make sure we release marker after match or\n            // unbuffered char stream will keep buffering\n            this._input.release(tokenStartMarker);\n        }\n    }\n    /** Instruct the lexer to skip creating a token for current lexer rule\n     *  and look for another token.  nextToken() knows to keep looking when\n     *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that\n     *  if token==undefined at end of any token rule, it creates one for you\n     *  and emits it.\n     */\n    skip() {\n        this._type = Lexer.SKIP;\n    }\n    more() {\n        this._type = Lexer.MORE;\n    }\n    mode(m) {\n        this._mode = m;\n    }\n    pushMode(m) {\n        if (LexerATNSimulator_1.LexerATNSimulator.debug) {\n            console.log(\"pushMode \" + m);\n        }\n        this._modeStack.push(this._mode);\n        this.mode(m);\n    }\n    popMode() {\n        if (this._modeStack.isEmpty) {\n            throw new Error(\"EmptyStackException\");\n        }\n        if (LexerATNSimulator_1.LexerATNSimulator.debug) {\n            console.log(\"popMode back to \" + this._modeStack.peek());\n        }\n        this.mode(this._modeStack.pop());\n        return this._mode;\n    }\n    get tokenFactory() {\n        return this._factory;\n    }\n    // @Override\n    set tokenFactory(factory) {\n        this._factory = factory;\n    }\n    get inputStream() {\n        return this._input;\n    }\n    /** Set the char stream and reset the lexer */\n    set inputStream(input) {\n        this.reset(false);\n        this._input = input;\n        this._tokenFactorySourcePair = { source: this, stream: this._input };\n    }\n    get sourceName() {\n        return this._input.sourceName;\n    }\n    emit(token) {\n        if (!token) {\n            token = this._factory.create(this._tokenFactorySourcePair, this._type, this._text, this._channel, this._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine, this._tokenStartCharPositionInLine);\n        }\n        this._token = token;\n        return token;\n    }\n    emitEOF() {\n        let cpos = this.charPositionInLine;\n        let line = this.line;\n        let eof = this._factory.create(this._tokenFactorySourcePair, Token_1.Token.EOF, undefined, Token_1.Token.DEFAULT_CHANNEL, this._input.index, this._input.index - 1, line, cpos);\n        this.emit(eof);\n        return eof;\n    }\n    get line() {\n        return this.interpreter.line;\n    }\n    set line(line) {\n        this.interpreter.line = line;\n    }\n    get charPositionInLine() {\n        return this.interpreter.charPositionInLine;\n    }\n    set charPositionInLine(charPositionInLine) {\n        this.interpreter.charPositionInLine = charPositionInLine;\n    }\n    /** What is the index of the current character of lookahead? */\n    get charIndex() {\n        return this._input.index;\n    }\n    /** Return the text matched so far for the current token or any\n     *  text override.\n     */\n    get text() {\n        if (this._text != null) {\n            return this._text;\n        }\n        return this.interpreter.getText(this._input);\n    }\n    /** Set the complete text of this token; it wipes any previous\n     *  changes to the text.\n     */\n    set text(text) {\n        this._text = text;\n    }\n    /** Override if emitting multiple tokens. */\n    get token() { return this._token; }\n    set token(_token) {\n        this._token = _token;\n    }\n    set type(ttype) {\n        this._type = ttype;\n    }\n    get type() {\n        return this._type;\n    }\n    set channel(channel) {\n        this._channel = channel;\n    }\n    get channel() {\n        return this._channel;\n    }\n    /** Return a list of all Token objects in input char stream.\n     *  Forces load of all tokens. Does not include EOF token.\n     */\n    getAllTokens() {\n        let tokens = [];\n        let t = this.nextToken();\n        while (t.type !== Token_1.Token.EOF) {\n            tokens.push(t);\n            t = this.nextToken();\n        }\n        return tokens;\n    }\n    notifyListeners(e) {\n        let text = this._input.getText(Interval_1.Interval.of(this._tokenStartCharIndex, this._input.index));\n        let msg = \"token recognition error at: '\" +\n            this.getErrorDisplay(text) + \"'\";\n        let listener = this.getErrorListenerDispatch();\n        if (listener.syntaxError) {\n            listener.syntaxError(this, undefined, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);\n        }\n    }\n    getErrorDisplay(s) {\n        if (typeof s === \"number\") {\n            switch (s) {\n                case Token_1.Token.EOF:\n                    return \"<EOF>\";\n                case 0x0a:\n                    return \"\\\\n\";\n                case 0x09:\n                    return \"\\\\t\";\n                case 0x0d:\n                    return \"\\\\r\";\n            }\n            return String.fromCharCode(s);\n        }\n        return s.replace(/\\n/g, \"\\\\n\")\n            .replace(/\\t/g, \"\\\\t\")\n            .replace(/\\r/g, \"\\\\r\");\n    }\n    getCharErrorDisplay(c) {\n        let s = this.getErrorDisplay(c);\n        return \"'\" + s + \"'\";\n    }\n    recover(re) {\n        if (re instanceof LexerNoViableAltException_1.LexerNoViableAltException) {\n            if (this._input.LA(1) !== IntStream_1.IntStream.EOF) {\n                // skip a char and try again\n                this.interpreter.consume(this._input);\n            }\n        }\n        else {\n            //System.out.println(\"consuming char \"+(char)input.LA(1)+\" during recovery\");\n            //re.printStackTrace();\n            // TODO: Do we lose character or line position information?\n            this._input.consume();\n        }\n    }\n}\nLexer.DEFAULT_MODE = 0;\nLexer.MORE = -2;\nLexer.SKIP = -3;\nLexer.MIN_CHAR_VALUE = 0x0000;\nLexer.MAX_CHAR_VALUE = 0x10FFFF;\n__decorate([\n    Decorators_1.Override\n], Lexer.prototype, \"nextToken\", null);\n__decorate([\n    Decorators_1.Override\n], Lexer.prototype, \"tokenFactory\", null);\n__decorate([\n    Decorators_1.Override\n], Lexer.prototype, \"inputStream\", null);\n__decorate([\n    Decorators_1.Override\n], Lexer.prototype, \"sourceName\", null);\n__decorate([\n    Decorators_1.Override\n], Lexer.prototype, \"line\", null);\n__decorate([\n    Decorators_1.Override\n], Lexer.prototype, \"charPositionInLine\", null);\nexports.Lexer = Lexer;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:51.7913318-07:00\n\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\nimport { CharStream } from \"./CharStream\";\nimport { CommonTokenFactory } from \"./CommonTokenFactory\";\nimport { IntegerStack } from \"./misc/IntegerStack\";\nimport { Interval } from \"./misc/Interval\";\nimport { IntStream } from \"./IntStream\";\nimport { LexerATNSimulator } from \"./atn/LexerATNSimulator\";\nimport { LexerNoViableAltException } from \"./LexerNoViableAltException\";\nimport { Override } from \"./Decorators\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { Recognizer } from \"./Recognizer\";\nimport { Token } from \"./Token\";\nimport { TokenFactory } from \"./TokenFactory\";\nimport { TokenSource } from \"./TokenSource\";\n\n/** A lexer is recognizer that draws input symbols from a character stream.\n *  lexer grammars result in a subclass of this object. A Lexer object\n *  uses simplified match() and error recovery mechanisms in the interest\n *  of speed.\n */\nexport abstract class Lexer extends Recognizer<number, LexerATNSimulator>\n\timplements TokenSource {\n\tpublic static readonly DEFAULT_MODE: number = 0;\n\tpublic static readonly MORE: number = -2;\n\tpublic static readonly SKIP: number = -3;\n\n\tstatic get DEFAULT_TOKEN_CHANNEL(): number {\n\t\treturn Token.DEFAULT_CHANNEL;\n\t}\n\n\tstatic get HIDDEN(): number {\n\t\treturn Token.HIDDEN_CHANNEL;\n\t}\n\n\tpublic static readonly MIN_CHAR_VALUE: number = 0x0000;\n\tpublic static readonly MAX_CHAR_VALUE: number = 0x10FFFF;\n\n\tpublic _input: CharStream;\n\n\tprotected _tokenFactorySourcePair: { source: TokenSource, stream: CharStream };\n\n\t/** How to create token objects */\n\tprotected _factory: TokenFactory = CommonTokenFactory.DEFAULT;\n\n\t/** The goal of all lexer rules/methods is to create a token object.\n\t *  This is an instance variable as multiple rules may collaborate to\n\t *  create a single token.  nextToken will return this object after\n\t *  matching lexer rule(s).  If you subclass to allow multiple token\n\t *  emissions, then set this to the last token to be matched or\n\t *  something non-undefined so that the auto token emit mechanism will not\n\t *  emit another token.\n\t */\n\tpublic _token: Token | undefined;\n\n\t/** What character index in the stream did the current token start at?\n\t *  Needed, for example, to get the text for current token.  Set at\n\t *  the start of nextToken.\n\t */\n\tpublic _tokenStartCharIndex: number = -1;\n\n\t/** The line on which the first character of the token resides */\n\tpublic _tokenStartLine: number = 0;\n\n\t/** The character position of first character within the line */\n\tpublic _tokenStartCharPositionInLine: number = 0;\n\n\t/** Once we see EOF on char stream, next token will be EOF.\n\t *  If you have DONE : EOF ; then you see DONE EOF.\n\t */\n\tpublic _hitEOF: boolean = false;\n\n\t/** The channel number for the current token */\n\tpublic _channel: number = 0;\n\n\t/** The token type for the current token */\n\tpublic _type: number = 0;\n\n\tpublic readonly _modeStack: IntegerStack = new IntegerStack();\n\tpublic _mode: number = Lexer.DEFAULT_MODE;\n\n\t/** You can set the text for the current token to override what is in\n\t *  the input char buffer.  Set `text` or can set this instance var.\n\t */\n\tpublic _text: string | undefined;\n\n\tconstructor(input: CharStream) {\n\t\tsuper();\n\t\tthis._input = input;\n\t\tthis._tokenFactorySourcePair = { source: this, stream: input };\n\t}\n\n\tpublic reset(): void;\n\tpublic reset(resetInput: boolean): void;\n\tpublic reset(resetInput?: boolean): void {\n\t\t// wack Lexer state variables\n\t\tif (resetInput === undefined || resetInput) {\n\t\t\tthis._input.seek(0); // rewind the input\n\t\t}\n\n\t\tthis._token = undefined;\n\t\tthis._type = Token.INVALID_TYPE;\n\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\tthis._tokenStartCharIndex = -1;\n\t\tthis._tokenStartCharPositionInLine = -1;\n\t\tthis._tokenStartLine = -1;\n\t\tthis._text = undefined;\n\n\t\tthis._hitEOF = false;\n\t\tthis._mode = Lexer.DEFAULT_MODE;\n\t\tthis._modeStack.clear();\n\n\t\tthis.interpreter.reset();\n\t}\n\n\t/** Return a token from this source; i.e., match a token on the char\n\t *  stream.\n\t */\n\t@Override\n\tpublic nextToken(): Token {\n\t\tif (this._input == null) {\n\t\t\tthrow new Error(\"nextToken requires a non-null input stream.\");\n\t\t}\n\n\t\t// Mark start location in char stream so unbuffered streams are\n\t\t// guaranteed at least have text of current token\n\t\tlet tokenStartMarker: number = this._input.mark();\n\t\ttry {\n\t\t\touter:\n\t\t\twhile (true) {\n\t\t\t\tif (this._hitEOF) {\n\t\t\t\t\treturn this.emitEOF();\n\t\t\t\t}\n\n\t\t\t\tthis._token = undefined;\n\t\t\t\tthis._channel = Token.DEFAULT_CHANNEL;\n\t\t\t\tthis._tokenStartCharIndex = this._input.index;\n\t\t\t\tthis._tokenStartCharPositionInLine = this.interpreter.charPositionInLine;\n\t\t\t\tthis._tokenStartLine = this.interpreter.line;\n\t\t\t\tthis._text = undefined;\n\t\t\t\tdo {\n\t\t\t\t\tthis._type = Token.INVALID_TYPE;\n//\t\t\t\tSystem.out.println(\"nextToken line \"+tokenStartLine+\" at \"+((char)input.LA(1))+\n//\t\t\t\t\t\t\t\t   \" in mode \"+mode+\n//\t\t\t\t\t\t\t\t   \" at index \"+input.index);\n\t\t\t\t\tlet ttype: number;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tttype = this.interpreter.match(this._input, this._mode);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {\n\t\t\t\t\t\tif (e instanceof LexerNoViableAltException) {\n\t\t\t\t\t\t\tthis.notifyListeners(e);\t\t// report error\n\t\t\t\t\t\t\tthis.recover(e);\n\t\t\t\t\t\t\tttype = Lexer.SKIP;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthrow e;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this._input.LA(1) === IntStream.EOF) {\n\t\t\t\t\t\tthis._hitEOF = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Token.INVALID_TYPE) {\n\t\t\t\t\t\tthis._type = ttype;\n\t\t\t\t\t}\n\t\t\t\t\tif (this._type === Lexer.SKIP) {\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\t\t\t\t} while (this._type === Lexer.MORE);\n\t\t\t\tif (this._token == null) {\n\t\t\t\t\treturn this.emit();\n\t\t\t\t}\n\t\t\t\treturn this._token;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\t// make sure we release marker after match or\n\t\t\t// unbuffered char stream will keep buffering\n\t\t\tthis._input.release(tokenStartMarker);\n\t\t}\n\t}\n\n\t/** Instruct the lexer to skip creating a token for current lexer rule\n\t *  and look for another token.  nextToken() knows to keep looking when\n\t *  a lexer rule finishes with token set to SKIP_TOKEN.  Recall that\n\t *  if token==undefined at end of any token rule, it creates one for you\n\t *  and emits it.\n\t */\n\tpublic skip(): void {\n\t\tthis._type = Lexer.SKIP;\n\t}\n\n\tpublic more(): void {\n\t\tthis._type = Lexer.MORE;\n\t}\n\n\tpublic mode(m: number): void {\n\t\tthis._mode = m;\n\t}\n\n\tpublic pushMode(m: number): void {\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"pushMode \" + m);\n\t\t}\n\t\tthis._modeStack.push(this._mode);\n\t\tthis.mode(m);\n\t}\n\n\tpublic popMode(): number {\n\t\tif (this._modeStack.isEmpty) {\n\t\t\tthrow new Error(\"EmptyStackException\");\n\t\t}\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"popMode back to \" + this._modeStack.peek());\n\t\t}\n\t\tthis.mode(this._modeStack.pop());\n\t\treturn this._mode;\n\t}\n\n\t@Override\n\tget tokenFactory(): TokenFactory {\n\t\treturn this._factory;\n\t}\n\n\t// @Override\n\tset tokenFactory(factory: TokenFactory) {\n\t\tthis._factory = factory;\n\t}\n\n\t@Override\n\tget inputStream(): CharStream {\n\t\treturn this._input;\n\t}\n\n\t/** Set the char stream and reset the lexer */\n\tset inputStream(input: CharStream) {\n\t\tthis.reset(false);\n\t\tthis._input = input;\n\t\tthis._tokenFactorySourcePair = { source: this, stream: this._input };\n\t}\n\n\t@Override\n\tget sourceName(): string {\n\t\treturn this._input.sourceName;\n\t}\n\n\n\t/** The standard method called to automatically emit a token at the\n\t *  outermost lexical rule.  The token object should point into the\n\t *  char buffer start..stop.  If there is a text override in 'text',\n\t *  use that to set the token's text.  Override this method to emit\n\t *  custom Token objects or provide a new factory.\n\t */\n\tpublic emit(token: Token): Token;\n\n\t/** By default does not support multiple emits per nextToken invocation\n\t *  for efficiency reasons.  Subclass and override this method, nextToken,\n\t *  and getToken (to push tokens into a list and pull from that list\n\t *  rather than a single variable as this implementation does).\n\t */\n\tpublic emit(): Token;\n\n\tpublic emit(token?: Token): Token {\n\t\tif (!token) {\n\t\t\ttoken = this._factory.create(\n\t\t\t\tthis._tokenFactorySourcePair, this._type, this._text, this._channel,\n\t\t\t\tthis._tokenStartCharIndex, this.charIndex - 1, this._tokenStartLine,\n\t\t\t\tthis._tokenStartCharPositionInLine);\n\t\t}\n\t\tthis._token = token;\n\t\treturn token;\n\t}\n\n\tpublic emitEOF(): Token {\n\t\tlet cpos: number = this.charPositionInLine;\n\t\tlet line: number = this.line;\n\t\tlet eof: Token = this._factory.create(\n\t\t\tthis._tokenFactorySourcePair, Token.EOF, undefined,\n\t\t\tToken.DEFAULT_CHANNEL, this._input.index, this._input.index - 1,\n\t\t\tline, cpos);\n\t\tthis.emit(eof);\n\t\treturn eof;\n\t}\n\n\t@Override\n\tget line(): number {\n\t\treturn this.interpreter.line;\n\t}\n\n\tset line(line: number) {\n\t\tthis.interpreter.line = line;\n\t}\n\n\t@Override\n\tget charPositionInLine(): number {\n\t\treturn this.interpreter.charPositionInLine;\n\t}\n\n\tset charPositionInLine(charPositionInLine: number) {\n\t\tthis.interpreter.charPositionInLine = charPositionInLine;\n\t}\n\n\t/** What is the index of the current character of lookahead? */\n\tget charIndex(): number {\n\t\treturn this._input.index;\n\t}\n\n\t/** Return the text matched so far for the current token or any\n\t *  text override.\n\t */\n\tget text(): string {\n\t\tif (this._text != null) {\n\t\t\treturn this._text;\n\t\t}\n\t\treturn this.interpreter.getText(this._input);\n\t}\n\n\t/** Set the complete text of this token; it wipes any previous\n\t *  changes to the text.\n\t */\n\tset text(text: string) {\n\t\tthis._text = text;\n\t}\n\n\t/** Override if emitting multiple tokens. */\n\tget token(): Token | undefined { return this._token; }\n\n\tset token(_token: Token | undefined) {\n\t\tthis._token = _token;\n\t}\n\n\tset type(ttype: number) {\n\t\tthis._type = ttype;\n\t}\n\n\tget type(): number {\n\t\treturn this._type;\n\t}\n\n\tset channel(channel: number) {\n\t\tthis._channel = channel;\n\t}\n\n\tget channel(): number {\n\t\treturn this._channel;\n\t}\n\n\tpublic abstract readonly channelNames: string[];\n\n\tpublic abstract readonly modeNames: string[];\n\n\t/** Return a list of all Token objects in input char stream.\n\t *  Forces load of all tokens. Does not include EOF token.\n\t */\n\tpublic getAllTokens(): Token[] {\n\t\tlet tokens: Token[] = [];\n\t\tlet t: Token = this.nextToken();\n\t\twhile (t.type !== Token.EOF) {\n\t\t\ttokens.push(t);\n\t\t\tt = this.nextToken();\n\t\t}\n\t\treturn tokens;\n\t}\n\n\tpublic notifyListeners(e: LexerNoViableAltException): void {\n\t\tlet text: string = this._input.getText(\n\t\t\tInterval.of(this._tokenStartCharIndex, this._input.index));\n\t\tlet msg: string = \"token recognition error at: '\" +\n\t\t\tthis.getErrorDisplay(text) + \"'\";\n\n\t\tlet listener: ANTLRErrorListener<number> = this.getErrorListenerDispatch();\n\t\tif (listener.syntaxError) {\n\t\t\tlistener.syntaxError(this, undefined, this._tokenStartLine, this._tokenStartCharPositionInLine, msg, e);\n\t\t}\n\t}\n\n\tpublic getErrorDisplay(s: string | number): string {\n\t\tif (typeof s === \"number\") {\n\t\t\tswitch (s) {\n\t\t\tcase Token.EOF:\n\t\t\t\treturn \"<EOF>\";\n\t\t\tcase 0x0a:\n\t\t\t\treturn \"\\\\n\";\n\t\t\tcase 0x09:\n\t\t\t\treturn \"\\\\t\";\n\t\t\tcase 0x0d:\n\t\t\t\treturn \"\\\\r\";\n\t\t\t}\n\t\t\treturn String.fromCharCode(s);\n\t\t}\n\t\treturn s.replace(/\\n/g, \"\\\\n\")\n\t\t\t.replace(/\\t/g, \"\\\\t\")\n\t\t\t.replace(/\\r/g, \"\\\\r\");\n\t}\n\n\tpublic getCharErrorDisplay(c: number): string {\n\t\tlet s: string = this.getErrorDisplay(c);\n\t\treturn \"'\" + s + \"'\";\n\t}\n\n\t/** Lexers can normally match any char in it's vocabulary after matching\n\t *  a token, so do the easy thing and just kill a character and hope\n\t *  it all works out.  You can instead use the rule invocation stack\n\t *  to do sophisticated error recovery if you are in a fragment rule.\n\t */\n\tpublic recover(re: RecognitionException): void;\n\tpublic recover(re: LexerNoViableAltException): void;\n\tpublic recover(re: RecognitionException): void {\n\t\tif (re instanceof LexerNoViableAltException) {\n\t\t\tif (this._input.LA(1) !== IntStream.EOF) {\n\t\t\t\t// skip a char and try again\n\t\t\t\tthis.interpreter.consume(this._input);\n\t\t\t}\n\t\t} else {\n\t\t\t//System.out.println(\"consuming char \"+(char)input.LA(1)+\" during recovery\");\n\t\t\t//re.printStackTrace();\n\t\t\t// TODO: Do we lose character or line position information?\n\t\t\tthis._input.consume();\n\t\t}\n\t}\n}\n"]}