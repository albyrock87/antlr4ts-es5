{"version":3,"sources":["ANTLRInputStream.js","../src/ANTLRInputStream.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","assert","require","Decorators_1","IntStream_1","READ_BUFFER_SIZE","INITIAL_BUFFER_SIZE","ANTLRInputStream","input","p","data","n","LA","IntStream","EOF","Error","charCodeAt","marker","index","Math","min","consume","interval","start","a","stop","b","count","substr","name","UNKNOWN_SOURCE_NAME","Override","prototype"],"mappings":"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","file":"ANTLRInputStream.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n// ConvertTo-TS run at 2016-10-04T11:26:49.0828748-07:00\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst Decorators_1 = require(\"./Decorators\");\nconst IntStream_1 = require(\"./IntStream\");\nconst READ_BUFFER_SIZE = 1024;\nconst INITIAL_BUFFER_SIZE = 1024;\n/**\n * Vacuum all input from a {@link Reader}/{@link InputStream} and then treat it\n * like a `char[]` buffer. Can also pass in a {@link String} or\n * `char[]` to use.\n *\n * If you need encoding, pass in stream/reader with correct encoding.\n *\n * @deprecated as of 4.7, please use `CharStreams` interface.\n */\nclass ANTLRInputStream {\n    /** Copy data in string to a local char array */\n    constructor(input) {\n        /** 0..n-1 index into string of next char */\n        this.p = 0;\n        this.data = input;\n        this.n = input.length;\n    }\n    /** Reset the stream so that it's in the same state it was\n     *  when the object was created *except* the data array is not\n     *  touched.\n     */\n    reset() {\n        this.p = 0;\n    }\n    consume() {\n        if (this.p >= this.n) {\n            assert(this.LA(1) === IntStream_1.IntStream.EOF);\n            throw new Error(\"cannot consume EOF\");\n        }\n        //System.out.println(\"prev p=\"+p+\", c=\"+(char)data[p]);\n        if (this.p < this.n) {\n            this.p++;\n            //System.out.println(\"p moves to \"+p+\" (c='\"+(char)data[p]+\"')\");\n        }\n    }\n    LA(i) {\n        if (i === 0) {\n            return 0; // undefined\n        }\n        if (i < 0) {\n            i++; // e.g., translate LA(-1) to use offset i=0; then data[p+0-1]\n            if ((this.p + i - 1) < 0) {\n                return IntStream_1.IntStream.EOF; // invalid; no char before first char\n            }\n        }\n        if ((this.p + i - 1) >= this.n) {\n            //System.out.println(\"char LA(\"+i+\")=EOF; p=\"+p);\n            return IntStream_1.IntStream.EOF;\n        }\n        //System.out.println(\"char LA(\"+i+\")=\"+(char)data[p+i-1]+\"; p=\"+p);\n        //System.out.println(\"LA(\"+i+\"); p=\"+p+\" n=\"+n+\" data.length=\"+data.length);\n        return this.data.charCodeAt(this.p + i - 1);\n    }\n    LT(i) {\n        return this.LA(i);\n    }\n    /** Return the current input symbol index 0..n where n indicates the\n     *  last symbol has been read.  The index is the index of char to\n     *  be returned from LA(1).\n     */\n    get index() {\n        return this.p;\n    }\n    get size() {\n        return this.n;\n    }\n    /** mark/release do nothing; we have entire buffer */\n    mark() {\n        return -1;\n    }\n    release(marker) {\n        // No default implementation since this stream buffers the entire input\n    }\n    /** consume() ahead until p==index; can't just set p=index as we must\n     *  update line and charPositionInLine. If we seek backwards, just set p\n     */\n    seek(index) {\n        if (index <= this.p) {\n            this.p = index; // just jump; don't update stream state (line, ...)\n            return;\n        }\n        // seek forward, consume until p hits index or n (whichever comes first)\n        index = Math.min(index, this.n);\n        while (this.p < index) {\n            this.consume();\n        }\n    }\n    getText(interval) {\n        let start = interval.a;\n        let stop = interval.b;\n        if (stop >= this.n) {\n            stop = this.n - 1;\n        }\n        let count = stop - start + 1;\n        if (start >= this.n) {\n            return \"\";\n        }\n        // System.err.println(\"data: \"+Arrays.toString(data)+\", n=\"+n+\n        // \t\t\t\t   \", start=\"+start+\n        // \t\t\t\t   \", stop=\"+stop);\n        return this.data.substr(start, count);\n    }\n    get sourceName() {\n        if (!this.name) {\n            return IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;\n        }\n        return this.name;\n    }\n    toString() { return this.data; }\n}\n__decorate([\n    Decorators_1.Override\n], ANTLRInputStream.prototype, \"consume\", null);\n__decorate([\n    Decorators_1.Override\n], ANTLRInputStream.prototype, \"LA\", null);\n__decorate([\n    Decorators_1.Override\n], ANTLRInputStream.prototype, \"index\", null);\n__decorate([\n    Decorators_1.Override\n], ANTLRInputStream.prototype, \"size\", null);\n__decorate([\n    Decorators_1.Override\n], ANTLRInputStream.prototype, \"mark\", null);\n__decorate([\n    Decorators_1.Override\n], ANTLRInputStream.prototype, \"release\", null);\n__decorate([\n    Decorators_1.Override\n], ANTLRInputStream.prototype, \"seek\", null);\n__decorate([\n    Decorators_1.Override\n], ANTLRInputStream.prototype, \"getText\", null);\n__decorate([\n    Decorators_1.Override\n], ANTLRInputStream.prototype, \"sourceName\", null);\n__decorate([\n    Decorators_1.Override\n], ANTLRInputStream.prototype, \"toString\", null);\nexports.ANTLRInputStream = ANTLRInputStream;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n// ConvertTo-TS run at 2016-10-04T11:26:49.0828748-07:00\n\nimport * as assert from \"assert\";\nimport { CharStream } from \"./CharStream\";\nimport { Arrays } from \"./misc/Arrays\";\nimport { Override } from \"./Decorators\";\nimport { IntStream } from \"./IntStream\";\nimport { Interval } from \"./misc/Interval\";\n\nconst READ_BUFFER_SIZE: number = 1024;\nconst INITIAL_BUFFER_SIZE: number = 1024;\n\n/**\n * Vacuum all input from a {@link Reader}/{@link InputStream} and then treat it\n * like a `char[]` buffer. Can also pass in a {@link String} or\n * `char[]` to use.\n *\n * If you need encoding, pass in stream/reader with correct encoding.\n *\n * @deprecated as of 4.7, please use `CharStreams` interface.\n */\nexport class ANTLRInputStream implements CharStream {\n\t/** The data being scanned */\n\tprotected data: string;\n\n\t/** How many characters are actually in the buffer */\n\tprotected n: number;\n\n\t/** 0..n-1 index into string of next char */\n\tprotected p: number = 0;\n\n\t/** What is name or source of this char stream? */\n\tpublic name?: string;\n\n\t/** Copy data in string to a local char array */\n\tconstructor(input: string) {\n\t\tthis.data = input;\n\t\tthis.n = input.length;\n\t}\n\n\t/** Reset the stream so that it's in the same state it was\n\t *  when the object was created *except* the data array is not\n\t *  touched.\n\t */\n\tpublic reset(): void {\n\t\tthis.p = 0;\n\t}\n\n\t@Override\n\tpublic consume(): void {\n\t\tif (this.p >= this.n) {\n\t\t\tassert(this.LA(1) === IntStream.EOF);\n\t\t\tthrow new Error(\"cannot consume EOF\");\n\t\t}\n\n\t\t//System.out.println(\"prev p=\"+p+\", c=\"+(char)data[p]);\n\t\tif (this.p < this.n) {\n\t\t\tthis.p++;\n\t\t\t//System.out.println(\"p moves to \"+p+\" (c='\"+(char)data[p]+\"')\");\n\t\t}\n\t}\n\n\t@Override\n\tpublic LA(i: number): number {\n\t\tif (i === 0) {\n\t\t\treturn 0; // undefined\n\t\t}\n\t\tif (i < 0) {\n\t\t\ti++; // e.g., translate LA(-1) to use offset i=0; then data[p+0-1]\n\t\t\tif ((this.p + i - 1) < 0) {\n\t\t\t\treturn IntStream.EOF; // invalid; no char before first char\n\t\t\t}\n\t\t}\n\n\t\tif ((this.p + i - 1) >= this.n) {\n\t\t\t//System.out.println(\"char LA(\"+i+\")=EOF; p=\"+p);\n\t\t\treturn IntStream.EOF;\n\t\t}\n\t\t//System.out.println(\"char LA(\"+i+\")=\"+(char)data[p+i-1]+\"; p=\"+p);\n\t\t//System.out.println(\"LA(\"+i+\"); p=\"+p+\" n=\"+n+\" data.length=\"+data.length);\n\t\treturn this.data.charCodeAt(this.p + i - 1);\n\t}\n\n\tpublic LT(i: number): number {\n\t\treturn this.LA(i);\n\t}\n\n\t/** Return the current input symbol index 0..n where n indicates the\n\t *  last symbol has been read.  The index is the index of char to\n\t *  be returned from LA(1).\n\t */\n\t@Override\n\tget index(): number {\n\t\treturn this.p;\n\t}\n\n\t@Override\n\tget size(): number {\n\t\treturn this.n;\n\t}\n\n\t/** mark/release do nothing; we have entire buffer */\n\t@Override\n\tpublic mark(): number {\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic release(marker: number): void {\n\t\t// No default implementation since this stream buffers the entire input\n\t}\n\n\t/** consume() ahead until p==index; can't just set p=index as we must\n\t *  update line and charPositionInLine. If we seek backwards, just set p\n\t */\n\t@Override\n\tpublic seek(index: number): void {\n\t\tif (index <= this.p) {\n\t\t\tthis.p = index; // just jump; don't update stream state (line, ...)\n\t\t\treturn;\n\t\t}\n\t\t// seek forward, consume until p hits index or n (whichever comes first)\n\t\tindex = Math.min(index, this.n);\n\t\twhile (this.p < index) {\n\t\t\tthis.consume();\n\t\t}\n\t}\n\n\t@Override\n\tpublic getText(interval: Interval): string {\n\t\tlet start: number = interval.a;\n\t\tlet stop: number = interval.b;\n\t\tif (stop >= this.n) {\n\t\t\tstop = this.n - 1;\n\t\t}\n\t\tlet count: number = stop - start + 1;\n\t\tif (start >= this.n) {\n\t\t\treturn \"\";\n\t\t}\n\t\t// System.err.println(\"data: \"+Arrays.toString(data)+\", n=\"+n+\n\t\t// \t\t\t\t   \", start=\"+start+\n\t\t// \t\t\t\t   \", stop=\"+stop);\n\t\treturn this.data.substr(start, count);\n\t}\n\n\t@Override\n\tget sourceName(): string {\n\t\tif (!this.name) {\n\t\t\treturn IntStream.UNKNOWN_SOURCE_NAME;\n\t\t}\n\t\treturn this.name;\n\t}\n\n\t@Override\n\tpublic toString() { return this.data; }\n}\n"]}