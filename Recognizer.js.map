{"version":3,"sources":["Recognizer.js","../src/Recognizer.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","ConsoleErrorListener_1","require","ProxyErrorListener_1","Decorators_1","Token_1","Utils","Recognizer","_listeners","ConsoleErrorListener","INSTANCE","_stateNumber","vocabulary","result","tokenTypeMapCache","get","intermediateResult","Map","atn","maxTokenType","literalName","getLiteralName","set","symbolicName","getSymbolicName","Token","EOF","ruleNames","Error","ruleIndexMapCache","toMap","tokenName","ttype","getTokenTypeMap","INVALID_TYPE","e","token","getOffendingToken","line","charPositionInLine","listener","TypeError","push","position","indexOf","splice","slice","ProxyErrorListener","getErrorListeners","_localctx","ruleIndex","actionIndex","localctx","precedence","_interp","interpreter","Promise","resolve","undefined","atnState","WeakMap","SuppressWarnings","NotNull","prototype"],"mappings":"AAAA;ACAA;;;;;;;;;;;;;ADKA,IAAIA,UAAU,GAAI,UAAQ,SAAKA,UAAd,IAA6B,UAAUC,UAAV,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AACnF,MAAIC,CAAC,GAAGC,SAAS,CAACC,MAAlB;AAAA,MAA0BC,CAAC,GAAGH,CAAC,GAAG,CAAJ,GAAQH,MAAR,GAAiBE,IAAI,KAAK,IAAT,GAAgBA,IAAI,GAAGK,MAAM,CAACC,wBAAP,CAAgCR,MAAhC,EAAwCC,GAAxC,CAAvB,GAAsEC,IAArH;AAAA,MAA2HO,CAA3H;AACA,MAAI,QAAOC,OAAP,0DAAOA,OAAP,OAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAA/D,EAA2EL,CAAC,GAAGI,OAAO,CAACC,QAAR,CAAiBZ,UAAjB,EAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,IAA1C,CAAJ,CAA3E,KACK,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAX,GAAoB,CAAjC,EAAoCO,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C;AAAiD,QAAIH,CAAC,GAAGV,UAAU,CAACa,CAAD,CAAlB,EAAuBN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACH,CAAD,CAAT,GAAeH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACT,MAAD,EAASC,GAAT,EAAcK,CAAd,CAAT,GAA4BG,CAAC,CAACT,MAAD,EAASC,GAAT,CAA7C,KAA+DK,CAAnE;AAAxE;AACL,SAAOH,CAAC,GAAG,CAAJ,IAASG,CAAT,IAAcC,MAAM,CAACM,cAAP,CAAsBb,MAAtB,EAA8BC,GAA9B,EAAmCK,CAAnC,CAAd,EAAqDA,CAA5D;AACH,CALD;;AAMA,IAAIQ,OAAO,GAAI,UAAQ,SAAKA,OAAd,IAA0B,UAAUC,UAAV,EAAsBC,SAAtB,EAAiC;AACrE,SAAO,UAAUhB,MAAV,EAAkBC,GAAlB,EAAuB;AAAEe,IAAAA,SAAS,CAAChB,MAAD,EAASC,GAAT,EAAcc,UAAd,CAAT;AAAqC,GAArE;AACH,CAFD;;AAGAR,MAAM,CAACM,cAAP,CAAsBI,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;ACLA,IAAAC,sBAAA,GAAAC,OAAA,CAAA,wBAAA,CAAA;;AAGA,IAAAC,oBAAA,GAAAD,OAAA,CAAA,sBAAA,CAAA;;AAGA,IAAAE,YAAA,GAAAF,OAAA,CAAA,cAAA,CAAA;;AACA,IAAAG,OAAA,GAAAH,OAAA,CAAA,SAAA,CAAA;;AAIA,IAAAI,KAAA,GAAAJ,OAAA,CAAA,cAAA,CAAA;;IAEAK,U;;;AAAA,wBAAA;AAAA;AAUkB,SAAAC,UAAA,GAAiD,CAACP,sBAAA,CAAAQ,oBAAA,CAAqBC,QAAtB,CAAjD;AAIT,SAAAC,YAAA,GAAe,CAAC,CAAhB;AAkNR;AAtMA;;;;;;;;;sCAMsB;AACrB,UAAIC,UAAU,GAAe,KAAKA,UAAlC;AACA,UAAIC,MAAM,GAAGN,UAAU,CAACO,iBAAX,CAA6BC,GAA7B,CAAiCH,UAAjC,CAAb;;AACA,UAAIC,MAAM,IAAI,IAAd,EAAoB;AACnB,YAAIG,kBAAkB,GAAG,IAAIC,GAAJ,EAAzB;;AACA,aAAK,IAAIvB,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAI,KAAKwB,GAAL,CAASC,YAA9B,EAA4CzB,CAAC,EAA7C,EAAiD;AAChD,cAAI0B,WAAW,GAAGR,UAAU,CAACS,cAAX,CAA0B3B,CAA1B,CAAlB;;AACA,cAAI0B,WAAW,IAAI,IAAnB,EAAyB;AACxBJ,YAAAA,kBAAkB,CAACM,GAAnB,CAAuBF,WAAvB,EAAoC1B,CAApC;AACA;;AAED,cAAI6B,YAAY,GAAGX,UAAU,CAACY,eAAX,CAA2B9B,CAA3B,CAAnB;;AACA,cAAI6B,YAAY,IAAI,IAApB,EAA0B;AACzBP,YAAAA,kBAAkB,CAACM,GAAnB,CAAuBC,YAAvB,EAAqC7B,CAArC;AACA;AACD;;AAEDsB,QAAAA,kBAAkB,CAACM,GAAnB,CAAuB,KAAvB,EAA8BjB,OAAA,CAAAoB,KAAA,CAAMC,GAApC;AACAb,QAAAA,MAAM,GAAGG,kBAAT;AACAT,QAAAA,UAAU,CAACO,iBAAX,CAA6BQ,GAA7B,CAAiCV,UAAjC,EAA6CC,MAA7C;AACA;;AAED,aAAOA,MAAP;AACA;AAED;;;;;;;;sCAMsB;AACrB,UAAIc,SAAS,GAAa,KAAKA,SAA/B;;AACA,UAAIA,SAAS,IAAI,IAAjB,EAAuB;AACtB,cAAM,IAAIC,KAAJ,CAAU,+DAAV,CAAN;AACA;;AAED,UAAIf,MAAM,GAA4CN,UAAU,CAACsB,iBAAX,CAA6Bd,GAA7B,CAAiCY,SAAjC,CAAtD;;AACA,UAAId,MAAM,IAAI,IAAd,EAAoB;AACnBA,QAAAA,MAAM,GAAGP,KAAK,CAACwB,KAAN,CAAYH,SAAZ,CAAT;AACApB,QAAAA,UAAU,CAACsB,iBAAX,CAA6BP,GAA7B,CAAiCK,SAAjC,EAA4Cd,MAA5C;AACA;;AAED,aAAOA,MAAP;AACA;;;iCAEmBkB,S,EAAiB;AACpC,UAAIC,KAAK,GAAG,KAAKC,eAAL,GAAuBlB,GAAvB,CAA2BgB,SAA3B,CAAZ;;AACA,UAAIC,KAAK,IAAI,IAAb,EAAmB;AAClB,eAAOA,KAAP;AACA;;AACD,aAAO3B,OAAA,CAAAoB,KAAA,CAAMS,YAAb;AACA;AAED;;;;;;;;;;;AAwDA;mCAE+BC,C,EAAuB;AACrD,UAAIC,KAAK,GAAGD,CAAC,CAACE,iBAAF,EAAZ;;AACA,UAAI,CAACD,KAAL,EAAY;AACX,eAAO,EAAP;AACA;;AACD,UAAIE,IAAI,GAAGF,KAAK,CAACE,IAAjB;AACA,UAAIC,kBAAkB,GAAWH,KAAK,CAACG,kBAAvC;AACA,aAAO,UAAUD,IAAV,GAAiB,GAAjB,GAAuBC,kBAA9B;AACA;AAED;;;;;;qCAGiCC,Q,EAAqC;AACrE,UAAI,CAACA,QAAL,EAAe;AACd,cAAM,IAAIC,SAAJ,CAAc,2BAAd,CAAN;AACA;;AACD,WAAKjC,UAAL,CAAgBkC,IAAhB,CAAqBF,QAArB;AACA;;;wCAEmCA,Q,EAAqC;AACxE,UAAIG,QAAQ,GAAG,KAAKnC,UAAL,CAAgBoC,OAAhB,CAAwBJ,QAAxB,CAAf;;AACA,UAAIG,QAAQ,KAAK,CAAC,CAAlB,EAAqB;AACpB,aAAKnC,UAAL,CAAgBqC,MAAhB,CAAuBF,QAAvB,EAAiC,CAAjC;AACA;AACD;;;2CAE0B;AAC1B,WAAKnC,UAAL,CAAgBrB,MAAhB,GAAyB,CAAzB;AACA;;;wCAGuB;AACvB,aAAO,KAAKqB,UAAL,CAAgBsC,KAAhB,CAAsB,CAAtB,CAAP;AACA;;;+CAE8B;AAC9B,aAAO,IAAI3C,oBAAA,CAAA4C,kBAAJ,CAA6D,KAAKC,iBAAL,EAA7D,CAAP;AACA,K,CAED;AACA;;;;4BAECC,S,EACAC,S,EACAC,W,EAAmB;AACnB,aAAO,IAAP;AACA;;;6BAGAC,Q,EACAC,U,EAAkB;AAClB,aAAO,IAAP;AACA;;;2BAGAJ,S,EACAC,S,EACAC,W,EAAmB,CACnB;AACA;;;wBA9GgB;AAChB,YAAM,IAAIvB,KAAJ,CAAU,4BAAV,CAAN;AACA;AAOD;;;;;;;;wBAMO;AACN,aAAO,KAAK0B,OAAL,CAAapC,GAApB;AACA;AAED;;;;;;;;wBAMe;AACd,aAAO,KAAKoC,OAAZ;AACA;AAED;;;;;;;sBAMyBC,W,EAA2B;AACnD,WAAKD,OAAL,GAAeC,WAAf;AACA;AAED;;;;;;;;wBAKa;AACZ,aAAOC,OAAO,CAACC,OAAR,CAAgBC,SAAhB,CAAP;AACA;;;wBAkEQ;AACR,aAAO,KAAK/C,YAAZ;AACA;AAED;;;;;;;;sBAOUgD,Q,EAAgB;AAC3B;AACE,WAAKhD,YAAL,GAAoBgD,QAApB,CAFyB,CAG3B;AACE;;;;;AA5NsBpD,UAAA,CAAAmB,GAAA,GAAc,CAAC,CAAf;AAERnB,UAAA,CAAAO,iBAAA,GACd,IAAI8C,OAAJ,EADc;AAEArD,UAAA,CAAAsB,iBAAA,GACd,IAAI+B,OAAJ,EADc;;AAKfhF,UAAA,CAAA,CAFCwB,YAAA,CAAAyD,gBAAA,CAAiB,QAAjB,CAED,EADCzD,YAAA,CAAA0D,OACD,CAAA,EDyJEvD,UAAU,CAACwD,SCzJb,EDyJwB,YCzJxB,EDyJsC,KAAK,CCzJ3C,CAAA;;AAsBAnF,UAAA,CAAA,CADCwB,YAAA,CAAA0D,OACD,CAAA,EDsIEvD,UAAU,CAACwD,SCtIb,EDsIwB,iBCtIxB,EDsI2C,ICtI3C,CAAA;;AA+BAnF,UAAA,CAAA,CADCwB,YAAA,CAAA0D,OACD,CAAA,ED0GEvD,UAAU,CAACwD,SC1Gb,ED0GwB,iBC1GxB,ED0G2C,IC1G3C,CAAA;;AA+BAnF,UAAA,CAAA,CADCwB,YAAA,CAAA0D,OACD,CAAA,ED8EEvD,UAAU,CAACwD,SC9Eb,ED8EwB,eC9ExB,ED8EyC,IC9EzC,CAAA;;AAeAnF,UAAA,CAAA,CADCwB,YAAA,CAAA0D,OACD,CAAA,EDkEEvD,UAAU,CAACwD,SClEb,EDkEwB,KClExB,EDkE+B,IClE/B,CAAA;;AAUAnF,UAAA,CAAA,CADCwB,YAAA,CAAA0D,OACD,EAUiBlE,OAAA,CAAA,CAAA,EAAAQ,YAAA,CAAA0D,OAAA,CAVjB,CAAA,ED4DEvD,UAAU,CAACwD,SC5Db,ED4DwB,aC5DxB,ED4DuC,IC5DvC,CAAA;;AAyBAnF,UAAA,CAAA,CADCwB,YAAA,CAAA0D,OACD,EAAuBlE,OAAA,CAAA,CAAA,EAAAQ,YAAA,CAAA0D,OAAA,CAAvB,CAAA,EDuCEvD,UAAU,CAACwD,SCvCb,EDuCwB,gBCvCxB,EDuC0C,ICvC1C,CAAA;;AAaAnF,UAAA,CAAA,CAAyBgB,OAAA,CAAA,CAAA,EAAAQ,YAAA,CAAA0D,OAAA,CAAzB,CAAA,ED6BEvD,UAAU,CAACwD,SC7Bb,ED6BwB,kBC7BxB,ED6B4C,IC7B5C,CAAA;;AAOAnF,UAAA,CAAA,CAA4BgB,OAAA,CAAA,CAAA,EAAAQ,YAAA,CAAA0D,OAAA,CAA5B,CAAA,EDyBEvD,UAAU,CAACwD,SCzBb,EDyBwB,qBCzBxB,EDyB+C,ICzB/C,CAAA;;AAYAnF,UAAA,CAAA,CADCwB,YAAA,CAAA0D,OACD,CAAA,EDgBEvD,UAAU,CAACwD,SChBb,EDgBwB,mBChBxB,EDgB6C,IChB7C,CAAA;;AAhLDhE,OAAA,CAAAQ,UAAA,GAAAA,UAAA","file":"Recognizer.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ConsoleErrorListener_1 = require(\"./ConsoleErrorListener\");\nconst ProxyErrorListener_1 = require(\"./ProxyErrorListener\");\nconst Decorators_1 = require(\"./Decorators\");\nconst Token_1 = require(\"./Token\");\nconst Utils = require(\"./misc/Utils\");\nclass Recognizer {\n    constructor() {\n        this._listeners = [ConsoleErrorListener_1.ConsoleErrorListener.INSTANCE];\n        this._stateNumber = -1;\n    }\n    /**\n     * Get a map from token names to token types.\n     *\n     * Used for XPath and tree pattern compilation.\n     */\n    getTokenTypeMap() {\n        let vocabulary = this.vocabulary;\n        let result = Recognizer.tokenTypeMapCache.get(vocabulary);\n        if (result == null) {\n            let intermediateResult = new Map();\n            for (let i = 0; i <= this.atn.maxTokenType; i++) {\n                let literalName = vocabulary.getLiteralName(i);\n                if (literalName != null) {\n                    intermediateResult.set(literalName, i);\n                }\n                let symbolicName = vocabulary.getSymbolicName(i);\n                if (symbolicName != null) {\n                    intermediateResult.set(symbolicName, i);\n                }\n            }\n            intermediateResult.set(\"EOF\", Token_1.Token.EOF);\n            result = intermediateResult;\n            Recognizer.tokenTypeMapCache.set(vocabulary, result);\n        }\n        return result;\n    }\n    /**\n     * Get a map from rule names to rule indexes.\n     *\n     * Used for XPath and tree pattern compilation.\n     */\n    getRuleIndexMap() {\n        let ruleNames = this.ruleNames;\n        if (ruleNames == null) {\n            throw new Error(\"The current recognizer does not provide a list of rule names.\");\n        }\n        let result = Recognizer.ruleIndexMapCache.get(ruleNames);\n        if (result == null) {\n            result = Utils.toMap(ruleNames);\n            Recognizer.ruleIndexMapCache.set(ruleNames, result);\n        }\n        return result;\n    }\n    getTokenType(tokenName) {\n        let ttype = this.getTokenTypeMap().get(tokenName);\n        if (ttype != null) {\n            return ttype;\n        }\n        return Token_1.Token.INVALID_TYPE;\n    }\n    /**\n     * If this recognizer was generated, it will have a serialized ATN\n     * representation of the grammar.\n     *\n     * For interpreters, we don't know their serialized ATN despite having\n     * created the interpreter from it.\n     */\n    get serializedATN() {\n        throw new Error(\"there is no serialized ATN\");\n    }\n    /**\n     * Get the {@link ATN} used by the recognizer for prediction.\n     *\n     * @returns The {@link ATN} used by the recognizer for prediction.\n     */\n    get atn() {\n        return this._interp.atn;\n    }\n    /**\n     * Get the ATN interpreter used by the recognizer for prediction.\n     *\n     * @returns The ATN interpreter used by the recognizer for prediction.\n     */\n    get interpreter() {\n        return this._interp;\n    }\n    /**\n     * Set the ATN interpreter used by the recognizer for prediction.\n     *\n     * @param interpreter The ATN interpreter used by the recognizer for\n     * prediction.\n     */\n    set interpreter(interpreter) {\n        this._interp = interpreter;\n    }\n    /** If profiling during the parse/lex, this will return DecisionInfo records\n     *  for each decision in recognizer in a ParseInfo object.\n     *\n     * @since 4.3\n     */\n    get parseInfo() {\n        return Promise.resolve(undefined);\n    }\n    /** What is the error header, normally line/character position information? */\n    getErrorHeader(e) {\n        let token = e.getOffendingToken();\n        if (!token) {\n            return \"\";\n        }\n        let line = token.line;\n        let charPositionInLine = token.charPositionInLine;\n        return \"line \" + line + \":\" + charPositionInLine;\n    }\n    /**\n     * @exception NullPointerException if `listener` is `undefined`.\n     */\n    addErrorListener(listener) {\n        if (!listener) {\n            throw new TypeError(\"listener must not be null\");\n        }\n        this._listeners.push(listener);\n    }\n    removeErrorListener(listener) {\n        let position = this._listeners.indexOf(listener);\n        if (position !== -1) {\n            this._listeners.splice(position, 1);\n        }\n    }\n    removeErrorListeners() {\n        this._listeners.length = 0;\n    }\n    getErrorListeners() {\n        return this._listeners.slice(0);\n    }\n    getErrorListenerDispatch() {\n        return new ProxyErrorListener_1.ProxyErrorListener(this.getErrorListeners());\n    }\n    // subclass needs to override these if there are sempreds or actions\n    // that the ATN interp needs to execute\n    sempred(_localctx, ruleIndex, actionIndex) {\n        return true;\n    }\n    precpred(localctx, precedence) {\n        return true;\n    }\n    action(_localctx, ruleIndex, actionIndex) {\n        // intentionally empty\n    }\n    get state() {\n        return this._stateNumber;\n    }\n    /** Indicate that the recognizer has changed internal state that is\n     *  consistent with the ATN state passed in.  This way we always know\n     *  where we are in the ATN as the parser goes along. The rule\n     *  context objects form a stack that lets us see the stack of\n     *  invoking rules. Combine this and we have complete ATN\n     *  configuration information.\n     */\n    set state(atnState) {\n        //\t\tSystem.err.println(\"setState \"+atnState);\n        this._stateNumber = atnState;\n        //\t\tif ( traceATNStates ) _ctx.trace(atnState);\n    }\n}\nRecognizer.EOF = -1;\nRecognizer.tokenTypeMapCache = new WeakMap();\nRecognizer.ruleIndexMapCache = new WeakMap();\n__decorate([\n    Decorators_1.SuppressWarnings(\"serial\"),\n    Decorators_1.NotNull\n], Recognizer.prototype, \"_listeners\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], Recognizer.prototype, \"getTokenTypeMap\", null);\n__decorate([\n    Decorators_1.NotNull\n], Recognizer.prototype, \"getRuleIndexMap\", null);\n__decorate([\n    Decorators_1.NotNull\n], Recognizer.prototype, \"serializedATN\", null);\n__decorate([\n    Decorators_1.NotNull\n], Recognizer.prototype, \"atn\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], Recognizer.prototype, \"interpreter\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], Recognizer.prototype, \"getErrorHeader\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], Recognizer.prototype, \"addErrorListener\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], Recognizer.prototype, \"removeErrorListener\", null);\n__decorate([\n    Decorators_1.NotNull\n], Recognizer.prototype, \"getErrorListeners\", null);\nexports.Recognizer = Recognizer;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:57.1954441-07:00\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\nimport { ATN } from \"./atn/ATN\";\nimport { ATNSimulator } from \"./atn/ATNSimulator\";\nimport { ConsoleErrorListener } from \"./ConsoleErrorListener\";\nimport { IntStream } from \"./IntStream\";\nimport { ParseInfo } from \"./atn/ParseInfo\";\nimport { ProxyErrorListener } from \"./ProxyErrorListener\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { RuleContext } from \"./RuleContext\";\nimport { SuppressWarnings, NotNull } from \"./Decorators\";\nimport { Token } from \"./Token\";\nimport { Vocabulary } from \"./Vocabulary\";\nimport { VocabularyImpl } from \"./VocabularyImpl\";\n\nimport * as Utils from \"./misc/Utils\";\n\nexport abstract class Recognizer<TSymbol, ATNInterpreter extends ATNSimulator> {\n\tpublic static readonly EOF: number = -1;\n\n\tprivate static tokenTypeMapCache =\n\t\tnew WeakMap<Vocabulary, ReadonlyMap<string, number>>();\n\tprivate static ruleIndexMapCache =\n\t\tnew WeakMap<string[], ReadonlyMap<string, number>>();\n\n\t@SuppressWarnings(\"serial\")\n\t@NotNull\n\tprivate readonly _listeners: Array<ANTLRErrorListener<TSymbol>> = [ConsoleErrorListener.INSTANCE];\n\n\tprotected _interp: ATNInterpreter;\n\n\tprivate _stateNumber = -1;\n\n\tpublic abstract readonly ruleNames: string[];\n\n\t/**\n\t * Get the vocabulary used by the recognizer.\n\t *\n\t * @returns A {@link Vocabulary} instance providing information about the\n\t * vocabulary used by the grammar.\n\t */\n\tpublic abstract readonly vocabulary: Vocabulary;\n\n\t/**\n\t * Get a map from token names to token types.\n\t *\n\t * Used for XPath and tree pattern compilation.\n\t */\n\t@NotNull\n\tpublic getTokenTypeMap(): ReadonlyMap<string, number> {\n\t\tlet vocabulary: Vocabulary = this.vocabulary;\n\t\tlet result = Recognizer.tokenTypeMapCache.get(vocabulary);\n\t\tif (result == null) {\n\t\t\tlet intermediateResult = new Map<string, number>();\n\t\t\tfor (let i = 0; i <= this.atn.maxTokenType; i++) {\n\t\t\t\tlet literalName = vocabulary.getLiteralName(i);\n\t\t\t\tif (literalName != null) {\n\t\t\t\t\tintermediateResult.set(literalName, i);\n\t\t\t\t}\n\n\t\t\t\tlet symbolicName = vocabulary.getSymbolicName(i);\n\t\t\t\tif (symbolicName != null) {\n\t\t\t\t\tintermediateResult.set(symbolicName, i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tintermediateResult.set(\"EOF\", Token.EOF);\n\t\t\tresult = intermediateResult;\n\t\t\tRecognizer.tokenTypeMapCache.set(vocabulary, result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get a map from rule names to rule indexes.\n\t *\n\t * Used for XPath and tree pattern compilation.\n\t */\n\t@NotNull\n\tpublic getRuleIndexMap(): ReadonlyMap<string, number> {\n\t\tlet ruleNames: string[] = this.ruleNames;\n\t\tif (ruleNames == null) {\n\t\t\tthrow new Error(\"The current recognizer does not provide a list of rule names.\");\n\t\t}\n\n\t\tlet result: ReadonlyMap<string, number> | undefined = Recognizer.ruleIndexMapCache.get(ruleNames);\n\t\tif (result == null) {\n\t\t\tresult = Utils.toMap(ruleNames);\n\t\t\tRecognizer.ruleIndexMapCache.set(ruleNames, result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic getTokenType(tokenName: string): number {\n\t\tlet ttype = this.getTokenTypeMap().get(tokenName);\n\t\tif (ttype != null) {\n\t\t\treturn ttype;\n\t\t}\n\t\treturn Token.INVALID_TYPE;\n\t}\n\n\t/**\n\t * If this recognizer was generated, it will have a serialized ATN\n\t * representation of the grammar.\n\t *\n\t * For interpreters, we don't know their serialized ATN despite having\n\t * created the interpreter from it.\n\t */\n\t@NotNull\n\tget serializedATN(): string {\n\t\tthrow new Error(\"there is no serialized ATN\");\n\t}\n\n\t/** For debugging and other purposes, might want the grammar name.\n\t *  Have ANTLR generate an implementation for this method.\n\t */\n\tpublic abstract readonly grammarFileName: string;\n\n\t/**\n\t * Get the {@link ATN} used by the recognizer for prediction.\n\t *\n\t * @returns The {@link ATN} used by the recognizer for prediction.\n\t */\n\t@NotNull\n\tget atn(): ATN {\n\t\treturn this._interp.atn;\n\t}\n\n\t/**\n\t * Get the ATN interpreter used by the recognizer for prediction.\n\t *\n\t * @returns The ATN interpreter used by the recognizer for prediction.\n\t */\n\t@NotNull\n\tget interpreter(): ATNInterpreter {\n\t\treturn this._interp;\n\t}\n\n\t/**\n\t * Set the ATN interpreter used by the recognizer for prediction.\n\t *\n\t * @param interpreter The ATN interpreter used by the recognizer for\n\t * prediction.\n\t */\n\tset interpreter(@NotNull interpreter: ATNInterpreter) {\n\t\tthis._interp = interpreter;\n\t}\n\n\t/** If profiling during the parse/lex, this will return DecisionInfo records\n\t *  for each decision in recognizer in a ParseInfo object.\n\t *\n\t * @since 4.3\n\t */\n\tget parseInfo(): Promise<ParseInfo | undefined> {\n\t\treturn Promise.resolve(undefined);\n\t}\n\n\t/** What is the error header, normally line/character position information? */\n\t@NotNull\n\tpublic getErrorHeader(@NotNull e: RecognitionException): string {\n\t\tlet token = e.getOffendingToken();\n\t\tif (!token) {\n\t\t\treturn \"\";\n\t\t}\n\t\tlet line = token.line;\n\t\tlet charPositionInLine: number = token.charPositionInLine;\n\t\treturn \"line \" + line + \":\" + charPositionInLine;\n\t}\n\n\t/**\n\t * @exception NullPointerException if `listener` is `undefined`.\n\t */\n\tpublic addErrorListener(@NotNull listener: ANTLRErrorListener<TSymbol>): void {\n\t\tif (!listener) {\n\t\t\tthrow new TypeError(\"listener must not be null\");\n\t\t}\n\t\tthis._listeners.push(listener);\n\t}\n\n\tpublic removeErrorListener(@NotNull listener: ANTLRErrorListener<TSymbol>): void {\n\t\tlet position = this._listeners.indexOf(listener);\n\t\tif (position !== -1) {\n\t\t\tthis._listeners.splice(position, 1);\n\t\t}\n\t}\n\n\tpublic removeErrorListeners(): void {\n\t\tthis._listeners.length = 0;\n\t}\n\n\t@NotNull\n\tpublic getErrorListeners(): Array<ANTLRErrorListener<TSymbol>> {\n\t\treturn this._listeners.slice(0);\n\t}\n\n\tpublic getErrorListenerDispatch(): ANTLRErrorListener<TSymbol> {\n\t\treturn new ProxyErrorListener<TSymbol, ANTLRErrorListener<TSymbol>>(this.getErrorListeners());\n\t}\n\n\t// subclass needs to override these if there are sempreds or actions\n\t// that the ATN interp needs to execute\n\tpublic sempred(\n\t\t_localctx: RuleContext | undefined,\n\t\truleIndex: number,\n\t\tactionIndex: number): boolean {\n\t\treturn true;\n\t}\n\n\tpublic precpred(\n\t\tlocalctx: RuleContext | undefined,\n\t\tprecedence: number): boolean {\n\t\treturn true;\n\t}\n\n\tpublic action(\n\t\t_localctx: RuleContext | undefined,\n\t\truleIndex: number,\n\t\tactionIndex: number): void {\n\t\t// intentionally empty\n\t}\n\n\tget state(): number {\n\t\treturn this._stateNumber;\n\t}\n\n\t/** Indicate that the recognizer has changed internal state that is\n\t *  consistent with the ATN state passed in.  This way we always know\n\t *  where we are in the ATN as the parser goes along. The rule\n\t *  context objects form a stack that lets us see the stack of\n\t *  invoking rules. Combine this and we have complete ATN\n\t *  configuration information.\n\t */\n\tset state(atnState: number) {\n//\t\tSystem.err.println(\"setState \"+atnState);\n\t\tthis._stateNumber = atnState;\n//\t\tif ( traceATNStates ) _ctx.trace(atnState);\n\t}\n\n\tpublic abstract readonly inputStream: IntStream | undefined;\n}\n"]}