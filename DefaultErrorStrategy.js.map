{"version":3,"sources":["DefaultErrorStrategy.js","../src/DefaultErrorStrategy.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","ATNState_1","require","ATNStateType_1","FailedPredicateException_1","InputMismatchException_1","IntervalSet_1","NoViableAltException_1","PredictionContext_1","Token_1","Decorators_1","DefaultErrorStrategy","errorRecoveryMode","lastErrorIndex","nextTokensState","ATNState","INVALID_STATE_NUMBER","recognizer","endErrorCondition","lastErrorStates","undefined","e","inErrorRecoveryMode","beginErrorCondition","NoViableAltException","reportNoViableAlternative","InputMismatchException","reportInputMismatch","FailedPredicateException","reportFailedPredicate","console","error","notifyErrorListeners","toString","message","offendingToken","getOffendingToken","inputStream","index","contains","state","consume","IntervalSet","add","followSet","getErrorRecoverySet","consumeUntil","s","interpreter","atn","states","tokens","la","LA","nextTokens","nextTokensContext","Token","EPSILON","context","stateType","ATNStateType","BLOCK_START","STAR_BLOCK_START","PLUS_BLOCK_START","STAR_LOOP_ENTRY","singleTokenDeletion","PLUS_LOOP_BACK","STAR_LOOP_BACK","reportUnwantedToken","expecting","getExpectedTokens","whatFollowsLoopIterationOrRule","or","input","startToken","type","EOF","getTextFromRange","msg","escapeWSAndQuote","expected","expectedTokens","expectedString","toStringVocabulary","vocabulary","getTokenErrorDisplay","ruleName","ruleNames","ruleIndex","t","currentToken","tokenName","matchedSymbol","singleTokenInsertion","getMissingSymbol","currentSymbolType","currentState","next","transition","expectingAtLL2","PredictionContext","fromRuleContext","reportMissingToken","nextTokenType","reportMatch","currentSymbol","expectedTokenType","INVALID_TYPE","isNil","minElement","tokenText","getDisplayName","current","lookback","tryLT","constructToken","tokenSource","factory","tokenFactory","x","stream","create","source","DEFAULT_CHANNEL","line","charPositionInLine","getSymbolText","getSymbolType","symbol","text","replace","ctx","recoverSet","invokingState","rt","follow","followState","addAll","_parent","remove","set","ttype","Override","prototype","NotNull"],"mappings":"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","file":"DefaultErrorStrategy.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ATNState_1 = require(\"./atn/ATNState\");\nconst ATNStateType_1 = require(\"./atn/ATNStateType\");\nconst FailedPredicateException_1 = require(\"./FailedPredicateException\");\nconst InputMismatchException_1 = require(\"./InputMismatchException\");\nconst IntervalSet_1 = require(\"./misc/IntervalSet\");\nconst NoViableAltException_1 = require(\"./NoViableAltException\");\nconst PredictionContext_1 = require(\"./atn/PredictionContext\");\nconst Token_1 = require(\"./Token\");\nconst Decorators_1 = require(\"./Decorators\");\n/**\n * This is the default implementation of {@link ANTLRErrorStrategy} used for\n * error reporting and recovery in ANTLR parsers.\n */\nclass DefaultErrorStrategy {\n    constructor() {\n        /**\n         * Indicates whether the error strategy is currently \"recovering from an\n         * error\". This is used to suppress reporting multiple error messages while\n         * attempting to recover from a detected syntax error.\n         *\n         * @see #inErrorRecoveryMode\n         */\n        this.errorRecoveryMode = false;\n        /** The index into the input stream where the last error occurred.\n         * \tThis is used to prevent infinite loops where an error is found\n         *  but no token is consumed during recovery...another error is found,\n         *  ad nauseum.  This is a failsafe mechanism to guarantee that at least\n         *  one token/tree node is consumed for two errors.\n         */\n        this.lastErrorIndex = -1;\n        /**\n         * @see #nextTokensContext\n         */\n        this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;\n    }\n    /**\n     * {@inheritDoc}\n     *\n     * The default implementation simply calls {@link #endErrorCondition} to\n     * ensure that the handler is not in error recovery mode.\n     */\n    reset(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n    /**\n     * This method is called to enter error recovery mode when a recognition\n     * exception is reported.\n     *\n     * @param recognizer the parser instance\n     */\n    beginErrorCondition(recognizer) {\n        this.errorRecoveryMode = true;\n    }\n    /**\n     * {@inheritDoc}\n     */\n    inErrorRecoveryMode(recognizer) {\n        return this.errorRecoveryMode;\n    }\n    /**\n     * This method is called to leave error recovery mode after recovering from\n     * a recognition exception.\n     *\n     * @param recognizer\n     */\n    endErrorCondition(recognizer) {\n        this.errorRecoveryMode = false;\n        this.lastErrorStates = undefined;\n        this.lastErrorIndex = -1;\n    }\n    /**\n     * {@inheritDoc}\n     *\n     * The default implementation simply calls {@link #endErrorCondition}.\n     */\n    reportMatch(recognizer) {\n        this.endErrorCondition(recognizer);\n    }\n    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns immediately if the handler is already\n     * in error recovery mode. Otherwise, it calls {@link #beginErrorCondition}\n     * and dispatches the reporting task based on the runtime type of `e`\n     * according to the following table.\n     *\n     * * {@link NoViableAltException}: Dispatches the call to\n     *   {@link #reportNoViableAlternative}\n     * * {@link InputMismatchException}: Dispatches the call to\n     *   {@link #reportInputMismatch}\n     * * {@link FailedPredicateException}: Dispatches the call to\n     *   {@link #reportFailedPredicate}\n     * * All other types: calls {@link Parser#notifyErrorListeners} to report\n     *   the exception\n     */\n    reportError(recognizer, e) {\n        // if we've already reported an error and have not matched a token\n        // yet successfully, don't report any errors.\n        if (this.inErrorRecoveryMode(recognizer)) {\n            //\t\t\tSystem.err.print(\"[SPURIOUS] \");\n            return; // don't report spurious errors\n        }\n        this.beginErrorCondition(recognizer);\n        if (e instanceof NoViableAltException_1.NoViableAltException) {\n            this.reportNoViableAlternative(recognizer, e);\n        }\n        else if (e instanceof InputMismatchException_1.InputMismatchException) {\n            this.reportInputMismatch(recognizer, e);\n        }\n        else if (e instanceof FailedPredicateException_1.FailedPredicateException) {\n            this.reportFailedPredicate(recognizer, e);\n        }\n        else {\n            console.error(`unknown recognition error type: ${e}`);\n            this.notifyErrorListeners(recognizer, e.toString(), e);\n        }\n    }\n    notifyErrorListeners(recognizer, message, e) {\n        let offendingToken = e.getOffendingToken(recognizer);\n        if (offendingToken === undefined) {\n            // Pass null to notifyErrorListeners so it in turn calls the error listeners with undefined as the offending\n            // token. If we passed undefined, it would instead call the listeners with currentToken from the parser.\n            offendingToken = null;\n        }\n        recognizer.notifyErrorListeners(message, offendingToken, e);\n    }\n    /**\n     * {@inheritDoc}\n     *\n     * The default implementation resynchronizes the parser by consuming tokens\n     * until we find one in the resynchronization set--loosely the set of tokens\n     * that can follow the current rule.\n     */\n    recover(recognizer, e) {\n        //\t\tSystem.out.println(\"recover in \"+recognizer.getRuleInvocationStack()+\n        //\t\t\t\t\t\t   \" index=\"+recognizer.inputStream.index+\n        //\t\t\t\t\t\t   \", lastErrorIndex=\"+\n        //\t\t\t\t\t\t   lastErrorIndex+\n        //\t\t\t\t\t\t   \", states=\"+lastErrorStates);\n        if (this.lastErrorIndex === recognizer.inputStream.index &&\n            this.lastErrorStates &&\n            this.lastErrorStates.contains(recognizer.state)) {\n            // uh oh, another error at same token index and previously-visited\n            // state in ATN; must be a case where LT(1) is in the recovery\n            // token set so nothing got consumed. Consume a single token\n            // at least to prevent an infinite loop; this is a failsafe.\n            //\t\t\tSystem.err.println(\"seen error condition before index=\"+\n            //\t\t\t\t\t\t\t   lastErrorIndex+\", states=\"+lastErrorStates);\n            //\t\t\tSystem.err.println(\"FAILSAFE consumes \"+recognizer.getTokenNames()[recognizer.inputStream.LA(1)]);\n            recognizer.consume();\n        }\n        this.lastErrorIndex = recognizer.inputStream.index;\n        if (!this.lastErrorStates) {\n            this.lastErrorStates = new IntervalSet_1.IntervalSet();\n        }\n        this.lastErrorStates.add(recognizer.state);\n        let followSet = this.getErrorRecoverySet(recognizer);\n        this.consumeUntil(recognizer, followSet);\n    }\n    /**\n     * The default implementation of {@link ANTLRErrorStrategy#sync} makes sure\n     * that the current lookahead symbol is consistent with what were expecting\n     * at this point in the ATN. You can call this anytime but ANTLR only\n     * generates code to check before subrules/loops and each iteration.\n     *\n     * Implements Jim Idle's magic sync mechanism in closures and optional\n     * subrules. E.g.,\n     *\n     * ```antlr\n     * a : sync ( stuff sync )* ;\n     * sync : {consume to what can follow sync} ;\n     * ```\n     *\n     * At the start of a sub rule upon error, {@link #sync} performs single\n     * token deletion, if possible. If it can't do that, it bails on the current\n     * rule and uses the default error recovery, which consumes until the\n     * resynchronization set of the current rule.\n     *\n     * If the sub rule is optional (`(...)?`, `(...)*`, or block\n     * with an empty alternative), then the expected set includes what follows\n     * the subrule.\n     *\n     * During loop iteration, it consumes until it sees a token that can start a\n     * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n     * stay in the loop as long as possible.\n     *\n     * **ORIGINS**\n     *\n     * Previous versions of ANTLR did a poor job of their recovery within loops.\n     * A single mismatch token or missing token would force the parser to bail\n     * out of the entire rules surrounding the loop. So, for rule\n     *\n     * ```antlr\n     * classDef : 'class' ID '{' member* '}'\n     * ```\n     *\n     * input with an extra token between members would force the parser to\n     * consume until it found the next class definition rather than the next\n     * member definition of the current class.\n     *\n     * This functionality cost a little bit of effort because the parser has to\n     * compare token set at the start of the loop and at each iteration. If for\n     * some reason speed is suffering for you, you can turn off this\n     * functionality by simply overriding this method as a blank { }.\n     */\n    sync(recognizer) {\n        let s = recognizer.interpreter.atn.states[recognizer.state];\n        //\t\tSystem.err.println(\"sync @ \"+s.stateNumber+\"=\"+s.getClass().getSimpleName());\n        // If already recovering, don't try to sync\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        let tokens = recognizer.inputStream;\n        let la = tokens.LA(1);\n        // try cheaper subset first; might get lucky. seems to shave a wee bit off\n        let nextTokens = recognizer.atn.nextTokens(s);\n        if (nextTokens.contains(la)) {\n            // We are sure the token matches\n            this.nextTokensContext = undefined;\n            this.nextTokensState = ATNState_1.ATNState.INVALID_STATE_NUMBER;\n            return;\n        }\n        if (nextTokens.contains(Token_1.Token.EPSILON)) {\n            if (this.nextTokensContext === undefined) {\n                // It's possible the next token won't match; information tracked\n                // by sync is restricted for performance.\n                this.nextTokensContext = recognizer.context;\n                this.nextTokensState = recognizer.state;\n            }\n            return;\n        }\n        switch (s.stateType) {\n            case ATNStateType_1.ATNStateType.BLOCK_START:\n            case ATNStateType_1.ATNStateType.STAR_BLOCK_START:\n            case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:\n            case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:\n                // report error and recover if possible\n                if (this.singleTokenDeletion(recognizer)) {\n                    return;\n                }\n                throw new InputMismatchException_1.InputMismatchException(recognizer);\n            case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:\n            case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:\n                //\t\t\tSystem.err.println(\"at loop back: \"+s.getClass().getSimpleName());\n                this.reportUnwantedToken(recognizer);\n                let expecting = recognizer.getExpectedTokens();\n                let whatFollowsLoopIterationOrRule = expecting.or(this.getErrorRecoverySet(recognizer));\n                this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n                break;\n            default:\n                // do nothing if we can't identify the exact kind of ATN state\n                break;\n        }\n    }\n    /**\n     * This is called by {@link #reportError} when the exception is a\n     * {@link NoViableAltException}.\n     *\n     * @see #reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportNoViableAlternative(recognizer, e) {\n        let tokens = recognizer.inputStream;\n        let input;\n        if (tokens) {\n            if (e.startToken.type === Token_1.Token.EOF) {\n                input = \"<EOF>\";\n            }\n            else {\n                input = tokens.getTextFromRange(e.startToken, e.getOffendingToken());\n            }\n        }\n        else {\n            input = \"<unknown input>\";\n        }\n        let msg = \"no viable alternative at input \" + this.escapeWSAndQuote(input);\n        this.notifyErrorListeners(recognizer, msg, e);\n    }\n    /**\n     * This is called by {@link #reportError} when the exception is an\n     * {@link InputMismatchException}.\n     *\n     * @see #reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportInputMismatch(recognizer, e) {\n        let expected = e.expectedTokens;\n        let expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : \"\";\n        let msg = \"mismatched input \" + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) +\n            \" expecting \" + expectedString;\n        this.notifyErrorListeners(recognizer, msg, e);\n    }\n    /**\n     * This is called by {@link #reportError} when the exception is a\n     * {@link FailedPredicateException}.\n     *\n     * @see #reportError\n     *\n     * @param recognizer the parser instance\n     * @param e the recognition exception\n     */\n    reportFailedPredicate(recognizer, e) {\n        let ruleName = recognizer.ruleNames[recognizer.context.ruleIndex];\n        let msg = \"rule \" + ruleName + \" \" + e.message;\n        this.notifyErrorListeners(recognizer, msg, e);\n    }\n    /**\n     * This method is called to report a syntax error which requires the removal\n     * of a token from the input stream. At the time this method is called, the\n     * erroneous symbol is current `LT(1)` symbol and has not yet been\n     * removed from the input stream. When this method returns,\n     * `recognizer` is in error recovery mode.\n     *\n     * This method is called when {@link #singleTokenDeletion} identifies\n     * single-token deletion as a viable recovery strategy for a mismatched\n     * input error.\n     *\n     * The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser#notifyErrorListeners}.\n     *\n     * @param recognizer the parser instance\n     */\n    reportUnwantedToken(recognizer) {\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        let t = recognizer.currentToken;\n        let tokenName = this.getTokenErrorDisplay(t);\n        let expecting = this.getExpectedTokens(recognizer);\n        let msg = \"extraneous input \" + tokenName + \" expecting \" +\n            expecting.toStringVocabulary(recognizer.vocabulary);\n        recognizer.notifyErrorListeners(msg, t, undefined);\n    }\n    /**\n     * This method is called to report a syntax error which requires the\n     * insertion of a missing token into the input stream. At the time this\n     * method is called, the missing token has not yet been inserted. When this\n     * method returns, `recognizer` is in error recovery mode.\n     *\n     * This method is called when {@link #singleTokenInsertion} identifies\n     * single-token insertion as a viable recovery strategy for a mismatched\n     * input error.\n     *\n     * The default implementation simply returns if the handler is already in\n     * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to\n     * enter error recovery mode, followed by calling\n     * {@link Parser#notifyErrorListeners}.\n     *\n     * @param recognizer the parser instance\n     */\n    reportMissingToken(recognizer) {\n        if (this.inErrorRecoveryMode(recognizer)) {\n            return;\n        }\n        this.beginErrorCondition(recognizer);\n        let t = recognizer.currentToken;\n        let expecting = this.getExpectedTokens(recognizer);\n        let msg = \"missing \" + expecting.toStringVocabulary(recognizer.vocabulary) +\n            \" at \" + this.getTokenErrorDisplay(t);\n        recognizer.notifyErrorListeners(msg, t, undefined);\n    }\n    /**\n     * {@inheritDoc}\n     *\n     * The default implementation attempts to recover from the mismatched input\n     * by using single token insertion and deletion as described below. If the\n     * recovery attempt fails, this method\n     * {@link InputMismatchException}.\n     *\n     * **EXTRA TOKEN** (single token deletion)\n     *\n     * `LA(1)` is not what we are looking for. If `LA(2)` has the\n     * right token, however, then assume `LA(1)` is some extra spurious\n     * token and delete it. Then consume and return the next token (which was\n     * the `LA(2)` token) as the successful result of the match operation.\n     *\n     * This recovery strategy is implemented by {@link #singleTokenDeletion}.\n     *\n     * **MISSING TOKEN** (single token insertion)\n     *\n     * If current token (at `LA(1)`) is consistent with what could come\n     * after the expected `LA(1)` token, then assume the token is missing\n     * and use the parser's {@link TokenFactory} to create it on the fly. The\n     * \"insertion\" is performed by returning the created token as the successful\n     * result of the match operation.\n     *\n     * This recovery strategy is implemented by {@link #singleTokenInsertion}.\n     *\n     * **EXAMPLE**\n     *\n     * For example, Input `i=(3;` is clearly missing the `')'`. When\n     * the parser returns from the nested call to `expr`, it will have\n     * call chain:\n     *\n     * ```\n     * stat → expr → atom\n     * ```\n     *\n     * and it will be trying to match the `')'` at this point in the\n     * derivation:\n     *\n     * ```\n     * => ID '=' '(' INT ')' ('+' atom)* ';'\n     *                    ^\n     * ```\n     *\n     * The attempt to match `')'` will fail when it sees `';'` and\n     * call {@link #recoverInline}. To recover, it sees that `LA(1)==';'`\n     * is in the set of tokens that can follow the `')'` token reference\n     * in rule `atom`. It can assume that you forgot the `')'`.\n     */\n    recoverInline(recognizer) {\n        // SINGLE TOKEN DELETION\n        let matchedSymbol = this.singleTokenDeletion(recognizer);\n        if (matchedSymbol) {\n            // we have deleted the extra token.\n            // now, move past ttype token as if all were ok\n            recognizer.consume();\n            return matchedSymbol;\n        }\n        // SINGLE TOKEN INSERTION\n        if (this.singleTokenInsertion(recognizer)) {\n            return this.getMissingSymbol(recognizer);\n        }\n        // even that didn't work; must throw the exception\n        if (this.nextTokensContext === undefined) {\n            throw new InputMismatchException_1.InputMismatchException(recognizer);\n        }\n        else {\n            throw new InputMismatchException_1.InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);\n        }\n    }\n    /**\n     * This method implements the single-token insertion inline error recovery\n     * strategy. It is called by {@link #recoverInline} if the single-token\n     * deletion strategy fails to recover from the mismatched input. If this\n     * method returns `true`, `recognizer` will be in error recovery\n     * mode.\n     *\n     * This method determines whether or not single-token insertion is viable by\n     * checking if the `LA(1)` input symbol could be successfully matched\n     * if it were instead the `LA(2)` symbol. If this method returns\n     * `true`, the caller is responsible for creating and inserting a\n     * token with the correct type to produce this behavior.\n     *\n     * @param recognizer the parser instance\n     * @returns `true` if single-token insertion is a viable recovery\n     * strategy for the current mismatched input, otherwise `false`\n     */\n    singleTokenInsertion(recognizer) {\n        let currentSymbolType = recognizer.inputStream.LA(1);\n        // if current token is consistent with what could come after current\n        // ATN state, then we know we're missing a token; error recovery\n        // is free to conjure up and insert the missing token\n        let currentState = recognizer.interpreter.atn.states[recognizer.state];\n        let next = currentState.transition(0).target;\n        let atn = recognizer.interpreter.atn;\n        let expectingAtLL2 = atn.nextTokens(next, PredictionContext_1.PredictionContext.fromRuleContext(atn, recognizer.context));\n        //\t\tconsole.warn(\"LT(2) set=\"+expectingAtLL2.toString(recognizer.getTokenNames()));\n        if (expectingAtLL2.contains(currentSymbolType)) {\n            this.reportMissingToken(recognizer);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * This method implements the single-token deletion inline error recovery\n     * strategy. It is called by {@link #recoverInline} to attempt to recover\n     * from mismatched input. If this method returns `undefined`, the parser and error\n     * handler state will not have changed. If this method returns non-`undefined`,\n     * `recognizer` will *not* be in error recovery mode since the\n     * returned token was a successful match.\n     *\n     * If the single-token deletion is successful, this method calls\n     * {@link #reportUnwantedToken} to report the error, followed by\n     * {@link Parser#consume} to actually \"delete\" the extraneous token. Then,\n     * before returning {@link #reportMatch} is called to signal a successful\n     * match.\n     *\n     * @param recognizer the parser instance\n     * @returns the successfully matched {@link Token} instance if single-token\n     * deletion successfully recovers from the mismatched input, otherwise\n     * `undefined`\n     */\n    singleTokenDeletion(recognizer) {\n        let nextTokenType = recognizer.inputStream.LA(2);\n        let expecting = this.getExpectedTokens(recognizer);\n        if (expecting.contains(nextTokenType)) {\n            this.reportUnwantedToken(recognizer);\n            /*\n            System.err.println(\"recoverFromMismatchedToken deleting \"+\n                               ((TokenStream)recognizer.inputStream).LT(1)+\n                               \" since \"+((TokenStream)recognizer.inputStream).LT(2)+\n                               \" is what we want\");\n            */\n            recognizer.consume(); // simply delete extra token\n            // we want to return the token we're actually matching\n            let matchedSymbol = recognizer.currentToken;\n            this.reportMatch(recognizer); // we know current token is correct\n            return matchedSymbol;\n        }\n        return undefined;\n    }\n    /** Conjure up a missing token during error recovery.\n     *\n     *  The recognizer attempts to recover from single missing\n     *  symbols. But, actions might refer to that missing symbol.\n     *  For example, x=ID {f($x);}. The action clearly assumes\n     *  that there has been an identifier matched previously and that\n     *  $x points at that token. If that token is missing, but\n     *  the next token in the stream is what we want we assume that\n     *  this token is missing and we keep going. Because we\n     *  have to return some token to replace the missing token,\n     *  we have to conjure one up. This method gives the user control\n     *  over the tokens returned for missing tokens. Mostly,\n     *  you will want to create something special for identifier\n     *  tokens. For literals such as '{' and ',', the default\n     *  action in the parser or tree parser works. It simply creates\n     *  a CommonToken of the appropriate type. The text will be the token.\n     *  If you change what tokens must be created by the lexer,\n     *  override this method to create the appropriate tokens.\n     */\n    getMissingSymbol(recognizer) {\n        let currentSymbol = recognizer.currentToken;\n        let expecting = this.getExpectedTokens(recognizer);\n        let expectedTokenType = Token_1.Token.INVALID_TYPE;\n        if (!expecting.isNil) {\n            // get any element\n            expectedTokenType = expecting.minElement;\n        }\n        let tokenText;\n        if (expectedTokenType === Token_1.Token.EOF) {\n            tokenText = \"<missing EOF>\";\n        }\n        else {\n            tokenText = \"<missing \" + recognizer.vocabulary.getDisplayName(expectedTokenType) + \">\";\n        }\n        let current = currentSymbol;\n        let lookback = recognizer.inputStream.tryLT(-1);\n        if (current.type === Token_1.Token.EOF && lookback != null) {\n            current = lookback;\n        }\n        return this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);\n    }\n    constructToken(tokenSource, expectedTokenType, tokenText, current) {\n        let factory = tokenSource.tokenFactory;\n        let x = current.tokenSource;\n        let stream = x ? x.inputStream : undefined;\n        return factory.create({ source: tokenSource, stream }, expectedTokenType, tokenText, Token_1.Token.DEFAULT_CHANNEL, -1, -1, current.line, current.charPositionInLine);\n    }\n    getExpectedTokens(recognizer) {\n        return recognizer.getExpectedTokens();\n    }\n    /** How should a token be displayed in an error message? The default\n     *  is to display just the text, but during development you might\n     *  want to have a lot of information spit out.  Override in that case\n     *  to use t.toString() (which, for CommonToken, dumps everything about\n     *  the token). This is better than forcing you to override a method in\n     *  your token objects because you don't have to go modify your lexer\n     *  so that it creates a new Java type.\n     */\n    getTokenErrorDisplay(t) {\n        if (!t) {\n            return \"<no token>\";\n        }\n        let s = this.getSymbolText(t);\n        if (!s) {\n            if (this.getSymbolType(t) === Token_1.Token.EOF) {\n                s = \"<EOF>\";\n            }\n            else {\n                s = `<${this.getSymbolType(t)}>`;\n            }\n        }\n        return this.escapeWSAndQuote(s);\n    }\n    getSymbolText(symbol) {\n        return symbol.text;\n    }\n    getSymbolType(symbol) {\n        return symbol.type;\n    }\n    escapeWSAndQuote(s) {\n        //\t\tif ( s==null ) return s;\n        s = s.replace(\"\\n\", \"\\\\n\");\n        s = s.replace(\"\\r\", \"\\\\r\");\n        s = s.replace(\"\\t\", \"\\\\t\");\n        return \"'\" + s + \"'\";\n    }\n    /*  Compute the error recovery set for the current rule.  During\n     *  rule invocation, the parser pushes the set of tokens that can\n     *  follow that rule reference on the stack; this amounts to\n     *  computing FIRST of what follows the rule reference in the\n     *  enclosing rule. See LinearApproximator.FIRST().\n     *  This local follow set only includes tokens\n     *  from within the rule; i.e., the FIRST computation done by\n     *  ANTLR stops at the end of a rule.\n     *\n     *  EXAMPLE\n     *\n     *  When you find a \"no viable alt exception\", the input is not\n     *  consistent with any of the alternatives for rule r.  The best\n     *  thing to do is to consume tokens until you see something that\n     *  can legally follow a call to r *or* any rule that called r.\n     *  You don't want the exact set of viable next tokens because the\n     *  input might just be missing a token--you might consume the\n     *  rest of the input looking for one of the missing tokens.\n     *\n     *  Consider grammar:\n     *\n     *  a : '[' b ']'\n     *    | '(' b ')'\n     *    ;\n     *  b : c '^' INT ;\n     *  c : ID\n     *    | INT\n     *    ;\n     *\n     *  At each rule invocation, the set of tokens that could follow\n     *  that rule is pushed on a stack.  Here are the various\n     *  context-sensitive follow sets:\n     *\n     *  FOLLOW(b1_in_a) = FIRST(']') = ']'\n     *  FOLLOW(b2_in_a) = FIRST(')') = ')'\n     *  FOLLOW(c_in_b) = FIRST('^') = '^'\n     *\n     *  Upon erroneous input \"[]\", the call chain is\n     *\n     *  a -> b -> c\n     *\n     *  and, hence, the follow context stack is:\n     *\n     *  depth     follow set       start of rule execution\n     *    0         <EOF>                    a (from main())\n     *    1          ']'                     b\n     *    2          '^'                     c\n     *\n     *  Notice that ')' is not included, because b would have to have\n     *  been called from a different context in rule a for ')' to be\n     *  included.\n     *\n     *  For error recovery, we cannot consider FOLLOW(c)\n     *  (context-sensitive or otherwise).  We need the combined set of\n     *  all context-sensitive FOLLOW sets--the set of all tokens that\n     *  could follow any reference in the call chain.  We need to\n     *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if\n     *  we resync'd to that token, we'd consume until EOF.  We need to\n     *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n     *  In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n     *  not consume anything. After printing an error, rule c would\n     *  return normally.  Rule b would not find the required '^' though.\n     *  At this point, it gets a mismatched token error and\n     *  exception (since LA(1) is not in the viable following token\n     *  set).  The rule exception handler tries to recover, but finds\n     *  the same recovery set and doesn't consume anything.  Rule b\n     *  exits normally returning to rule a.  Now it finds the ']' (and\n     *  with the successful match exits errorRecovery mode).\n     *\n     *  So, you can see that the parser walks up the call chain looking\n     *  for the token that was a member of the recovery set.\n     *\n     *  Errors are not generated in errorRecovery mode.\n     *\n     *  ANTLR's error recovery mechanism is based upon original ideas:\n     *\n     *  \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n     *\n     *  and\n     *\n     *  \"A note on error recovery in recursive descent parsers\":\n     *  http://portal.acm.org/citation.cfm?id=947902.947905\n     *\n     *  Later, Josef Grosch had some good ideas:\n     *\n     *  \"Efficient and Comfortable Error Recovery in Recursive Descent\n     *  Parsers\":\n     *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n     *\n     *  Like Grosch I implement context-sensitive FOLLOW sets that are combined\n     *  at run-time upon error to avoid overhead during parsing.\n     */\n    getErrorRecoverySet(recognizer) {\n        let atn = recognizer.interpreter.atn;\n        let ctx = recognizer.context;\n        let recoverSet = new IntervalSet_1.IntervalSet();\n        while (ctx && ctx.invokingState >= 0) {\n            // compute what follows who invoked us\n            let invokingState = atn.states[ctx.invokingState];\n            let rt = invokingState.transition(0);\n            let follow = atn.nextTokens(rt.followState);\n            recoverSet.addAll(follow);\n            ctx = ctx._parent;\n        }\n        recoverSet.remove(Token_1.Token.EPSILON);\n        //\t\tSystem.out.println(\"recover set \"+recoverSet.toString(recognizer.getTokenNames()));\n        return recoverSet;\n    }\n    /** Consume tokens until one matches the given token set. */\n    consumeUntil(recognizer, set) {\n        //\t\tSystem.err.println(\"consumeUntil(\"+set.toString(recognizer.getTokenNames())+\")\");\n        let ttype = recognizer.inputStream.LA(1);\n        while (ttype !== Token_1.Token.EOF && !set.contains(ttype)) {\n            //System.out.println(\"consume during recover LA(1)=\"+getTokenNames()[input.LA(1)]);\n            //\t\t\trecognizer.inputStream.consume();\n            recognizer.consume();\n            ttype = recognizer.inputStream.LA(1);\n        }\n    }\n}\n__decorate([\n    Decorators_1.Override\n], DefaultErrorStrategy.prototype, \"reset\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"beginErrorCondition\", null);\n__decorate([\n    Decorators_1.Override\n], DefaultErrorStrategy.prototype, \"inErrorRecoveryMode\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"endErrorCondition\", null);\n__decorate([\n    Decorators_1.Override\n], DefaultErrorStrategy.prototype, \"reportMatch\", null);\n__decorate([\n    Decorators_1.Override\n], DefaultErrorStrategy.prototype, \"reportError\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"notifyErrorListeners\", null);\n__decorate([\n    Decorators_1.Override\n], DefaultErrorStrategy.prototype, \"recover\", null);\n__decorate([\n    Decorators_1.Override\n], DefaultErrorStrategy.prototype, \"sync\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"reportNoViableAlternative\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"reportInputMismatch\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"reportFailedPredicate\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"reportUnwantedToken\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"reportMissingToken\", null);\n__decorate([\n    Decorators_1.Override\n], DefaultErrorStrategy.prototype, \"recoverInline\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"singleTokenInsertion\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"singleTokenDeletion\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"getMissingSymbol\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"getExpectedTokens\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"getSymbolText\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"getSymbolType\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"escapeWSAndQuote\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"getErrorRecoverySet\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], DefaultErrorStrategy.prototype, \"consumeUntil\", null);\nexports.DefaultErrorStrategy = DefaultErrorStrategy;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:50.8290527-07:00\n\nimport { ANTLRErrorStrategy } from \"./ANTLRErrorStrategy\";\nimport { ATN } from \"./atn/ATN\";\nimport { ATNState } from \"./atn/ATNState\";\nimport { ATNStateType } from \"./atn/ATNStateType\";\nimport { FailedPredicateException } from \"./FailedPredicateException\";\nimport { InputMismatchException } from \"./InputMismatchException\";\nimport { IntervalSet } from \"./misc/IntervalSet\";\nimport { NoViableAltException } from \"./NoViableAltException\";\nimport { Parser } from \"./Parser\";\nimport { ParserRuleContext } from \"./ParserRuleContext\";\nimport { PredictionContext } from \"./atn/PredictionContext\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { RuleContext } from \"./RuleContext\";\nimport { RuleTransition } from \"./atn/RuleTransition\";\nimport { TokenStream } from \"./TokenStream\";\nimport { Token } from \"./Token\";\nimport { TokenFactory } from \"./TokenFactory\";\nimport { TokenSource } from \"./TokenSource\";\nimport { Vocabulary } from \"./Vocabulary\";\nimport { Override, NotNull } from \"./Decorators\";\n\n/**\n * This is the default implementation of {@link ANTLRErrorStrategy} used for\n * error reporting and recovery in ANTLR parsers.\n */\nexport class DefaultErrorStrategy implements ANTLRErrorStrategy {\n\t/**\n\t * Indicates whether the error strategy is currently \"recovering from an\n\t * error\". This is used to suppress reporting multiple error messages while\n\t * attempting to recover from a detected syntax error.\n\t *\n\t * @see #inErrorRecoveryMode\n\t */\n\tprotected errorRecoveryMode: boolean = false;\n\n\t/** The index into the input stream where the last error occurred.\n\t * \tThis is used to prevent infinite loops where an error is found\n\t *  but no token is consumed during recovery...another error is found,\n\t *  ad nauseum.  This is a failsafe mechanism to guarantee that at least\n\t *  one token/tree node is consumed for two errors.\n\t */\n\tprotected lastErrorIndex: number = -1;\n\n\tprotected lastErrorStates?: IntervalSet;\n\n\t/**\n\t * This field is used to propagate information about the lookahead following\n\t * the previous match. Since prediction prefers completing the current rule\n\t * to error recovery efforts, error reporting may occur later than the\n\t * original point where it was discoverable. The original context is used to\n\t * compute the true expected sets as though the reporting occurred as early\n\t * as possible.\n\t */\n\tprotected nextTokensContext?: ParserRuleContext;\n\n\t/**\n\t * @see #nextTokensContext\n\t */\n\tprotected nextTokensState: number = ATNState.INVALID_STATE_NUMBER;\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The default implementation simply calls {@link #endErrorCondition} to\n\t * ensure that the handler is not in error recovery mode.\n\t */\n\t@Override\n\tpublic reset(recognizer: Parser): void {\n\t\tthis.endErrorCondition(recognizer);\n\t}\n\n\t/**\n\t * This method is called to enter error recovery mode when a recognition\n\t * exception is reported.\n\t *\n\t * @param recognizer the parser instance\n\t */\n\tprotected beginErrorCondition(@NotNull recognizer: Parser): void {\n\t\tthis.errorRecoveryMode = true;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic inErrorRecoveryMode(recognizer: Parser): boolean {\n\t\treturn this.errorRecoveryMode;\n\t}\n\n\t/**\n\t * This method is called to leave error recovery mode after recovering from\n\t * a recognition exception.\n\t *\n\t * @param recognizer\n\t */\n\tprotected endErrorCondition(@NotNull recognizer: Parser): void {\n\t\tthis.errorRecoveryMode = false;\n\t\tthis.lastErrorStates = undefined;\n\t\tthis.lastErrorIndex = -1;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The default implementation simply calls {@link #endErrorCondition}.\n\t */\n\t@Override\n\tpublic reportMatch(recognizer: Parser): void {\n\t\tthis.endErrorCondition(recognizer);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The default implementation returns immediately if the handler is already\n\t * in error recovery mode. Otherwise, it calls {@link #beginErrorCondition}\n\t * and dispatches the reporting task based on the runtime type of `e`\n\t * according to the following table.\n\t *\n\t * * {@link NoViableAltException}: Dispatches the call to\n\t *   {@link #reportNoViableAlternative}\n\t * * {@link InputMismatchException}: Dispatches the call to\n\t *   {@link #reportInputMismatch}\n\t * * {@link FailedPredicateException}: Dispatches the call to\n\t *   {@link #reportFailedPredicate}\n\t * * All other types: calls {@link Parser#notifyErrorListeners} to report\n\t *   the exception\n\t */\n\t@Override\n\tpublic reportError(\n\t\trecognizer: Parser,\n\t\te: RecognitionException): void {\n\t\t// if we've already reported an error and have not matched a token\n\t\t// yet successfully, don't report any errors.\n\t\tif (this.inErrorRecoveryMode(recognizer)) {\n//\t\t\tSystem.err.print(\"[SPURIOUS] \");\n\t\t\treturn; // don't report spurious errors\n\t\t}\n\t\tthis.beginErrorCondition(recognizer);\n\t\tif (e instanceof NoViableAltException) {\n\t\t\tthis.reportNoViableAlternative(recognizer, e);\n\t\t}\n\t\telse if (e instanceof InputMismatchException) {\n\t\t\tthis.reportInputMismatch(recognizer, e);\n\t\t}\n\t\telse if (e instanceof FailedPredicateException) {\n\t\t\tthis.reportFailedPredicate(recognizer, e);\n\t\t}\n\t\telse {\n\t\t\tconsole.error(`unknown recognition error type: ${e}`);\n\t\t\tthis.notifyErrorListeners(recognizer, e.toString(), e);\n\t\t}\n\t}\n\n\tprotected notifyErrorListeners(@NotNull recognizer: Parser, message: string, e: RecognitionException): void {\n\t\tlet offendingToken: Token | null | undefined = e.getOffendingToken(recognizer);\n\t\tif (offendingToken === undefined) {\n\t\t\t// Pass null to notifyErrorListeners so it in turn calls the error listeners with undefined as the offending\n\t\t\t// token. If we passed undefined, it would instead call the listeners with currentToken from the parser.\n\t\t\toffendingToken = null;\n\t\t}\n\n\t\trecognizer.notifyErrorListeners(message, offendingToken, e);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The default implementation resynchronizes the parser by consuming tokens\n\t * until we find one in the resynchronization set--loosely the set of tokens\n\t * that can follow the current rule.\n\t */\n\t@Override\n\tpublic recover(recognizer: Parser, e: RecognitionException): void {\n//\t\tSystem.out.println(\"recover in \"+recognizer.getRuleInvocationStack()+\n//\t\t\t\t\t\t   \" index=\"+recognizer.inputStream.index+\n//\t\t\t\t\t\t   \", lastErrorIndex=\"+\n//\t\t\t\t\t\t   lastErrorIndex+\n//\t\t\t\t\t\t   \", states=\"+lastErrorStates);\n\t\tif (this.lastErrorIndex === recognizer.inputStream.index &&\n\t\t\tthis.lastErrorStates &&\n\t\t\tthis.lastErrorStates.contains(recognizer.state)) {\n\t\t\t// uh oh, another error at same token index and previously-visited\n\t\t\t// state in ATN; must be a case where LT(1) is in the recovery\n\t\t\t// token set so nothing got consumed. Consume a single token\n\t\t\t// at least to prevent an infinite loop; this is a failsafe.\n//\t\t\tSystem.err.println(\"seen error condition before index=\"+\n//\t\t\t\t\t\t\t   lastErrorIndex+\", states=\"+lastErrorStates);\n//\t\t\tSystem.err.println(\"FAILSAFE consumes \"+recognizer.getTokenNames()[recognizer.inputStream.LA(1)]);\n\t\t\trecognizer.consume();\n\t\t}\n\t\tthis.lastErrorIndex = recognizer.inputStream.index;\n\t\tif (!this.lastErrorStates) {\n\t\t\tthis.lastErrorStates = new IntervalSet();\n\t\t}\n\t\tthis.lastErrorStates.add(recognizer.state);\n\t\tlet followSet: IntervalSet = this.getErrorRecoverySet(recognizer);\n\t\tthis.consumeUntil(recognizer, followSet);\n\t}\n\n\t/**\n\t * The default implementation of {@link ANTLRErrorStrategy#sync} makes sure\n\t * that the current lookahead symbol is consistent with what were expecting\n\t * at this point in the ATN. You can call this anytime but ANTLR only\n\t * generates code to check before subrules/loops and each iteration.\n\t *\n\t * Implements Jim Idle's magic sync mechanism in closures and optional\n\t * subrules. E.g.,\n\t *\n\t * ```antlr\n\t * a : sync ( stuff sync )* ;\n\t * sync : {consume to what can follow sync} ;\n\t * ```\n\t *\n\t * At the start of a sub rule upon error, {@link #sync} performs single\n\t * token deletion, if possible. If it can't do that, it bails on the current\n\t * rule and uses the default error recovery, which consumes until the\n\t * resynchronization set of the current rule.\n\t *\n\t * If the sub rule is optional (`(...)?`, `(...)*`, or block\n\t * with an empty alternative), then the expected set includes what follows\n\t * the subrule.\n\t *\n\t * During loop iteration, it consumes until it sees a token that can start a\n\t * sub rule or what follows loop. Yes, that is pretty aggressive. We opt to\n\t * stay in the loop as long as possible.\n\t *\n\t * **ORIGINS**\n\t *\n\t * Previous versions of ANTLR did a poor job of their recovery within loops.\n\t * A single mismatch token or missing token would force the parser to bail\n\t * out of the entire rules surrounding the loop. So, for rule\n\t *\n\t * ```antlr\n\t * classDef : 'class' ID '{' member* '}'\n\t * ```\n\t *\n\t * input with an extra token between members would force the parser to\n\t * consume until it found the next class definition rather than the next\n\t * member definition of the current class.\n\t *\n\t * This functionality cost a little bit of effort because the parser has to\n\t * compare token set at the start of the loop and at each iteration. If for\n\t * some reason speed is suffering for you, you can turn off this\n\t * functionality by simply overriding this method as a blank { }.\n\t */\n\t@Override\n\tpublic sync(recognizer: Parser): void {\n\t\tlet s: ATNState = recognizer.interpreter.atn.states[recognizer.state];\n//\t\tSystem.err.println(\"sync @ \"+s.stateNumber+\"=\"+s.getClass().getSimpleName());\n\t\t// If already recovering, don't try to sync\n\t\tif (this.inErrorRecoveryMode(recognizer)) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet tokens: TokenStream = recognizer.inputStream;\n\t\tlet la: number = tokens.LA(1);\n\n\t\t// try cheaper subset first; might get lucky. seems to shave a wee bit off\n\t\tlet nextTokens: IntervalSet = recognizer.atn.nextTokens(s);\n\t\tif (nextTokens.contains(la)) {\n\t\t\t// We are sure the token matches\n\t\t\tthis.nextTokensContext = undefined;\n\t\t\tthis.nextTokensState = ATNState.INVALID_STATE_NUMBER;\n\t\t\treturn;\n\t\t}\n\n\t\tif (nextTokens.contains(Token.EPSILON)) {\n\t\t\tif (this.nextTokensContext === undefined) {\n\t\t\t\t// It's possible the next token won't match; information tracked\n\t\t\t\t// by sync is restricted for performance.\n\t\t\t\tthis.nextTokensContext = recognizer.context;\n\t\t\t\tthis.nextTokensState = recognizer.state;\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tswitch (s.stateType) {\n\t\tcase ATNStateType.BLOCK_START:\n\t\tcase ATNStateType.STAR_BLOCK_START:\n\t\tcase ATNStateType.PLUS_BLOCK_START:\n\t\tcase ATNStateType.STAR_LOOP_ENTRY:\n\t\t\t// report error and recover if possible\n\t\t\tif (this.singleTokenDeletion(recognizer)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthrow new InputMismatchException(recognizer);\n\n\t\tcase ATNStateType.PLUS_LOOP_BACK:\n\t\tcase ATNStateType.STAR_LOOP_BACK:\n//\t\t\tSystem.err.println(\"at loop back: \"+s.getClass().getSimpleName());\n\t\t\tthis.reportUnwantedToken(recognizer);\n\t\t\tlet expecting: IntervalSet = recognizer.getExpectedTokens();\n\t\t\tlet whatFollowsLoopIterationOrRule: IntervalSet =\n\t\t\t\texpecting.or(this.getErrorRecoverySet(recognizer));\n\t\t\tthis.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\t// do nothing if we can't identify the exact kind of ATN state\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/**\n\t * This is called by {@link #reportError} when the exception is a\n\t * {@link NoViableAltException}.\n\t *\n\t * @see #reportError\n\t *\n\t * @param recognizer the parser instance\n\t * @param e the recognition exception\n\t */\n\tprotected reportNoViableAlternative(\n\t\t@NotNull recognizer: Parser,\n\t\t@NotNull e: NoViableAltException): void {\n\t\tlet tokens: TokenStream = recognizer.inputStream;\n\t\tlet input: string;\n\t\tif (tokens) {\n\t\t\tif (e.startToken.type === Token.EOF) {\n\t\t\t\tinput = \"<EOF>\";\n\t\t\t} else {\n\t\t\t\tinput = tokens.getTextFromRange(e.startToken, e.getOffendingToken());\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tinput = \"<unknown input>\";\n\t\t}\n\t\tlet msg: string = \"no viable alternative at input \" + this.escapeWSAndQuote(input);\n\t\tthis.notifyErrorListeners(recognizer, msg, e);\n\t}\n\n\t/**\n\t * This is called by {@link #reportError} when the exception is an\n\t * {@link InputMismatchException}.\n\t *\n\t * @see #reportError\n\t *\n\t * @param recognizer the parser instance\n\t * @param e the recognition exception\n\t */\n\tprotected reportInputMismatch(\n\t\t@NotNull recognizer: Parser,\n\t\t@NotNull e: InputMismatchException): void {\n\t\tlet expected = e.expectedTokens;\n\t\tlet expectedString = expected ? expected.toStringVocabulary(recognizer.vocabulary) : \"\";\n\t\tlet msg: string = \"mismatched input \" + this.getTokenErrorDisplay(e.getOffendingToken(recognizer)) +\n\t\t\t\" expecting \" + expectedString;\n\t\tthis.notifyErrorListeners(recognizer, msg, e);\n\t}\n\n\t/**\n\t * This is called by {@link #reportError} when the exception is a\n\t * {@link FailedPredicateException}.\n\t *\n\t * @see #reportError\n\t *\n\t * @param recognizer the parser instance\n\t * @param e the recognition exception\n\t */\n\tprotected reportFailedPredicate(\n\t\t@NotNull recognizer: Parser,\n\t\t@NotNull e: FailedPredicateException): void {\n\t\tlet ruleName: string = recognizer.ruleNames[recognizer.context.ruleIndex];\n\t\tlet msg: string = \"rule \" + ruleName + \" \" + e.message;\n\t\tthis.notifyErrorListeners(recognizer, msg, e);\n\t}\n\n\t/**\n\t * This method is called to report a syntax error which requires the removal\n\t * of a token from the input stream. At the time this method is called, the\n\t * erroneous symbol is current `LT(1)` symbol and has not yet been\n\t * removed from the input stream. When this method returns,\n\t * `recognizer` is in error recovery mode.\n\t *\n\t * This method is called when {@link #singleTokenDeletion} identifies\n\t * single-token deletion as a viable recovery strategy for a mismatched\n\t * input error.\n\t *\n\t * The default implementation simply returns if the handler is already in\n\t * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to\n\t * enter error recovery mode, followed by calling\n\t * {@link Parser#notifyErrorListeners}.\n\t *\n\t * @param recognizer the parser instance\n\t */\n\tprotected reportUnwantedToken(@NotNull recognizer: Parser): void {\n\t\tif (this.inErrorRecoveryMode(recognizer)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.beginErrorCondition(recognizer);\n\n\t\tlet t: Token = recognizer.currentToken;\n\t\tlet tokenName: string = this.getTokenErrorDisplay(t);\n\t\tlet expecting: IntervalSet = this.getExpectedTokens(recognizer);\n\t\tlet msg: string = \"extraneous input \" + tokenName + \" expecting \" +\n\t\t\texpecting.toStringVocabulary(recognizer.vocabulary);\n\t\trecognizer.notifyErrorListeners(msg, t, undefined);\n\t}\n\n\t/**\n\t * This method is called to report a syntax error which requires the\n\t * insertion of a missing token into the input stream. At the time this\n\t * method is called, the missing token has not yet been inserted. When this\n\t * method returns, `recognizer` is in error recovery mode.\n\t *\n\t * This method is called when {@link #singleTokenInsertion} identifies\n\t * single-token insertion as a viable recovery strategy for a mismatched\n\t * input error.\n\t *\n\t * The default implementation simply returns if the handler is already in\n\t * error recovery mode. Otherwise, it calls {@link #beginErrorCondition} to\n\t * enter error recovery mode, followed by calling\n\t * {@link Parser#notifyErrorListeners}.\n\t *\n\t * @param recognizer the parser instance\n\t */\n\tprotected reportMissingToken(@NotNull recognizer: Parser): void {\n\t\tif (this.inErrorRecoveryMode(recognizer)) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.beginErrorCondition(recognizer);\n\n\t\tlet t: Token = recognizer.currentToken;\n\t\tlet expecting: IntervalSet = this.getExpectedTokens(recognizer);\n\t\tlet msg: string = \"missing \" + expecting.toStringVocabulary(recognizer.vocabulary) +\n\t\t\t\" at \" + this.getTokenErrorDisplay(t);\n\n\t\trecognizer.notifyErrorListeners(msg, t, undefined);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The default implementation attempts to recover from the mismatched input\n\t * by using single token insertion and deletion as described below. If the\n\t * recovery attempt fails, this method\n\t * {@link InputMismatchException}.\n\t *\n\t * **EXTRA TOKEN** (single token deletion)\n\t *\n\t * `LA(1)` is not what we are looking for. If `LA(2)` has the\n\t * right token, however, then assume `LA(1)` is some extra spurious\n\t * token and delete it. Then consume and return the next token (which was\n\t * the `LA(2)` token) as the successful result of the match operation.\n\t *\n\t * This recovery strategy is implemented by {@link #singleTokenDeletion}.\n\t *\n\t * **MISSING TOKEN** (single token insertion)\n\t *\n\t * If current token (at `LA(1)`) is consistent with what could come\n\t * after the expected `LA(1)` token, then assume the token is missing\n\t * and use the parser's {@link TokenFactory} to create it on the fly. The\n\t * \"insertion\" is performed by returning the created token as the successful\n\t * result of the match operation.\n\t *\n\t * This recovery strategy is implemented by {@link #singleTokenInsertion}.\n\t *\n\t * **EXAMPLE**\n\t *\n\t * For example, Input `i=(3;` is clearly missing the `')'`. When\n\t * the parser returns from the nested call to `expr`, it will have\n\t * call chain:\n\t *\n\t * ```\n\t * stat → expr → atom\n\t * ```\n\t *\n\t * and it will be trying to match the `')'` at this point in the\n\t * derivation:\n\t *\n\t * ```\n\t * => ID '=' '(' INT ')' ('+' atom)* ';'\n\t *                    ^\n\t * ```\n\t *\n\t * The attempt to match `')'` will fail when it sees `';'` and\n\t * call {@link #recoverInline}. To recover, it sees that `LA(1)==';'`\n\t * is in the set of tokens that can follow the `')'` token reference\n\t * in rule `atom`. It can assume that you forgot the `')'`.\n\t */\n\t@Override\n\tpublic recoverInline(recognizer: Parser): Token {\n\t\t// SINGLE TOKEN DELETION\n\t\tlet matchedSymbol = this.singleTokenDeletion(recognizer);\n\t\tif (matchedSymbol) {\n\t\t\t// we have deleted the extra token.\n\t\t\t// now, move past ttype token as if all were ok\n\t\t\trecognizer.consume();\n\t\t\treturn matchedSymbol;\n\t\t}\n\n\t\t// SINGLE TOKEN INSERTION\n\t\tif (this.singleTokenInsertion(recognizer)) {\n\t\t\treturn this.getMissingSymbol(recognizer);\n\t\t}\n\n\t\t// even that didn't work; must throw the exception\n\t\tif (this.nextTokensContext === undefined) {\n\t\t\tthrow new InputMismatchException(recognizer);\n\t\t} else {\n\t\t\tthrow new InputMismatchException(recognizer, this.nextTokensState, this.nextTokensContext);\n\t\t}\n\t}\n\n\t/**\n\t * This method implements the single-token insertion inline error recovery\n\t * strategy. It is called by {@link #recoverInline} if the single-token\n\t * deletion strategy fails to recover from the mismatched input. If this\n\t * method returns `true`, `recognizer` will be in error recovery\n\t * mode.\n\t *\n\t * This method determines whether or not single-token insertion is viable by\n\t * checking if the `LA(1)` input symbol could be successfully matched\n\t * if it were instead the `LA(2)` symbol. If this method returns\n\t * `true`, the caller is responsible for creating and inserting a\n\t * token with the correct type to produce this behavior.\n\t *\n\t * @param recognizer the parser instance\n\t * @returns `true` if single-token insertion is a viable recovery\n\t * strategy for the current mismatched input, otherwise `false`\n\t */\n\tprotected singleTokenInsertion(@NotNull recognizer: Parser): boolean {\n\t\tlet currentSymbolType: number = recognizer.inputStream.LA(1);\n\t\t// if current token is consistent with what could come after current\n\t\t// ATN state, then we know we're missing a token; error recovery\n\t\t// is free to conjure up and insert the missing token\n\t\tlet currentState = recognizer.interpreter.atn.states[recognizer.state];\n\t\tlet next: ATNState = currentState.transition(0).target;\n\t\tlet atn: ATN = recognizer.interpreter.atn;\n\t\tlet expectingAtLL2: IntervalSet = atn.nextTokens(next, PredictionContext.fromRuleContext(atn, recognizer.context));\n//\t\tconsole.warn(\"LT(2) set=\"+expectingAtLL2.toString(recognizer.getTokenNames()));\n\t\tif (expectingAtLL2.contains(currentSymbolType)) {\n\t\t\tthis.reportMissingToken(recognizer);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * This method implements the single-token deletion inline error recovery\n\t * strategy. It is called by {@link #recoverInline} to attempt to recover\n\t * from mismatched input. If this method returns `undefined`, the parser and error\n\t * handler state will not have changed. If this method returns non-`undefined`,\n\t * `recognizer` will *not* be in error recovery mode since the\n\t * returned token was a successful match.\n\t *\n\t * If the single-token deletion is successful, this method calls\n\t * {@link #reportUnwantedToken} to report the error, followed by\n\t * {@link Parser#consume} to actually \"delete\" the extraneous token. Then,\n\t * before returning {@link #reportMatch} is called to signal a successful\n\t * match.\n\t *\n\t * @param recognizer the parser instance\n\t * @returns the successfully matched {@link Token} instance if single-token\n\t * deletion successfully recovers from the mismatched input, otherwise\n\t * `undefined`\n\t */\n\tprotected singleTokenDeletion(@NotNull recognizer: Parser): Token | undefined {\n\t\tlet nextTokenType: number = recognizer.inputStream.LA(2);\n\t\tlet expecting: IntervalSet = this.getExpectedTokens(recognizer);\n\t\tif (expecting.contains(nextTokenType)) {\n\t\t\tthis.reportUnwantedToken(recognizer);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)recognizer.inputStream).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)recognizer.inputStream).LT(2)+\n\t\t\t\t\t\t\t   \" is what we want\");\n\t\t\t*/\n\t\t\trecognizer.consume(); // simply delete extra token\n\t\t\t// we want to return the token we're actually matching\n\t\t\tlet matchedSymbol: Token = recognizer.currentToken;\n\t\t\tthis.reportMatch(recognizer);  // we know current token is correct\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/** Conjure up a missing token during error recovery.\n\t *\n\t *  The recognizer attempts to recover from single missing\n\t *  symbols. But, actions might refer to that missing symbol.\n\t *  For example, x=ID {f($x);}. The action clearly assumes\n\t *  that there has been an identifier matched previously and that\n\t *  $x points at that token. If that token is missing, but\n\t *  the next token in the stream is what we want we assume that\n\t *  this token is missing and we keep going. Because we\n\t *  have to return some token to replace the missing token,\n\t *  we have to conjure one up. This method gives the user control\n\t *  over the tokens returned for missing tokens. Mostly,\n\t *  you will want to create something special for identifier\n\t *  tokens. For literals such as '{' and ',', the default\n\t *  action in the parser or tree parser works. It simply creates\n\t *  a CommonToken of the appropriate type. The text will be the token.\n\t *  If you change what tokens must be created by the lexer,\n\t *  override this method to create the appropriate tokens.\n\t */\n\t@NotNull\n\tprotected getMissingSymbol(@NotNull recognizer: Parser): Token {\n\t\tlet currentSymbol: Token = recognizer.currentToken;\n\t\tlet expecting: IntervalSet = this.getExpectedTokens(recognizer);\n\t\tlet expectedTokenType: number = Token.INVALID_TYPE;\n\t\tif (!expecting.isNil) {\n\t\t\t// get any element\n\t\t\texpectedTokenType = expecting.minElement;\n\t\t}\n\n\t\tlet tokenText: string;\n\t\tif (expectedTokenType === Token.EOF) {\n\t\t\ttokenText = \"<missing EOF>\";\n\t\t} else {\n\t\t\ttokenText = \"<missing \" + recognizer.vocabulary.getDisplayName(expectedTokenType) + \">\";\n\t\t}\n\t\tlet current: Token = currentSymbol;\n\t\tlet lookback = recognizer.inputStream.tryLT(-1);\n\t\tif (current.type === Token.EOF && lookback != null) {\n\t\t\tcurrent = lookback;\n\t\t}\n\n\t\treturn this.constructToken(recognizer.inputStream.tokenSource, expectedTokenType, tokenText, current);\n\t}\n\n\tprotected constructToken(\n\t\ttokenSource: TokenSource,\n\t\texpectedTokenType: number,\n\t\ttokenText: string,\n\t\tcurrent: Token): Token {\n\t\tlet factory: TokenFactory = tokenSource.tokenFactory;\n\t\tlet x = current.tokenSource;\n\t\tlet stream = x ? x.inputStream : undefined;\n\n\t\treturn factory.create(\n\t\t\t{ source: tokenSource, stream },\n\t\t\texpectedTokenType, tokenText,\n\t\t\tToken.DEFAULT_CHANNEL,\n\t\t\t-1, -1,\n\t\t\tcurrent.line, current.charPositionInLine);\n\t}\n\n\t@NotNull\n\tprotected getExpectedTokens(@NotNull recognizer: Parser): IntervalSet {\n\t\treturn recognizer.getExpectedTokens();\n\t}\n\n\t/** How should a token be displayed in an error message? The default\n\t *  is to display just the text, but during development you might\n\t *  want to have a lot of information spit out.  Override in that case\n\t *  to use t.toString() (which, for CommonToken, dumps everything about\n\t *  the token). This is better than forcing you to override a method in\n\t *  your token objects because you don't have to go modify your lexer\n\t *  so that it creates a new Java type.\n\t */\n\tprotected getTokenErrorDisplay(t: Token | undefined): string {\n\t\tif (!t) {\n\t\t\treturn \"<no token>\";\n\t\t}\n\t\tlet s = this.getSymbolText(t);\n\t\tif (!s) {\n\t\t\tif (this.getSymbolType(t) === Token.EOF) {\n\t\t\t\ts = \"<EOF>\";\n\t\t\t} else {\n\t\t\t\ts = `<${this.getSymbolType(t)}>`;\n\t\t\t}\n\t\t}\n\t\treturn this.escapeWSAndQuote(s);\n\t}\n\n\tprotected getSymbolText(@NotNull symbol: Token): string | undefined {\n\t\treturn symbol.text;\n\t}\n\n\tprotected getSymbolType(@NotNull symbol: Token): number {\n\t\treturn symbol.type;\n\t}\n\n\t@NotNull\n\tprotected escapeWSAndQuote(@NotNull s: string): string {\n//\t\tif ( s==null ) return s;\n\t\ts = s.replace(\"\\n\", \"\\\\n\");\n\t\ts = s.replace(\"\\r\", \"\\\\r\");\n\t\ts = s.replace(\"\\t\", \"\\\\t\");\n\t\treturn \"'\" + s + \"'\";\n\t}\n\n\t/*  Compute the error recovery set for the current rule.  During\n\t *  rule invocation, the parser pushes the set of tokens that can\n\t *  follow that rule reference on the stack; this amounts to\n\t *  computing FIRST of what follows the rule reference in the\n\t *  enclosing rule. See LinearApproximator.FIRST().\n\t *  This local follow set only includes tokens\n\t *  from within the rule; i.e., the FIRST computation done by\n\t *  ANTLR stops at the end of a rule.\n\t *\n\t *  EXAMPLE\n\t *\n\t *  When you find a \"no viable alt exception\", the input is not\n\t *  consistent with any of the alternatives for rule r.  The best\n\t *  thing to do is to consume tokens until you see something that\n\t *  can legally follow a call to r *or* any rule that called r.\n\t *  You don't want the exact set of viable next tokens because the\n\t *  input might just be missing a token--you might consume the\n\t *  rest of the input looking for one of the missing tokens.\n\t *\n\t *  Consider grammar:\n\t *\n\t *  a : '[' b ']'\n\t *    | '(' b ')'\n\t *    ;\n\t *  b : c '^' INT ;\n\t *  c : ID\n\t *    | INT\n\t *    ;\n\t *\n\t *  At each rule invocation, the set of tokens that could follow\n\t *  that rule is pushed on a stack.  Here are the various\n\t *  context-sensitive follow sets:\n\t *\n\t *  FOLLOW(b1_in_a) = FIRST(']') = ']'\n\t *  FOLLOW(b2_in_a) = FIRST(')') = ')'\n\t *  FOLLOW(c_in_b) = FIRST('^') = '^'\n\t *\n\t *  Upon erroneous input \"[]\", the call chain is\n\t *\n\t *  a -> b -> c\n\t *\n\t *  and, hence, the follow context stack is:\n\t *\n\t *  depth     follow set       start of rule execution\n\t *    0         <EOF>                    a (from main())\n\t *    1          ']'                     b\n\t *    2          '^'                     c\n\t *\n\t *  Notice that ')' is not included, because b would have to have\n\t *  been called from a different context in rule a for ')' to be\n\t *  included.\n\t *\n\t *  For error recovery, we cannot consider FOLLOW(c)\n\t *  (context-sensitive or otherwise).  We need the combined set of\n\t *  all context-sensitive FOLLOW sets--the set of all tokens that\n\t *  could follow any reference in the call chain.  We need to\n\t *  resync to one of those tokens.  Note that FOLLOW(c)='^' and if\n\t *  we resync'd to that token, we'd consume until EOF.  We need to\n\t *  sync to context-sensitive FOLLOWs for a, b, and c: {']','^'}.\n\t *  In this case, for input \"[]\", LA(1) is ']' and in the set, so we would\n\t *  not consume anything. After printing an error, rule c would\n\t *  return normally.  Rule b would not find the required '^' though.\n\t *  At this point, it gets a mismatched token error and\n\t *  exception (since LA(1) is not in the viable following token\n\t *  set).  The rule exception handler tries to recover, but finds\n\t *  the same recovery set and doesn't consume anything.  Rule b\n\t *  exits normally returning to rule a.  Now it finds the ']' (and\n\t *  with the successful match exits errorRecovery mode).\n\t *\n\t *  So, you can see that the parser walks up the call chain looking\n\t *  for the token that was a member of the recovery set.\n\t *\n\t *  Errors are not generated in errorRecovery mode.\n\t *\n\t *  ANTLR's error recovery mechanism is based upon original ideas:\n\t *\n\t *  \"Algorithms + Data Structures = Programs\" by Niklaus Wirth\n\t *\n\t *  and\n\t *\n\t *  \"A note on error recovery in recursive descent parsers\":\n\t *  http://portal.acm.org/citation.cfm?id=947902.947905\n\t *\n\t *  Later, Josef Grosch had some good ideas:\n\t *\n\t *  \"Efficient and Comfortable Error Recovery in Recursive Descent\n\t *  Parsers\":\n\t *  ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip\n\t *\n\t *  Like Grosch I implement context-sensitive FOLLOW sets that are combined\n\t *  at run-time upon error to avoid overhead during parsing.\n\t */\n\t@NotNull\n\tprotected getErrorRecoverySet(@NotNull recognizer: Parser): IntervalSet {\n\t\tlet atn: ATN = recognizer.interpreter.atn;\n\t\tlet ctx: RuleContext | undefined = recognizer.context;\n\t\tlet recoverSet: IntervalSet = new IntervalSet();\n\t\twhile (ctx && ctx.invokingState >= 0) {\n\t\t\t// compute what follows who invoked us\n\t\t\tlet invokingState: ATNState = atn.states[ctx.invokingState];\n\t\t\tlet rt = invokingState.transition(0) as RuleTransition;\n\t\t\tlet follow: IntervalSet = atn.nextTokens(rt.followState);\n\t\t\trecoverSet.addAll(follow);\n\t\t\tctx = ctx._parent;\n\t\t}\n\t\trecoverSet.remove(Token.EPSILON);\n//\t\tSystem.out.println(\"recover set \"+recoverSet.toString(recognizer.getTokenNames()));\n\t\treturn recoverSet;\n\t}\n\n\t/** Consume tokens until one matches the given token set. */\n\tprotected consumeUntil(@NotNull recognizer: Parser, @NotNull set: IntervalSet): void {\n//\t\tSystem.err.println(\"consumeUntil(\"+set.toString(recognizer.getTokenNames())+\")\");\n\t\tlet ttype: number = recognizer.inputStream.LA(1);\n\t\twhile (ttype !== Token.EOF && !set.contains(ttype)) {\n\t\t\t//System.out.println(\"consume during recover LA(1)=\"+getTokenNames()[input.LA(1)]);\n//\t\t\trecognizer.inputStream.consume();\n\t\t\trecognizer.consume();\n\t\t\tttype = recognizer.inputStream.LA(1);\n\t\t}\n\t}\n}\n"]}