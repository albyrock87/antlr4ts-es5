{"version":3,"sources":["LexerInterpreter.js","../src/LexerInterpreter.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","Lexer_1","require","LexerATNSimulator_1","Decorators_1","Decorators_2","LexerInterpreter","grammarFileName","vocabulary","ruleNames","channelNames","modeNames","atn","input","grammarType","Error","_grammarFileName","_atn","_ruleNames","slice","_channelNames","_modeNames","_vocabulary","_interp","LexerATNSimulator","Lexer","NotNull","prototype","Override"],"mappings":"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","file":"LexerInterpreter.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Lexer_1 = require(\"./Lexer\");\nconst LexerATNSimulator_1 = require(\"./atn/LexerATNSimulator\");\nconst Decorators_1 = require(\"./Decorators\");\nconst Decorators_2 = require(\"./Decorators\");\nlet LexerInterpreter = class LexerInterpreter extends Lexer_1.Lexer {\n    constructor(grammarFileName, vocabulary, ruleNames, channelNames, modeNames, atn, input) {\n        super(input);\n        if (atn.grammarType !== 0 /* LEXER */) {\n            throw new Error(\"IllegalArgumentException: The ATN must be a lexer ATN.\");\n        }\n        this._grammarFileName = grammarFileName;\n        this._atn = atn;\n        this._ruleNames = ruleNames.slice(0);\n        this._channelNames = channelNames.slice(0);\n        this._modeNames = modeNames.slice(0);\n        this._vocabulary = vocabulary;\n        this._interp = new LexerATNSimulator_1.LexerATNSimulator(atn, this);\n    }\n    get atn() {\n        return this._atn;\n    }\n    get grammarFileName() {\n        return this._grammarFileName;\n    }\n    get ruleNames() {\n        return this._ruleNames;\n    }\n    get channelNames() {\n        return this._channelNames;\n    }\n    get modeNames() {\n        return this._modeNames;\n    }\n    get vocabulary() {\n        return this._vocabulary;\n    }\n};\n__decorate([\n    Decorators_1.NotNull\n], LexerInterpreter.prototype, \"_vocabulary\", void 0);\n__decorate([\n    Decorators_2.Override\n], LexerInterpreter.prototype, \"atn\", null);\n__decorate([\n    Decorators_2.Override\n], LexerInterpreter.prototype, \"grammarFileName\", null);\n__decorate([\n    Decorators_2.Override\n], LexerInterpreter.prototype, \"ruleNames\", null);\n__decorate([\n    Decorators_2.Override\n], LexerInterpreter.prototype, \"channelNames\", null);\n__decorate([\n    Decorators_2.Override\n], LexerInterpreter.prototype, \"modeNames\", null);\n__decorate([\n    Decorators_2.Override\n], LexerInterpreter.prototype, \"vocabulary\", null);\nLexerInterpreter = __decorate([\n    __param(1, Decorators_1.NotNull)\n], LexerInterpreter);\nexports.LexerInterpreter = LexerInterpreter;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:51.9954566-07:00\n\nimport { ATN } from \"./atn/ATN\";\nimport { ATNType } from \"./atn/ATNType\";\nimport { CharStream } from \"./CharStream\";\nimport { Lexer } from \"./Lexer\";\nimport { LexerATNSimulator } from \"./atn/LexerATNSimulator\";\nimport { NotNull } from \"./Decorators\";\nimport { Override } from \"./Decorators\";\nimport { Vocabulary } from \"./Vocabulary\";\n\nexport class LexerInterpreter extends Lexer {\n\tprotected _grammarFileName: string;\n\tprotected _atn: ATN;\n\n\tprotected _ruleNames: string[];\n\tprotected _channelNames: string[];\n\tprotected _modeNames: string[];\n\t@NotNull\n\tprivate _vocabulary: Vocabulary;\n\n\tconstructor(grammarFileName: string, @NotNull vocabulary: Vocabulary, ruleNames: string[], channelNames: string[], modeNames: string[], atn: ATN, input: CharStream) {\n\t\tsuper(input);\n\n\t\tif (atn.grammarType !== ATNType.LEXER) {\n\t\t\tthrow new Error(\"IllegalArgumentException: The ATN must be a lexer ATN.\");\n\t\t}\n\n\t\tthis._grammarFileName = grammarFileName;\n\t\tthis._atn = atn;\n\n\t\tthis._ruleNames = ruleNames.slice(0);\n\t\tthis._channelNames = channelNames.slice(0);\n\t\tthis._modeNames = modeNames.slice(0);\n\t\tthis._vocabulary = vocabulary;\n\t\tthis._interp = new LexerATNSimulator(atn, this);\n\t}\n\n\t@Override\n\tget atn(): ATN {\n\t\treturn this._atn;\n\t}\n\n\t@Override\n\tget grammarFileName(): string {\n\t\treturn this._grammarFileName;\n\t}\n\n\t@Override\n\tget ruleNames(): string[] {\n\t\treturn this._ruleNames;\n\t}\n\n\t@Override\n\tget channelNames(): string[] {\n\t\treturn this._channelNames;\n\t}\n\n\t@Override\n\tget modeNames(): string[] {\n\t\treturn this._modeNames;\n\t}\n\n\t@Override\n\tget vocabulary(): Vocabulary {\n\t\treturn this._vocabulary;\n\t}\n}\n"]}