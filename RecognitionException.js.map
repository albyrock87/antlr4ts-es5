{"version":3,"sources":["RecognitionException.js","../src/RecognitionException.ts"],"names":["Object","defineProperty","exports","value","RecognitionException","recognizer","input","ctx","message","_offendingState","_recognizer","state","offendingState","undefined","offendingToken","atn","getExpectedTokens","Error"],"mappings":"AAAA;ACAA;;;;;;;;;;;;;;;;;;;ADKAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;ACYA;;;;;;;IAMAC,oB;;;;;AAkCC,gCACCC,UADD,EAECC,KAFD,EAGCC,GAHD,EAICC,OAJD,EAIiB;AAAA;;AAAA;AAChB,gIAAMA,OAAN;AAtBO,UAAAC,eAAA,GAA0B,CAAC,CAA3B;AAwBP,UAAKC,WAAL,GAAmBL,UAAnB;AACA,UAAKC,KAAL,GAAaA,KAAb;AACA,UAAKC,GAAL,GAAWA,GAAX;;AACA,QAAIF,UAAJ,EAAgB;AACf,YAAKI,eAAL,GAAuBJ,UAAU,CAACM,KAAlC;AACA;;AARe;AAShB;AAED;;;;;;;;;;;;;sCAa4BC,c,EAAsB;AACjD,WAAKH,eAAL,GAAuBG,cAAvB;AACA;AAED;;;;;;;;;;;;;sCA4CyBP,U,EAAmC;AAC3D,UAAIA,UAAU,IAAIA,UAAU,KAAK,KAAKK,WAAtC,EAAmD;AAClD,eAAOG,SAAP;AACA;;AACD,aAAO,KAAKC,cAAZ;AACA;;;sCAGAT,U,EACAS,c,EAAwB;AACxB,UAAIT,UAAU,KAAK,KAAKK,WAAxB,EAAqC;AACpC,aAAKI,cAAL,GAAsBA,cAAtB;AACA;AACD;AAED;;;;;;;;;;;wBAnEkB;AACjB,aAAO,KAAKL,eAAZ;AACA;;;wBAgBiB;AACjB,UAAI,KAAKC,WAAT,EAAsB;AACrB,eAAO,KAAKA,WAAL,CAAiBK,GAAjB,CAAqBC,iBAArB,CAAuC,KAAKP,eAA5C,EAA6D,KAAKF,GAAlE,CAAP;AACA;;AACD,aAAOM,SAAP;AACA;AAED;;;;;;;;;;;wBAQW;AACV,aAAO,KAAKN,GAAZ;AACA;AAED;;;;;;;;;;;;;wBAWe;AACd,aAAO,KAAKD,KAAZ;AACA;;;wBAyBa;AACb,aAAO,KAAKI,WAAZ;AACA;;;oCAvIwCO,K;;AAA1Cf,OAAA,CAAAE,oBAAA,GAAAA,oBAAA","file":"RecognitionException.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/** The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\n *  3 kinds of errors: prediction errors, failed predicate errors, and\n *  mismatched input errors. In each case, the parser knows where it is\n *  in the input, where it is in the ATN, the rule invocation stack,\n *  and what kind of problem occurred.\n */\nclass RecognitionException extends Error {\n    constructor(recognizer, input, ctx, message) {\n        super(message);\n        this._offendingState = -1;\n        this._recognizer = recognizer;\n        this.input = input;\n        this.ctx = ctx;\n        if (recognizer) {\n            this._offendingState = recognizer.state;\n        }\n    }\n    /**\n     * Get the ATN state number the parser was in at the time the error\n     * occurred. For {@link NoViableAltException} and\n     * {@link LexerNoViableAltException} exceptions, this is the\n     * {@link DecisionState} number. For others, it is the state whose outgoing\n     * edge we couldn't match.\n     *\n     * If the state number is not known, this method returns -1.\n     */\n    get offendingState() {\n        return this._offendingState;\n    }\n    setOffendingState(offendingState) {\n        this._offendingState = offendingState;\n    }\n    /**\n     * Gets the set of input symbols which could potentially follow the\n     * previously matched symbol at the time this exception was thrown.\n     *\n     * If the set of expected tokens is not known and could not be computed,\n     * this method returns `undefined`.\n     *\n     * @returns The set of token types that could potentially follow the current\n     * state in the ATN, or `undefined` if the information is not available.\n     */\n    get expectedTokens() {\n        if (this._recognizer) {\n            return this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);\n        }\n        return undefined;\n    }\n    /**\n     * Gets the {@link RuleContext} at the time this exception was thrown.\n     *\n     * If the context is not available, this method returns `undefined`.\n     *\n     * @returns The {@link RuleContext} at the time this exception was thrown.\n     * If the context is not available, this method returns `undefined`.\n     */\n    get context() {\n        return this.ctx;\n    }\n    /**\n     * Gets the input stream which is the symbol source for the recognizer where\n     * this exception was thrown.\n     *\n     * If the input stream is not available, this method returns `undefined`.\n     *\n     * @returns The input stream which is the symbol source for the recognizer\n     * where this exception was thrown, or `undefined` if the stream is not\n     * available.\n     */\n    get inputStream() {\n        return this.input;\n    }\n    getOffendingToken(recognizer) {\n        if (recognizer && recognizer !== this._recognizer) {\n            return undefined;\n        }\n        return this.offendingToken;\n    }\n    setOffendingToken(recognizer, offendingToken) {\n        if (recognizer === this._recognizer) {\n            this.offendingToken = offendingToken;\n        }\n    }\n    /**\n     * Gets the {@link Recognizer} where this exception occurred.\n     *\n     * If the recognizer is not available, this method returns `undefined`.\n     *\n     * @returns The recognizer where this exception occurred, or `undefined` if\n     * the recognizer is not available.\n     */\n    get recognizer() {\n        return this._recognizer;\n    }\n}\nexports.RecognitionException = RecognitionException;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:57.0697674-07:00\nimport { CharStream } from \"./CharStream\";\nimport { IntervalSet } from \"./misc/IntervalSet\";\nimport { IntStream } from \"./IntStream\";\nimport { Lexer } from \"./Lexer\";\nimport { Parser } from \"./Parser\";\nimport { ParserRuleContext } from \"./ParserRuleContext\";\nimport { Recognizer } from \"./Recognizer\";\nimport { RuleContext } from \"./RuleContext\";\nimport { Token } from \"./Token\";\n\n\n/** The root of the ANTLR exception hierarchy. In general, ANTLR tracks just\n *  3 kinds of errors: prediction errors, failed predicate errors, and\n *  mismatched input errors. In each case, the parser knows where it is\n *  in the input, where it is in the ATN, the rule invocation stack,\n *  and what kind of problem occurred.\n */\nexport class RecognitionException extends Error {\n\t// private static serialVersionUID: number =  -3861826954750022374L;\n\n\t/** The {@link Recognizer} where this exception originated. */\n\tprivate _recognizer?: Recognizer<any, any>;\n\n\tprivate ctx?: RuleContext;\n\n\tprivate input?: IntStream;\n\n\t/**\n\t * The current {@link Token} when an error occurred. Since not all streams\n\t * support accessing symbols by index, we have to track the {@link Token}\n\t * instance itself.\n\t */\n\tprivate offendingToken?: Token;\n\n\tprivate _offendingState: number = -1;\n\n\tconstructor(\n\t\tlexer: Lexer | undefined,\n\t\tinput: CharStream);\n\n\tconstructor(\n\t\trecognizer: Recognizer<Token, any> | undefined,\n\t\tinput: IntStream | undefined,\n\t\tctx: ParserRuleContext | undefined);\n\n\tconstructor(\n\t\trecognizer: Recognizer<Token, any> | undefined,\n\t\tinput: IntStream | undefined,\n\t\tctx: ParserRuleContext | undefined,\n\t\tmessage: string);\n\n\tconstructor(\n\t\trecognizer: Lexer | Recognizer<Token, any> | undefined,\n\t\tinput: CharStream | IntStream | undefined,\n\t\tctx?: ParserRuleContext,\n\t\tmessage?: string) {\n\t\tsuper(message);\n\n\t\tthis._recognizer = recognizer;\n\t\tthis.input = input;\n\t\tthis.ctx = ctx;\n\t\tif (recognizer) {\n\t\t\tthis._offendingState = recognizer.state;\n\t\t}\n\t}\n\n\t/**\n\t * Get the ATN state number the parser was in at the time the error\n\t * occurred. For {@link NoViableAltException} and\n\t * {@link LexerNoViableAltException} exceptions, this is the\n\t * {@link DecisionState} number. For others, it is the state whose outgoing\n\t * edge we couldn't match.\n\t *\n\t * If the state number is not known, this method returns -1.\n\t */\n\tget offendingState(): number {\n\t\treturn this._offendingState;\n\t}\n\n\tprotected setOffendingState(offendingState: number): void {\n\t\tthis._offendingState = offendingState;\n\t}\n\n\t/**\n\t * Gets the set of input symbols which could potentially follow the\n\t * previously matched symbol at the time this exception was thrown.\n\t *\n\t * If the set of expected tokens is not known and could not be computed,\n\t * this method returns `undefined`.\n\t *\n\t * @returns The set of token types that could potentially follow the current\n\t * state in the ATN, or `undefined` if the information is not available.\n\t */\n\tget expectedTokens(): IntervalSet | undefined {\n\t\tif (this._recognizer) {\n\t\t\treturn this._recognizer.atn.getExpectedTokens(this._offendingState, this.ctx);\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/**\n\t * Gets the {@link RuleContext} at the time this exception was thrown.\n\t *\n\t * If the context is not available, this method returns `undefined`.\n\t *\n\t * @returns The {@link RuleContext} at the time this exception was thrown.\n\t * If the context is not available, this method returns `undefined`.\n\t */\n\tget context(): RuleContext | undefined {\n\t\treturn this.ctx;\n\t}\n\n\t/**\n\t * Gets the input stream which is the symbol source for the recognizer where\n\t * this exception was thrown.\n\t *\n\t * If the input stream is not available, this method returns `undefined`.\n\t *\n\t * @returns The input stream which is the symbol source for the recognizer\n\t * where this exception was thrown, or `undefined` if the stream is not\n\t * available.\n\t */\n\n\tget inputStream(): IntStream | undefined {\n\t\treturn this.input;\n\t}\n\n\tpublic getOffendingToken(recognizer?: Recognizer<Token, any>): Token | undefined {\n\t\tif (recognizer && recognizer !== this._recognizer) {\n\t\t\treturn undefined;\n\t\t}\n\t\treturn this.offendingToken;\n\t}\n\n\tprotected setOffendingToken<TSymbol extends Token>(\n\t\trecognizer: Recognizer<TSymbol, any>,\n\t\toffendingToken?: TSymbol): void {\n\t\tif (recognizer === this._recognizer) {\n\t\t\tthis.offendingToken = offendingToken;\n\t\t}\n\t}\n\n\t/**\n\t * Gets the {@link Recognizer} where this exception occurred.\n\t *\n\t * If the recognizer is not available, this method returns `undefined`.\n\t *\n\t * @returns The recognizer where this exception occurred, or `undefined` if\n\t * the recognizer is not available.\n\t */\n\tget recognizer(): Recognizer<any, any> | undefined {\n\t\treturn this._recognizer;\n\t}\n}\n"]}