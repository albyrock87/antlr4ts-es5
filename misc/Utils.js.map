{"version":3,"sources":["misc/Utils.js","../src/misc/Utils.ts"],"names":["Object","defineProperty","exports","value","escapeWhitespace","s","escapeSpaces","replace","join","collection","separator","buf","first","current","equals","x","y","undefined","toMap","keys","m","Map","i","length","set","toCharArray","str","result","Uint16Array","charCodeAt"],"mappings":"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","file":"Utils.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction escapeWhitespace(s, escapeSpaces) {\n    return escapeSpaces ? s.replace(/ /, \"\\u00B7\") : s\n        .replace(/\\t/, \"\\\\t\")\n        .replace(/\\n/, \"\\\\n\")\n        .replace(/\\r/, \"\\\\r\");\n}\nexports.escapeWhitespace = escapeWhitespace;\n// Seriously: why isn't this built in to java? ugh!\nfunction join(collection, separator) {\n    let buf = \"\";\n    let first = true;\n    for (let current of collection) {\n        if (first) {\n            first = false;\n        }\n        else {\n            buf += separator;\n        }\n        buf += current;\n    }\n    return buf;\n}\nexports.join = join;\nfunction equals(x, y) {\n    if (x === y) {\n        return true;\n    }\n    if (x === undefined || y === undefined) {\n        return false;\n    }\n    return x.equals(y);\n}\nexports.equals = equals;\n// export function numNonnull(data: any[]): number {\n// \tlet n: number =  0;\n// \tif ( data == null ) return n;\n// \tfor (let o of data) {\n// \t\tif ( o!=null ) n++;\n// \t}\n// \treturn n;\n// }\n// export function removeAllElements<T>(data: Collection<T>, value: T): void {\n// \tif ( data==null ) return;\n// \twhile ( data.contains(value) ) data.remove(value);\n// }\n// export function writeFile(@NotNull file: File, @NotNull content: Uint8Array): void {\n// \tlet fos: FileOutputStream = new FileOutputStream(file);\n// \ttry {\n// \t\tfos.write(content);\n// \t} finally {\n// \t\tfos.close();\n// \t}\n// }\n// export function writeFile(@NotNull fileName: string, @NotNull content: string): void {\n// \twriteFile(fileName, content, null);\n// }\n// export function writeFile(@NotNull fileName: string, @NotNull content: string, @Nullable encoding: string): void {\n// \tlet f: File =  new File(fileName);\n// \tlet fos: FileOutputStream =  new FileOutputStream(f);\n// \tlet osw: OutputStreamWriter;\n// \tif (encoding != null) {\n// \t\tosw = new OutputStreamWriter(fos, encoding);\n// \t}\n// \telse {\n// \t\tosw = new OutputStreamWriter(fos);\n// \t}\n// \ttry {\n// \t\tosw.write(content);\n// \t}\n// \tfinally {\n// \t\tosw.close();\n// \t}\n// }\n// @NotNull\n// export function readFile(@NotNull fileName: string): char[] {\n// \treturn readFile(fileName, null);\n// }\n// @NotNull\n// export function readFile(@NotNull fileName: string, @Nullable encoding: string): char[] {\n// \tlet f: File =  new File(fileName);\n// \tlet size: number =  (int)f.length();\n// \tlet isr: InputStreamReader;\n// \tlet fis: FileInputStream =  new FileInputStream(fileName);\n// \tif ( encoding!=null ) {\n// \t\tisr = new InputStreamReader(fis, encoding);\n// \t}\n// \telse {\n// \t\tisr = new InputStreamReader(fis);\n// \t}\n// \tlet data: char[] =  null;\n// \ttry {\n// \t\tdata = new char[size];\n// \t\tlet n: number =  isr.read(data);\n// \t\tif (n < data.length) {\n// \t\t\tdata = Arrays.copyOf(data, n);\n// \t\t}\n// \t}\n// \tfinally {\n// \t\tisr.close();\n// \t}\n// \treturn data;\n// }\n// export function removeAll<T>(@NotNull predicate: List<T> list,@NotNull Predicate<? super T>): void {\n// \tlet j: number =  0;\n// \tfor (let i = 0; i < list.size; i++) {\n// \t\tlet item: T =  list.get(i);\n// \t\tif (!predicate.eval(item)) {\n// \t\t\tif (j != i) {\n// \t\t\t\tlist.set(j, item);\n// \t\t\t}\n// \t\t\tj++;\n// \t\t}\n// \t}\n// \tif (j < list.size) {\n// \t\tlist.subList(j, list.size).clear();\n// \t}\n// }\n// export function removeAll<T>(@NotNull predicate: Iterable<T> iterable,@NotNull Predicate<? super T>): void {\n// \tif (iterable instanceof List<?>) {\n// \t\tremoveAll((List<T>)iterable, predicate);\n// \t\treturn;\n// \t}\n// \tfor (Iterator<T> iterator = iterable.iterator(); iterator.hasNext(); ) {\n// \t\tlet item: T =  iterator.next();\n// \t\tif (predicate.eval(item)) {\n// \t\t\titerator.remove();\n// \t\t}\n// \t}\n// }\n/** Convert array of strings to string&rarr;index map. Useful for\n *  converting rulenames to name&rarr;ruleindex map.\n */\nfunction toMap(keys) {\n    let m = new Map();\n    for (let i = 0; i < keys.length; i++) {\n        m.set(keys[i], i);\n    }\n    return m;\n}\nexports.toMap = toMap;\nfunction toCharArray(str) {\n    if (typeof str === \"string\") {\n        let result = new Uint16Array(str.length);\n        for (let i = 0; i < str.length; i++) {\n            result[i] = str.charCodeAt(i);\n        }\n        return result;\n    }\n    else {\n        return str.toCharArray();\n    }\n}\nexports.toCharArray = toCharArray;\n// /**\n// \t* @since 4.5\n// \t*/\n// @NotNull\n// export function toSet(@NotNull bits: BitSet): IntervalSet {\n// \tlet s: IntervalSet =  new IntervalSet();\n// \tlet i: number =  bits.nextSetBit(0);\n// \twhile ( i >= 0 ) {\n// \t\ts.add(i);\n// \t\ti = bits.nextSetBit(i+1);\n// \t}\n// \treturn s;\n// }\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:45.0833752-07:00\n\n// Taking a case-by-case approach to pporting this functionaltiy\n// as much of it may be supported natively by JavaScript. Or otherwise need\n// substantial rethink\n\nimport { NotNull } from \"../Decorators\";\nimport { Equatable } from \"./Stubs\";\nimport { IntegerList } from \"./IntegerList\";\n\nexport function escapeWhitespace(s: string, escapeSpaces: boolean): string {\n\treturn escapeSpaces ? s.replace(/ /, \"\\u00B7\") : s\n\t\t.replace(/\\t/, \"\\\\t\")\n\t\t.replace(/\\n/, \"\\\\n\")\n\t\t.replace(/\\r/, \"\\\\r\");\n}\n\n// Seriously: why isn't this built in to java? ugh!\nexport function join(collection: Iterable<any>, separator: string): string {\n\tlet buf = \"\";\n\tlet first = true;\n\tfor (let current of collection) {\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t} else {\n\t\t\tbuf += separator;\n\t\t}\n\n\t\tbuf += current;\n\t}\n\n\treturn buf;\n}\n\nexport function equals(x: Equatable | undefined, y: Equatable | undefined): boolean {\n\tif (x === y) {\n\t\treturn true;\n\t}\n\n\tif (x === undefined || y === undefined) {\n\t\treturn false;\n\t}\n\n\treturn x.equals(y);\n}\n\n// export function numNonnull(data: any[]): number {\n// \tlet n: number =  0;\n// \tif ( data == null ) return n;\n// \tfor (let o of data) {\n// \t\tif ( o!=null ) n++;\n// \t}\n// \treturn n;\n// }\n\n// export function removeAllElements<T>(data: Collection<T>, value: T): void {\n// \tif ( data==null ) return;\n// \twhile ( data.contains(value) ) data.remove(value);\n// }\n\n// export function writeFile(@NotNull file: File, @NotNull content: Uint8Array): void {\n// \tlet fos: FileOutputStream = new FileOutputStream(file);\n// \ttry {\n// \t\tfos.write(content);\n// \t} finally {\n// \t\tfos.close();\n// \t}\n// }\n\n// export function writeFile(@NotNull fileName: string, @NotNull content: string): void {\n// \twriteFile(fileName, content, null);\n// }\n\n// export function writeFile(@NotNull fileName: string, @NotNull content: string, @Nullable encoding: string): void {\n// \tlet f: File =  new File(fileName);\n// \tlet fos: FileOutputStream =  new FileOutputStream(f);\n// \tlet osw: OutputStreamWriter;\n// \tif (encoding != null) {\n// \t\tosw = new OutputStreamWriter(fos, encoding);\n// \t}\n// \telse {\n// \t\tosw = new OutputStreamWriter(fos);\n// \t}\n\n// \ttry {\n// \t\tosw.write(content);\n// \t}\n// \tfinally {\n// \t\tosw.close();\n// \t}\n// }\n\n// @NotNull\n// export function readFile(@NotNull fileName: string): char[] {\n// \treturn readFile(fileName, null);\n// }\n\n// @NotNull\n// export function readFile(@NotNull fileName: string, @Nullable encoding: string): char[] {\n// \tlet f: File =  new File(fileName);\n// \tlet size: number =  (int)f.length();\n// \tlet isr: InputStreamReader;\n// \tlet fis: FileInputStream =  new FileInputStream(fileName);\n// \tif ( encoding!=null ) {\n// \t\tisr = new InputStreamReader(fis, encoding);\n// \t}\n// \telse {\n// \t\tisr = new InputStreamReader(fis);\n// \t}\n// \tlet data: char[] =  null;\n// \ttry {\n// \t\tdata = new char[size];\n// \t\tlet n: number =  isr.read(data);\n// \t\tif (n < data.length) {\n// \t\t\tdata = Arrays.copyOf(data, n);\n// \t\t}\n// \t}\n// \tfinally {\n// \t\tisr.close();\n// \t}\n// \treturn data;\n// }\n\n// export function removeAll<T>(@NotNull predicate: List<T> list,@NotNull Predicate<? super T>): void {\n// \tlet j: number =  0;\n// \tfor (let i = 0; i < list.size; i++) {\n// \t\tlet item: T =  list.get(i);\n// \t\tif (!predicate.eval(item)) {\n// \t\t\tif (j != i) {\n// \t\t\t\tlist.set(j, item);\n// \t\t\t}\n\n// \t\t\tj++;\n// \t\t}\n// \t}\n\n// \tif (j < list.size) {\n// \t\tlist.subList(j, list.size).clear();\n// \t}\n// }\n\n// export function removeAll<T>(@NotNull predicate: Iterable<T> iterable,@NotNull Predicate<? super T>): void {\n// \tif (iterable instanceof List<?>) {\n// \t\tremoveAll((List<T>)iterable, predicate);\n// \t\treturn;\n// \t}\n\n// \tfor (Iterator<T> iterator = iterable.iterator(); iterator.hasNext(); ) {\n// \t\tlet item: T =  iterator.next();\n// \t\tif (predicate.eval(item)) {\n// \t\t\titerator.remove();\n// \t\t}\n// \t}\n// }\n\n/** Convert array of strings to string&rarr;index map. Useful for\n *  converting rulenames to name&rarr;ruleindex map.\n */\nexport function toMap(keys: string[]): Map<string, number> {\n\tlet m: Map<string, number> = new Map<string, number>();\n\tfor (let i = 0; i < keys.length; i++) {\n\t\tm.set(keys[i], i);\n\t}\n\n\treturn m;\n}\n\nexport function toCharArray(str: string): Uint16Array;\nexport function toCharArray(data: IntegerList): Uint16Array;\nexport function toCharArray(str: string | IntegerList): Uint16Array {\n\tif (typeof str === \"string\") {\n\t\tlet result = new Uint16Array(str.length);\n\t\tfor (let i = 0; i < str.length; i++) {\n\t\t\tresult[i] = str.charCodeAt(i);\n\t\t}\n\n\t\treturn result;\n\t} else {\n\t\treturn str.toCharArray();\n\t}\n}\n\n// /**\n// \t* @since 4.5\n// \t*/\n// @NotNull\n// export function toSet(@NotNull bits: BitSet): IntervalSet {\n// \tlet s: IntervalSet =  new IntervalSet();\n// \tlet i: number =  bits.nextSetBit(0);\n// \twhile ( i >= 0 ) {\n// \t\ts.add(i);\n// \t\ti = bits.nextSetBit(i+1);\n// \t}\n// \treturn s;\n// }\n"]}