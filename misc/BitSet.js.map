{"version":3,"sources":["misc/BitSet.js","../src/misc/BitSet.ts"],"names":["Object","defineProperty","exports","value","util","require","MurmurHash_1","EMPTY_DATA","Uint16Array","getIndex","bitNumber","unIndex","n","findLSBSet","word","bit","i","RangeError","findMSBSet","bitsFor","fromBit","toBit","POP_CNT","Uint8Array","stride","index","length","j","BitSet","arg","data","slice","max","v","set","other","words","Math","min","lastWord","isEmpty","result","fromIndex","toIndex","fill","undefined","get","smallerLength","bound","previousSetBit","ignore","mask","minWords","dest","longer","temp","forEach","_setBits","MurmurHash","hashCode","obj","len","first","nextSetBit","Symbol","iterator","BitSetIterator","inspect","custom","toString","byteLength","bits","done"],"mappings":"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","file":"BitSet.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst util = require(\"util\");\nconst MurmurHash_1 = require(\"./MurmurHash\");\n/**\n * Private empty array used to construct empty BitSets\n */\nconst EMPTY_DATA = new Uint16Array(0);\n/**\n * Gets the word index of the `UInt16` element in `BitSet.data` containing the bit with the specified index.\n */\nfunction getIndex(bitNumber) {\n    return bitNumber >>> 4;\n}\n/**\n * Convert a word index into the bit index of the LSB of that word\n */\nfunction unIndex(n) {\n    return n * 16;\n}\n/**\n * Get's the bit number of the least signficant bit set LSB which is set in a word non-zero word;\n * Bit numbers run from LSB to MSB starting with 0.\n */\nfunction findLSBSet(word) {\n    let bit = 1;\n    for (let i = 0; i < 16; i++) {\n        if ((word & bit) !== 0) {\n            return i;\n        }\n        bit = (bit << 1) >>> 0;\n    }\n    throw new RangeError(\"No specified bit found\");\n}\nfunction findMSBSet(word) {\n    let bit = (1 << 15) >>> 0;\n    for (let i = 15; i >= 0; i--) {\n        if ((word & bit) !== 0) {\n            return i;\n        }\n        bit = bit >>> 1;\n    }\n    throw new RangeError(\"No specified bit found\");\n}\n/**\n * Gets a 16-bit mask with bit numbers fromBit to toBit (inclusive) set.\n * Bit numbers run from LSB to MSB starting with 0.\n */\nfunction bitsFor(fromBit, toBit) {\n    fromBit &= 0xF;\n    toBit &= 0xF;\n    if (fromBit === toBit) {\n        return (1 << fromBit) >>> 0;\n    }\n    return ((0xFFFF >>> (15 - toBit)) ^ (0xFFFF >>> (16 - fromBit)));\n}\n/**\n * A lookup table for number of set bits in a 16-bit integer.   This is used to quickly count the cardinality (number of unique elements) of a BitSet.\n */\nconst POP_CNT = new Uint8Array(65536);\nfor (let i = 0; i < 16; i++) {\n    const stride = (1 << i) >>> 0;\n    let index = 0;\n    while (index < POP_CNT.length) {\n        // skip the numbers where the bit isn't set\n        index += stride;\n        // increment the ones where the bit is set\n        for (let j = 0; j < stride; j++) {\n            POP_CNT[index]++;\n            index++;\n        }\n    }\n}\nclass BitSet {\n    /*\n    ** constructor implementation\n    */\n    constructor(arg) {\n        if (!arg) {\n            // covering the case of unspecified and nbits===0\n            this.data = EMPTY_DATA;\n        }\n        else if (typeof arg === \"number\") {\n            if (arg < 0) {\n                throw new RangeError(\"nbits cannot be negative\");\n            }\n            else {\n                this.data = new Uint16Array(getIndex(arg - 1) + 1);\n            }\n        }\n        else {\n            if (arg instanceof BitSet) {\n                this.data = arg.data.slice(0); // Clone the data\n            }\n            else {\n                let max = -1;\n                for (let v of arg) {\n                    if (max < v) {\n                        max = v;\n                    }\n                }\n                this.data = new Uint16Array(getIndex(max - 1) + 1);\n                for (let v of arg) {\n                    this.set(v);\n                }\n            }\n        }\n    }\n    /**\n     * Performs a logical **AND** of this target bit set with the argument bit set. This bit set is modified so that\n     * each bit in it has the value `true` if and only if it both initially had the value `true` and the corresponding\n     * bit in the bit set argument also had the value `true`.\n     */\n    and(set) {\n        const data = this.data;\n        const other = set.data;\n        const words = Math.min(data.length, other.length);\n        let lastWord = -1; // Keep track of index of last non-zero word\n        for (let i = 0; i < words; i++) {\n            let value = data[i] &= other[i];\n            if (value !== 0) {\n                lastWord = i;\n            }\n        }\n        if (lastWord === -1) {\n            this.data = EMPTY_DATA;\n        }\n        if (lastWord < data.length - 1) {\n            this.data = data.slice(0, lastWord + 1);\n        }\n    }\n    /**\n     * Clears all of the bits in this `BitSet` whose corresponding bit is set in the specified `BitSet`.\n     */\n    andNot(set) {\n        const data = this.data;\n        const other = set.data;\n        const words = Math.min(data.length, other.length);\n        let lastWord = -1; // Keep track of index of last non-zero word\n        for (let i = 0; i < words; i++) {\n            let value = data[i] &= (other[i] ^ 0xFFFF);\n            if (value !== 0) {\n                lastWord = i;\n            }\n        }\n        if (lastWord === -1) {\n            this.data = EMPTY_DATA;\n        }\n        if (lastWord < data.length - 1) {\n            this.data = data.slice(0, lastWord + 1);\n        }\n    }\n    /**\n     * Returns the number of bits set to `true` in this `BitSet`.\n     */\n    cardinality() {\n        if (this.isEmpty) {\n            return 0;\n        }\n        const data = this.data;\n        const length = data.length;\n        let result = 0;\n        for (let i = 0; i < length; i++) {\n            result += POP_CNT[data[i]];\n        }\n        return result;\n    }\n    clear(fromIndex, toIndex) {\n        if (fromIndex == null) {\n            this.data.fill(0);\n        }\n        else if (toIndex == null) {\n            this.set(fromIndex, false);\n        }\n        else {\n            this.set(fromIndex, toIndex, false);\n        }\n    }\n    flip(fromIndex, toIndex) {\n        if (toIndex == null) {\n            toIndex = fromIndex;\n        }\n        if (fromIndex < 0 || toIndex < fromIndex) {\n            throw new RangeError();\n        }\n        let word = getIndex(fromIndex);\n        const lastWord = getIndex(toIndex);\n        if (word === lastWord) {\n            this.data[word] ^= bitsFor(fromIndex, toIndex);\n        }\n        else {\n            this.data[word++] ^= bitsFor(fromIndex, 15);\n            while (word < lastWord) {\n                this.data[word++] ^= 0xFFFF;\n            }\n            this.data[word++] ^= bitsFor(0, toIndex);\n        }\n    }\n    get(fromIndex, toIndex) {\n        if (toIndex === undefined) {\n            return !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));\n        }\n        else {\n            // return a BitSet\n            let result = new BitSet(toIndex + 1);\n            for (let i = fromIndex; i <= toIndex; i++) {\n                result.set(i, this.get(i));\n            }\n            return result;\n        }\n    }\n    /**\n     * Returns true if the specified `BitSet` has any bits set to `true` that are also set to `true` in this `BitSet`.\n     *\n     * @param set `BitSet` to intersect with\n     */\n    intersects(set) {\n        let smallerLength = Math.min(this.length(), set.length());\n        if (smallerLength === 0) {\n            return false;\n        }\n        let bound = getIndex(smallerLength - 1);\n        for (let i = 0; i <= bound; i++) {\n            if ((this.data[i] & set.data[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns true if this `BitSet` contains no bits that are set to `true`.\n     */\n    get isEmpty() {\n        return this.length() === 0;\n    }\n    /**\n     * Returns the \"logical size\" of this `BitSet`: the index of the highest set bit in the `BitSet` plus one. Returns\n     * zero if the `BitSet` contains no set bits.\n     */\n    length() {\n        if (!this.data.length) {\n            return 0;\n        }\n        return this.previousSetBit(unIndex(this.data.length) - 1) + 1;\n    }\n    /**\n     * Returns the index of the first bit that is set to `false` that occurs on or after the specified starting index,\n     * If no such bit exists then `-1` is returned.\n     *\n     * @param fromIndex the index to start checking from (inclusive)\n     *\n     * @throws RangeError if the specified index is negative\n     */\n    nextClearBit(fromIndex) {\n        if (fromIndex < 0) {\n            throw new RangeError(\"fromIndex cannot be negative\");\n        }\n        const data = this.data;\n        const length = data.length;\n        let word = getIndex(fromIndex);\n        if (word > length) {\n            return -1;\n        }\n        let ignore = 0xFFFF ^ bitsFor(fromIndex, 15);\n        if ((data[word] | ignore) === 0xFFFF) {\n            word++;\n            ignore = 0;\n            for (; word < length; word++) {\n                if (data[word] !== 0xFFFF) {\n                    break;\n                }\n            }\n            if (word === length) {\n                // Hit the end\n                return -1;\n            }\n        }\n        return unIndex(word) + findLSBSet((data[word] | ignore) ^ 0xFFFF);\n    }\n    /**\n     * Returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.\n     * If no such bit exists then `-1` is returned.\n     *\n     * To iterate over the `true` bits in a `BitSet`, use the following loop:\n     *\n     * ```\n     * for (let i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {\n     *   // operate on index i here\n     * }\n     * ```\n     *\n     * @param fromIndex the index to start checking from (inclusive)\n     *\n     * @throws RangeError if the specified index is negative\n     */\n    nextSetBit(fromIndex) {\n        if (fromIndex < 0) {\n            throw new RangeError(\"fromIndex cannot be negative\");\n        }\n        const data = this.data;\n        const length = data.length;\n        let word = getIndex(fromIndex);\n        if (word > length) {\n            return -1;\n        }\n        let mask = bitsFor(fromIndex, 15);\n        if ((data[word] & mask) === 0) {\n            word++;\n            mask = 0xFFFF;\n            for (; word < length; word++) {\n                if (data[word] !== 0) {\n                    break;\n                }\n            }\n            if (word >= length) {\n                return -1;\n            }\n        }\n        return unIndex(word) + findLSBSet(data[word] & mask);\n    }\n    /**\n     * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it\n     * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit\n     * set argument has the value `true`.\n     */\n    or(set) {\n        const data = this.data;\n        const other = set.data;\n        const minWords = Math.min(data.length, other.length);\n        const words = Math.max(data.length, other.length);\n        const dest = data.length === words ? data : new Uint16Array(words);\n        let lastWord = -1;\n        // Or those words both sets have in common\n        for (let i = 0; i < minWords; i++) {\n            let value = dest[i] = data[i] | other[i];\n            if (value !== 0) {\n                lastWord = i;\n            }\n        }\n        // Copy words from larger set (if there is one)\n        const longer = data.length > other.length ? data : other;\n        for (let i = minWords; i < words; i++) {\n            let value = dest[i] = longer[i];\n            if (value !== 0) {\n                lastWord = i;\n            }\n        }\n        if (lastWord === -1) {\n            this.data = EMPTY_DATA;\n        }\n        else if (dest.length === lastWord + 1) {\n            this.data = dest;\n        }\n        else {\n            this.data = dest.slice(0, lastWord);\n        }\n    }\n    /**\n     * Returns the index of the nearest bit that is set to `false` that occurs on or before the specified starting\n     * index. If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.\n     *\n     * @param fromIndex the index to start checking from (inclusive)\n     *\n     * @throws RangeError if the specified index is less than `-1`\n     */\n    previousClearBit(fromIndex) {\n        if (fromIndex < 0) {\n            throw new RangeError(\"fromIndex cannot be negative\");\n        }\n        const data = this.data;\n        const length = data.length;\n        let word = getIndex(fromIndex);\n        if (word >= length) {\n            word = length - 1;\n        }\n        let ignore = 0xFFFF ^ bitsFor(0, fromIndex);\n        if ((data[word] | ignore) === 0xFFFF) {\n            ignore = 0;\n            word--;\n            for (; word >= 0; word--) {\n                if (data[word] !== 0xFFFF) {\n                    break;\n                }\n            }\n            if (word < 0) {\n                // Hit the end\n                return -1;\n            }\n        }\n        return unIndex(word) + findMSBSet((data[word] | ignore) ^ 0xFFFF);\n    }\n    /**\n     * Returns the index of the nearest bit that is set to `true` that occurs on or before the specified starting index.\n     * If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.\n     *\n     * To iterate over the `true` bits in a `BitSet`, use the following loop:\n     *\n     * ```\n     * for (let i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {\n     *   // operate on index i here\n     * }\n     * ```\n     *\n     * @param fromIndex the index to start checking from (inclusive)\n     *\n     * @throws RangeError if the specified index is less than `-1`\n     */\n    previousSetBit(fromIndex) {\n        if (fromIndex < 0) {\n            throw new RangeError(\"fromIndex cannot be negative\");\n        }\n        const data = this.data;\n        const length = data.length;\n        let word = getIndex(fromIndex);\n        if (word >= length) {\n            word = length - 1;\n        }\n        let mask = bitsFor(0, fromIndex);\n        if ((data[word] & mask) === 0) {\n            word--;\n            mask = 0xFFFF;\n            for (; word >= 0; word--) {\n                if (data[word] !== 0) {\n                    break;\n                }\n            }\n            if (word < 0) {\n                return -1;\n            }\n        }\n        return unIndex(word) + findMSBSet(data[word] & mask);\n    }\n    set(fromIndex, toIndex, value) {\n        if (toIndex === undefined) {\n            toIndex = fromIndex;\n            value = true;\n        }\n        else if (typeof toIndex === \"boolean\") {\n            value = toIndex;\n            toIndex = fromIndex;\n        }\n        if (value === undefined) {\n            value = true;\n        }\n        if (fromIndex < 0 || fromIndex > toIndex) {\n            throw new RangeError();\n        }\n        let word = getIndex(fromIndex);\n        let lastWord = getIndex(toIndex);\n        if (value && lastWord >= this.data.length) {\n            // Grow array \"just enough\" for bits we need to set\n            let temp = new Uint16Array(lastWord + 1);\n            this.data.forEach((value, index) => temp[index] = value);\n            this.data = temp;\n        }\n        else if (!value) {\n            // But there is no need to grow array to clear bits.\n            if (word >= this.data.length) {\n                // Early exit\n                return;\n            }\n            if (lastWord >= this.data.length) {\n                // Adjust work to fit array\n                lastWord = this.data.length - 1;\n                toIndex = this.data.length * 16 - 1;\n            }\n        }\n        if (word === lastWord) {\n            this._setBits(word, value, bitsFor(fromIndex, toIndex));\n        }\n        else {\n            this._setBits(word++, value, bitsFor(fromIndex, 15));\n            while (word < lastWord) {\n                this.data[word++] = value ? 0xFFFF : 0;\n            }\n            this._setBits(word, value, bitsFor(0, toIndex));\n        }\n    }\n    _setBits(word, value, mask) {\n        if (value) {\n            this.data[word] |= mask;\n        }\n        else {\n            this.data[word] &= 0xFFFF ^ mask;\n        }\n    }\n    /**\n     * Returns the number of bits of space actually in use by this `BitSet` to represent bit values. The maximum element\n     * in the set is the size - 1st element.\n     */\n    get size() {\n        return this.data.byteLength * 8;\n    }\n    /**\n     * Returns a new byte array containing all the bits in this bit set.\n     *\n     * More precisely, if\n     * `let bytes = s.toByteArray();`\n     * then `bytes.length === (s.length()+7)/8` and `s.get(n) === ((bytes[n/8] & (1<<(n%8))) != 0)` for all\n     * `n < 8 * bytes.length`.\n     */\n    // toByteArray(): Int8Array {\n    // \tthrow new Error(\"NOT IMPLEMENTED\");\n    // }\n    /**\n     * Returns a new integer array containing all the bits in this bit set.\n     *\n     * More precisely, if\n     * `let integers = s.toIntegerArray();`\n     * then `integers.length === (s.length()+31)/32` and `s.get(n) === ((integers[n/32] & (1<<(n%32))) != 0)` for all\n     * `n < 32 * integers.length`.\n     */\n    // toIntegerArray(): Int32Array {\n    // \tthrow new Error(\"NOT IMPLEMENTED\");\n    // }\n    hashCode() {\n        return MurmurHash_1.MurmurHash.hashCode(this.data, 22);\n    }\n    /**\n     * Compares this object against the specified object. The result is `true` if and only if the argument is not\n     * `undefined` and is a `Bitset` object that has exactly the same set of bits set to `true` as this bit set. That\n     * is, for every nonnegative index `k`,\n     *\n     * ```\n     * ((BitSet)obj).get(k) == this.get(k)\n     * ```\n     *\n     * must be true. The current sizes of the two bit sets are not compared.\n     */\n    equals(obj) {\n        if (obj === this) {\n            return true;\n        }\n        else if (!(obj instanceof BitSet)) {\n            return false;\n        }\n        const len = this.length();\n        if (len !== obj.length()) {\n            return false;\n        }\n        if (len === 0) {\n            return true;\n        }\n        let bound = getIndex(len - 1);\n        for (let i = 0; i <= bound; i++) {\n            if (this.data[i] !== obj.data[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns a string representation of this bit set. For every index for which this `BitSet` contains a bit in the\n     * set state, the decimal representation of that index is included in the result. Such indices are listed in order\n     * from lowest to highest, separated by \", \" (a comma and a space) and surrounded by braces, resulting in the usual\n     * mathematical notation for a set of integers.\n     *\n     * Example:\n     *\n     *     BitSet drPepper = new BitSet();\n     *\n     * Now `drPepper.toString()` returns `\"{}\"`.\n     *\n     *     drPepper.set(2);\n     *\n     * Now `drPepper.toString()` returns `\"{2}\"`.\n     *\n     *     drPepper.set(4);\n     *     drPepper.set(10);\n     *\n     * Now `drPepper.toString()` returns `\"{2, 4, 10}\"`.\n     */\n    toString() {\n        let result = \"{\";\n        let first = true;\n        for (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {\n            if (first) {\n                first = false;\n            }\n            else {\n                result += \", \";\n            }\n            result += i;\n        }\n        result += \"}\";\n        return result;\n    }\n    // static valueOf(bytes: Int8Array): BitSet;\n    // static valueOf(buffer: ArrayBuffer): BitSet;\n    // static valueOf(integers: Int32Array): BitSet;\n    // static valueOf(data: Int8Array | Int32Array | ArrayBuffer): BitSet {\n    // \tthrow new Error(\"NOT IMPLEMENTED\");\n    // }\n    /**\n     * Performs a logical **XOR** of this bit set with the bit set argument. This bit set is modified so that a bit in\n     * it has the value `true` if and only if one of the following statements holds:\n     *\n     * * The bit initially has the value `true`, and the corresponding bit in the argument has the value `false`.\n     * * The bit initially has the value `false`, and the corresponding bit in the argument has the value `true`.\n     */\n    xor(set) {\n        const data = this.data;\n        const other = set.data;\n        const minWords = Math.min(data.length, other.length);\n        const words = Math.max(data.length, other.length);\n        const dest = data.length === words ? data : new Uint16Array(words);\n        let lastWord = -1;\n        // Xor those words both sets have in common\n        for (let i = 0; i < minWords; i++) {\n            let value = dest[i] = data[i] ^ other[i];\n            if (value !== 0) {\n                lastWord = i;\n            }\n        }\n        // Copy words from larger set (if there is one)\n        const longer = data.length > other.length ? data : other;\n        for (let i = minWords; i < words; i++) {\n            let value = dest[i] = longer[i];\n            if (value !== 0) {\n                lastWord = i;\n            }\n        }\n        if (lastWord === -1) {\n            this.data = EMPTY_DATA;\n        }\n        else if (dest.length === lastWord + 1) {\n            this.data = dest;\n        }\n        else {\n            this.data = dest.slice(0, lastWord + 1);\n        }\n    }\n    clone() {\n        return new BitSet(this);\n    }\n    [Symbol.iterator]() {\n        return new BitSetIterator(this.data);\n    }\n    // Overrides formatting for nodejs assert etc.\n    [util.inspect.custom]() {\n        return \"BitSet \" + this.toString();\n    }\n}\nexports.BitSet = BitSet;\nclass BitSetIterator {\n    constructor(data) {\n        this.data = data;\n        this.index = 0;\n        this.mask = 0xFFFF;\n    }\n    next() {\n        while (this.index < this.data.length) {\n            const bits = this.data[this.index] & this.mask;\n            if (bits !== 0) {\n                const bitNumber = unIndex(this.index) + findLSBSet(bits);\n                this.mask = bitsFor(bitNumber + 1, 15);\n                return { done: false, value: bitNumber };\n            }\n            this.index++;\n            this.mask = 0xFFFF;\n        }\n        return { done: true, value: -1 };\n    }\n    [Symbol.iterator]() { return this; }\n}\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\nimport * as assert from \"assert\";\nimport * as util from \"util\";\nimport { MurmurHash } from \"./MurmurHash\";\n\n/**\n * Private empty array used to construct empty BitSets\n */\nconst EMPTY_DATA: Uint16Array = new Uint16Array(0);\n\n/**\n * Gets the word index of the `UInt16` element in `BitSet.data` containing the bit with the specified index.\n */\nfunction getIndex(bitNumber: number) {\n\treturn bitNumber >>> 4;\n}\n\n/**\n * Convert a word index into the bit index of the LSB of that word\n */\n\nfunction unIndex(n: number) {\n\treturn n * 16;\n}\n\n/**\n * Get's the bit number of the least signficant bit set LSB which is set in a word non-zero word;\n * Bit numbers run from LSB to MSB starting with 0.\n */\nfunction findLSBSet(word: number) {\n\tlet bit = 1;\n\tfor (let i = 0; i < 16; i++) {\n\t\tif ((word & bit) !== 0) {\n\t\t\treturn i;\n\t\t}\n\t\tbit = (bit << 1) >>> 0;\n\t}\n\tthrow new RangeError(\"No specified bit found\");\n}\n\nfunction findMSBSet(word: number) {\n\tlet bit = (1 << 15) >>> 0;\n\tfor (let i = 15; i >= 0; i--) {\n\t\tif ((word & bit) !== 0) {\n\t\t\treturn i;\n\t\t}\n\t\tbit = bit >>> 1;\n\t}\n\tthrow new RangeError(\"No specified bit found\");\n}\n\n/**\n * Gets a 16-bit mask with bit numbers fromBit to toBit (inclusive) set.\n * Bit numbers run from LSB to MSB starting with 0.\n */\nfunction bitsFor(fromBit: number, toBit: number): number {\n\tfromBit &= 0xF;\n\ttoBit &= 0xF;\n\tif (fromBit === toBit) {\n\t\treturn (1 << fromBit) >>> 0;\n\t}\n\treturn ((0xFFFF >>> (15 - toBit)) ^ (0xFFFF >>> (16 - fromBit)));\n}\n\n/**\n * A lookup table for number of set bits in a 16-bit integer.   This is used to quickly count the cardinality (number of unique elements) of a BitSet.\n */\nconst POP_CNT: Uint8Array = new Uint8Array(65536);\nfor (let i = 0; i < 16; i++) {\n\tconst stride = (1 << i) >>> 0;\n\tlet index = 0;\n\twhile (index < POP_CNT.length) {\n\t\t// skip the numbers where the bit isn't set\n\t\tindex += stride;\n\n\t\t// increment the ones where the bit is set\n\t\tfor (let j = 0; j < stride; j++) {\n\t\t\tPOP_CNT[index]++;\n\t\t\tindex++;\n\t\t}\n\t}\n}\n\nexport class BitSet implements Iterable<number>{\n\tprivate data: Uint16Array;\n\n\t/**\n\t * Creates a new bit set. All bits are initially `false`.\n\t */\n\tconstructor();\n\n\t/**\n\t * Creates a bit set whose initial size is large enough to explicitly represent bits with indices in the range `0`\n\t * through `nbits-1`. All bits are initially `false`.\n\t */\n\tconstructor(nbits: number);\n\n\t/**\n\t * Creates a bit set from a iterable list of numbers (including another BitSet);\n\t */\n\tconstructor(numbers: Iterable<number>);\n\n\t/*\n\t** constructor implementation\n\t*/\n\tconstructor(arg?: number | Iterable<number>) {\n\t\tif (!arg) {\n\t\t\t// covering the case of unspecified and nbits===0\n\t\t\tthis.data = EMPTY_DATA;\n\t\t} else if (typeof arg === \"number\") {\n\t\t\tif (arg < 0) {\n\t\t\t\tthrow new RangeError(\"nbits cannot be negative\");\n\t\t\t} else {\n\t\t\t\tthis.data = new Uint16Array(getIndex(arg - 1) + 1);\n\t\t\t}\n\t\t} else {\n\t\t\tif (arg instanceof BitSet) {\n\t\t\t\tthis.data = arg.data.slice(0); // Clone the data\n\t\t\t} else {\n\t\t\t\tlet max = -1;\n\t\t\t\tfor (let v of arg) {\n\t\t\t\t\tif (max < v) {\n\t\t\t\t\t\tmax = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.data = new Uint16Array(getIndex(max - 1) + 1);\n\t\t\t\tfor (let v of arg) {\n\t\t\t\t\tthis.set(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Performs a logical **AND** of this target bit set with the argument bit set. This bit set is modified so that\n\t * each bit in it has the value `true` if and only if it both initially had the value `true` and the corresponding\n\t * bit in the bit set argument also had the value `true`.\n\t */\n\tpublic and(set: BitSet): void {\n\t\tconst data = this.data;\n\t\tconst other = set.data;\n\t\tconst words = Math.min(data.length, other.length);\n\n\t\tlet lastWord = -1;\t// Keep track of index of last non-zero word\n\n\t\tfor (let i = 0; i < words; i++) {\n\t\t\tlet value = data[i] &= other[i];\n\t\t\tif (value !== 0) {\n\t\t\t\tlastWord = i;\n\t\t\t}\n\t\t}\n\n\t\tif (lastWord === -1) {\n\t\t\tthis.data = EMPTY_DATA;\n\t\t}\n\n\t\tif (lastWord < data.length - 1) {\n\t\t\tthis.data = data.slice(0, lastWord + 1);\n\t\t}\n\t}\n\n\t/**\n\t * Clears all of the bits in this `BitSet` whose corresponding bit is set in the specified `BitSet`.\n\t */\n\tpublic andNot(set: BitSet): void {\n\t\tconst data = this.data;\n\t\tconst other = set.data;\n\t\tconst words = Math.min(data.length, other.length);\n\n\t\tlet lastWord = -1;\t// Keep track of index of last non-zero word\n\n\t\tfor (let i = 0; i < words; i++) {\n\t\t\tlet value = data[i] &= (other[i] ^ 0xFFFF);\n\t\t\tif (value !== 0) {\n\t\t\t\tlastWord = i;\n\t\t\t}\n\t\t}\n\n\t\tif (lastWord === -1) {\n\t\t\tthis.data = EMPTY_DATA;\n\t\t}\n\n\t\tif (lastWord < data.length - 1) {\n\t\t\tthis.data = data.slice(0, lastWord + 1);\n\t\t}\n\t}\n\n\n\t/**\n\t * Returns the number of bits set to `true` in this `BitSet`.\n\t */\n\tpublic cardinality(): number {\n\t\tif (this.isEmpty) {\n\t\t\treturn 0;\n\t\t}\n\t\tconst data = this.data;\n\t\tconst length = data.length;\n\t\tlet result = 0;\n\n\t\tfor (let i = 0; i < length; i++) {\n\t\t\tresult += POP_CNT[data[i]];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Sets all of the bits in this `BitSet` to `false`.\n\t */\n\tpublic clear(): void;\n\n\t/**\n\t * Sets the bit specified by the index to `false`.\n\t *\n\t * @param bitIndex the index of the bit to be cleared\n\t *\n\t * @throws RangeError if the specified index is negative\n\t */\n\tpublic clear(bitIndex: number): void;\n\n\t/**\n\t * Sets the bits from the specified `fromIndex` (inclusive) to the specified `toIndex` (exclusive) to `false`.\n\t *\n\t * @param fromIndex index of the first bit to be cleared\n\t * @param toIndex index after the last bit to be cleared\n\t *\n\t * @throws RangeError if `fromIndex` is negative, or `toIndex` is negative, or `fromIndex` is larger than `toIndex`\n\t */\n\tpublic clear(fromIndex: number, toIndex: number): void;\n\tpublic clear(fromIndex?: number, toIndex?: number): void {\n\t\tif (fromIndex == null) {\n\t\t\tthis.data.fill(0);\n\t\t} else if (toIndex == null) {\n\t\t\tthis.set(fromIndex, false);\n\t\t} else {\n\t\t\tthis.set(fromIndex, toIndex, false);\n\t\t}\n\t}\n\n\t/**\n\t * Sets the bit at the specified index to the complement of its current value.\n\t *\n\t * @param bitIndex the index of the bit to flip\n\t *\n\t * @throws RangeError if the specified index is negative\n\t */\n\tpublic flip(bitIndex: number): void;\n\n\t/**\n\t * Sets each bit from the specified `fromIndex` (inclusive) to the specified `toIndex` (exclusive) to the complement\n\t * of its current value.\n\t *\n\t * @param fromIndex index of the first bit to flip\n\t * @param toIndex index after the last bit to flip\n\t *\n\t * @throws RangeError if `fromIndex` is negative, or `toIndex` is negative, or `fromIndex` is larger than `toIndex`\n\t */\n\tpublic flip(fromIndex: number, toIndex: number): void;\n\tpublic flip(fromIndex: number, toIndex?: number): void {\n\t\tif (toIndex == null) {\n\t\t\ttoIndex = fromIndex;\n\t\t}\n\t\tif (fromIndex < 0 || toIndex < fromIndex) {\n\t\t\tthrow new RangeError();\n\t\t}\n\n\t\tlet word = getIndex(fromIndex);\n\t\tconst lastWord = getIndex(toIndex);\n\n\t\tif (word === lastWord) {\n\t\t\tthis.data[word] ^= bitsFor(fromIndex, toIndex);\n\t\t} else {\n\t\t\tthis.data[word++] ^= bitsFor(fromIndex, 15);\n\t\t\twhile (word < lastWord) {\n\t\t\t\tthis.data[word++] ^= 0xFFFF;\n\t\t\t}\n\t\t\tthis.data[word++] ^= bitsFor(0, toIndex);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the value of the bit with the specified index. The value is `true` if the bit with the index `bitIndex`\n\t * is currently set in this `BitSet`; otherwise, the result is `false`.\n\t *\n\t * @param bitIndex the bit index\n\t *\n\t * @throws RangeError if the specified index is negative\n\t */\n\tpublic get(bitIndex: number): boolean;\n\n\t/**\n\t * Returns a new `BitSet` composed of bits from this `BitSet` from `fromIndex` (inclusive) to `toIndex` (exclusive).\n\t *\n\t * @param fromIndex index of the first bit to include\n\t * @param toIndex index after the last bit to include\n\t *\n\t * @throws RangeError if `fromIndex` is negative, or `toIndex` is negative, or `fromIndex` is larger than `toIndex`\n\t */\n\tpublic get(fromIndex: number, toIndex: number): BitSet;\n\tpublic get(fromIndex: number, toIndex?: number): boolean | BitSet {\n\t\tif (toIndex === undefined) {\n\t\t\treturn !!(this.data[getIndex(fromIndex)] & bitsFor(fromIndex, fromIndex));\n\t\t} else {\n\t\t\t// return a BitSet\n\t\t\tlet result = new BitSet(toIndex + 1);\n\t\t\tfor (let i = fromIndex; i <= toIndex; i++) {\n\t\t\t\tresult.set(i, this.get(i));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Returns true if the specified `BitSet` has any bits set to `true` that are also set to `true` in this `BitSet`.\n\t *\n\t * @param set `BitSet` to intersect with\n\t */\n\tpublic intersects(set: BitSet): boolean {\n\t\tlet smallerLength = Math.min(this.length(), set.length());\n\t\tif (smallerLength === 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet bound = getIndex(smallerLength - 1);\n\t\tfor (let i = 0; i <= bound; i++) {\n\t\t\tif ((this.data[i] & set.data[i]) !== 0) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/**\n\t * Returns true if this `BitSet` contains no bits that are set to `true`.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.length() === 0;\n\t}\n\n\t/**\n\t * Returns the \"logical size\" of this `BitSet`: the index of the highest set bit in the `BitSet` plus one. Returns\n\t * zero if the `BitSet` contains no set bits.\n\t */\n\tpublic length(): number {\n\t\tif (!this.data.length) {\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.previousSetBit(unIndex(this.data.length) - 1) + 1;\n\t}\n\n\t/**\n\t * Returns the index of the first bit that is set to `false` that occurs on or after the specified starting index,\n\t * If no such bit exists then `-1` is returned.\n\t *\n\t * @param fromIndex the index to start checking from (inclusive)\n\t *\n\t * @throws RangeError if the specified index is negative\n\t */\n\tpublic nextClearBit(fromIndex: number): number {\n\t\tif (fromIndex < 0) {\n\t\t\tthrow new RangeError(\"fromIndex cannot be negative\");\n\t\t}\n\n\t\tconst data = this.data;\n\t\tconst length = data.length;\n\t\tlet word = getIndex(fromIndex);\n\t\tif (word > length) {\n\t\t\treturn -1;\n\t\t}\n\n\t\tlet ignore = 0xFFFF ^ bitsFor(fromIndex, 15);\n\n\t\tif ((data[word] | ignore) === 0xFFFF) {\n\t\t\tword++;\n\t\t\tignore = 0;\n\t\t\tfor (; word < length; word++) {\n\t\t\t\tif (data[word] !== 0xFFFF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (word === length) {\n\t\t\t\t// Hit the end\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn unIndex(word) + findLSBSet((data[word] | ignore) ^ 0xFFFF);\n\t}\n\n\t/**\n\t * Returns the index of the first bit that is set to `true` that occurs on or after the specified starting index.\n\t * If no such bit exists then `-1` is returned.\n\t *\n\t * To iterate over the `true` bits in a `BitSet`, use the following loop:\n\t *\n\t * ```\n\t * for (let i = bs.nextSetBit(0); i >= 0; i = bs.nextSetBit(i + 1)) {\n\t *   // operate on index i here\n\t * }\n\t * ```\n\t *\n\t * @param fromIndex the index to start checking from (inclusive)\n\t *\n\t * @throws RangeError if the specified index is negative\n\t */\n\tpublic nextSetBit(fromIndex: number): number {\n\t\tif (fromIndex < 0) {\n\t\t\tthrow new RangeError(\"fromIndex cannot be negative\");\n\t\t}\n\n\t\tconst data = this.data;\n\t\tconst length = data.length;\n\t\tlet word = getIndex(fromIndex);\n\t\tif (word > length) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet mask = bitsFor(fromIndex, 15);\n\n\t\tif ((data[word] & mask) === 0) {\n\t\t\tword++;\n\t\t\tmask = 0xFFFF;\n\t\t\tfor (; word < length; word++) {\n\t\t\t\tif (data[word] !== 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (word >= length) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn unIndex(word) + findLSBSet(data[word] & mask);\n\t}\n\n\t/**\n\t * Performs a logical **OR** of this bit set with the bit set argument. This bit set is modified so that a bit in it\n\t * has the value `true` if and only if it either already had the value `true` or the corresponding bit in the bit\n\t * set argument has the value `true`.\n\t */\n\tpublic or(set: BitSet): void {\n\t\tconst data = this.data;\n\t\tconst other = set.data;\n\t\tconst minWords = Math.min(data.length, other.length);\n\t\tconst words = Math.max(data.length, other.length);\n\t\tconst dest = data.length === words ? data : new Uint16Array(words);\n\n\t\tlet lastWord = -1;\n\n\t\t// Or those words both sets have in common\n\n\t\tfor (let i = 0; i < minWords; i++) {\n\t\t\tlet value = dest[i] = data[i] | other[i];\n\t\t\tif (value !== 0) {\n\t\t\t\tlastWord = i;\n\t\t\t}\n\t\t}\n\n\t\t// Copy words from larger set (if there is one)\n\n\t\tconst longer = data.length > other.length ? data : other;\n\t\tfor (let i = minWords; i < words; i++) {\n\t\t\tlet value = dest[i] = longer[i];\n\t\t\tif (value !== 0) {\n\t\t\t\tlastWord = i;\n\t\t\t}\n\t\t}\n\n\t\tif (lastWord === -1) {\n\t\t\tthis.data = EMPTY_DATA;\n\t\t} else if (dest.length === lastWord + 1) {\n\t\t\tthis.data = dest;\n\t\t} else {\n\t\t\tthis.data = dest.slice(0, lastWord);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the index of the nearest bit that is set to `false` that occurs on or before the specified starting\n\t * index. If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.\n\t *\n\t * @param fromIndex the index to start checking from (inclusive)\n\t *\n\t * @throws RangeError if the specified index is less than `-1`\n\t */\n\tpublic previousClearBit(fromIndex: number): number {\n\t\tif (fromIndex < 0) {\n\t\t\tthrow new RangeError(\"fromIndex cannot be negative\");\n\t\t}\n\n\t\tconst data = this.data;\n\t\tconst length = data.length;\n\t\tlet word = getIndex(fromIndex);\n\t\tif (word >= length) {\n\t\t\tword = length - 1;\n\t\t}\n\n\t\tlet ignore = 0xFFFF ^ bitsFor(0, fromIndex);\n\n\t\tif ((data[word] | ignore) === 0xFFFF) {\n\t\t\tignore = 0;\n\t\t\tword--;\n\t\t\tfor (; word >= 0; word--) {\n\t\t\t\tif (data[word] !== 0xFFFF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (word < 0) {\n\t\t\t\t// Hit the end\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn unIndex(word) + findMSBSet((data[word] | ignore) ^ 0xFFFF);\n\t}\n\n\n\t/**\n\t * Returns the index of the nearest bit that is set to `true` that occurs on or before the specified starting index.\n\t * If no such bit exists, or if `-1` is given as the starting index, then `-1` is returned.\n\t *\n\t * To iterate over the `true` bits in a `BitSet`, use the following loop:\n\t *\n\t * ```\n\t * for (let i = bs.length(); (i = bs.previousSetBit(i-1)) >= 0; ) {\n\t *   // operate on index i here\n\t * }\n\t * ```\n\t *\n\t * @param fromIndex the index to start checking from (inclusive)\n\t *\n\t * @throws RangeError if the specified index is less than `-1`\n\t */\n\tpublic previousSetBit(fromIndex: number): number {\n\t\tif (fromIndex < 0) {\n\t\t\tthrow new RangeError(\"fromIndex cannot be negative\");\n\t\t}\n\n\t\tconst data = this.data;\n\t\tconst length = data.length;\n\t\tlet word = getIndex(fromIndex);\n\t\tif (word >= length) {\n\t\t\tword = length - 1;\n\t\t}\n\n\t\tlet mask = bitsFor(0, fromIndex);\n\n\t\tif ((data[word] & mask) === 0) {\n\t\t\tword--;\n\t\t\tmask = 0xFFFF;\n\t\t\tfor (; word >= 0; word--) {\n\t\t\t\tif (data[word] !== 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (word < 0) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t\treturn unIndex(word) + findMSBSet(data[word] & mask);\n\t}\n\n\t/**\n\t * Sets the bit at the specified index to `true`.\n\t *\n\t * @param bitIndex a bit index\n\t *\n\t * @throws RangeError if the specified index is negative\n\t */\n\tpublic set(bitIndex: number): void;\n\n\t/**\n\t * Sets the bit at the specified index to the specified value.\n\t *\n\t * @param bitIndex a bit index\n\t * @param value a boolean value to set\n\t *\n\t * @throws RangeError if the specified index is negative\n\t */\n\tpublic set(bitIndex: number, value: boolean): void;\n\n\t/**\n\t * Sets the bits from the specified `fromIndex` (inclusive) to the specified `toIndex` (exclusive) to `true`.\n\t *\n\t * @param fromIndex index of the first bit to be set\n\t * @param toIndex index after the last bit to be set\n\t *\n\t * @throws RangeError if `fromIndex` is negative, or `toIndex` is negative, or `fromIndex` is larger than `toIndex`\n\t */\n\tpublic set(fromIndex: number, toIndex: number): void;\n\n\t/**\n\t * Sets the bits from the specified `fromIndex` (inclusive) to the specified `toIndex` (exclusive) to the specified\n\t * value.\n\t *\n\t * @param fromIndex index of the first bit to be set\n\t * @param toIndex index after the last bit to be set\n\t * @param value value to set the selected bits to\n\t *\n\t * @throws RangeError if `fromIndex` is negative, or `toIndex` is negative, or `fromIndex` is larger than `toIndex`\n\t */\n\tpublic set(fromIndex: number, toIndex: number, value: boolean): void;\n\tpublic set(fromIndex: number, toIndex?: boolean | number, value?: boolean): void {\n\t\tif (toIndex === undefined) {\n\t\t\ttoIndex = fromIndex;\n\t\t\tvalue = true;\n\t\t} else if (typeof toIndex === \"boolean\") {\n\t\t\tvalue = toIndex;\n\t\t\ttoIndex = fromIndex;\n\t\t}\n\n\t\tif (value === undefined) {\n\t\t\tvalue = true;\n\t\t}\n\n\t\tif (fromIndex < 0 || fromIndex > toIndex) {\n\t\t\tthrow new RangeError();\n\t\t}\n\n\t\tlet word = getIndex(fromIndex);\n\t\tlet lastWord = getIndex(toIndex);\n\n\t\tif (value && lastWord >= this.data.length) {\n\t\t\t// Grow array \"just enough\" for bits we need to set\n\t\t\tlet temp = new Uint16Array(lastWord + 1);\n\t\t\tthis.data.forEach((value, index) => temp[index] = value);\n\t\t\tthis.data = temp;\n\t\t} else if (!value) {\n\t\t\t// But there is no need to grow array to clear bits.\n\t\t\tif (word >= this.data.length) {\n\t\t\t\t// Early exit\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (lastWord >= this.data.length) {\n\t\t\t\t// Adjust work to fit array\n\t\t\t\tlastWord = this.data.length - 1;\n\t\t\t\ttoIndex = this.data.length * 16 - 1;\n\t\t\t}\n\t\t}\n\n\t\tif (word === lastWord) {\n\t\t\tthis._setBits(word, value, bitsFor(fromIndex, toIndex));\n\t\t} else {\n\t\t\tthis._setBits(word++, value, bitsFor(fromIndex, 15));\n\t\t\twhile (word < lastWord) {\n\t\t\t\tthis.data[word++] = value ? 0xFFFF : 0;\n\t\t\t}\n\t\t\tthis._setBits(word, value, bitsFor(0, toIndex));\n\t\t}\n\t}\n\n\tprivate _setBits(word: number, value: boolean, mask: number) {\n\t\tif (value) {\n\t\t\tthis.data[word] |= mask;\n\t\t} else {\n\t\t\tthis.data[word] &= 0xFFFF ^ mask;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the number of bits of space actually in use by this `BitSet` to represent bit values. The maximum element\n\t * in the set is the size - 1st element.\n\t */\n\tget size(): number {\n\t\treturn this.data.byteLength * 8;\n\t}\n\n\t/**\n\t * Returns a new byte array containing all the bits in this bit set.\n\t *\n\t * More precisely, if\n\t * `let bytes = s.toByteArray();`\n\t * then `bytes.length === (s.length()+7)/8` and `s.get(n) === ((bytes[n/8] & (1<<(n%8))) != 0)` for all\n\t * `n < 8 * bytes.length`.\n\t */\n\t// toByteArray(): Int8Array {\n\t// \tthrow new Error(\"NOT IMPLEMENTED\");\n\t// }\n\n\t/**\n\t * Returns a new integer array containing all the bits in this bit set.\n\t *\n\t * More precisely, if\n\t * `let integers = s.toIntegerArray();`\n\t * then `integers.length === (s.length()+31)/32` and `s.get(n) === ((integers[n/32] & (1<<(n%32))) != 0)` for all\n\t * `n < 32 * integers.length`.\n\t */\n\t// toIntegerArray(): Int32Array {\n\t// \tthrow new Error(\"NOT IMPLEMENTED\");\n\t// }\n\n\tpublic hashCode(): number {\n\t\treturn MurmurHash.hashCode(this.data, 22);\n\t}\n\n\t/**\n\t * Compares this object against the specified object. The result is `true` if and only if the argument is not\n\t * `undefined` and is a `Bitset` object that has exactly the same set of bits set to `true` as this bit set. That\n\t * is, for every nonnegative index `k`,\n\t *\n\t * ```\n\t * ((BitSet)obj).get(k) == this.get(k)\n\t * ```\n\t *\n\t * must be true. The current sizes of the two bit sets are not compared.\n\t */\n\tpublic equals(obj: any): boolean {\n\t\tif (obj === this) {\n\t\t\treturn true;\n\t\t} else if (!(obj instanceof BitSet)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tconst len = this.length();\n\n\t\tif (len !== obj.length()) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (len === 0) {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet bound = getIndex(len - 1);\n\t\tfor (let i = 0; i <= bound; i++) {\n\t\t\tif (this.data[i] !== obj.data[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns a string representation of this bit set. For every index for which this `BitSet` contains a bit in the\n\t * set state, the decimal representation of that index is included in the result. Such indices are listed in order\n\t * from lowest to highest, separated by \", \" (a comma and a space) and surrounded by braces, resulting in the usual\n\t * mathematical notation for a set of integers.\n\t *\n\t * Example:\n\t *\n\t *     BitSet drPepper = new BitSet();\n\t *\n\t * Now `drPepper.toString()` returns `\"{}\"`.\n\t *\n\t *     drPepper.set(2);\n\t *\n\t * Now `drPepper.toString()` returns `\"{2}\"`.\n\t *\n\t *     drPepper.set(4);\n\t *     drPepper.set(10);\n\t *\n\t * Now `drPepper.toString()` returns `\"{2, 4, 10}\"`.\n\t */\n\tpublic toString(): string {\n\t\tlet result = \"{\";\n\n\t\tlet first = true;\n\t\tfor (let i = this.nextSetBit(0); i >= 0; i = this.nextSetBit(i + 1)) {\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tresult += \", \";\n\t\t\t}\n\n\t\t\tresult += i;\n\t\t}\n\n\t\tresult += \"}\";\n\t\treturn result;\n\t}\n\n\t// static valueOf(bytes: Int8Array): BitSet;\n\t// static valueOf(buffer: ArrayBuffer): BitSet;\n\t// static valueOf(integers: Int32Array): BitSet;\n\t// static valueOf(data: Int8Array | Int32Array | ArrayBuffer): BitSet {\n\t// \tthrow new Error(\"NOT IMPLEMENTED\");\n\t// }\n\n\t/**\n\t * Performs a logical **XOR** of this bit set with the bit set argument. This bit set is modified so that a bit in\n\t * it has the value `true` if and only if one of the following statements holds:\n\t *\n\t * * The bit initially has the value `true`, and the corresponding bit in the argument has the value `false`.\n\t * * The bit initially has the value `false`, and the corresponding bit in the argument has the value `true`.\n\t */\n\tpublic xor(set: BitSet): void {\n\t\tconst data = this.data;\n\t\tconst other = set.data;\n\t\tconst minWords = Math.min(data.length, other.length);\n\t\tconst words = Math.max(data.length, other.length);\n\t\tconst dest = data.length === words ? data : new Uint16Array(words);\n\n\t\tlet lastWord = -1;\n\n\t\t// Xor those words both sets have in common\n\n\t\tfor (let i = 0; i < minWords; i++) {\n\t\t\tlet value = dest[i] = data[i] ^ other[i];\n\t\t\tif (value !== 0) {\n\t\t\t\tlastWord = i;\n\t\t\t}\n\t\t}\n\n\t\t// Copy words from larger set (if there is one)\n\n\t\tconst longer = data.length > other.length ? data : other;\n\t\tfor (let i = minWords; i < words; i++) {\n\t\t\tlet value = dest[i] = longer[i];\n\t\t\tif (value !== 0) {\n\t\t\t\tlastWord = i;\n\t\t\t}\n\t\t}\n\n\t\tif (lastWord === -1) {\n\t\t\tthis.data = EMPTY_DATA;\n\t\t} else if (dest.length === lastWord + 1) {\n\t\t\tthis.data = dest;\n\t\t} else {\n\t\t\tthis.data = dest.slice(0, lastWord + 1);\n\t\t}\n\t}\n\n\tpublic clone() {\n\t\treturn new BitSet(this);\n\t}\n\n\tpublic [Symbol.iterator](): IterableIterator<number> {\n\t\treturn new BitSetIterator(this.data);\n\t}\n\n\t// Overrides formatting for nodejs assert etc.\n\tpublic [(util.inspect as any).custom](): string {\n\t\treturn \"BitSet \" + this.toString();\n\t}\n}\n\nclass BitSetIterator implements IterableIterator<number>{\n\tprivate index = 0;\n\tprivate mask = 0xFFFF;\n\n\tconstructor(private data: Uint16Array) { }\n\n\tpublic next() {\n\t\twhile (this.index < this.data.length) {\n\t\t\tconst bits = this.data[this.index] & this.mask;\n\t\t\tif (bits !== 0) {\n\t\t\t\tconst bitNumber = unIndex(this.index) + findLSBSet(bits);\n\t\t\t\tthis.mask = bitsFor(bitNumber + 1, 15);\n\t\t\t\treturn { done: false, value: bitNumber };\n\t\t\t}\n\t\t\tthis.index++;\n\t\t\tthis.mask = 0xFFFF;\n\t\t}\n\t\treturn { done: true, value: -1 };\n\t}\n\n\tpublic [Symbol.iterator](): IterableIterator<number> { return this; }\n}\n"]}