{"version":3,"sources":["misc/IntegerList.js","../src/misc/IntegerList.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","Arrays_1","require","Decorators_1","EMPTY_DATA","Int32Array","INITIAL_SIZE","MAX_ARRAY_SIZE","IntegerList","arg","_data","_size","slice","add","ensureCapacity","list","Array","isArray","subarray","set","size","current","xi","index","RangeError","previous","get","copyWithin","fromIndex","toIndex","fill","from","sort","o","hashCode","toString","undefined","Arrays","binarySearch","capacity","newLength","tmp","resultArray","Uint16Array","resultIdx","calculatedPreciseResultSize","codePoint","newResultArray","charArraySize","pair","String","fromCodePoint","charCodeAt","result","NotNull","prototype","Override"],"mappings":"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","file":"IntegerList.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:40.5099429-07:00\nconst Arrays_1 = require(\"./Arrays\");\nconst Decorators_1 = require(\"../Decorators\");\nconst EMPTY_DATA = new Int32Array(0);\nconst INITIAL_SIZE = 4;\nconst MAX_ARRAY_SIZE = (((1 << 31) >>> 0) - 1) - 8;\n/**\n *\n * @author Sam Harwell\n */\nclass IntegerList {\n    constructor(arg) {\n        if (!arg) {\n            this._data = EMPTY_DATA;\n            this._size = 0;\n        }\n        else if (arg instanceof IntegerList) {\n            this._data = arg._data.slice(0);\n            this._size = arg._size;\n        }\n        else if (typeof arg === \"number\") {\n            if (arg === 0) {\n                this._data = EMPTY_DATA;\n                this._size = 0;\n            }\n            else {\n                this._data = new Int32Array(arg);\n                this._size = 0;\n            }\n        }\n        else {\n            // arg is Iterable<number>\n            this._data = EMPTY_DATA;\n            this._size = 0;\n            for (let value of arg) {\n                this.add(value);\n            }\n        }\n    }\n    add(value) {\n        if (this._data.length === this._size) {\n            this.ensureCapacity(this._size + 1);\n        }\n        this._data[this._size] = value;\n        this._size++;\n    }\n    addAll(list) {\n        if (Array.isArray(list)) {\n            this.ensureCapacity(this._size + list.length);\n            this._data.subarray(this._size, this._size + list.length).set(list);\n            this._size += list.length;\n        }\n        else if (list instanceof IntegerList) {\n            this.ensureCapacity(this._size + list._size);\n            this._data.subarray(this._size, this._size + list.size).set(list._data);\n            this._size += list._size;\n        }\n        else {\n            // list is JavaCollection<number>\n            this.ensureCapacity(this._size + list.size);\n            let current = 0;\n            for (let xi of list) {\n                this._data[this._size + current] = xi;\n                current++;\n            }\n            this._size += list.size;\n        }\n    }\n    get(index) {\n        if (index < 0 || index >= this._size) {\n            throw RangeError();\n        }\n        return this._data[index];\n    }\n    contains(value) {\n        for (let i = 0; i < this._size; i++) {\n            if (this._data[i] === value) {\n                return true;\n            }\n        }\n        return false;\n    }\n    set(index, value) {\n        if (index < 0 || index >= this._size) {\n            throw RangeError();\n        }\n        let previous = this._data[index];\n        this._data[index] = value;\n        return previous;\n    }\n    removeAt(index) {\n        let value = this.get(index);\n        this._data.copyWithin(index, index + 1, this._size);\n        this._data[this._size - 1] = 0;\n        this._size--;\n        return value;\n    }\n    removeRange(fromIndex, toIndex) {\n        if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {\n            throw RangeError();\n        }\n        if (fromIndex > toIndex) {\n            throw RangeError();\n        }\n        this._data.copyWithin(toIndex, fromIndex, this._size);\n        this._data.fill(0, this._size - (toIndex - fromIndex), this._size);\n        this._size -= (toIndex - fromIndex);\n    }\n    get isEmpty() {\n        return this._size === 0;\n    }\n    get size() {\n        return this._size;\n    }\n    trimToSize() {\n        if (this._data.length === this._size) {\n            return;\n        }\n        this._data = this._data.slice(0, this._size);\n    }\n    clear() {\n        this._data.fill(0, 0, this._size);\n        this._size = 0;\n    }\n    toArray() {\n        if (this._size === 0) {\n            return [];\n        }\n        return Array.from(this._data.subarray(0, this._size));\n    }\n    sort() {\n        this._data.subarray(0, this._size).sort();\n    }\n    /**\n     * Compares the specified object with this list for equality.  Returns\n     * `true` if and only if the specified object is also an {@link IntegerList},\n     * both lists have the same size, and all corresponding pairs of elements in\n     * the two lists are equal.  In other words, two lists are defined to be\n     * equal if they contain the same elements in the same order.\n     *\n     * This implementation first checks if the specified object is this\n     * list. If so, it returns `true`; if not, it checks if the\n     * specified object is an {@link IntegerList}. If not, it returns `false`;\n     * if so, it checks the size of both lists. If the lists are not the same size,\n     * it returns `false`; otherwise it iterates over both lists, comparing\n     * corresponding pairs of elements.  If any comparison returns `false`,\n     * this method returns `false`.\n     *\n     * @param o the object to be compared for equality with this list\n     * @returns `true` if the specified object is equal to this list\n     */\n    equals(o) {\n        if (o === this) {\n            return true;\n        }\n        if (!(o instanceof IntegerList)) {\n            return false;\n        }\n        if (this._size !== o._size) {\n            return false;\n        }\n        for (let i = 0; i < this._size; i++) {\n            if (this._data[i] !== o._data[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Returns the hash code value for this list.\n     *\n     * This implementation uses exactly the code that is used to define the\n     * list hash function in the documentation for the {@link List#hashCode}\n     * method.\n     *\n     * @returns the hash code value for this list\n     */\n    hashCode() {\n        let hashCode = 1;\n        for (let i = 0; i < this._size; i++) {\n            hashCode = 31 * hashCode + this._data[i];\n        }\n        return hashCode;\n    }\n    /**\n     * Returns a string representation of this list.\n     */\n    toString() {\n        return this._data.toString();\n    }\n    binarySearch(key, fromIndex, toIndex) {\n        if (fromIndex === undefined) {\n            fromIndex = 0;\n        }\n        if (toIndex === undefined) {\n            toIndex = this._size;\n        }\n        if (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {\n            throw new RangeError();\n        }\n        if (fromIndex > toIndex) {\n            throw new RangeError();\n        }\n        return Arrays_1.Arrays.binarySearch(this._data, key, fromIndex, toIndex);\n    }\n    ensureCapacity(capacity) {\n        if (capacity < 0 || capacity > MAX_ARRAY_SIZE) {\n            throw new RangeError();\n        }\n        let newLength;\n        if (this._data.length === 0) {\n            newLength = INITIAL_SIZE;\n        }\n        else {\n            newLength = this._data.length;\n        }\n        while (newLength < capacity) {\n            newLength = newLength * 2;\n            if (newLength < 0 || newLength > MAX_ARRAY_SIZE) {\n                newLength = MAX_ARRAY_SIZE;\n            }\n        }\n        let tmp = new Int32Array(newLength);\n        tmp.set(this._data);\n        this._data = tmp;\n    }\n    /** Convert the list to a UTF-16 encoded char array. If all values are less\n     *  than the 0xFFFF 16-bit code point limit then this is just a char array\n     *  of 16-bit char as usual. For values in the supplementary range, encode\n     * them as two UTF-16 code units.\n     */\n    toCharArray() {\n        // Optimize for the common case (all data values are < 0xFFFF) to avoid an extra scan\n        let resultArray = new Uint16Array(this._size);\n        let resultIdx = 0;\n        let calculatedPreciseResultSize = false;\n        for (let i = 0; i < this._size; i++) {\n            let codePoint = this._data[i];\n            if (codePoint >= 0 && codePoint < 0x10000) {\n                resultArray[resultIdx] = codePoint;\n                resultIdx++;\n                continue;\n            }\n            // Calculate the precise result size if we encounter a code point > 0xFFFF\n            if (!calculatedPreciseResultSize) {\n                let newResultArray = new Uint16Array(this.charArraySize());\n                newResultArray.set(resultArray, 0);\n                resultArray = newResultArray;\n                calculatedPreciseResultSize = true;\n            }\n            // This will throw RangeError if the code point is not a valid Unicode code point\n            let pair = String.fromCodePoint(codePoint);\n            resultArray[resultIdx] = pair.charCodeAt(0);\n            resultArray[resultIdx + 1] = pair.charCodeAt(1);\n            resultIdx += 2;\n        }\n        return resultArray;\n    }\n    charArraySize() {\n        let result = 0;\n        for (let i = 0; i < this._size; i++) {\n            result += this._data[i] >= 0x10000 ? 2 : 1;\n        }\n        return result;\n    }\n}\n__decorate([\n    Decorators_1.NotNull\n], IntegerList.prototype, \"_data\", void 0);\n__decorate([\n    Decorators_1.Override\n], IntegerList.prototype, \"equals\", null);\n__decorate([\n    Decorators_1.Override\n], IntegerList.prototype, \"hashCode\", null);\n__decorate([\n    Decorators_1.Override\n], IntegerList.prototype, \"toString\", null);\nexports.IntegerList = IntegerList;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:40.5099429-07:00\n\nimport { Arrays } from \"./Arrays\";\nimport { NotNull, Override } from \"../Decorators\";\nimport { JavaCollection } from \"./Stubs\";\n\nconst EMPTY_DATA: Int32Array = new Int32Array(0);\n\nconst INITIAL_SIZE: number = 4;\nconst MAX_ARRAY_SIZE: number = (((1 << 31) >>> 0) - 1) - 8;\n\n/**\n *\n * @author Sam Harwell\n */\nexport class IntegerList {\n\t@NotNull\n\tprivate _data: Int32Array;\n\n\tprivate _size: number;\n\n\tconstructor(arg?: number | IntegerList | Iterable<number>) {\n\t\tif (!arg) {\n\t\t\tthis._data = EMPTY_DATA;\n\t\t\tthis._size = 0;\n\t\t} else if (arg instanceof IntegerList) {\n\t\t\tthis._data = arg._data.slice(0);\n\t\t\tthis._size = arg._size;\n\t\t} else if (typeof arg === \"number\") {\n\t\t\tif (arg === 0) {\n\t\t\t\tthis._data = EMPTY_DATA;\n\t\t\t\tthis._size = 0;\n\t\t\t} else {\n\t\t\t\tthis._data = new Int32Array(arg);\n\t\t\t\tthis._size = 0;\n\t\t\t}\n\t\t} else {\n\t\t\t// arg is Iterable<number>\n\t\t\tthis._data = EMPTY_DATA;\n\t\t\tthis._size = 0;\n\t\t\tfor (let value of arg) {\n\t\t\t\tthis.add(value);\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic add(value: number): void {\n\t\tif (this._data.length === this._size) {\n\t\t\tthis.ensureCapacity(this._size + 1);\n\t\t}\n\n\t\tthis._data[this._size] = value;\n\t\tthis._size++;\n\t}\n\n\tpublic addAll(list: number[] | IntegerList | JavaCollection<number>): void {\n\t\tif (Array.isArray(list)) {\n\t\t\tthis.ensureCapacity(this._size + list.length);\n\t\t\tthis._data.subarray(this._size, this._size + list.length).set(list);\n\t\t\tthis._size += list.length;\n\t\t} else if (list instanceof IntegerList) {\n\t\t\tthis.ensureCapacity(this._size + list._size);\n\t\t\tthis._data.subarray(this._size, this._size + list.size).set(list._data);\n\t\t\tthis._size += list._size;\n\t\t} else {\n\t\t\t// list is JavaCollection<number>\n\t\t\tthis.ensureCapacity(this._size + list.size);\n\t\t\tlet current: number = 0;\n\t\t\tfor (let xi of list) {\n\t\t\t\tthis._data[this._size + current] = xi;\n\t\t\t\tcurrent++;\n\t\t\t}\n\n\t\t\tthis._size += list.size;\n\t\t}\n\t}\n\n\tpublic get(index: number): number {\n\t\tif (index < 0 || index >= this._size) {\n\t\t\tthrow RangeError();\n\t\t}\n\n\t\treturn this._data[index];\n\t}\n\n\tpublic contains(value: number): boolean {\n\t\tfor (let i = 0; i < this._size; i++) {\n\t\t\tif (this._data[i] === value) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tpublic set(index: number, value: number): number {\n\t\tif (index < 0 || index >= this._size) {\n\t\t\tthrow RangeError();\n\t\t}\n\n\t\tlet previous: number = this._data[index];\n\t\tthis._data[index] = value;\n\t\treturn previous;\n\t}\n\n\tpublic removeAt(index: number): number {\n\t\tlet value: number = this.get(index);\n\t\tthis._data.copyWithin(index, index + 1, this._size);\n\t\tthis._data[this._size - 1] = 0;\n\t\tthis._size--;\n\t\treturn value;\n\t}\n\n\tpublic removeRange(fromIndex: number, toIndex: number): void {\n\t\tif (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {\n\t\t\tthrow RangeError();\n\t\t}\n\n\t\tif (fromIndex > toIndex) {\n\t\t\tthrow RangeError();\n\t\t}\n\n\t\tthis._data.copyWithin(toIndex, fromIndex, this._size);\n\t\tthis._data.fill(0, this._size - (toIndex - fromIndex), this._size);\n\t\tthis._size -= (toIndex - fromIndex);\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this._size === 0;\n\t}\n\n\tget size(): number {\n\t\treturn this._size;\n\t}\n\n\tpublic trimToSize(): void {\n\t\tif (this._data.length === this._size) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._data = this._data.slice(0, this._size);\n\t}\n\n\tpublic clear(): void {\n\t\tthis._data.fill(0, 0, this._size);\n\t\tthis._size = 0;\n\t}\n\n\tpublic toArray(): number[] {\n\t\tif (this._size === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn Array.from(this._data.subarray(0, this._size));\n\t}\n\n\tpublic sort(): void {\n\t\tthis._data.subarray(0, this._size).sort();\n\t}\n\n\t/**\n\t * Compares the specified object with this list for equality.  Returns\n\t * `true` if and only if the specified object is also an {@link IntegerList},\n\t * both lists have the same size, and all corresponding pairs of elements in\n\t * the two lists are equal.  In other words, two lists are defined to be\n\t * equal if they contain the same elements in the same order.\n\t *\n\t * This implementation first checks if the specified object is this\n\t * list. If so, it returns `true`; if not, it checks if the\n\t * specified object is an {@link IntegerList}. If not, it returns `false`;\n\t * if so, it checks the size of both lists. If the lists are not the same size,\n\t * it returns `false`; otherwise it iterates over both lists, comparing\n\t * corresponding pairs of elements.  If any comparison returns `false`,\n\t * this method returns `false`.\n\t *\n\t * @param o the object to be compared for equality with this list\n\t * @returns `true` if the specified object is equal to this list\n\t */\n\t@Override\n\tpublic equals(o: any): boolean {\n\t\tif (o === this) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!(o instanceof IntegerList)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this._size !== o._size) {\n\t\t\treturn false;\n\t\t}\n\n\t\tfor (let i = 0; i < this._size; i++) {\n\t\t\tif (this._data[i] !== o._data[i]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Returns the hash code value for this list.\n\t *\n\t * This implementation uses exactly the code that is used to define the\n\t * list hash function in the documentation for the {@link List#hashCode}\n\t * method.\n\t *\n\t * @returns the hash code value for this list\n\t */\n\t@Override\n\tpublic hashCode(): number {\n\t\tlet hashCode: number = 1;\n\t\tfor (let i = 0; i < this._size; i++) {\n\t\t\thashCode = 31 * hashCode + this._data[i];\n\t\t}\n\n\t\treturn hashCode;\n\t}\n\n\t/**\n\t * Returns a string representation of this list.\n\t */\n\t@Override\n\tpublic toString(): string {\n\t\treturn this._data.toString();\n\t}\n\n\tpublic binarySearch(key: number, fromIndex?: number, toIndex?: number): number {\n\t\tif (fromIndex === undefined) {\n\t\t\tfromIndex = 0;\n\t\t}\n\n\t\tif (toIndex === undefined) {\n\t\t\ttoIndex = this._size;\n\t\t}\n\n\t\tif (fromIndex < 0 || toIndex < 0 || fromIndex > this._size || toIndex > this._size) {\n\t\t\tthrow new RangeError();\n\t\t}\n\n\t\tif (fromIndex > toIndex) {\n\t\t\tthrow new RangeError();\n\t\t}\n\n\t\treturn Arrays.binarySearch(this._data, key, fromIndex, toIndex);\n\t}\n\n\tprivate ensureCapacity(capacity: number): void {\n\t\tif (capacity < 0 || capacity > MAX_ARRAY_SIZE) {\n\t\t\tthrow new RangeError();\n\t\t}\n\n\t\tlet newLength: number;\n\t\tif (this._data.length === 0) {\n\t\t\tnewLength = INITIAL_SIZE;\n\t\t} else {\n\t\t\tnewLength = this._data.length;\n\t\t}\n\n\t\twhile (newLength < capacity) {\n\t\t\tnewLength = newLength * 2;\n\t\t\tif (newLength < 0 || newLength > MAX_ARRAY_SIZE) {\n\t\t\t\tnewLength = MAX_ARRAY_SIZE;\n\t\t\t}\n\t\t}\n\n\t\tlet tmp = new Int32Array(newLength);\n\t\ttmp.set(this._data);\n\t\tthis._data = tmp;\n\t}\n\n\t/** Convert the list to a UTF-16 encoded char array. If all values are less\n\t *  than the 0xFFFF 16-bit code point limit then this is just a char array\n\t *  of 16-bit char as usual. For values in the supplementary range, encode\n\t * them as two UTF-16 code units.\n\t */\n\tpublic toCharArray(): Uint16Array {\n\t\t// Optimize for the common case (all data values are < 0xFFFF) to avoid an extra scan\n\t\tlet resultArray: Uint16Array = new Uint16Array(this._size);\n\t\tlet resultIdx = 0;\n\t\tlet calculatedPreciseResultSize = false;\n\t\tfor (let i = 0; i < this._size; i++) {\n\t\t\tlet codePoint = this._data[i];\n\t\t\tif (codePoint >= 0 && codePoint < 0x10000) {\n\t\t\t\tresultArray[resultIdx] = codePoint;\n\t\t\t\tresultIdx++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Calculate the precise result size if we encounter a code point > 0xFFFF\n\t\t\tif (!calculatedPreciseResultSize) {\n\t\t\t\tlet newResultArray = new Uint16Array(this.charArraySize());\n\t\t\t\tnewResultArray.set(resultArray, 0);\n\t\t\t\tresultArray = newResultArray;\n\t\t\t\tcalculatedPreciseResultSize = true;\n\t\t\t}\n\n\t\t\t// This will throw RangeError if the code point is not a valid Unicode code point\n\t\t\tlet pair = String.fromCodePoint(codePoint);\n\t\t\tresultArray[resultIdx] = pair.charCodeAt(0);\n\t\t\tresultArray[resultIdx + 1] = pair.charCodeAt(1);\n\t\t\tresultIdx += 2;\n\t\t}\n\t\treturn resultArray;\n\t}\n\n\tprivate charArraySize(): number {\n\t\tlet result = 0;\n\t\tfor (let i = 0; i < this._size; i++) {\n\t\t\tresult += this._data[i] >= 0x10000 ? 2 : 1;\n\t\t}\n\t\treturn result;\n\t}\n}\n"]}