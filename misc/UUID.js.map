{"version":3,"sources":["misc/UUID.js","../src/misc/UUID.ts"],"names":["Object","defineProperty","exports","value","MurmurHash_1","require","UUID","mostSigBits","moreSigBits","lessSigBits","leastSigBits","data","Uint32Array","MurmurHash","hashCode","obj","toString","substr","test","Error","segments","split","parseInt"],"mappings":"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","file":"UUID.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MurmurHash_1 = require(\"./MurmurHash\");\nclass UUID {\n    constructor(mostSigBits, moreSigBits, lessSigBits, leastSigBits) {\n        this.data = new Uint32Array(4);\n        this.data[0] = mostSigBits;\n        this.data[1] = moreSigBits;\n        this.data[2] = lessSigBits;\n        this.data[3] = leastSigBits;\n    }\n    static fromString(data) {\n        if (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {\n            throw new Error(\"Incorrectly formatted UUID\");\n        }\n        let segments = data.split(\"-\");\n        let mostSigBits = parseInt(segments[0], 16);\n        let moreSigBits = ((parseInt(segments[1], 16) << 16) >>> 0) + parseInt(segments[2], 16);\n        let lessSigBits = ((parseInt(segments[3], 16) << 16) >>> 0) + parseInt(segments[4].substr(0, 4), 16);\n        let leastSigBits = parseInt(segments[4].substr(-8), 16);\n        return new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);\n    }\n    hashCode() {\n        return MurmurHash_1.MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);\n    }\n    equals(obj) {\n        if (obj === this) {\n            return true;\n        }\n        else if (!(obj instanceof UUID)) {\n            return false;\n        }\n        return this.data[0] === obj.data[0]\n            && this.data[1] === obj.data[1]\n            && this.data[2] === obj.data[2]\n            && this.data[3] === obj.data[3];\n    }\n    toString() {\n        return (\"00000000\" + this.data[0].toString(16)).substr(-8)\n            + \"-\" + (\"0000\" + (this.data[1] >>> 16).toString(16)).substr(-4)\n            + \"-\" + (\"0000\" + this.data[1].toString(16)).substr(-4)\n            + \"-\" + (\"0000\" + (this.data[2] >>> 16).toString(16)).substr(-4)\n            + \"-\" + (\"0000\" + this.data[2].toString(16)).substr(-4)\n            + (\"00000000\" + this.data[3].toString(16)).substr(-8);\n    }\n}\nexports.UUID = UUID;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\nimport { Equatable } from \"./Stubs\";\nimport { MurmurHash } from \"./MurmurHash\";\n\nexport class UUID implements Equatable {\n\tprivate readonly data: Uint32Array;\n\n\tconstructor(mostSigBits: number, moreSigBits: number, lessSigBits: number, leastSigBits: number) {\n\t\tthis.data = new Uint32Array(4);\n\t\tthis.data[0] = mostSigBits;\n\t\tthis.data[1] = moreSigBits;\n\t\tthis.data[2] = lessSigBits;\n\t\tthis.data[3] = leastSigBits;\n\t}\n\n\tpublic static fromString(data: string): UUID {\n\t\tif (!/^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/.test(data)) {\n\t\t\tthrow new Error(\"Incorrectly formatted UUID\");\n\t\t}\n\n\t\tlet segments = data.split(\"-\");\n\t\tlet mostSigBits = parseInt(segments[0], 16);\n\t\tlet moreSigBits = ((parseInt(segments[1], 16) << 16) >>> 0) + parseInt(segments[2], 16);\n\t\tlet lessSigBits = ((parseInt(segments[3], 16) << 16) >>> 0) + parseInt(segments[4].substr(0, 4), 16);\n\t\tlet leastSigBits = parseInt(segments[4].substr(-8), 16);\n\t\treturn new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);\n\t}\n\n\tpublic hashCode(): number {\n\t\treturn MurmurHash.hashCode([this.data[0], this.data[1], this.data[2], this.data[3]]);\n\t}\n\n\tpublic equals(obj: any): boolean {\n\t\tif (obj === this) {\n\t\t\treturn true;\n\t\t} else if (!(obj instanceof UUID)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.data[0] === obj.data[0]\n\t\t\t&& this.data[1] === obj.data[1]\n\t\t\t&& this.data[2] === obj.data[2]\n\t\t\t&& this.data[3] === obj.data[3];\n\t}\n\n\tpublic toString(): string {\n\t\treturn (\"00000000\" + this.data[0].toString(16)).substr(-8)\n\t\t\t+ \"-\" + (\"0000\" + (this.data[1] >>> 16).toString(16)).substr(-4)\n\t\t\t+ \"-\" + (\"0000\" + this.data[1].toString(16)).substr(-4)\n\t\t\t+ \"-\" + (\"0000\" + (this.data[2] >>> 16).toString(16)).substr(-4)\n\t\t\t+ \"-\" + (\"0000\" + this.data[2].toString(16)).substr(-4)\n\t\t\t+ (\"00000000\" + this.data[3].toString(16)).substr(-8);\n\t}\n}\n"]}