{"version":3,"sources":["misc/IntervalSet.js","../src/misc/IntervalSet.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","ArrayEqualityComparator_1","require","IntegerList_1","Interval_1","Lexer_1","MurmurHash_1","Decorators_1","Token_1","IntervalSet","intervals","readonly","_intervals","slice","Error","a","b","addRange","Interval","of","addition","equals","adjacent","disjoint","bigger","union","next","splice","startsBeforeDisjoint","push","set","other","n","I","add","toArray","minElement","maxElement","complement","vocabulary","isNil","EMPTY_SET","vocabularyIS","addAll","subtract","o","myIntervals","theirIntervals","intersection","mySize","theirSize","j","mine","theirs","properlyContains","startsAfterNonDisjoint","el","l","m","hash","MurmurHash","initialize","update","finish","ArrayEqualityComparator","INSTANCE","elemAreChar","buf","size","first","Token","EOF","String","fromCodePoint","elementName","EPSILON","getDisplayName","values","IntegerList","v","s","Set","Array","oldb","RangeError","last","numIntervals","firstInterval","sets","left","right","result","resultI","rightI","resultInterval","rightInterval","beforeCurrent","afterCurrent","_COMPLETE_CHAR_SET","undefined","Lexer","MIN_CHAR_VALUE","MAX_CHAR_VALUE","setReadonly","_EMPTY_SET","Override","prototype","NotNull"],"mappings":"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","file":"IntervalSet.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:40.8683480-07:00\nconst ArrayEqualityComparator_1 = require(\"./ArrayEqualityComparator\");\nconst IntegerList_1 = require(\"./IntegerList\");\nconst Interval_1 = require(\"./Interval\");\nconst Lexer_1 = require(\"../Lexer\");\nconst MurmurHash_1 = require(\"./MurmurHash\");\nconst Decorators_1 = require(\"../Decorators\");\nconst Token_1 = require(\"../Token\");\n/**\n * This class implements the {@link IntSet} backed by a sorted array of\n * non-overlapping intervals. It is particularly efficient for representing\n * large collections of numbers, where the majority of elements appear as part\n * of a sequential range of numbers that are all part of the set. For example,\n * the set { 1, 2, 3, 4, 7, 8 } may be represented as { [1, 4], [7, 8] }.\n *\n * This class is able to represent sets containing any combination of values in\n * the range {@link Integer#MIN_VALUE} to {@link Integer#MAX_VALUE}\n * (inclusive).\n */\nclass IntervalSet {\n    constructor(intervals) {\n        this.readonly = false;\n        if (intervals != null) {\n            this._intervals = intervals.slice(0);\n        }\n        else {\n            this._intervals = [];\n        }\n    }\n    static get COMPLETE_CHAR_SET() {\n        if (IntervalSet._COMPLETE_CHAR_SET === undefined) {\n            IntervalSet._COMPLETE_CHAR_SET = IntervalSet.of(Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE);\n            IntervalSet._COMPLETE_CHAR_SET.setReadonly(true);\n        }\n        return IntervalSet._COMPLETE_CHAR_SET;\n    }\n    static get EMPTY_SET() {\n        if (IntervalSet._EMPTY_SET == null) {\n            IntervalSet._EMPTY_SET = new IntervalSet();\n            IntervalSet._EMPTY_SET.setReadonly(true);\n        }\n        return IntervalSet._EMPTY_SET;\n    }\n    /**\n     * Create a set with all ints within range [a..b] (inclusive). If b is omitted, the set contains the single element\n     * a.\n     */\n    static of(a, b = a) {\n        let s = new IntervalSet();\n        s.add(a, b);\n        return s;\n    }\n    clear() {\n        if (this.readonly) {\n            throw new Error(\"can't alter readonly IntervalSet\");\n        }\n        this._intervals.length = 0;\n    }\n    /** Add interval; i.e., add all integers from a to b to set.\n     *  If b&lt;a, do nothing.\n     *  Keep list in sorted order (by left range value).\n     *  If overlap, combine ranges.  For example,\n     *  If this is {1..5, 10..20}, adding 6..7 yields\n     *  {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.\n     */\n    add(a, b = a) {\n        this.addRange(Interval_1.Interval.of(a, b));\n    }\n    // copy on write so we can cache a..a intervals and sets of that\n    addRange(addition) {\n        if (this.readonly) {\n            throw new Error(\"can't alter readonly IntervalSet\");\n        }\n        //System.out.println(\"add \"+addition+\" to \"+intervals.toString());\n        if (addition.b < addition.a) {\n            return;\n        }\n        // find position in list\n        // Use iterators as we modify list in place\n        for (let i = 0; i < this._intervals.length; i++) {\n            let r = this._intervals[i];\n            if (addition.equals(r)) {\n                return;\n            }\n            if (addition.adjacent(r) || !addition.disjoint(r)) {\n                // next to each other, make a single larger interval\n                let bigger = addition.union(r);\n                this._intervals[i] = bigger;\n                // make sure we didn't just create an interval that\n                // should be merged with next interval in list\n                while (i < this._intervals.length - 1) {\n                    i++;\n                    let next = this._intervals[i];\n                    if (!bigger.adjacent(next) && bigger.disjoint(next)) {\n                        break;\n                    }\n                    // if we bump up against or overlap next, merge\n                    // remove this one\n                    this._intervals.splice(i, 1);\n                    i--;\n                    // move backwards to what we just set\n                    this._intervals[i] = bigger.union(next);\n                    // set to 3 merged ones\n                }\n                // first call to next after previous duplicates the result\n                return;\n            }\n            if (addition.startsBeforeDisjoint(r)) {\n                // insert before r\n                this._intervals.splice(i, 0, addition);\n                return;\n            }\n            // if disjoint and after r, a future iteration will handle it\n        }\n        // ok, must be after last interval (and disjoint from last interval)\n        // just add it\n        this._intervals.push(addition);\n    }\n    /** combine all sets in the array returned the or'd value */\n    static or(sets) {\n        let r = new IntervalSet();\n        for (let s of sets) {\n            r.addAll(s);\n        }\n        return r;\n    }\n    addAll(set) {\n        if (set == null) {\n            return this;\n        }\n        if (set instanceof IntervalSet) {\n            let other = set;\n            // walk set and add each interval\n            let n = other._intervals.length;\n            for (let i = 0; i < n; i++) {\n                let I = other._intervals[i];\n                this.add(I.a, I.b);\n            }\n        }\n        else {\n            for (let value of set.toArray()) {\n                this.add(value);\n            }\n        }\n        return this;\n    }\n    complementRange(minElement, maxElement) {\n        return this.complement(IntervalSet.of(minElement, maxElement));\n    }\n    /** {@inheritDoc} */\n    complement(vocabulary) {\n        if (vocabulary.isNil) {\n            // nothing in common with null set\n            return IntervalSet.EMPTY_SET;\n        }\n        let vocabularyIS;\n        if (vocabulary instanceof IntervalSet) {\n            vocabularyIS = vocabulary;\n        }\n        else {\n            vocabularyIS = new IntervalSet();\n            vocabularyIS.addAll(vocabulary);\n        }\n        return vocabularyIS.subtract(this);\n    }\n    subtract(a) {\n        if (a == null || a.isNil) {\n            return new IntervalSet(this._intervals);\n        }\n        if (a instanceof IntervalSet) {\n            return IntervalSet.subtract(this, a);\n        }\n        let other = new IntervalSet();\n        other.addAll(a);\n        return IntervalSet.subtract(this, other);\n    }\n    /**\n     * Compute the set difference between two interval sets. The specific\n     * operation is `left - right`.\n     */\n    static subtract(left, right) {\n        if (left.isNil) {\n            return new IntervalSet();\n        }\n        let result = new IntervalSet(left._intervals);\n        if (right.isNil) {\n            // right set has no elements; just return the copy of the current set\n            return result;\n        }\n        let resultI = 0;\n        let rightI = 0;\n        while (resultI < result._intervals.length && rightI < right._intervals.length) {\n            let resultInterval = result._intervals[resultI];\n            let rightInterval = right._intervals[rightI];\n            // operation: (resultInterval - rightInterval) and update indexes\n            if (rightInterval.b < resultInterval.a) {\n                rightI++;\n                continue;\n            }\n            if (rightInterval.a > resultInterval.b) {\n                resultI++;\n                continue;\n            }\n            let beforeCurrent;\n            let afterCurrent;\n            if (rightInterval.a > resultInterval.a) {\n                beforeCurrent = new Interval_1.Interval(resultInterval.a, rightInterval.a - 1);\n            }\n            if (rightInterval.b < resultInterval.b) {\n                afterCurrent = new Interval_1.Interval(rightInterval.b + 1, resultInterval.b);\n            }\n            if (beforeCurrent) {\n                if (afterCurrent) {\n                    // split the current interval into two\n                    result._intervals[resultI] = beforeCurrent;\n                    result._intervals.splice(resultI + 1, 0, afterCurrent);\n                    resultI++;\n                    rightI++;\n                    continue;\n                }\n                else {\n                    // replace the current interval\n                    result._intervals[resultI] = beforeCurrent;\n                    resultI++;\n                    continue;\n                }\n            }\n            else {\n                if (afterCurrent) {\n                    // replace the current interval\n                    result._intervals[resultI] = afterCurrent;\n                    rightI++;\n                    continue;\n                }\n                else {\n                    // remove the current interval (thus no need to increment resultI)\n                    result._intervals.splice(resultI, 1);\n                    continue;\n                }\n            }\n        }\n        // If rightI reached right.intervals.size, no more intervals to subtract from result.\n        // If resultI reached result.intervals.size, we would be subtracting from an empty set.\n        // Either way, we are done.\n        return result;\n    }\n    or(a) {\n        let o = new IntervalSet();\n        o.addAll(this);\n        o.addAll(a);\n        return o;\n    }\n    /** {@inheritDoc} */\n    and(other) {\n        if (other.isNil) { //|| !(other instanceof IntervalSet) ) {\n            // nothing in common with null set\n            return new IntervalSet();\n        }\n        let myIntervals = this._intervals;\n        let theirIntervals = other._intervals;\n        let intersection;\n        let mySize = myIntervals.length;\n        let theirSize = theirIntervals.length;\n        let i = 0;\n        let j = 0;\n        // iterate down both interval lists looking for nondisjoint intervals\n        while (i < mySize && j < theirSize) {\n            let mine = myIntervals[i];\n            let theirs = theirIntervals[j];\n            //System.out.println(\"mine=\"+mine+\" and theirs=\"+theirs);\n            if (mine.startsBeforeDisjoint(theirs)) {\n                // move this iterator looking for interval that might overlap\n                i++;\n            }\n            else if (theirs.startsBeforeDisjoint(mine)) {\n                // move other iterator looking for interval that might overlap\n                j++;\n            }\n            else if (mine.properlyContains(theirs)) {\n                // overlap, add intersection, get next theirs\n                if (!intersection) {\n                    intersection = new IntervalSet();\n                }\n                intersection.addRange(mine.intersection(theirs));\n                j++;\n            }\n            else if (theirs.properlyContains(mine)) {\n                // overlap, add intersection, get next mine\n                if (!intersection) {\n                    intersection = new IntervalSet();\n                }\n                intersection.addRange(mine.intersection(theirs));\n                i++;\n            }\n            else if (!mine.disjoint(theirs)) {\n                // overlap, add intersection\n                if (!intersection) {\n                    intersection = new IntervalSet();\n                }\n                intersection.addRange(mine.intersection(theirs));\n                // Move the iterator of lower range [a..b], but not\n                // the upper range as it may contain elements that will collide\n                // with the next iterator. So, if mine=[0..115] and\n                // theirs=[115..200], then intersection is 115 and move mine\n                // but not theirs as theirs may collide with the next range\n                // in thisIter.\n                // move both iterators to next ranges\n                if (mine.startsAfterNonDisjoint(theirs)) {\n                    j++;\n                }\n                else if (theirs.startsAfterNonDisjoint(mine)) {\n                    i++;\n                }\n            }\n        }\n        if (!intersection) {\n            return new IntervalSet();\n        }\n        return intersection;\n    }\n    /** {@inheritDoc} */\n    contains(el) {\n        let n = this._intervals.length;\n        let l = 0;\n        let r = n - 1;\n        // Binary search for the element in the (sorted, disjoint) array of intervals.\n        while (l <= r) {\n            let m = (l + r) >> 1;\n            let I = this._intervals[m];\n            let a = I.a;\n            let b = I.b;\n            if (b < el) {\n                l = m + 1;\n            }\n            else if (a > el) {\n                r = m - 1;\n            }\n            else {\n                // el >= a && el <= b\n                return true;\n            }\n        }\n        return false;\n    }\n    /** {@inheritDoc} */\n    get isNil() {\n        return this._intervals == null || this._intervals.length === 0;\n    }\n    /**\n     * Returns the maximum value contained in the set if not isNil.\n     *\n     * @return the maximum value contained in the set.\n     * @throws RangeError if set is empty\n     */\n    get maxElement() {\n        if (this.isNil) {\n            throw new RangeError(\"set is empty\");\n        }\n        let last = this._intervals[this._intervals.length - 1];\n        return last.b;\n    }\n    /**\n     * Returns the minimum value contained in the set if not isNil.\n     *\n     * @return the minimum value contained in the set.\n     * @throws RangeError if set is empty\n     */\n    get minElement() {\n        if (this.isNil) {\n            throw new RangeError(\"set is empty\");\n        }\n        return this._intervals[0].a;\n    }\n    /** Return a list of Interval objects. */\n    get intervals() {\n        return this._intervals;\n    }\n    hashCode() {\n        let hash = MurmurHash_1.MurmurHash.initialize();\n        for (let I of this._intervals) {\n            hash = MurmurHash_1.MurmurHash.update(hash, I.a);\n            hash = MurmurHash_1.MurmurHash.update(hash, I.b);\n        }\n        hash = MurmurHash_1.MurmurHash.finish(hash, this._intervals.length * 2);\n        return hash;\n    }\n    /** Are two IntervalSets equal?  Because all intervals are sorted\n     *  and disjoint, equals is a simple linear walk over both lists\n     *  to make sure they are the same.  Interval.equals() is used\n     *  by the List.equals() method to check the ranges.\n     */\n    equals(o) {\n        if (o == null || !(o instanceof IntervalSet)) {\n            return false;\n        }\n        return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);\n    }\n    toString(elemAreChar = false) {\n        let buf = \"\";\n        if (this._intervals == null || this._intervals.length === 0) {\n            return \"{}\";\n        }\n        if (this.size > 1) {\n            buf += \"{\";\n        }\n        let first = true;\n        for (let I of this._intervals) {\n            if (first) {\n                first = false;\n            }\n            else {\n                buf += \", \";\n            }\n            let a = I.a;\n            let b = I.b;\n            if (a === b) {\n                if (a === Token_1.Token.EOF) {\n                    buf += \"<EOF>\";\n                }\n                else if (elemAreChar) {\n                    buf += \"'\" + String.fromCodePoint(a) + \"'\";\n                }\n                else {\n                    buf += a;\n                }\n            }\n            else {\n                if (elemAreChar) {\n                    buf += \"'\" + String.fromCodePoint(a) + \"'..'\" + String.fromCodePoint(b) + \"'\";\n                }\n                else {\n                    buf += a + \"..\" + b;\n                }\n            }\n        }\n        if (this.size > 1) {\n            buf += \"}\";\n        }\n        return buf;\n    }\n    toStringVocabulary(vocabulary) {\n        if (this._intervals == null || this._intervals.length === 0) {\n            return \"{}\";\n        }\n        let buf = \"\";\n        if (this.size > 1) {\n            buf += \"{\";\n        }\n        let first = true;\n        for (let I of this._intervals) {\n            if (first) {\n                first = false;\n            }\n            else {\n                buf += \", \";\n            }\n            let a = I.a;\n            let b = I.b;\n            if (a === b) {\n                buf += this.elementName(vocabulary, a);\n            }\n            else {\n                for (let i = a; i <= b; i++) {\n                    if (i > a) {\n                        buf += \", \";\n                    }\n                    buf += this.elementName(vocabulary, i);\n                }\n            }\n        }\n        if (this.size > 1) {\n            buf += \"}\";\n        }\n        return buf;\n    }\n    elementName(vocabulary, a) {\n        if (a === Token_1.Token.EOF) {\n            return \"<EOF>\";\n        }\n        else if (a === Token_1.Token.EPSILON) {\n            return \"<EPSILON>\";\n        }\n        else {\n            return vocabulary.getDisplayName(a);\n        }\n    }\n    get size() {\n        let n = 0;\n        let numIntervals = this._intervals.length;\n        if (numIntervals === 1) {\n            let firstInterval = this._intervals[0];\n            return firstInterval.b - firstInterval.a + 1;\n        }\n        for (let i = 0; i < numIntervals; i++) {\n            let I = this._intervals[i];\n            n += (I.b - I.a + 1);\n        }\n        return n;\n    }\n    toIntegerList() {\n        let values = new IntegerList_1.IntegerList(this.size);\n        let n = this._intervals.length;\n        for (let i = 0; i < n; i++) {\n            let I = this._intervals[i];\n            let a = I.a;\n            let b = I.b;\n            for (let v = a; v <= b; v++) {\n                values.add(v);\n            }\n        }\n        return values;\n    }\n    toSet() {\n        let s = new Set();\n        for (let I of this._intervals) {\n            let a = I.a;\n            let b = I.b;\n            for (let v = a; v <= b; v++) {\n                s.add(v);\n            }\n        }\n        return s;\n    }\n    toArray() {\n        let values = new Array();\n        let n = this._intervals.length;\n        for (let i = 0; i < n; i++) {\n            let I = this._intervals[i];\n            let a = I.a;\n            let b = I.b;\n            for (let v = a; v <= b; v++) {\n                values.push(v);\n            }\n        }\n        return values;\n    }\n    remove(el) {\n        if (this.readonly) {\n            throw new Error(\"can't alter readonly IntervalSet\");\n        }\n        let n = this._intervals.length;\n        for (let i = 0; i < n; i++) {\n            let I = this._intervals[i];\n            let a = I.a;\n            let b = I.b;\n            if (el < a) {\n                break; // list is sorted and el is before this interval; not here\n            }\n            // if whole interval x..x, rm\n            if (el === a && el === b) {\n                this._intervals.splice(i, 1);\n                break;\n            }\n            // if on left edge x..b, adjust left\n            if (el === a) {\n                this._intervals[i] = Interval_1.Interval.of(I.a + 1, I.b);\n                break;\n            }\n            // if on right edge a..x, adjust right\n            if (el === b) {\n                this._intervals[i] = Interval_1.Interval.of(I.a, I.b - 1);\n                break;\n            }\n            // if in middle a..x..b, split interval\n            if (el > a && el < b) { // found in this interval\n                let oldb = I.b;\n                this._intervals[i] = Interval_1.Interval.of(I.a, el - 1); // [a..x-1]\n                this.add(el + 1, oldb); // add [x+1..b]\n            }\n        }\n    }\n    get isReadonly() {\n        return this.readonly;\n    }\n    setReadonly(readonly) {\n        if (this.readonly && !readonly) {\n            throw new Error(\"can't alter readonly IntervalSet\");\n        }\n        this.readonly = readonly;\n    }\n}\n__decorate([\n    Decorators_1.Override\n], IntervalSet.prototype, \"addAll\", null);\n__decorate([\n    Decorators_1.Override\n], IntervalSet.prototype, \"complement\", null);\n__decorate([\n    Decorators_1.Override\n], IntervalSet.prototype, \"subtract\", null);\n__decorate([\n    Decorators_1.Override\n], IntervalSet.prototype, \"or\", null);\n__decorate([\n    Decorators_1.Override\n], IntervalSet.prototype, \"and\", null);\n__decorate([\n    Decorators_1.Override\n], IntervalSet.prototype, \"contains\", null);\n__decorate([\n    Decorators_1.Override\n], IntervalSet.prototype, \"isNil\", null);\n__decorate([\n    Decorators_1.Override\n], IntervalSet.prototype, \"hashCode\", null);\n__decorate([\n    Decorators_1.Override\n], IntervalSet.prototype, \"equals\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], IntervalSet.prototype, \"toStringVocabulary\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], IntervalSet.prototype, \"elementName\", null);\n__decorate([\n    Decorators_1.Override\n], IntervalSet.prototype, \"size\", null);\n__decorate([\n    Decorators_1.Override\n], IntervalSet.prototype, \"remove\", null);\n__decorate([\n    Decorators_1.NotNull\n], IntervalSet, \"of\", null);\n__decorate([\n    Decorators_1.NotNull\n], IntervalSet, \"subtract\", null);\nexports.IntervalSet = IntervalSet;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:40.8683480-07:00\n\nimport { ArrayEqualityComparator } from \"./ArrayEqualityComparator\";\nimport { IntegerList } from \"./IntegerList\";\nimport { Interval } from \"./Interval\";\nimport { IntSet } from \"./IntSet\";\nimport { Lexer } from \"../Lexer\";\nimport { MurmurHash } from \"./MurmurHash\";\nimport { Override, NotNull } from \"../Decorators\";\nimport { Token } from \"../Token\";\nimport { Vocabulary } from \"../Vocabulary\";\n\n/**\n * This class implements the {@link IntSet} backed by a sorted array of\n * non-overlapping intervals. It is particularly efficient for representing\n * large collections of numbers, where the majority of elements appear as part\n * of a sequential range of numbers that are all part of the set. For example,\n * the set { 1, 2, 3, 4, 7, 8 } may be represented as { [1, 4], [7, 8] }.\n *\n * This class is able to represent sets containing any combination of values in\n * the range {@link Integer#MIN_VALUE} to {@link Integer#MAX_VALUE}\n * (inclusive).\n */\nexport class IntervalSet implements IntSet {\n\tprivate static _COMPLETE_CHAR_SET: IntervalSet;\n\tstatic get COMPLETE_CHAR_SET(): IntervalSet {\n\t\tif (IntervalSet._COMPLETE_CHAR_SET === undefined) {\n\t\t\tIntervalSet._COMPLETE_CHAR_SET = IntervalSet.of(Lexer.MIN_CHAR_VALUE, Lexer.MAX_CHAR_VALUE);\n\t\t\tIntervalSet._COMPLETE_CHAR_SET.setReadonly(true);\n\t\t}\n\n\t\treturn IntervalSet._COMPLETE_CHAR_SET;\n\t}\n\n\tprivate static _EMPTY_SET: IntervalSet;\n\tstatic get EMPTY_SET(): IntervalSet {\n\t\tif (IntervalSet._EMPTY_SET == null) {\n\t\t\tIntervalSet._EMPTY_SET = new IntervalSet();\n\t\t\tIntervalSet._EMPTY_SET.setReadonly(true);\n\t\t}\n\n\t\treturn IntervalSet._EMPTY_SET;\n\t}\n\n\t/** The list of sorted, disjoint intervals. */\n\tprivate _intervals: Interval[];\n\n\tprivate readonly: boolean = false;\n\n\tconstructor(intervals?: Interval[]) {\n\t\tif (intervals != null) {\n\t\t\tthis._intervals = intervals.slice(0);\n\t\t} else {\n\t\t\tthis._intervals = [];\n\t\t}\n\t}\n\n\t/**\n\t * Create a set with all ints within range [a..b] (inclusive). If b is omitted, the set contains the single element\n\t * a.\n\t */\n\t@NotNull\n\tpublic static of(a: number, b: number = a): IntervalSet {\n\t\tlet s: IntervalSet = new IntervalSet();\n\t\ts.add(a, b);\n\t\treturn s;\n\t}\n\n\tpublic clear(): void {\n\t\tif (this.readonly) {\n\t\t\tthrow new Error(\"can't alter readonly IntervalSet\");\n\t\t}\n\n\t\tthis._intervals.length = 0;\n\t}\n\n\t/** Add interval; i.e., add all integers from a to b to set.\n\t *  If b&lt;a, do nothing.\n\t *  Keep list in sorted order (by left range value).\n\t *  If overlap, combine ranges.  For example,\n\t *  If this is {1..5, 10..20}, adding 6..7 yields\n\t *  {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.\n\t */\n\tpublic add(a: number, b: number = a): void {\n\t\tthis.addRange(Interval.of(a, b));\n\t}\n\n\t// copy on write so we can cache a..a intervals and sets of that\n\tprotected addRange(addition: Interval): void {\n\t\tif (this.readonly) {\n\t\t\tthrow new Error(\"can't alter readonly IntervalSet\");\n\t\t}\n\n\t\t//System.out.println(\"add \"+addition+\" to \"+intervals.toString());\n\t\tif (addition.b < addition.a) {\n\t\t\treturn;\n\t\t}\n\n\t\t// find position in list\n\t\t// Use iterators as we modify list in place\n\t\tfor (let i: number = 0; i < this._intervals.length; i++) {\n\t\t\tlet r: Interval = this._intervals[i];\n\t\t\tif (addition.equals(r)) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (addition.adjacent(r) || !addition.disjoint(r)) {\n\t\t\t\t// next to each other, make a single larger interval\n\t\t\t\tlet bigger: Interval = addition.union(r);\n\t\t\t\tthis._intervals[i] = bigger;\n\t\t\t\t// make sure we didn't just create an interval that\n\t\t\t\t// should be merged with next interval in list\n\t\t\t\twhile (i < this._intervals.length - 1) {\n\t\t\t\t\ti++;\n\t\t\t\t\tlet next: Interval = this._intervals[i];\n\t\t\t\t\tif (!bigger.adjacent(next) && bigger.disjoint(next)) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\t// if we bump up against or overlap next, merge\n\t\t\t\t\t// remove this one\n\t\t\t\t\tthis._intervals.splice(i, 1);\n\t\t\t\t\ti--;\n\t\t\t\t\t// move backwards to what we just set\n\t\t\t\t\tthis._intervals[i] = bigger.union(next);\n\t\t\t\t\t// set to 3 merged ones\n\t\t\t\t}\n\n\t\t\t\t// first call to next after previous duplicates the result\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (addition.startsBeforeDisjoint(r)) {\n\t\t\t\t// insert before r\n\t\t\t\tthis._intervals.splice(i, 0, addition);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// if disjoint and after r, a future iteration will handle it\n\t\t}\n\n\t\t// ok, must be after last interval (and disjoint from last interval)\n\t\t// just add it\n\t\tthis._intervals.push(addition);\n\t}\n\n\t/** combine all sets in the array returned the or'd value */\n\tpublic static or(sets: IntervalSet[]): IntervalSet {\n\t\tlet r: IntervalSet = new IntervalSet();\n\t\tfor (let s of sets) {\n\t\t\tr.addAll(s);\n\t\t}\n\n\t\treturn r;\n\t}\n\n\t@Override\n\tpublic addAll(set: IntSet): IntervalSet {\n\t\tif (set == null) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (set instanceof IntervalSet) {\n\t\t\tlet other: IntervalSet = set;\n\t\t\t// walk set and add each interval\n\t\t\tlet n: number = other._intervals.length;\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\tlet I: Interval = other._intervals[i];\n\t\t\t\tthis.add(I.a, I.b);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor (let value of set.toArray()) {\n\t\t\t\tthis.add(value);\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tpublic complementRange(minElement: number, maxElement: number): IntervalSet {\n\t\treturn this.complement(IntervalSet.of(minElement, maxElement));\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic complement(vocabulary: IntSet): IntervalSet {\n\t\tif (vocabulary.isNil) {\n\t\t\t// nothing in common with null set\n\t\t\treturn IntervalSet.EMPTY_SET;\n\t\t}\n\n\t\tlet vocabularyIS: IntervalSet;\n\t\tif (vocabulary instanceof IntervalSet) {\n\t\t\tvocabularyIS = vocabulary;\n\t\t} else {\n\t\t\tvocabularyIS = new IntervalSet();\n\t\t\tvocabularyIS.addAll(vocabulary);\n\t\t}\n\n\t\treturn vocabularyIS.subtract(this);\n\t}\n\n\t@Override\n\tpublic subtract(a: IntSet): IntervalSet {\n\t\tif (a == null || a.isNil) {\n\t\t\treturn new IntervalSet(this._intervals);\n\t\t}\n\n\t\tif (a instanceof IntervalSet) {\n\t\t\treturn IntervalSet.subtract(this, a);\n\t\t}\n\n\t\tlet other: IntervalSet = new IntervalSet();\n\t\tother.addAll(a);\n\t\treturn IntervalSet.subtract(this, other);\n\t}\n\n\t/**\n\t * Compute the set difference between two interval sets. The specific\n\t * operation is `left - right`.\n\t */\n\t@NotNull\n\tpublic static subtract(left: IntervalSet, right: IntervalSet): IntervalSet {\n\t\tif (left.isNil) {\n\t\t\treturn new IntervalSet();\n\t\t}\n\n\t\tlet result: IntervalSet = new IntervalSet(left._intervals);\n\t\tif (right.isNil) {\n\t\t\t// right set has no elements; just return the copy of the current set\n\t\t\treturn result;\n\t\t}\n\n\t\tlet resultI: number = 0;\n\t\tlet rightI: number = 0;\n\t\twhile (resultI < result._intervals.length && rightI < right._intervals.length) {\n\t\t\tlet resultInterval: Interval = result._intervals[resultI];\n\t\t\tlet rightInterval: Interval = right._intervals[rightI];\n\n\t\t\t// operation: (resultInterval - rightInterval) and update indexes\n\n\t\t\tif (rightInterval.b < resultInterval.a) {\n\t\t\t\trightI++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (rightInterval.a > resultInterval.b) {\n\t\t\t\tresultI++;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet beforeCurrent: Interval | undefined;\n\t\t\tlet afterCurrent: Interval | undefined;\n\t\t\tif (rightInterval.a > resultInterval.a) {\n\t\t\t\tbeforeCurrent = new Interval(resultInterval.a, rightInterval.a - 1);\n\t\t\t}\n\n\t\t\tif (rightInterval.b < resultInterval.b) {\n\t\t\t\tafterCurrent = new Interval(rightInterval.b + 1, resultInterval.b);\n\t\t\t}\n\n\t\t\tif (beforeCurrent) {\n\t\t\t\tif (afterCurrent) {\n\t\t\t\t\t// split the current interval into two\n\t\t\t\t\tresult._intervals[resultI] = beforeCurrent;\n\t\t\t\t\tresult._intervals.splice(resultI + 1, 0, afterCurrent);\n\t\t\t\t\tresultI++;\n\t\t\t\t\trightI++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// replace the current interval\n\t\t\t\t\tresult._intervals[resultI] = beforeCurrent;\n\t\t\t\t\tresultI++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (afterCurrent) {\n\t\t\t\t\t// replace the current interval\n\t\t\t\t\tresult._intervals[resultI] = afterCurrent;\n\t\t\t\t\trightI++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// remove the current interval (thus no need to increment resultI)\n\t\t\t\t\tresult._intervals.splice(resultI, 1);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If rightI reached right.intervals.size, no more intervals to subtract from result.\n\t\t// If resultI reached result.intervals.size, we would be subtracting from an empty set.\n\t\t// Either way, we are done.\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic or(a: IntSet): IntervalSet {\n\t\tlet o: IntervalSet = new IntervalSet();\n\t\to.addAll(this);\n\t\to.addAll(a);\n\t\treturn o;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic and(other: IntSet): IntervalSet {\n\t\tif (other.isNil) { //|| !(other instanceof IntervalSet) ) {\n\t\t\t// nothing in common with null set\n\t\t\treturn new IntervalSet();\n\t\t}\n\n\t\tlet myIntervals: Interval[] = this._intervals;\n\t\tlet theirIntervals: Interval[] = (other as IntervalSet)._intervals;\n\t\tlet intersection: IntervalSet | undefined;\n\t\tlet mySize: number = myIntervals.length;\n\t\tlet theirSize: number = theirIntervals.length;\n\t\tlet i: number = 0;\n\t\tlet j: number = 0;\n\t\t// iterate down both interval lists looking for nondisjoint intervals\n\t\twhile (i < mySize && j < theirSize) {\n\t\t\tlet mine: Interval = myIntervals[i];\n\t\t\tlet theirs: Interval = theirIntervals[j];\n\t\t\t//System.out.println(\"mine=\"+mine+\" and theirs=\"+theirs);\n\t\t\tif (mine.startsBeforeDisjoint(theirs)) {\n\t\t\t\t// move this iterator looking for interval that might overlap\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (theirs.startsBeforeDisjoint(mine)) {\n\t\t\t\t// move other iterator looking for interval that might overlap\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if (mine.properlyContains(theirs)) {\n\t\t\t\t// overlap, add intersection, get next theirs\n\t\t\t\tif (!intersection) {\n\t\t\t\t\tintersection = new IntervalSet();\n\t\t\t\t}\n\n\t\t\t\tintersection.addRange(mine.intersection(theirs));\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if (theirs.properlyContains(mine)) {\n\t\t\t\t// overlap, add intersection, get next mine\n\t\t\t\tif (!intersection) {\n\t\t\t\t\tintersection = new IntervalSet();\n\t\t\t\t}\n\n\t\t\t\tintersection.addRange(mine.intersection(theirs));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if (!mine.disjoint(theirs)) {\n\t\t\t\t// overlap, add intersection\n\t\t\t\tif (!intersection) {\n\t\t\t\t\tintersection = new IntervalSet();\n\t\t\t\t}\n\n\t\t\t\tintersection.addRange(mine.intersection(theirs));\n\t\t\t\t// Move the iterator of lower range [a..b], but not\n\t\t\t\t// the upper range as it may contain elements that will collide\n\t\t\t\t// with the next iterator. So, if mine=[0..115] and\n\t\t\t\t// theirs=[115..200], then intersection is 115 and move mine\n\t\t\t\t// but not theirs as theirs may collide with the next range\n\t\t\t\t// in thisIter.\n\t\t\t\t// move both iterators to next ranges\n\t\t\t\tif (mine.startsAfterNonDisjoint(theirs)) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if (theirs.startsAfterNonDisjoint(mine)) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!intersection) {\n\t\t\treturn new IntervalSet();\n\t\t}\n\n\t\treturn intersection;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tpublic contains(el: number): boolean {\n\t\tlet n: number = this._intervals.length;\n\t\tlet l: number = 0;\n\t\tlet r: number = n - 1;\n\t\t// Binary search for the element in the (sorted, disjoint) array of intervals.\n\t\twhile (l <= r) {\n\t\t\tlet m: number = (l + r) >> 1;\n\t\t\tlet I: Interval = this._intervals[m];\n\t\t\tlet a: number = I.a;\n\t\t\tlet b: number = I.b;\n\t\t\tif (b < el) {\n\t\t\t\tl = m + 1;\n\t\t\t} else if (a > el) {\n\t\t\t\tr = m - 1;\n\t\t\t} else {\n\t\t\t\t// el >= a && el <= b\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t/** {@inheritDoc} */\n\t@Override\n\tget isNil(): boolean {\n\t\treturn this._intervals == null || this._intervals.length === 0;\n\t}\n\n\t/**\n\t * Returns the maximum value contained in the set if not isNil.\n\t *\n\t * @return the maximum value contained in the set.\n\t * @throws RangeError if set is empty\n\t */\n\tget maxElement(): number {\n\t\tif (this.isNil) {\n\t\t\tthrow new RangeError(\"set is empty\");\n\t\t}\n\n\t\tlet last: Interval = this._intervals[this._intervals.length - 1];\n\t\treturn last.b;\n\t}\n\n\t/**\n\t * Returns the minimum value contained in the set if not isNil.\n\t *\n\t * @return the minimum value contained in the set.\n\t * @throws RangeError if set is empty\n\t */\n\tget minElement(): number {\n\t\tif (this.isNil) {\n\t\t\tthrow new RangeError(\"set is empty\");\n\t\t}\n\n\t\treturn this._intervals[0].a;\n\t}\n\n\t/** Return a list of Interval objects. */\n\tget intervals(): Interval[] {\n\t\treturn this._intervals;\n\t}\n\n\t@Override\n\tpublic hashCode(): number {\n\t\tlet hash: number = MurmurHash.initialize();\n\t\tfor (let I of this._intervals) {\n\t\t\thash = MurmurHash.update(hash, I.a);\n\t\t\thash = MurmurHash.update(hash, I.b);\n\t\t}\n\n\t\thash = MurmurHash.finish(hash, this._intervals.length * 2);\n\t\treturn hash;\n\t}\n\n\t/** Are two IntervalSets equal?  Because all intervals are sorted\n\t *  and disjoint, equals is a simple linear walk over both lists\n\t *  to make sure they are the same.  Interval.equals() is used\n\t *  by the List.equals() method to check the ranges.\n\t */\n\t@Override\n\tpublic equals(o: any): boolean {\n\t\tif (o == null || !(o instanceof IntervalSet)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ArrayEqualityComparator.INSTANCE.equals(this._intervals, o._intervals);\n\t}\n\n\tpublic toString(elemAreChar: boolean = false): string {\n\t\tlet buf: string = \"\";\n\t\tif (this._intervals == null || this._intervals.length === 0) {\n\t\t\treturn \"{}\";\n\t\t}\n\n\t\tif (this.size > 1) {\n\t\t\tbuf += \"{\";\n\t\t}\n\n\t\tlet first: boolean = true;\n\t\tfor (let I of this._intervals) {\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tbuf += \", \";\n\t\t\t}\n\n\t\t\tlet a: number = I.a;\n\t\t\tlet b: number = I.b;\n\t\t\tif (a === b) {\n\t\t\t\tif (a === Token.EOF) {\n\t\t\t\t\tbuf += \"<EOF>\";\n\t\t\t\t} else if (elemAreChar) {\n\t\t\t\t\tbuf += \"'\" + String.fromCodePoint(a) + \"'\";\n\t\t\t\t} else {\n\t\t\t\t\tbuf += a;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (elemAreChar) {\n\t\t\t\t\tbuf += \"'\" + String.fromCodePoint(a) + \"'..'\" + String.fromCodePoint(b) + \"'\";\n\t\t\t\t} else {\n\t\t\t\t\tbuf += a + \"..\" + b;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.size > 1) {\n\t\t\tbuf += \"}\";\n\t\t}\n\n\t\treturn buf;\n\t}\n\n\tpublic toStringVocabulary( @NotNull vocabulary: Vocabulary): string {\n\t\tif (this._intervals == null || this._intervals.length === 0) {\n\t\t\treturn \"{}\";\n\t\t}\n\n\t\tlet buf: string = \"\";\n\t\tif (this.size > 1) {\n\t\t\tbuf += \"{\";\n\t\t}\n\n\t\tlet first: boolean = true;\n\t\tfor (let I of this._intervals) {\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tbuf += \", \";\n\t\t\t}\n\n\t\t\tlet a: number = I.a;\n\t\t\tlet b: number = I.b;\n\t\t\tif (a === b) {\n\t\t\t\tbuf += this.elementName(vocabulary, a);\n\t\t\t} else {\n\t\t\t\tfor (let i = a; i <= b; i++) {\n\t\t\t\t\tif (i > a) {\n\t\t\t\t\t\tbuf += \", \";\n\t\t\t\t\t}\n\n\t\t\t\t\tbuf += this.elementName(vocabulary, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (this.size > 1) {\n\t\t\tbuf += \"}\";\n\t\t}\n\n\t\treturn buf;\n\t}\n\n\t@NotNull\n\tprotected elementName( @NotNull vocabulary: Vocabulary, a: number): string {\n\t\tif (a === Token.EOF) {\n\t\t\treturn \"<EOF>\";\n\t\t} else if (a === Token.EPSILON) {\n\t\t\treturn \"<EPSILON>\";\n\t\t} else {\n\t\t\treturn vocabulary.getDisplayName(a);\n\t\t}\n\t}\n\n\t@Override\n\tget size(): number {\n\t\tlet n: number = 0;\n\t\tlet numIntervals: number = this._intervals.length;\n\t\tif (numIntervals === 1) {\n\t\t\tlet firstInterval: Interval = this._intervals[0];\n\t\t\treturn firstInterval.b - firstInterval.a + 1;\n\t\t}\n\n\t\tfor (let i = 0; i < numIntervals; i++) {\n\t\t\tlet I: Interval = this._intervals[i];\n\t\t\tn += (I.b - I.a + 1);\n\t\t}\n\n\t\treturn n;\n\t}\n\n\tpublic toIntegerList(): IntegerList {\n\t\tlet values: IntegerList = new IntegerList(this.size);\n\t\tlet n: number = this._intervals.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet I: Interval = this._intervals[i];\n\t\t\tlet a: number = I.a;\n\t\t\tlet b: number = I.b;\n\t\t\tfor (let v = a; v <= b; v++) {\n\t\t\t\tvalues.add(v);\n\t\t\t}\n\t\t}\n\n\t\treturn values;\n\t}\n\n\tpublic toSet(): Set<number> {\n\t\tlet s: Set<number> = new Set<number>();\n\t\tfor (let I of this._intervals) {\n\t\t\tlet a: number = I.a;\n\t\t\tlet b: number = I.b;\n\t\t\tfor (let v = a; v <= b; v++) {\n\t\t\t\ts.add(v);\n\t\t\t}\n\t\t}\n\n\t\treturn s;\n\t}\n\n\tpublic toArray(): number[] {\n\t\tlet values: number[] = new Array<number>();\n\t\tlet n: number = this._intervals.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet I: Interval = this._intervals[i];\n\t\t\tlet a: number = I.a;\n\t\t\tlet b: number = I.b;\n\t\t\tfor (let v = a; v <= b; v++) {\n\t\t\t\tvalues.push(v);\n\t\t\t}\n\t\t}\n\n\t\treturn values;\n\t}\n\n\t@Override\n\tpublic remove(el: number): void {\n\t\tif (this.readonly) {\n\t\t\tthrow new Error(\"can't alter readonly IntervalSet\");\n\t\t}\n\n\t\tlet n: number = this._intervals.length;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet I: Interval = this._intervals[i];\n\t\t\tlet a: number = I.a;\n\t\t\tlet b: number = I.b;\n\t\t\tif (el < a) {\n\t\t\t\tbreak; // list is sorted and el is before this interval; not here\n\t\t\t}\n\t\t\t// if whole interval x..x, rm\n\t\t\tif (el === a && el === b) {\n\t\t\t\tthis._intervals.splice(i, 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// if on left edge x..b, adjust left\n\t\t\tif (el === a) {\n\t\t\t\tthis._intervals[i] = Interval.of(I.a + 1, I.b);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// if on right edge a..x, adjust right\n\t\t\tif (el === b) {\n\t\t\t\tthis._intervals[i] = Interval.of(I.a, I.b - 1);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// if in middle a..x..b, split interval\n\t\t\tif (el > a && el < b) { // found in this interval\n\t\t\t\tlet oldb: number = I.b;\n\t\t\t\tthis._intervals[i] = Interval.of(I.a, el - 1); // [a..x-1]\n\t\t\t\tthis.add(el + 1, oldb); // add [x+1..b]\n\t\t\t}\n\t\t}\n\t}\n\n\tget isReadonly(): boolean {\n\t\treturn this.readonly;\n\t}\n\n\tpublic setReadonly(readonly: boolean): void {\n\t\tif (this.readonly && !readonly) {\n\t\t\tthrow new Error(\"can't alter readonly IntervalSet\");\n\t\t}\n\n\t\tthis.readonly = readonly;\n\t}\n}\n"]}