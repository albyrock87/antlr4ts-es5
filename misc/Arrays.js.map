{"version":3,"sources":["misc/Arrays.js","../src/misc/Arrays.ts"],"names":["Object","defineProperty","exports","value","Arrays","binarySearch","array","key","fromIndex","toIndex","binarySearch0","undefined","length","low","high","mid","midVal","toString","result","first","element"],"mappings":"AAAA;ACAA;;;;;ADKAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;ACAA,IAAiBC,MAAjB;;AAAA,CAAA,UAAiBA,MAAjB,EAAuB;AACtB;;;;;;;;;;AAUA,WAAAC,YAAA,CAA6BC,KAA7B,EAAuDC,GAAvD,EAAoEC,SAApE,EAAwFC,OAAxF,EAAwG;AACvG,WAAOC,aAAa,CAACJ,KAAD,EAAQE,SAAS,KAAKG,SAAd,GAA0BH,SAA1B,GAAsC,CAA9C,EAAiDC,OAAO,KAAKE,SAAZ,GAAwBF,OAAxB,GAAkCH,KAAK,CAACM,MAAzF,EAAiGL,GAAjG,CAApB;AACA;;AAFeH,EAAAA,MAAA,CAAAC,YAAA,GAAYA,YAAZ;;AAIhB,WAAAK,aAAA,CAAuBJ,KAAvB,EAAiDE,SAAjD,EAAoEC,OAApE,EAAqFF,GAArF,EAAgG;AAC/F,QAAIM,GAAG,GAAWL,SAAlB;AACA,QAAIM,IAAI,GAAWL,OAAO,GAAG,CAA7B;;AAEA,WAAOI,GAAG,IAAIC,IAAd,EAAoB;AACnB,UAAIC,GAAG,GAAYF,GAAG,GAAGC,IAAP,KAAiB,CAAnC;AACA,UAAIE,MAAM,GAAWV,KAAK,CAACS,GAAD,CAA1B;;AAEA,UAAIC,MAAM,GAAGT,GAAb,EAAkB;AACjBM,QAAAA,GAAG,GAAGE,GAAG,GAAG,CAAZ;AACA,OAFD,MAEO,IAAIC,MAAM,GAAGT,GAAb,EAAkB;AACxBO,QAAAA,IAAI,GAAGC,GAAG,GAAG,CAAb;AACA,OAFM,MAEA;AACN;AACA,eAAOA,GAAP;AACA;AACD,KAhB8F,CAkB/F;;;AACA,WAAO,EAAEF,GAAG,GAAG,CAAR,CAAP;AACA;;AAED,WAAAI,QAAA,CAA4BX,KAA5B,EAA8C;AAC7C,QAAIY,MAAM,GAAG,GAAb;AAEA,QAAIC,KAAK,GAAG,IAAZ;AAH6C;AAAA;AAAA;;AAAA;AAI7C,2BAAoBb,KAApB,8HAA2B;AAAA,YAAlBc,OAAkB;;AAC1B,YAAID,KAAJ,EAAW;AACVA,UAAAA,KAAK,GAAG,KAAR;AACA,SAFD,MAEO;AACND,UAAAA,MAAM,IAAI,IAAV;AACA;;AAED,YAAIE,OAAO,KAAK,IAAhB,EAAsB;AACrBF,UAAAA,MAAM,IAAI,MAAV;AACA,SAFD,MAEO,IAAIE,OAAO,KAAKT,SAAhB,EAA2B;AACjCO,UAAAA,MAAM,IAAI,WAAV;AACA,SAFM,MAEA;AACNA,UAAAA,MAAM,IAAIE,OAAV;AACA;AACD;AAlB4C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAoB7CF,IAAAA,MAAM,IAAI,GAAV;AACA,WAAOA,MAAP;AACA;;AAtBed,EAAAA,MAAA,CAAAa,QAAA,GAAQA,QAAR;AAuBhB,CA5DD,EAAiBb,MAAM,GAANF,OAAA,CAAAE,MAAA,KAAAF,OAAA,CAAAE,MAAA,GAAM,EAAN,CAAjB","file":"Arrays.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Arrays;\n(function (Arrays) {\n    /**\n     * Searches the specified array of numbers for the specified value using the binary search algorithm. The array must\n     * be sorted prior to making this call. If it is not sorted, the results are unspecified. If the array contains\n     * multiple elements with the specified value, there is no guarantee which one will be found.\n     *\n     * @returns index of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The\n     * insertion point is defined as the point at which the key would be inserted into the array: the index of the first\n     * element greater than the key, or array.length if all elements in the array are less than the specified key. Note\n     * that this guarantees that the return value will be >= 0 if and only if the key is found.\n     */\n    function binarySearch(array, key, fromIndex, toIndex) {\n        return binarySearch0(array, fromIndex !== undefined ? fromIndex : 0, toIndex !== undefined ? toIndex : array.length, key);\n    }\n    Arrays.binarySearch = binarySearch;\n    function binarySearch0(array, fromIndex, toIndex, key) {\n        let low = fromIndex;\n        let high = toIndex - 1;\n        while (low <= high) {\n            let mid = (low + high) >>> 1;\n            let midVal = array[mid];\n            if (midVal < key) {\n                low = mid + 1;\n            }\n            else if (midVal > key) {\n                high = mid - 1;\n            }\n            else {\n                // key found\n                return mid;\n            }\n        }\n        // key not found.\n        return -(low + 1);\n    }\n    function toString(array) {\n        let result = \"[\";\n        let first = true;\n        for (let element of array) {\n            if (first) {\n                first = false;\n            }\n            else {\n                result += \", \";\n            }\n            if (element === null) {\n                result += \"null\";\n            }\n            else if (element === undefined) {\n                result += \"undefined\";\n            }\n            else {\n                result += element;\n            }\n        }\n        result += \"]\";\n        return result;\n    }\n    Arrays.toString = toString;\n})(Arrays = exports.Arrays || (exports.Arrays = {}));\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\nexport namespace Arrays {\n\t/**\n\t * Searches the specified array of numbers for the specified value using the binary search algorithm. The array must\n\t * be sorted prior to making this call. If it is not sorted, the results are unspecified. If the array contains\n\t * multiple elements with the specified value, there is no guarantee which one will be found.\n\t *\n\t * @returns index of the search key, if it is contained in the array; otherwise, (-(insertion point) - 1). The\n\t * insertion point is defined as the point at which the key would be inserted into the array: the index of the first\n\t * element greater than the key, or array.length if all elements in the array are less than the specified key. Note\n\t * that this guarantees that the return value will be >= 0 if and only if the key is found.\n\t */\n\texport function binarySearch(array: ArrayLike<number>, key: number, fromIndex?: number, toIndex?: number): number {\n\t\treturn binarySearch0(array, fromIndex !== undefined ? fromIndex : 0, toIndex !== undefined ? toIndex : array.length, key);\n\t}\n\n\tfunction binarySearch0(array: ArrayLike<number>, fromIndex: number, toIndex: number, key: number): number {\n\t\tlet low: number = fromIndex;\n\t\tlet high: number = toIndex - 1;\n\n\t\twhile (low <= high) {\n\t\t\tlet mid: number = (low + high) >>> 1;\n\t\t\tlet midVal: number = array[mid];\n\n\t\t\tif (midVal < key) {\n\t\t\t\tlow = mid + 1;\n\t\t\t} else if (midVal > key) {\n\t\t\t\thigh = mid - 1;\n\t\t\t} else {\n\t\t\t\t// key found\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t}\n\n\t\t// key not found.\n\t\treturn -(low + 1);\n\t}\n\n\texport function toString<T>(array: Iterable<T>) {\n\t\tlet result = \"[\";\n\n\t\tlet first = true;\n\t\tfor (let element of array) {\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t} else {\n\t\t\t\tresult += \", \";\n\t\t\t}\n\n\t\t\tif (element === null) {\n\t\t\t\tresult += \"null\";\n\t\t\t} else if (element === undefined) {\n\t\t\t\tresult += \"undefined\";\n\t\t\t} else {\n\t\t\t\tresult += element;\n\t\t\t}\n\t\t}\n\n\t\tresult += \"]\";\n\t\treturn result;\n\t}\n}\n"]}