{"version":3,"sources":["misc/Interval.js","../src/misc/Interval.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","Decorators_1","require","INTERVAL_POOL_MAX_VALUE","Interval","a","b","o","hash","other","startsBeforeDisjoint","startsAfterDisjoint","of","Math","min","max","diff","startsBeforeNonDisjoint","startsAfterNonDisjoint","cache","_INVALID","Array","Override","prototype"],"mappings":"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","file":"Interval.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:40.7402214-07:00\nconst Decorators_1 = require(\"../Decorators\");\nconst INTERVAL_POOL_MAX_VALUE = 1000;\n/** An immutable inclusive interval a..b */\nclass Interval {\n    /**\n     * @param a The start of the interval\n     * @param b The end of the interval (inclusive)\n     */\n    constructor(a, b) {\n        this.a = a;\n        this.b = b;\n    }\n    static get INVALID() {\n        return Interval._INVALID;\n    }\n    /** Interval objects are used readonly so share all with the\n     *  same single value a==b up to some max size.  Use an array as a perfect hash.\n     *  Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new\n     *  Interval object with a..a in it.  On Java.g4, 218623 IntervalSets\n     *  have a..a (set with 1 element).\n     */\n    static of(a, b) {\n        // cache just a..a\n        if (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {\n            return new Interval(a, b);\n        }\n        if (Interval.cache[a] == null) {\n            Interval.cache[a] = new Interval(a, a);\n        }\n        return Interval.cache[a];\n    }\n    /** return number of elements between a and b inclusively. x..x is length 1.\n     *  if b &lt; a, then length is 0.  9..10 has length 2.\n     */\n    get length() {\n        if (this.b < this.a) {\n            return 0;\n        }\n        return this.b - this.a + 1;\n    }\n    equals(o) {\n        if (o === this) {\n            return true;\n        }\n        else if (!(o instanceof Interval)) {\n            return false;\n        }\n        return this.a === o.a && this.b === o.b;\n    }\n    hashCode() {\n        let hash = 23;\n        hash = hash * 31 + this.a;\n        hash = hash * 31 + this.b;\n        return hash;\n    }\n    /** Does this start completely before other? Disjoint */\n    startsBeforeDisjoint(other) {\n        return this.a < other.a && this.b < other.a;\n    }\n    /** Does this start at or before other? Nondisjoint */\n    startsBeforeNonDisjoint(other) {\n        return this.a <= other.a && this.b >= other.a;\n    }\n    /** Does this.a start after other.b? May or may not be disjoint */\n    startsAfter(other) {\n        return this.a > other.a;\n    }\n    /** Does this start completely after other? Disjoint */\n    startsAfterDisjoint(other) {\n        return this.a > other.b;\n    }\n    /** Does this start after other? NonDisjoint */\n    startsAfterNonDisjoint(other) {\n        return this.a > other.a && this.a <= other.b; // this.b>=other.b implied\n    }\n    /** Are both ranges disjoint? I.e., no overlap? */\n    disjoint(other) {\n        return this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);\n    }\n    /** Are two intervals adjacent such as 0..41 and 42..42? */\n    adjacent(other) {\n        return this.a === other.b + 1 || this.b === other.a - 1;\n    }\n    properlyContains(other) {\n        return other.a >= this.a && other.b <= this.b;\n    }\n    /** Return the interval computed from combining this and other */\n    union(other) {\n        return Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));\n    }\n    /** Return the interval in common between this and o */\n    intersection(other) {\n        return Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));\n    }\n    /** Return the interval with elements from `this` not in `other`;\n     *  `other` must not be totally enclosed (properly contained)\n     *  within `this`, which would result in two disjoint intervals\n     *  instead of the single one returned by this method.\n     */\n    differenceNotProperlyContained(other) {\n        let diff;\n        if (other.startsBeforeNonDisjoint(this)) {\n            // other.a to left of this.a (or same)\n            diff = Interval.of(Math.max(this.a, other.b + 1), this.b);\n        }\n        else if (other.startsAfterNonDisjoint(this)) {\n            // other.a to right of this.a\n            diff = Interval.of(this.a, other.a - 1);\n        }\n        return diff;\n    }\n    toString() {\n        return this.a + \"..\" + this.b;\n    }\n}\nInterval._INVALID = new Interval(-1, -2);\nInterval.cache = new Array(INTERVAL_POOL_MAX_VALUE + 1);\n__decorate([\n    Decorators_1.Override\n], Interval.prototype, \"equals\", null);\n__decorate([\n    Decorators_1.Override\n], Interval.prototype, \"hashCode\", null);\n__decorate([\n    Decorators_1.Override\n], Interval.prototype, \"toString\", null);\nexports.Interval = Interval;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:40.7402214-07:00\n\nimport { Override } from \"../Decorators\";\nimport { Equatable } from \"./Stubs\";\n\nconst INTERVAL_POOL_MAX_VALUE: number = 1000;\n\n/** An immutable inclusive interval a..b */\nexport class Interval implements Equatable {\n\tprivate static _INVALID: Interval = new Interval(-1, -2);\n\tstatic get INVALID(): Interval {\n\t\treturn Interval._INVALID;\n\t}\n\n\tprivate static readonly cache: Interval[] = new Array<Interval>(INTERVAL_POOL_MAX_VALUE + 1);\n\n\t/**\n\t * @param a The start of the interval\n\t * @param b The end of the interval (inclusive)\n\t */\n\tconstructor(public a: number, public b: number) {\n\t}\n\n\t/** Interval objects are used readonly so share all with the\n\t *  same single value a==b up to some max size.  Use an array as a perfect hash.\n\t *  Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new\n\t *  Interval object with a..a in it.  On Java.g4, 218623 IntervalSets\n\t *  have a..a (set with 1 element).\n\t */\n\tpublic static of(a: number, b: number): Interval {\n\t\t// cache just a..a\n\t\tif (a !== b || a < 0 || a > INTERVAL_POOL_MAX_VALUE) {\n\t\t\treturn new Interval(a, b);\n\t\t}\n\n\t\tif (Interval.cache[a] == null) {\n\t\t\tInterval.cache[a] = new Interval(a, a);\n\t\t}\n\n\t\treturn Interval.cache[a];\n\t}\n\n\t/** return number of elements between a and b inclusively. x..x is length 1.\n\t *  if b &lt; a, then length is 0.  9..10 has length 2.\n\t */\n\tget length(): number {\n\t\tif (this.b < this.a) {\n\t\t\treturn 0;\n\t\t}\n\n\t\treturn this.b - this.a + 1;\n\t}\n\n\t@Override\n\tpublic equals(o: any): boolean {\n\t\tif (o === this) {\n\t\t\treturn true;\n\t\t}\n\t\telse if (!(o instanceof Interval)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.a === o.a && this.b === o.b;\n\t}\n\n\t@Override\n\tpublic hashCode(): number {\n\t\tlet hash: number = 23;\n\t\thash = hash * 31 + this.a;\n\t\thash = hash * 31 + this.b;\n\t\treturn hash;\n\t}\n\n\t/** Does this start completely before other? Disjoint */\n\tpublic startsBeforeDisjoint(other: Interval): boolean {\n\t\treturn this.a < other.a && this.b < other.a;\n\t}\n\n\t/** Does this start at or before other? Nondisjoint */\n\tpublic startsBeforeNonDisjoint(other: Interval): boolean {\n\t\treturn this.a <= other.a && this.b >= other.a;\n\t}\n\n\t/** Does this.a start after other.b? May or may not be disjoint */\n\tpublic startsAfter(other: Interval): boolean {\n\t\treturn this.a > other.a;\n\t}\n\n\t/** Does this start completely after other? Disjoint */\n\tpublic startsAfterDisjoint(other: Interval): boolean {\n\t\treturn this.a > other.b;\n\t}\n\n\t/** Does this start after other? NonDisjoint */\n\tpublic startsAfterNonDisjoint(other: Interval): boolean {\n\t\treturn this.a > other.a && this.a <= other.b; // this.b>=other.b implied\n\t}\n\n\t/** Are both ranges disjoint? I.e., no overlap? */\n\tpublic disjoint(other: Interval): boolean {\n\t\treturn this.startsBeforeDisjoint(other) || this.startsAfterDisjoint(other);\n\t}\n\n\t/** Are two intervals adjacent such as 0..41 and 42..42? */\n\tpublic adjacent(other: Interval): boolean {\n\t\treturn this.a === other.b + 1 || this.b === other.a - 1;\n\t}\n\n\tpublic properlyContains(other: Interval): boolean {\n\t\treturn other.a >= this.a && other.b <= this.b;\n\t}\n\n\t/** Return the interval computed from combining this and other */\n\tpublic union(other: Interval): Interval {\n\t\treturn Interval.of(Math.min(this.a, other.a), Math.max(this.b, other.b));\n\t}\n\n\t/** Return the interval in common between this and o */\n\tpublic intersection(other: Interval): Interval {\n\t\treturn Interval.of(Math.max(this.a, other.a), Math.min(this.b, other.b));\n\t}\n\n\t/** Return the interval with elements from `this` not in `other`;\n\t *  `other` must not be totally enclosed (properly contained)\n\t *  within `this`, which would result in two disjoint intervals\n\t *  instead of the single one returned by this method.\n\t */\n\tpublic differenceNotProperlyContained(other: Interval): Interval | undefined {\n\t\tlet diff: Interval | undefined;\n\t\tif (other.startsBeforeNonDisjoint(this)) {\n\t\t\t// other.a to left of this.a (or same)\n\t\t\tdiff = Interval.of(Math.max(this.a, other.b + 1), this.b);\n\t\t} else if (other.startsAfterNonDisjoint(this)) {\n\t\t\t// other.a to right of this.a\n\t\t\tdiff = Interval.of(this.a, other.a - 1);\n\t\t}\n\n\t\treturn diff;\n\t}\n\n\t@Override\n\tpublic toString(): string {\n\t\treturn this.a + \"..\" + this.b;\n\t}\n}\n"]}