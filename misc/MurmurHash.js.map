{"version":3,"sources":["misc/MurmurHash.js","../src/misc/MurmurHash.ts"],"names":["Object","defineProperty","exports","value","MurmurHash","DEFAULT_SEED","initialize","seed","update","hash","c1","c2","r1","r2","m","n","hashString","hashCode","k","Math","imul","finish","numberOfWords","data","length","str","len","i","c","charCodeAt"],"mappings":"AAAA;ACAA;;;;;;;;;ADKAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;ACGA;;;;;AAIA,IAAiBC,UAAjB;;AAAA,CAAA,UAAiBA,UAAjB,EAA2B;AAE1B,MAAMC,YAAY,GAAW,CAA7B;AAEA;;;;;;;AAMA,WAAAC,UAAA,GAAsD;AAAA,QAA3BC,IAA2B,uEAAZF,YAAY;AACrD,WAAOE,IAAP;AACA;;AAFeH,EAAAA,UAAA,CAAAE,UAAA,GAAUA,UAAV;AAIhB;;;;;;;;AAOA,WAAAE,MAAA,CAAuBC,IAAvB,EAAqCN,KAArC,EAA0F;AACzF,QAAMO,EAAE,GAAW,UAAnB;AACA,QAAMC,EAAE,GAAW,UAAnB;AACA,QAAMC,EAAE,GAAW,EAAnB;AACA,QAAMC,EAAE,GAAW,EAAnB;AACA,QAAMC,CAAC,GAAW,CAAlB;AACA,QAAMC,CAAC,GAAW,UAAlB;;AAEA,QAAIZ,KAAK,IAAI,IAAb,EAAmB;AAClBA,MAAAA,KAAK,GAAG,CAAR;AACA,KAFD,MAEO,IAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AACrCA,MAAAA,KAAK,GAAGa,UAAU,CAACb,KAAD,CAAlB;AACA,KAFM,MAEA,IAAI,yBAAOA,KAAP,MAAiB,QAArB,EAA+B;AACrCA,MAAAA,KAAK,GAAGA,KAAK,CAACc,QAAN,EAAR;AACA;;AAED,QAAIC,CAAC,GAAWf,KAAhB;AACAe,IAAAA,CAAC,GAAGC,IAAI,CAACC,IAAL,CAAUF,CAAV,EAAaR,EAAb,CAAJ;AACAQ,IAAAA,CAAC,GAAIA,CAAC,IAAIN,EAAN,GAAaM,CAAC,KAAM,KAAKN,EAA7B;AACAM,IAAAA,CAAC,GAAGC,IAAI,CAACC,IAAL,CAAUF,CAAV,EAAaP,EAAb,CAAJ;AAEAF,IAAAA,IAAI,GAAGA,IAAI,GAAGS,CAAd;AACAT,IAAAA,IAAI,GAAIA,IAAI,IAAII,EAAT,GAAgBJ,IAAI,KAAM,KAAKI,EAAtC;AACAJ,IAAAA,IAAI,GAAGU,IAAI,CAACC,IAAL,CAAUX,IAAV,EAAgBK,CAAhB,IAAqBC,CAA5B;AAEA,WAAON,IAAI,GAAG,UAAd;AACA;;AA1BeL,EAAAA,UAAA,CAAAI,MAAA,GAAMA,MAAN;AA6BhB;;;;;;;;;AAQA,WAAAa,MAAA,CAAuBZ,IAAvB,EAAqCa,aAArC,EAA0D;AACzDb,IAAAA,IAAI,GAAGA,IAAI,GAAIa,aAAa,GAAG,CAA/B;AACAb,IAAAA,IAAI,GAAGA,IAAI,GAAIA,IAAI,KAAK,EAAxB;AACAA,IAAAA,IAAI,GAAGU,IAAI,CAACC,IAAL,CAAUX,IAAV,EAAgB,UAAhB,CAAP;AACAA,IAAAA,IAAI,GAAGA,IAAI,GAAIA,IAAI,KAAK,EAAxB;AACAA,IAAAA,IAAI,GAAGU,IAAI,CAACC,IAAL,CAAUX,IAAV,EAAgB,UAAhB,CAAP;AACAA,IAAAA,IAAI,GAAGA,IAAI,GAAIA,IAAI,KAAK,EAAxB;AACA,WAAOA,IAAP;AACA;;AAReL,EAAAA,UAAA,CAAAiB,MAAA,GAAMA,MAAN;AAUhB;;;;;;;;;;AASA,WAAAJ,QAAA,CAAgEM,IAAhE,EAA8G;AAAA,QAA3BhB,IAA2B,uEAAZF,YAAY;AAC7G,QAAII,IAAI,GAAWH,UAAU,CAACC,IAAD,CAA7B;AACA,QAAIiB,MAAM,GAAG,CAAb;AAF6G;AAAA;AAAA;;AAAA;AAG7G,2BAAkBD,IAAlB,8HAAwB;AAAA,YAAfpB,KAAe;AACvBM,QAAAA,IAAI,GAAGD,MAAM,CAACC,IAAD,EAAON,KAAP,CAAb;AACAqB,QAAAA,MAAM;AACN;AAN4G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQ7Gf,IAAAA,IAAI,GAAGY,MAAM,CAACZ,IAAD,EAAOe,MAAP,CAAb;AACA,WAAOf,IAAP;AACA;;AAVeL,EAAAA,UAAA,CAAAa,QAAA,GAAQA,QAAR;AAYhB;;;;;AAIA,WAAAD,UAAA,CAAoBS,GAApB,EAA+B;AAC9B,QAAIC,GAAG,GAAGD,GAAG,CAACD,MAAd;;AACA,QAAIE,GAAG,KAAK,CAAZ,EAAe;AACd,aAAO,CAAP;AACA;;AAED,QAAIjB,IAAI,GAAG,CAAX;;AACA,SAAK,IAAIkB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGD,GAApB,EAAyBC,CAAC,EAA1B,EAA8B;AAC7B,UAAIC,CAAC,GAAGH,GAAG,CAACI,UAAJ,CAAeF,CAAf,CAAR;AACAlB,MAAAA,IAAI,GAAI,CAAEA,IAAI,IAAI,CAAT,KAAgB,CAAjB,IAAsBA,IAAvB,GAA+BmB,CAAtC;AACAnB,MAAAA,IAAI,IAAI,CAAR;AACA;;AAED,WAAOA,IAAP;AACA;AACD,CA5GD,EAAiBL,UAAU,GAAVF,OAAA,CAAAE,UAAA,KAAAF,OAAA,CAAAE,UAAA,GAAU,EAAV,CAAjB","file":"MurmurHash.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n *\n * @author Sam Harwell\n */\nvar MurmurHash;\n(function (MurmurHash) {\n    const DEFAULT_SEED = 0;\n    /**\n     * Initialize the hash using the specified `seed`.\n     *\n     * @param seed the seed (optional)\n     * @returns the intermediate hash value\n     */\n    function initialize(seed = DEFAULT_SEED) {\n        return seed;\n    }\n    MurmurHash.initialize = initialize;\n    /**\n     * Update the intermediate hash value for the next input `value`.\n     *\n     * @param hash the intermediate hash value\n     * @param value the value to add to the current hash\n     * @returns the updated intermediate hash value\n     */\n    function update(hash, value) {\n        const c1 = 0xCC9E2D51;\n        const c2 = 0x1B873593;\n        const r1 = 15;\n        const r2 = 13;\n        const m = 5;\n        const n = 0xE6546B64;\n        if (value == null) {\n            value = 0;\n        }\n        else if (typeof value === \"string\") {\n            value = hashString(value);\n        }\n        else if (typeof value === \"object\") {\n            value = value.hashCode();\n        }\n        let k = value;\n        k = Math.imul(k, c1);\n        k = (k << r1) | (k >>> (32 - r1));\n        k = Math.imul(k, c2);\n        hash = hash ^ k;\n        hash = (hash << r2) | (hash >>> (32 - r2));\n        hash = Math.imul(hash, m) + n;\n        return hash & 0xFFFFFFFF;\n    }\n    MurmurHash.update = update;\n    /**\n     * Apply the final computation steps to the intermediate value `hash`\n     * to form the final result of the MurmurHash 3 hash function.\n     *\n     * @param hash the intermediate hash value\n     * @param numberOfWords the number of integer values added to the hash\n     * @returns the final hash result\n     */\n    function finish(hash, numberOfWords) {\n        hash = hash ^ (numberOfWords * 4);\n        hash = hash ^ (hash >>> 16);\n        hash = Math.imul(hash, 0x85EBCA6B);\n        hash = hash ^ (hash >>> 13);\n        hash = Math.imul(hash, 0xC2B2AE35);\n        hash = hash ^ (hash >>> 16);\n        return hash;\n    }\n    MurmurHash.finish = finish;\n    /**\n     * Utility function to compute the hash code of an array using the\n     * MurmurHash algorithm.\n     *\n     * @param <T> the array element type\n     * @param data the array data\n     * @param seed the seed for the MurmurHash algorithm\n     * @returns the hash code of the data\n     */\n    function hashCode(data, seed = DEFAULT_SEED) {\n        let hash = initialize(seed);\n        let length = 0;\n        for (let value of data) {\n            hash = update(hash, value);\n            length++;\n        }\n        hash = finish(hash, length);\n        return hash;\n    }\n    MurmurHash.hashCode = hashCode;\n    /**\n     * Function to hash a string. Based on the implementation found here:\n     * http://stackoverflow.com/a/7616484\n     */\n    function hashString(str) {\n        let len = str.length;\n        if (len === 0) {\n            return 0;\n        }\n        let hash = 0;\n        for (let i = 0; i < len; i++) {\n            let c = str.charCodeAt(i);\n            hash = (((hash << 5) >>> 0) - hash) + c;\n            hash |= 0;\n        }\n        return hash;\n    }\n})(MurmurHash = exports.MurmurHash || (exports.MurmurHash = {}));\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-03T02:09:42.1239660-07:00\nimport { Equatable } from \"./Stubs\";\n\n/**\n *\n * @author Sam Harwell\n */\nexport namespace MurmurHash {\n\n\tconst DEFAULT_SEED: number = 0;\n\n\t/**\n\t * Initialize the hash using the specified `seed`.\n\t *\n\t * @param seed the seed (optional)\n\t * @returns the intermediate hash value\n\t */\n\texport function initialize(seed: number = DEFAULT_SEED): number {\n\t\treturn seed;\n\t}\n\n\t/**\n\t * Update the intermediate hash value for the next input `value`.\n\t *\n\t * @param hash the intermediate hash value\n\t * @param value the value to add to the current hash\n\t * @returns the updated intermediate hash value\n\t */\n\texport function update(hash: number, value: number | string | Equatable | null | undefined): number {\n\t\tconst c1: number = 0xCC9E2D51;\n\t\tconst c2: number = 0x1B873593;\n\t\tconst r1: number = 15;\n\t\tconst r2: number = 13;\n\t\tconst m: number = 5;\n\t\tconst n: number = 0xE6546B64;\n\n\t\tif (value == null) {\n\t\t\tvalue = 0;\n\t\t} else if (typeof value === \"string\") {\n\t\t\tvalue = hashString(value);\n\t\t} else if (typeof value === \"object\") {\n\t\t\tvalue = value.hashCode();\n\t\t}\n\n\t\tlet k: number = value;\n\t\tk = Math.imul(k, c1);\n\t\tk = (k << r1) | (k >>> (32 - r1));\n\t\tk = Math.imul(k, c2);\n\n\t\thash = hash ^ k;\n\t\thash = (hash << r2) | (hash >>> (32 - r2));\n\t\thash = Math.imul(hash, m) + n;\n\n\t\treturn hash & 0xFFFFFFFF;\n\t}\n\n\n\t/**\n\t * Apply the final computation steps to the intermediate value `hash`\n\t * to form the final result of the MurmurHash 3 hash function.\n\t *\n\t * @param hash the intermediate hash value\n\t * @param numberOfWords the number of integer values added to the hash\n\t * @returns the final hash result\n\t */\n\texport function finish(hash: number, numberOfWords: number): number {\n\t\thash = hash ^ (numberOfWords * 4);\n\t\thash = hash ^ (hash >>> 16);\n\t\thash = Math.imul(hash, 0x85EBCA6B);\n\t\thash = hash ^ (hash >>> 13);\n\t\thash = Math.imul(hash, 0xC2B2AE35);\n\t\thash = hash ^ (hash >>> 16);\n\t\treturn hash;\n\t}\n\n\t/**\n\t * Utility function to compute the hash code of an array using the\n\t * MurmurHash algorithm.\n\t *\n\t * @param <T> the array element type\n\t * @param data the array data\n\t * @param seed the seed for the MurmurHash algorithm\n\t * @returns the hash code of the data\n\t */\n\texport function hashCode<T extends number | string | Equatable>(data: Iterable<T>, seed: number = DEFAULT_SEED): number {\n\t\tlet hash: number = initialize(seed);\n\t\tlet length = 0;\n\t\tfor (let value of data) {\n\t\t\thash = update(hash, value);\n\t\t\tlength++;\n\t\t}\n\n\t\thash = finish(hash, length);\n\t\treturn hash;\n\t}\n\n\t/**\n\t * Function to hash a string. Based on the implementation found here:\n\t * http://stackoverflow.com/a/7616484\n\t */\n\tfunction hashString(str: string): number {\n\t\tlet len = str.length;\n\t\tif (len === 0) {\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet hash = 0;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tlet c = str.charCodeAt(i);\n\t\t\thash = (((hash << 5) >>> 0) - hash) + c;\n\t\t\thash |= 0;\n\t\t}\n\n\t\treturn hash;\n\t}\n}\n"]}