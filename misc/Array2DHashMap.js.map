{"version":3,"sources":["misc/Array2DHashMap.js","../src/misc/Array2DHashMap.ts"],"names":["Object","defineProperty","exports","value","Array2DHashSet_1","require","MapKeyEqualityComparator","keyComparator","obj","hashCode","key","a","b","equals","Array2DHashMap","keyComparer","backingStore","Array2DHashSet","clear","contains","bucket","get","undefined","element","result","add","o","isEmpty","size"],"mappings":"AAAA;ACAA;;;;;;;;;;;ADKAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;ACAA,IAAAC,gBAAA,GAAAC,OAAA,CAAA,kBAAA,CAAA;;IASAC,wB;;;AAGC,oCAAYC,aAAZ,EAAgD;AAAA;AAC/C,SAAKA,aAAL,GAAqBA,aAArB;AACA;;;;6BAEeC,G,EAAiB;AAChC,aAAO,KAAKD,aAAL,CAAmBE,QAAnB,CAA4BD,GAAG,CAACE,GAAhC,CAAP;AACA;;;2BAEaC,C,EAAiBC,C,EAAe;AAC7C,aAAO,KAAKL,aAAL,CAAmBM,MAAnB,CAA0BF,CAAC,CAACD,GAA5B,EAAiCE,CAAC,CAACF,GAAnC,CAAP;AACA;;;;;IAGFI,c;;;AAKC,0BAAYC,WAAZ,EAAqE;AAAA;;AACpE,QAAIA,WAAW,YAAYD,cAA3B,EAA2C;AAC1C,WAAKE,YAAL,GAAoB,IAAIZ,gBAAA,CAAAa,cAAJ,CAAiCF,WAAW,CAACC,YAA7C,CAApB;AACA,KAFD,MAEO;AACN,WAAKA,YAAL,GAAoB,IAAIZ,gBAAA,CAAAa,cAAJ,CAAiC,IAAIX,wBAAJ,CAAmCS,WAAnC,CAAjC,CAApB;AACA;AACD;;;;4BAEW;AACX,WAAKC,YAAL,CAAkBE,KAAlB;AACA;;;gCAEkBR,G,EAAM;AACxB,aAAO,KAAKM,YAAL,CAAkBG,QAAlB,CAA2B;AAAET,QAAAA,GAAG,EAAHA;AAAF,OAA3B,CAAP;AACA;;;wBAEUA,G,EAAM;AAChB,UAAIU,MAAM,GAAG,KAAKJ,YAAL,CAAkBK,GAAlB,CAAsB;AAAEX,QAAAA,GAAG,EAAHA;AAAF,OAAtB,CAAb;;AACA,UAAI,CAACU,MAAL,EAAa;AACZ,eAAOE,SAAP;AACA;;AAED,aAAOF,MAAM,CAACjB,KAAd;AACA;;;wBAMUO,G,EAAQP,K,EAAQ;AAC1B,UAAIoB,OAAO,GAAG,KAAKP,YAAL,CAAkBK,GAAlB,CAAsB;AAAEX,QAAAA,GAAG,EAAHA,GAAF;AAAOP,QAAAA,KAAK,EAALA;AAAP,OAAtB,CAAd;AACA,UAAIqB,MAAJ;;AACA,UAAI,CAACD,OAAL,EAAc;AACb,aAAKP,YAAL,CAAkBS,GAAlB,CAAsB;AAAEf,UAAAA,GAAG,EAAHA,GAAF;AAAOP,UAAAA,KAAK,EAALA;AAAP,SAAtB;AACA,OAFD,MAEO;AACNqB,QAAAA,MAAM,GAAGD,OAAO,CAACpB,KAAjB;AACAoB,QAAAA,OAAO,CAACpB,KAAR,GAAgBA,KAAhB;AACA;;AAED,aAAOqB,MAAP;AACA;;;gCAEkBd,G,EAAQP,K,EAAQ;AAClC,UAAIoB,OAAO,GAAG,KAAKP,YAAL,CAAkBK,GAAlB,CAAsB;AAAEX,QAAAA,GAAG,EAAHA,GAAF;AAAOP,QAAAA,KAAK,EAALA;AAAP,OAAtB,CAAd;AACA,UAAIqB,MAAJ;;AACA,UAAI,CAACD,OAAL,EAAc;AACb,aAAKP,YAAL,CAAkBS,GAAlB,CAAsB;AAAEf,UAAAA,GAAG,EAAHA,GAAF;AAAOP,UAAAA,KAAK,EAALA;AAAP,SAAtB;AACA,OAFD,MAEO;AACNqB,QAAAA,MAAM,GAAGD,OAAO,CAACpB,KAAjB;AACA;;AAED,aAAOqB,MAAP;AACA;;;+BAMc;AACd,aAAO,KAAKR,YAAL,CAAkBP,QAAlB,EAAP;AACA;;;2BAEaiB,C,EAAM;AACnB,UAAI,EAAEA,CAAC,YAAYZ,cAAf,CAAJ,EAAoC;AACnC,eAAO,KAAP;AACA;;AAED,aAAO,KAAKE,YAAL,CAAkBH,MAAlB,CAAyBa,CAAC,CAACV,YAA3B,CAAP;AACA;;;wBA3CU;AACV,aAAO,KAAKA,YAAL,CAAkBW,OAAzB;AACA;;;wBA2BO;AACP,aAAO,KAAKX,YAAL,CAAkBY,IAAzB;AACA;;;;;AA7DF1B,OAAA,CAAAY,cAAA,GAAAA,cAAA","file":"Array2DHashMap.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Array2DHashSet_1 = require(\"./Array2DHashSet\");\nclass MapKeyEqualityComparator {\n    constructor(keyComparator) {\n        this.keyComparator = keyComparator;\n    }\n    hashCode(obj) {\n        return this.keyComparator.hashCode(obj.key);\n    }\n    equals(a, b) {\n        return this.keyComparator.equals(a.key, b.key);\n    }\n}\nclass Array2DHashMap {\n    constructor(keyComparer) {\n        if (keyComparer instanceof Array2DHashMap) {\n            this.backingStore = new Array2DHashSet_1.Array2DHashSet(keyComparer.backingStore);\n        }\n        else {\n            this.backingStore = new Array2DHashSet_1.Array2DHashSet(new MapKeyEqualityComparator(keyComparer));\n        }\n    }\n    clear() {\n        this.backingStore.clear();\n    }\n    containsKey(key) {\n        return this.backingStore.contains({ key });\n    }\n    get(key) {\n        let bucket = this.backingStore.get({ key });\n        if (!bucket) {\n            return undefined;\n        }\n        return bucket.value;\n    }\n    get isEmpty() {\n        return this.backingStore.isEmpty;\n    }\n    put(key, value) {\n        let element = this.backingStore.get({ key, value });\n        let result;\n        if (!element) {\n            this.backingStore.add({ key, value });\n        }\n        else {\n            result = element.value;\n            element.value = value;\n        }\n        return result;\n    }\n    putIfAbsent(key, value) {\n        let element = this.backingStore.get({ key, value });\n        let result;\n        if (!element) {\n            this.backingStore.add({ key, value });\n        }\n        else {\n            result = element.value;\n        }\n        return result;\n    }\n    get size() {\n        return this.backingStore.size;\n    }\n    hashCode() {\n        return this.backingStore.hashCode();\n    }\n    equals(o) {\n        if (!(o instanceof Array2DHashMap)) {\n            return false;\n        }\n        return this.backingStore.equals(o.backingStore);\n    }\n}\nexports.Array2DHashMap = Array2DHashMap;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\nimport { Array2DHashSet } from \"./Array2DHashSet\";\nimport { DefaultEqualityComparator } from \"./DefaultEqualityComparator\";\nimport { EqualityComparator } from \"./EqualityComparator\";\nimport { Equatable, JavaCollection, JavaMap, JavaSet } from \"./Stubs\";\n\n// Since `Array2DHashMap` is implemented on top of `Array2DHashSet`, we defined a bucket type which can store a\n// key-value pair. The value is optional since looking up values in the map by a key only needs to include the key.\ninterface Bucket<K, V> { key: K; value?: V; }\n\nclass MapKeyEqualityComparator<K, V> implements EqualityComparator<Bucket<K, V>> {\n\tprivate readonly keyComparator: EqualityComparator<K>;\n\n\tconstructor(keyComparator: EqualityComparator<K>) {\n\t\tthis.keyComparator = keyComparator;\n\t}\n\n\tpublic hashCode(obj: Bucket<K, V>): number {\n\t\treturn this.keyComparator.hashCode(obj.key);\n\t}\n\n\tpublic equals(a: Bucket<K, V>, b: Bucket<K, V>): boolean {\n\t\treturn this.keyComparator.equals(a.key, b.key);\n\t}\n}\n\nexport class Array2DHashMap<K, V> implements JavaMap<K, V> {\n\tprivate backingStore: Array2DHashSet<Bucket<K, V>>;\n\n\tconstructor(keyComparer: EqualityComparator<K>);\n\tconstructor(map: Array2DHashMap<K, V>);\n\tconstructor(keyComparer: EqualityComparator<K> | Array2DHashMap<K, V>) {\n\t\tif (keyComparer instanceof Array2DHashMap) {\n\t\t\tthis.backingStore = new Array2DHashSet<Bucket<K, V>>(keyComparer.backingStore);\n\t\t} else {\n\t\t\tthis.backingStore = new Array2DHashSet<Bucket<K, V>>(new MapKeyEqualityComparator<K, V>(keyComparer));\n\t\t}\n\t}\n\n\tpublic clear(): void {\n\t\tthis.backingStore.clear();\n\t}\n\n\tpublic containsKey(key: K): boolean {\n\t\treturn this.backingStore.contains({ key });\n\t}\n\n\tpublic get(key: K): V | undefined {\n\t\tlet bucket = this.backingStore.get({ key });\n\t\tif (!bucket) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn bucket.value;\n\t}\n\n\tget isEmpty(): boolean {\n\t\treturn this.backingStore.isEmpty;\n\t}\n\n\tpublic put(key: K, value: V): V | undefined {\n\t\tlet element = this.backingStore.get({ key, value });\n\t\tlet result: V | undefined;\n\t\tif (!element) {\n\t\t\tthis.backingStore.add({ key, value });\n\t\t} else {\n\t\t\tresult = element.value;\n\t\t\telement.value = value;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic putIfAbsent(key: K, value: V): V | undefined {\n\t\tlet element = this.backingStore.get({ key, value });\n\t\tlet result: V | undefined;\n\t\tif (!element) {\n\t\t\tthis.backingStore.add({ key, value });\n\t\t} else {\n\t\t\tresult = element.value;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tget size(): number {\n\t\treturn this.backingStore.size;\n\t}\n\n\tpublic hashCode(): number {\n\t\treturn this.backingStore.hashCode();\n\t}\n\n\tpublic equals(o: any): boolean {\n\t\tif (!(o instanceof Array2DHashMap)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.backingStore.equals(o.backingStore);\n\t}\n}\n"]}