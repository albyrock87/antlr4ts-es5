{"version":3,"sources":["misc/InterpreterDataReader.js","../src/misc/InterpreterDataReader.ts"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","Object","defineProperty","exports","fs","require","util","VocabularyImpl_1","ATNDeserializer_1","splitToLines","buffer","lines","index","length","lineStart","lineEndLF","indexOf","charCodeAt","lineEndCR","lineEnd","push","toString","InterpreterDataReader","parseFile","fileName","InterpreterData","ruleNames","promisify","readFile","input","lineIndex","literalNames","symbolicNames","line","RangeError","undefined","displayNames","vocabulary","VocabularyImpl","channels","modes","elements","split","serializedATN","Uint16Array","i","element","startsWith","parseInt","substring","trim","endsWith","deserializer","ATNDeserializer","atn","deserialize"],"mappings":"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","file":"InterpreterDataReader.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst fs = require(\"fs\");\nconst util = require(\"util\");\nconst VocabularyImpl_1 = require(\"../VocabularyImpl\");\nconst ATNDeserializer_1 = require(\"../atn/ATNDeserializer\");\nfunction splitToLines(buffer) {\n    let lines = [];\n    let index = 0;\n    while (index < buffer.length) {\n        let lineStart = index;\n        let lineEndLF = buffer.indexOf(\"\\n\".charCodeAt(0), index);\n        let lineEndCR = buffer.indexOf(\"\\r\".charCodeAt(0), index);\n        let lineEnd;\n        if (lineEndCR >= 0 && (lineEndCR < lineEndLF || lineEndLF === -1)) {\n            lineEnd = lineEndCR;\n        }\n        else if (lineEndLF >= 0) {\n            lineEnd = lineEndLF;\n        }\n        else {\n            lineEnd = buffer.length;\n        }\n        lines.push(buffer.toString(\"utf-8\", lineStart, lineEnd));\n        if (lineEnd === lineEndCR && lineEnd + 1 === lineEndLF) {\n            index = lineEnd + 2;\n        }\n        else {\n            index = lineEnd + 1;\n        }\n    }\n    return lines;\n}\n// A class to read plain text interpreter data produced by ANTLR.\nvar InterpreterDataReader;\n(function (InterpreterDataReader) {\n    /**\n     * The structure of the data file is very simple. Everything is line based with empty lines\n     * separating the different parts. For lexers the layout is:\n     * token literal names:\n     * ...\n     *\n     * token symbolic names:\n     * ...\n     *\n     * rule names:\n     * ...\n     *\n     * channel names:\n     * ...\n     *\n     * mode names:\n     * ...\n     *\n     * atn:\n     * <a single line with comma separated int values> enclosed in a pair of squared brackets.\n     *\n     * Data for a parser does not contain channel and mode names.\n     */\n    function parseFile(fileName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let result = new InterpreterDataReader.InterpreterData();\n            result.ruleNames = [];\n            let input = yield util.promisify(fs.readFile)(fileName);\n            let lines = splitToLines(input);\n            try {\n                let line;\n                let lineIndex = 0;\n                let literalNames = [];\n                let symbolicNames = [];\n                line = lines[lineIndex++];\n                if (line !== \"token literal names:\") {\n                    throw new RangeError(\"Unexpected data entry\");\n                }\n                for (line = lines[lineIndex++]; line !== undefined; line = lines[lineIndex++]) {\n                    if (line.length === 0) {\n                        break;\n                    }\n                    literalNames.push(line === \"null\" ? \"\" : line);\n                }\n                line = lines[lineIndex++];\n                if (line !== \"token symbolic names:\") {\n                    throw new RangeError(\"Unexpected data entry\");\n                }\n                for (line = lines[lineIndex++]; line !== undefined; line = lines[lineIndex++]) {\n                    if (line.length === 0) {\n                        break;\n                    }\n                    symbolicNames.push(line === \"null\" ? \"\" : line);\n                }\n                let displayNames = [];\n                result.vocabulary = new VocabularyImpl_1.VocabularyImpl(literalNames, symbolicNames, displayNames);\n                line = lines[lineIndex++];\n                if (line !== \"rule names:\") {\n                    throw new RangeError(\"Unexpected data entry\");\n                }\n                for (line = lines[lineIndex++]; line !== undefined; line = lines[lineIndex++]) {\n                    if (line.length === 0) {\n                        break;\n                    }\n                    result.ruleNames.push(line);\n                }\n                line = lines[lineIndex++];\n                if (line === \"channel names:\") { // Additional lexer data.\n                    result.channels = [];\n                    for (line = lines[lineIndex++]; line !== undefined; line = lines[lineIndex++]) {\n                        if (line.length === 0) {\n                            break;\n                        }\n                        result.channels.push(line);\n                    }\n                    line = lines[lineIndex++];\n                    if (line !== \"mode names:\") {\n                        throw new RangeError(\"Unexpected data entry\");\n                    }\n                    result.modes = [];\n                    for (line = lines[lineIndex++]; line !== undefined; line = lines[lineIndex++]) {\n                        if (line.length === 0) {\n                            break;\n                        }\n                        result.modes.push(line);\n                    }\n                }\n                line = lines[lineIndex++];\n                if (line !== \"atn:\") {\n                    throw new RangeError(\"Unexpected data entry\");\n                }\n                line = lines[lineIndex++];\n                let elements = line.split(\",\");\n                let serializedATN = new Uint16Array(elements.length);\n                for (let i = 0; i < elements.length; ++i) {\n                    let value;\n                    let element = elements[i];\n                    if (element.startsWith(\"[\")) {\n                        value = parseInt(element.substring(1).trim(), 10);\n                    }\n                    else if (element.endsWith(\"]\")) {\n                        value = parseInt(element.substring(0, element.length - 1).trim(), 10);\n                    }\n                    else {\n                        value = parseInt(element.trim(), 10);\n                    }\n                    serializedATN[i] = value;\n                }\n                let deserializer = new ATNDeserializer_1.ATNDeserializer();\n                result.atn = deserializer.deserialize(serializedATN);\n            }\n            catch (e) {\n                // We just swallow the error and return empty objects instead.\n            }\n            return result;\n        });\n    }\n    InterpreterDataReader.parseFile = parseFile;\n    class InterpreterData {\n    }\n    InterpreterDataReader.InterpreterData = InterpreterData;\n})(InterpreterDataReader = exports.InterpreterDataReader || (exports.InterpreterDataReader = {}));\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\nimport * as fs from \"fs\";\nimport * as util from \"util\";\n\nimport { ATN } from \"../atn/ATN\";\nimport { Vocabulary } from \"../Vocabulary\";\nimport { VocabularyImpl } from \"../VocabularyImpl\";\nimport { ATNDeserializer } from \"../atn/ATNDeserializer\";\n\nfunction splitToLines(buffer: Buffer): string[] {\n\tlet lines: string[] = [];\n\n\tlet index = 0;\n\twhile (index < buffer.length) {\n\t\tlet lineStart = index;\n\t\tlet lineEndLF = buffer.indexOf(\"\\n\".charCodeAt(0), index);\n\t\tlet lineEndCR = buffer.indexOf(\"\\r\".charCodeAt(0), index);\n\t\tlet lineEnd: number;\n\t\tif (lineEndCR >= 0 && (lineEndCR < lineEndLF || lineEndLF === -1)) {\n\t\t\tlineEnd = lineEndCR;\n\t\t} else if (lineEndLF >= 0) {\n\t\t\tlineEnd = lineEndLF;\n\t\t} else {\n\t\t\tlineEnd = buffer.length;\n\t\t}\n\n\t\tlines.push(buffer.toString(\"utf-8\", lineStart, lineEnd));\n\t\tif (lineEnd === lineEndCR && lineEnd + 1 === lineEndLF) {\n\t\t\tindex = lineEnd + 2;\n\t\t} else {\n\t\t\tindex = lineEnd + 1;\n\t\t}\n\t}\n\n\treturn lines;\n}\n\n// A class to read plain text interpreter data produced by ANTLR.\nexport namespace InterpreterDataReader {\n\t/**\n\t * The structure of the data file is very simple. Everything is line based with empty lines\n\t * separating the different parts. For lexers the layout is:\n\t * token literal names:\n\t * ...\n\t *\n\t * token symbolic names:\n\t * ...\n\t *\n\t * rule names:\n\t * ...\n\t *\n\t * channel names:\n\t * ...\n\t *\n\t * mode names:\n\t * ...\n\t *\n\t * atn:\n\t * <a single line with comma separated int values> enclosed in a pair of squared brackets.\n\t *\n\t * Data for a parser does not contain channel and mode names.\n\t */\n\texport async function parseFile(fileName: string): Promise<InterpreterDataReader.InterpreterData> {\n\t\tlet result: InterpreterDataReader.InterpreterData = new InterpreterDataReader.InterpreterData();\n\t\tresult.ruleNames = [];\n\n\t\tlet input: Buffer = await util.promisify(fs.readFile)(fileName);\n\t\tlet lines = splitToLines(input);\n\n\t\ttry {\n\t\t\tlet line: string;\n\t\t\tlet lineIndex: number = 0;\n\t\t\tlet literalNames: string[] = [];\n\t\t\tlet symbolicNames: string[] = [];\n\n\t\t\tline = lines[lineIndex++];\n\t\t\tif (line !== \"token literal names:\") {\n\t\t\t\tthrow new RangeError(\"Unexpected data entry\");\n\t\t\t}\n\n\t\t\tfor (line = lines[lineIndex++]; line !== undefined; line = lines[lineIndex++]) {\n\t\t\t\tif (line.length === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tliteralNames.push(line === \"null\" ? \"\" : line);\n\t\t\t}\n\n\t\t\tline = lines[lineIndex++];\n\t\t\tif (line !== \"token symbolic names:\") {\n\t\t\t\tthrow new RangeError(\"Unexpected data entry\");\n\t\t\t}\n\n\t\t\tfor (line = lines[lineIndex++]; line !== undefined; line = lines[lineIndex++]) {\n\t\t\t\tif (line.length === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tsymbolicNames.push(line === \"null\" ? \"\" : line);\n\t\t\t}\n\n\t\t\tlet displayNames: string[] = [];\n\t\t\tresult.vocabulary = new VocabularyImpl(literalNames, symbolicNames, displayNames);\n\n\t\t\tline = lines[lineIndex++];\n\t\t\tif (line !== \"rule names:\") {\n\t\t\t\tthrow new RangeError(\"Unexpected data entry\");\n\t\t\t}\n\n\t\t\tfor (line = lines[lineIndex++]; line !== undefined; line = lines[lineIndex++]) {\n\t\t\t\tif (line.length === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tresult.ruleNames.push(line);\n\t\t\t}\n\n\t\t\tline = lines[lineIndex++];\n\t\t\tif (line === \"channel names:\") { // Additional lexer data.\n\t\t\t\tresult.channels = [];\n\t\t\t\tfor (line = lines[lineIndex++]; line !== undefined; line = lines[lineIndex++]) {\n\t\t\t\t\tif (line.length === 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult.channels.push(line);\n\t\t\t\t}\n\n\t\t\t\tline = lines[lineIndex++];\n\t\t\t\tif (line !== \"mode names:\") {\n\t\t\t\t\tthrow new RangeError(\"Unexpected data entry\");\n\t\t\t\t}\n\n\t\t\t\tresult.modes = [];\n\t\t\t\tfor (line = lines[lineIndex++]; line !== undefined; line = lines[lineIndex++]) {\n\t\t\t\t\tif (line.length === 0) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tresult.modes.push(line);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tline = lines[lineIndex++];\n\t\t\tif (line !== \"atn:\") {\n\t\t\t\tthrow new RangeError(\"Unexpected data entry\");\n\t\t\t}\n\n\t\t\tline = lines[lineIndex++];\n\t\t\tlet elements: string[] = line.split(\",\");\n\t\t\tlet serializedATN: Uint16Array = new Uint16Array(elements.length);\n\n\t\t\tfor (let i: number = 0; i < elements.length; ++i) {\n\t\t\t\tlet value: number;\n\t\t\t\tlet element: string = elements[i];\n\t\t\t\tif (element.startsWith(\"[\")) {\n\t\t\t\t\tvalue = parseInt(element.substring(1).trim(), 10);\n\t\t\t\t}\n\t\t\t\telse if (element.endsWith(\"]\")) {\n\t\t\t\t\tvalue = parseInt(element.substring(0, element.length - 1).trim(), 10);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tvalue = parseInt(element.trim(), 10);\n\t\t\t\t}\n\n\t\t\t\tserializedATN[i] = value;\n\t\t\t}\n\n\t\t\tlet deserializer: ATNDeserializer = new ATNDeserializer();\n\t\t\tresult.atn = deserializer.deserialize(serializedATN);\n\t\t}\n\t\tcatch (e) {\n\t\t\t// We just swallow the error and return empty objects instead.\n\t\t}\n\n\t\treturn result;\n\t}\n\n\texport class InterpreterData {\n\t\tpublic atn: ATN;\n\t\tpublic vocabulary: Vocabulary;\n\t\tpublic ruleNames: string[];\n\t\tpublic channels: string[]; // Only valid for lexer grammars.\n\t\tpublic modes: string[]; // ditto\n\t}\n}\n"]}