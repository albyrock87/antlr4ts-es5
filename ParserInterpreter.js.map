{"version":3,"sources":["ParserInterpreter.js","../src/ParserInterpreter.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","ATNState_1","require","ATNStateType_1","BitSet_1","FailedPredicateException_1","InputMismatchException_1","InterpreterRuleContext_1","LoopEndState_1","Decorators_1","Decorators_2","Parser_1","ParserATNSimulator_1","RecognitionException_1","StarLoopEntryState_1","Token_1","ParserInterpreter","grammarFileName","vocabulary","ruleNames","atn","input","inputStream","_parentContextStack","overrideDecision","overrideDecisionInputIndex","overrideDecisionAlt","overrideDecisionReached","_overrideDecisionRoot","undefined","old","_grammarFileName","_atn","pushRecursionContextStates","_ruleNames","_vocabulary","interpreter","ParserATNSimulator","slice","BitSet","states","state","StarLoopEntryState","precedenceRuleDecision","set","stateNumber","resetInput","startRuleIndex","startRuleStartState","ruleToStartState","_rootContext","createInterpreterRuleContext","ATNState","INVALID_STATE_NUMBER","isPrecedenceRule","enterRecursionRule","enterRule","p","atnState","stateType","ATNStateType","RULE_STOP","_ctx","isEmpty","result","parentContext","pop","unrollRecursionContexts","exitRule","visitRuleStopState","visitState","e","RecognitionException","ruleToStopState","ruleIndex","context","exception","errorHandler","reportError","recover","localctx","precedence","push","invokingState","predictedAlt","numberOfTransitions","visitDecisionState","transition","serializationType","get","LoopEndState","pushNewRecursionContext","match","_label","matches","_input","LA","Token","MIN_USER_TOKEN_TYPE","recoverInline","matchWildcard","ruleStartState","newctx","predicateTransition","sempred","predIndex","FailedPredicateException","actionTransition","action","actionIndex","precpred","Error","sync","decision","index","adaptivePredict","parent","invokingStateNumber","InterpreterRuleContext","ruleTransition","followState","tokenIndex","forcedAlt","tok","getOffendingToken","source","tokenSource","stream","sourcePair","InputMismatchException","expectedTokens","expectedTokenType","INVALID_TYPE","isNil","minElement","errToken","tokenFactory","create","text","DEFAULT_CHANNEL","line","charPositionInLine","addErrorNode","createErrorNode","_errHandler","Parser","NotNull","prototype","Override"],"mappings":"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","file":"ParserInterpreter.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ATNState_1 = require(\"./atn/ATNState\");\nconst ATNStateType_1 = require(\"./atn/ATNStateType\");\nconst BitSet_1 = require(\"./misc/BitSet\");\nconst FailedPredicateException_1 = require(\"./FailedPredicateException\");\nconst InputMismatchException_1 = require(\"./InputMismatchException\");\nconst InterpreterRuleContext_1 = require(\"./InterpreterRuleContext\");\nconst LoopEndState_1 = require(\"./atn/LoopEndState\");\nconst Decorators_1 = require(\"./Decorators\");\nconst Decorators_2 = require(\"./Decorators\");\nconst Parser_1 = require(\"./Parser\");\nconst ParserATNSimulator_1 = require(\"./atn/ParserATNSimulator\");\nconst RecognitionException_1 = require(\"./RecognitionException\");\nconst StarLoopEntryState_1 = require(\"./atn/StarLoopEntryState\");\nconst Token_1 = require(\"./Token\");\n/** A parser simulator that mimics what ANTLR's generated\n *  parser code does. A ParserATNSimulator is used to make\n *  predictions via adaptivePredict but this class moves a pointer through the\n *  ATN to simulate parsing. ParserATNSimulator just\n *  makes us efficient rather than having to backtrack, for example.\n *\n *  This properly creates parse trees even for left recursive rules.\n *\n *  We rely on the left recursive rule invocation and special predicate\n *  transitions to make left recursive rules work.\n *\n *  See TestParserInterpreter for examples.\n */\nlet ParserInterpreter = class ParserInterpreter extends Parser_1.Parser {\n    constructor(grammarFileName, vocabulary, ruleNames, atn, input) {\n        super(grammarFileName instanceof ParserInterpreter ? grammarFileName.inputStream : input);\n        /** This stack corresponds to the _parentctx, _parentState pair of locals\n         *  that would exist on call stack frames with a recursive descent parser;\n         *  in the generated function for a left-recursive rule you'd see:\n         *\n         *  private EContext e(int _p) {\n         *      ParserRuleContext _parentctx = _ctx;    // Pair.a\n         *      int _parentState = state;          // Pair.b\n         *      ...\n         *  }\n         *\n         *  Those values are used to create new recursive rule invocation contexts\n         *  associated with left operand of an alt like \"expr '*' expr\".\n         */\n        this._parentContextStack = [];\n        /** We need a map from (decision,inputIndex)->forced alt for computing ambiguous\n         *  parse trees. For now, we allow exactly one override.\n         */\n        this.overrideDecision = -1;\n        this.overrideDecisionInputIndex = -1;\n        this.overrideDecisionAlt = -1;\n        this.overrideDecisionReached = false; // latch and only override once; error might trigger infinite loop\n        /** What is the current context when we override a decisions?  This tells\n         *  us what the root of the parse tree is when using override\n         *  for an ambiguity/lookahead check.\n         */\n        this._overrideDecisionRoot = undefined;\n        if (grammarFileName instanceof ParserInterpreter) {\n            let old = grammarFileName;\n            this._grammarFileName = old._grammarFileName;\n            this._atn = old._atn;\n            this.pushRecursionContextStates = old.pushRecursionContextStates;\n            this._ruleNames = old._ruleNames;\n            this._vocabulary = old._vocabulary;\n            this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this._atn, this);\n        }\n        else {\n            // The second constructor requires non-null arguments\n            vocabulary = vocabulary;\n            ruleNames = ruleNames;\n            atn = atn;\n            this._grammarFileName = grammarFileName;\n            this._atn = atn;\n            this._ruleNames = ruleNames.slice(0);\n            this._vocabulary = vocabulary;\n            // identify the ATN states where pushNewRecursionContext() must be called\n            this.pushRecursionContextStates = new BitSet_1.BitSet(atn.states.length);\n            for (let state of atn.states) {\n                if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {\n                    continue;\n                }\n                if (state.precedenceRuleDecision) {\n                    this.pushRecursionContextStates.set(state.stateNumber);\n                }\n            }\n            // get atn simulator that knows how to do predictions\n            this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(atn, this);\n        }\n    }\n    reset(resetInput) {\n        if (resetInput === undefined) {\n            super.reset();\n        }\n        else {\n            super.reset(resetInput);\n        }\n        this.overrideDecisionReached = false;\n        this._overrideDecisionRoot = undefined;\n    }\n    get atn() {\n        return this._atn;\n    }\n    get vocabulary() {\n        return this._vocabulary;\n    }\n    get ruleNames() {\n        return this._ruleNames;\n    }\n    get grammarFileName() {\n        return this._grammarFileName;\n    }\n    /** Begin parsing at startRuleIndex */\n    parse(startRuleIndex) {\n        let startRuleStartState = this._atn.ruleToStartState[startRuleIndex];\n        this._rootContext = this.createInterpreterRuleContext(undefined, ATNState_1.ATNState.INVALID_STATE_NUMBER, startRuleIndex);\n        if (startRuleStartState.isPrecedenceRule) {\n            this.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);\n        }\n        else {\n            this.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);\n        }\n        while (true) {\n            let p = this.atnState;\n            switch (p.stateType) {\n                case ATNStateType_1.ATNStateType.RULE_STOP:\n                    // pop; return from rule\n                    if (this._ctx.isEmpty) {\n                        if (startRuleStartState.isPrecedenceRule) {\n                            let result = this._ctx;\n                            let parentContext = this._parentContextStack.pop();\n                            this.unrollRecursionContexts(parentContext[0]);\n                            return result;\n                        }\n                        else {\n                            this.exitRule();\n                            return this._rootContext;\n                        }\n                    }\n                    this.visitRuleStopState(p);\n                    break;\n                default:\n                    try {\n                        this.visitState(p);\n                    }\n                    catch (e) {\n                        if (e instanceof RecognitionException_1.RecognitionException) {\n                            this.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;\n                            this.context.exception = e;\n                            this.errorHandler.reportError(this, e);\n                            this.recover(e);\n                        }\n                        else {\n                            throw e;\n                        }\n                    }\n                    break;\n            }\n        }\n    }\n    enterRecursionRule(localctx, state, ruleIndex, precedence) {\n        this._parentContextStack.push([this._ctx, localctx.invokingState]);\n        super.enterRecursionRule(localctx, state, ruleIndex, precedence);\n    }\n    get atnState() {\n        return this._atn.states[this.state];\n    }\n    visitState(p) {\n        let predictedAlt = 1;\n        if (p.numberOfTransitions > 1) {\n            predictedAlt = this.visitDecisionState(p);\n        }\n        let transition = p.transition(predictedAlt - 1);\n        switch (transition.serializationType) {\n            case 1 /* EPSILON */:\n                if (this.pushRecursionContextStates.get(p.stateNumber) &&\n                    !(transition.target instanceof LoopEndState_1.LoopEndState)) {\n                    // We are at the start of a left recursive rule's (...)* loop\n                    // and we're not taking the exit branch of loop.\n                    let parentContext = this._parentContextStack[this._parentContextStack.length - 1];\n                    let localctx = this.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);\n                    this.pushNewRecursionContext(localctx, this._atn.ruleToStartState[p.ruleIndex].stateNumber, this._ctx.ruleIndex);\n                }\n                break;\n            case 5 /* ATOM */:\n                this.match(transition._label);\n                break;\n            case 2 /* RANGE */:\n            case 7 /* SET */:\n            case 8 /* NOT_SET */:\n                if (!transition.matches(this._input.LA(1), Token_1.Token.MIN_USER_TOKEN_TYPE, 65535)) {\n                    this.recoverInline();\n                }\n                this.matchWildcard();\n                break;\n            case 9 /* WILDCARD */:\n                this.matchWildcard();\n                break;\n            case 3 /* RULE */:\n                let ruleStartState = transition.target;\n                let ruleIndex = ruleStartState.ruleIndex;\n                let newctx = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);\n                if (ruleStartState.isPrecedenceRule) {\n                    this.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, transition.precedence);\n                }\n                else {\n                    this.enterRule(newctx, transition.target.stateNumber, ruleIndex);\n                }\n                break;\n            case 4 /* PREDICATE */:\n                let predicateTransition = transition;\n                if (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {\n                    throw new FailedPredicateException_1.FailedPredicateException(this);\n                }\n                break;\n            case 6 /* ACTION */:\n                let actionTransition = transition;\n                this.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);\n                break;\n            case 10 /* PRECEDENCE */:\n                if (!this.precpred(this._ctx, transition.precedence)) {\n                    let precedence = transition.precedence;\n                    throw new FailedPredicateException_1.FailedPredicateException(this, `precpred(_ctx, ${precedence})`);\n                }\n                break;\n            default:\n                throw new Error(\"UnsupportedOperationException: Unrecognized ATN transition type.\");\n        }\n        this.state = transition.target.stateNumber;\n    }\n    /** Method visitDecisionState() is called when the interpreter reaches\n     *  a decision state (instance of DecisionState). It gives an opportunity\n     *  for subclasses to track interesting things.\n     */\n    visitDecisionState(p) {\n        let predictedAlt;\n        this.errorHandler.sync(this);\n        let decision = p.decision;\n        if (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {\n            predictedAlt = this.overrideDecisionAlt;\n            this.overrideDecisionReached = true;\n        }\n        else {\n            predictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);\n        }\n        return predictedAlt;\n    }\n    /** Provide simple \"factory\" for InterpreterRuleContext's.\n     *  @since 4.5.1\n     */\n    createInterpreterRuleContext(parent, invokingStateNumber, ruleIndex) {\n        return new InterpreterRuleContext_1.InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);\n    }\n    visitRuleStopState(p) {\n        let ruleStartState = this._atn.ruleToStartState[p.ruleIndex];\n        if (ruleStartState.isPrecedenceRule) {\n            let parentContext = this._parentContextStack.pop();\n            this.unrollRecursionContexts(parentContext[0]);\n            this.state = parentContext[1];\n        }\n        else {\n            this.exitRule();\n        }\n        let ruleTransition = this._atn.states[this.state].transition(0);\n        this.state = ruleTransition.followState.stateNumber;\n    }\n    /** Override this parser interpreters normal decision-making process\n     *  at a particular decision and input token index. Instead of\n     *  allowing the adaptive prediction mechanism to choose the\n     *  first alternative within a block that leads to a successful parse,\n     *  force it to take the alternative, 1..n for n alternatives.\n     *\n     *  As an implementation limitation right now, you can only specify one\n     *  override. This is sufficient to allow construction of different\n     *  parse trees for ambiguous input. It means re-parsing the entire input\n     *  in general because you're never sure where an ambiguous sequence would\n     *  live in the various parse trees. For example, in one interpretation,\n     *  an ambiguous input sequence would be matched completely in expression\n     *  but in another it could match all the way back to the root.\n     *\n     *  s : e '!'? ;\n     *  e : ID\n     *    | ID '!'\n     *    ;\n     *\n     *  Here, x! can be matched as (s (e ID) !) or (s (e ID !)). In the first\n     *  case, the ambiguous sequence is fully contained only by the root.\n     *  In the second case, the ambiguous sequences fully contained within just\n     *  e, as in: (e ID !).\n     *\n     *  Rather than trying to optimize this and make\n     *  some intelligent decisions for optimization purposes, I settled on\n     *  just re-parsing the whole input and then using\n     *  {link Trees#getRootOfSubtreeEnclosingRegion} to find the minimal\n     *  subtree that contains the ambiguous sequence. I originally tried to\n     *  record the call stack at the point the parser detected and ambiguity but\n     *  left recursive rules create a parse tree stack that does not reflect\n     *  the actual call stack. That impedance mismatch was enough to make\n     *  it it challenging to restart the parser at a deeply nested rule\n     *  invocation.\n     *\n     *  Only parser interpreters can override decisions so as to avoid inserting\n     *  override checking code in the critical ALL(*) prediction execution path.\n     *\n     *  @since 4.5\n     */\n    addDecisionOverride(decision, tokenIndex, forcedAlt) {\n        this.overrideDecision = decision;\n        this.overrideDecisionInputIndex = tokenIndex;\n        this.overrideDecisionAlt = forcedAlt;\n    }\n    get overrideDecisionRoot() {\n        return this._overrideDecisionRoot;\n    }\n    /** Rely on the error handler for this parser but, if no tokens are consumed\n     *  to recover, add an error node. Otherwise, nothing is seen in the parse\n     *  tree.\n     */\n    recover(e) {\n        let i = this._input.index;\n        this.errorHandler.recover(this, e);\n        if (this._input.index === i) {\n            // no input consumed, better add an error node\n            let tok = e.getOffendingToken();\n            if (!tok) {\n                throw new Error(\"Expected exception to have an offending token\");\n            }\n            let source = tok.tokenSource;\n            let stream = source !== undefined ? source.inputStream : undefined;\n            let sourcePair = { source, stream };\n            if (e instanceof InputMismatchException_1.InputMismatchException) {\n                let expectedTokens = e.expectedTokens;\n                if (expectedTokens === undefined) {\n                    throw new Error(\"Expected the exception to provide expected tokens\");\n                }\n                let expectedTokenType = Token_1.Token.INVALID_TYPE;\n                if (!expectedTokens.isNil) {\n                    // get any element\n                    expectedTokenType = expectedTokens.minElement;\n                }\n                let errToken = this.tokenFactory.create(sourcePair, expectedTokenType, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, // invalid start/stop\n                tok.line, tok.charPositionInLine);\n                this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));\n            }\n            else { // NoViableAlt\n                let source = tok.tokenSource;\n                let errToken = this.tokenFactory.create(sourcePair, Token_1.Token.INVALID_TYPE, tok.text, Token_1.Token.DEFAULT_CHANNEL, -1, -1, // invalid start/stop\n                tok.line, tok.charPositionInLine);\n                this._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));\n            }\n        }\n    }\n    recoverInline() {\n        return this._errHandler.recoverInline(this);\n    }\n    /** Return the root of the parse, which can be useful if the parser\n     *  bails out. You still can access the top node. Note that,\n     *  because of the way left recursive rules add children, it's possible\n     *  that the root will not have any children if the start rule immediately\n     *  called and left recursive rule that fails.\n     *\n     * @since 4.5.1\n     */\n    get rootContext() {\n        return this._rootContext;\n    }\n};\n__decorate([\n    Decorators_1.NotNull\n], ParserInterpreter.prototype, \"_vocabulary\", void 0);\n__decorate([\n    Decorators_2.Override\n], ParserInterpreter.prototype, \"reset\", null);\n__decorate([\n    Decorators_2.Override\n], ParserInterpreter.prototype, \"atn\", null);\n__decorate([\n    Decorators_2.Override\n], ParserInterpreter.prototype, \"vocabulary\", null);\n__decorate([\n    Decorators_2.Override\n], ParserInterpreter.prototype, \"ruleNames\", null);\n__decorate([\n    Decorators_2.Override\n], ParserInterpreter.prototype, \"grammarFileName\", null);\n__decorate([\n    Decorators_2.Override\n], ParserInterpreter.prototype, \"enterRecursionRule\", null);\nParserInterpreter = __decorate([\n    __param(1, Decorators_1.NotNull)\n], ParserInterpreter);\nexports.ParserInterpreter = ParserInterpreter;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:53.1043451-07:00\n\nimport { ActionTransition } from \"./atn/ActionTransition\";\nimport { ATN } from \"./atn/ATN\";\nimport { ATNState } from \"./atn/ATNState\";\nimport { ATNStateType } from \"./atn/ATNStateType\";\nimport { AtomTransition } from \"./atn/AtomTransition\";\nimport { BitSet } from \"./misc/BitSet\";\nimport { DecisionState } from \"./atn/DecisionState\";\nimport { FailedPredicateException } from \"./FailedPredicateException\";\nimport { InputMismatchException } from \"./InputMismatchException\";\nimport { InterpreterRuleContext } from \"./InterpreterRuleContext\";\nimport { LoopEndState } from \"./atn/LoopEndState\";\nimport { NotNull } from \"./Decorators\";\nimport { Override } from \"./Decorators\";\nimport { Parser } from \"./Parser\";\nimport { ParserATNSimulator } from \"./atn/ParserATNSimulator\";\nimport { ParserRuleContext } from \"./ParserRuleContext\";\nimport { PrecedencePredicateTransition } from \"./atn/PrecedencePredicateTransition\";\nimport { PredicateTransition } from \"./atn/PredicateTransition\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { RuleStartState } from \"./atn/RuleStartState\";\nimport { RuleTransition } from \"./atn/RuleTransition\";\nimport { StarLoopEntryState } from \"./atn/StarLoopEntryState\";\nimport { Token } from \"./Token\";\nimport { TokenStream } from \"./TokenStream\";\nimport { Transition } from \"./atn/Transition\";\nimport { TransitionType } from \"./atn/TransitionType\";\nimport { Vocabulary } from \"./Vocabulary\";\n\n/** A parser simulator that mimics what ANTLR's generated\n *  parser code does. A ParserATNSimulator is used to make\n *  predictions via adaptivePredict but this class moves a pointer through the\n *  ATN to simulate parsing. ParserATNSimulator just\n *  makes us efficient rather than having to backtrack, for example.\n *\n *  This properly creates parse trees even for left recursive rules.\n *\n *  We rely on the left recursive rule invocation and special predicate\n *  transitions to make left recursive rules work.\n *\n *  See TestParserInterpreter for examples.\n */\nexport class ParserInterpreter extends Parser {\n\tprotected _grammarFileName: string;\n\tprotected _atn: ATN;\n\t/** This identifies StarLoopEntryState's that begin the (...)*\n\t *  precedence loops of left recursive rules.\n\t */\n\tprotected pushRecursionContextStates: BitSet;\n\n\tprotected _ruleNames: string[];\n\t@NotNull\n\tprivate _vocabulary: Vocabulary;\n\n\t/** This stack corresponds to the _parentctx, _parentState pair of locals\n\t *  that would exist on call stack frames with a recursive descent parser;\n\t *  in the generated function for a left-recursive rule you'd see:\n\t *\n\t *  private EContext e(int _p) {\n\t *      ParserRuleContext _parentctx = _ctx;    // Pair.a\n\t *      int _parentState = state;          // Pair.b\n\t *      ...\n\t *  }\n\t *\n\t *  Those values are used to create new recursive rule invocation contexts\n\t *  associated with left operand of an alt like \"expr '*' expr\".\n\t */\n\tprotected readonly _parentContextStack: Array<[ParserRuleContext, number]> = [];\n\n\t/** We need a map from (decision,inputIndex)->forced alt for computing ambiguous\n\t *  parse trees. For now, we allow exactly one override.\n\t */\n\tprotected overrideDecision: number = -1;\n\tprotected overrideDecisionInputIndex: number = -1;\n\tprotected overrideDecisionAlt: number = -1;\n\tprotected overrideDecisionReached: boolean = false; // latch and only override once; error might trigger infinite loop\n\n\t/** What is the current context when we override a decisions?  This tells\n\t *  us what the root of the parse tree is when using override\n\t *  for an ambiguity/lookahead check.\n\t */\n\tprotected _overrideDecisionRoot?: InterpreterRuleContext = undefined;\n\n\tprotected _rootContext: InterpreterRuleContext;\n\n\t/** A copy constructor that creates a new parser interpreter by reusing\n\t *  the fields of a previous interpreter.\n\t *\n\t *  @param old The interpreter to copy\n\t *\n\t *  @since 4.5\n\t */\n\tconstructor(/*@NotNull*/ old: ParserInterpreter);\n\tconstructor(\n\t\tgrammarFileName: string, /*@NotNull*/ vocabulary: Vocabulary,\n\t\truleNames: string[], atn: ATN, input: TokenStream);\n\tconstructor(\n\t\tgrammarFileName: ParserInterpreter | string, @NotNull vocabulary?: Vocabulary,\n\t\truleNames?: string[], atn?: ATN, input?: TokenStream) {\n\t\tsuper(grammarFileName instanceof ParserInterpreter ? grammarFileName.inputStream : input!);\n\t\tif (grammarFileName instanceof ParserInterpreter) {\n\t\t\tlet old: ParserInterpreter = grammarFileName;\n\t\t\tthis._grammarFileName = old._grammarFileName;\n\t\t\tthis._atn = old._atn;\n\t\t\tthis.pushRecursionContextStates = old.pushRecursionContextStates;\n\t\t\tthis._ruleNames = old._ruleNames;\n\t\t\tthis._vocabulary = old._vocabulary;\n\t\t\tthis.interpreter = new ParserATNSimulator(this._atn, this);\n\t\t} else {\n\t\t\t// The second constructor requires non-null arguments\n\t\t\tvocabulary = vocabulary!;\n\t\t\truleNames = ruleNames!;\n\t\t\tatn = atn!;\n\n\t\t\tthis._grammarFileName = grammarFileName;\n\t\t\tthis._atn = atn;\n\t\t\tthis._ruleNames = ruleNames.slice(0);\n\t\t\tthis._vocabulary = vocabulary;\n\n\t\t\t// identify the ATN states where pushNewRecursionContext() must be called\n\t\t\tthis.pushRecursionContextStates = new BitSet(atn.states.length);\n\t\t\tfor (let state of atn.states) {\n\t\t\t\tif (!(state instanceof StarLoopEntryState)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (state.precedenceRuleDecision) {\n\t\t\t\t\tthis.pushRecursionContextStates.set(state.stateNumber);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// get atn simulator that knows how to do predictions\n\t\t\tthis.interpreter = new ParserATNSimulator(atn, this);\n\t\t}\n\t}\n\n\t@Override\n\tpublic reset(resetInput?: boolean): void {\n\t\tif (resetInput === undefined) {\n\t\t\tsuper.reset();\n\t\t} else {\n\t\t\tsuper.reset(resetInput);\n\t\t}\n\n\t\tthis.overrideDecisionReached = false;\n\t\tthis._overrideDecisionRoot = undefined;\n\t}\n\n\t@Override\n\tget atn(): ATN {\n\t\treturn this._atn;\n\t}\n\n\t@Override\n\tget vocabulary(): Vocabulary {\n\t\treturn this._vocabulary;\n\t}\n\n\t@Override\n\tget ruleNames(): string[] {\n\t\treturn this._ruleNames;\n\t}\n\n\t@Override\n\tget grammarFileName(): string {\n\t\treturn this._grammarFileName;\n\t}\n\n\t/** Begin parsing at startRuleIndex */\n\tpublic parse(startRuleIndex: number): ParserRuleContext {\n\t\tlet startRuleStartState: RuleStartState = this._atn.ruleToStartState[startRuleIndex];\n\n\t\tthis._rootContext = this.createInterpreterRuleContext(undefined, ATNState.INVALID_STATE_NUMBER, startRuleIndex);\n\t\tif (startRuleStartState.isPrecedenceRule) {\n\t\t\tthis.enterRecursionRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex, 0);\n\t\t}\n\t\telse {\n\t\t\tthis.enterRule(this._rootContext, startRuleStartState.stateNumber, startRuleIndex);\n\t\t}\n\n\t\twhile (true) {\n\t\t\tlet p: ATNState = this.atnState;\n\t\t\tswitch (p.stateType) {\n\t\t\tcase ATNStateType.RULE_STOP:\n\t\t\t\t// pop; return from rule\n\t\t\t\tif (this._ctx.isEmpty) {\n\t\t\t\t\tif (startRuleStartState.isPrecedenceRule) {\n\t\t\t\t\t\tlet result: ParserRuleContext = this._ctx;\n\t\t\t\t\t\tlet parentContext: [ParserRuleContext, number] = this._parentContextStack.pop() !;\n\t\t\t\t\t\tthis.unrollRecursionContexts(parentContext[0]);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.exitRule();\n\t\t\t\t\t\treturn this._rootContext;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.visitRuleStopState(p);\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\ttry {\n\t\t\t\t\tthis.visitState(p);\n\t\t\t\t}\n\t\t\t\tcatch (e) {\n\t\t\t\t\tif (e instanceof RecognitionException) {\n\t\t\t\t\t\tthis.state = this._atn.ruleToStopState[p.ruleIndex].stateNumber;\n\t\t\t\t\t\tthis.context.exception = e;\n\t\t\t\t\t\tthis.errorHandler.reportError(this, e);\n\t\t\t\t\t\tthis.recover(e);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow e;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic enterRecursionRule(localctx: ParserRuleContext, state: number, ruleIndex: number, precedence: number): void {\n\t\tthis._parentContextStack.push([this._ctx, localctx.invokingState]);\n\t\tsuper.enterRecursionRule(localctx, state, ruleIndex, precedence);\n\t}\n\n\tprotected get atnState(): ATNState {\n\t\treturn this._atn.states[this.state];\n\t}\n\n\tprotected visitState(p: ATNState): void {\n\t\tlet predictedAlt: number = 1;\n\t\tif (p.numberOfTransitions > 1) {\n\t\t\tpredictedAlt = this.visitDecisionState(p as DecisionState);\n\t\t}\n\n\t\tlet transition: Transition = p.transition(predictedAlt - 1);\n\t\tswitch (transition.serializationType) {\n\t\tcase TransitionType.EPSILON:\n\t\t\tif (this.pushRecursionContextStates.get(p.stateNumber) &&\n\t\t\t\t!(transition.target instanceof LoopEndState)) {\n\t\t\t\t// We are at the start of a left recursive rule's (...)* loop\n\t\t\t\t// and we're not taking the exit branch of loop.\n\t\t\t\tlet parentContext = this._parentContextStack[this._parentContextStack.length - 1];\n\t\t\t\tlet localctx: InterpreterRuleContext =\n\t\t\t\t\tthis.createInterpreterRuleContext(parentContext[0], parentContext[1], this._ctx.ruleIndex);\n\t\t\t\tthis.pushNewRecursionContext(localctx,\n\t\t\t\t\tthis._atn.ruleToStartState[p.ruleIndex].stateNumber,\n\t\t\t\t\tthis._ctx.ruleIndex);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TransitionType.ATOM:\n\t\t\tthis.match((transition as AtomTransition)._label);\n\t\t\tbreak;\n\n\t\tcase TransitionType.RANGE:\n\t\tcase TransitionType.SET:\n\t\tcase TransitionType.NOT_SET:\n\t\t\tif (!transition.matches(this._input.LA(1), Token.MIN_USER_TOKEN_TYPE, 65535)) {\n\t\t\t\tthis.recoverInline();\n\t\t\t}\n\t\t\tthis.matchWildcard();\n\t\t\tbreak;\n\n\t\tcase TransitionType.WILDCARD:\n\t\t\tthis.matchWildcard();\n\t\t\tbreak;\n\n\t\tcase TransitionType.RULE:\n\t\t\tlet ruleStartState: RuleStartState = transition.target as RuleStartState;\n\t\t\tlet ruleIndex: number = ruleStartState.ruleIndex;\n\t\t\tlet newctx: InterpreterRuleContext = this.createInterpreterRuleContext(this._ctx, p.stateNumber, ruleIndex);\n\t\t\tif (ruleStartState.isPrecedenceRule) {\n\t\t\t\tthis.enterRecursionRule(newctx, ruleStartState.stateNumber, ruleIndex, (transition as RuleTransition).precedence);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.enterRule(newctx, transition.target.stateNumber, ruleIndex);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase TransitionType.PREDICATE:\n\t\t\tlet predicateTransition: PredicateTransition = transition as PredicateTransition;\n\t\t\tif (!this.sempred(this._ctx, predicateTransition.ruleIndex, predicateTransition.predIndex)) {\n\t\t\t\tthrow new FailedPredicateException(this);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase TransitionType.ACTION:\n\t\t\tlet actionTransition: ActionTransition = transition as ActionTransition;\n\t\t\tthis.action(this._ctx, actionTransition.ruleIndex, actionTransition.actionIndex);\n\t\t\tbreak;\n\n\t\tcase TransitionType.PRECEDENCE:\n\t\t\tif (!this.precpred(this._ctx, (transition as PrecedencePredicateTransition).precedence)) {\n\t\t\t\tlet precedence = (transition as PrecedencePredicateTransition).precedence;\n\t\t\t\tthrow new FailedPredicateException(this, `precpred(_ctx, ${precedence})`);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tthrow new Error(\"UnsupportedOperationException: Unrecognized ATN transition type.\");\n\t\t}\n\n\t\tthis.state = transition.target.stateNumber;\n\t}\n\n\t/** Method visitDecisionState() is called when the interpreter reaches\n\t *  a decision state (instance of DecisionState). It gives an opportunity\n\t *  for subclasses to track interesting things.\n\t */\n\tprotected visitDecisionState(p: DecisionState): number {\n\t\tlet predictedAlt: number;\n\t\tthis.errorHandler.sync(this);\n\t\tlet decision: number = p.decision;\n\t\tif (decision === this.overrideDecision && this._input.index === this.overrideDecisionInputIndex && !this.overrideDecisionReached) {\n\t\t\tpredictedAlt = this.overrideDecisionAlt;\n\t\t\tthis.overrideDecisionReached = true;\n\t\t}\n\t\telse {\n\t\t\tpredictedAlt = this.interpreter.adaptivePredict(this._input, decision, this._ctx);\n\t\t}\n\t\treturn predictedAlt;\n\t}\n\n\t/** Provide simple \"factory\" for InterpreterRuleContext's.\n\t *  @since 4.5.1\n\t */\n\tprotected createInterpreterRuleContext(\n\t\tparent: ParserRuleContext | undefined,\n\t\tinvokingStateNumber: number,\n\t\truleIndex: number): InterpreterRuleContext {\n\t\treturn new InterpreterRuleContext(ruleIndex, parent, invokingStateNumber);\n\t}\n\n\tprotected visitRuleStopState(p: ATNState): void {\n\t\tlet ruleStartState: RuleStartState = this._atn.ruleToStartState[p.ruleIndex];\n\t\tif (ruleStartState.isPrecedenceRule) {\n\t\t\tlet parentContext: [ParserRuleContext, number] = this._parentContextStack.pop()!;\n\t\t\tthis.unrollRecursionContexts(parentContext[0]);\n\t\t\tthis.state = parentContext[1];\n\t\t}\n\t\telse {\n\t\t\tthis.exitRule();\n\t\t}\n\n\t\tlet ruleTransition: RuleTransition = this._atn.states[this.state].transition(0) as RuleTransition;\n\t\tthis.state = ruleTransition.followState.stateNumber;\n\t}\n\n\t/** Override this parser interpreters normal decision-making process\n\t *  at a particular decision and input token index. Instead of\n\t *  allowing the adaptive prediction mechanism to choose the\n\t *  first alternative within a block that leads to a successful parse,\n\t *  force it to take the alternative, 1..n for n alternatives.\n\t *\n\t *  As an implementation limitation right now, you can only specify one\n\t *  override. This is sufficient to allow construction of different\n\t *  parse trees for ambiguous input. It means re-parsing the entire input\n\t *  in general because you're never sure where an ambiguous sequence would\n\t *  live in the various parse trees. For example, in one interpretation,\n\t *  an ambiguous input sequence would be matched completely in expression\n\t *  but in another it could match all the way back to the root.\n\t *\n\t *  s : e '!'? ;\n\t *  e : ID\n\t *    | ID '!'\n\t *    ;\n\t *\n\t *  Here, x! can be matched as (s (e ID) !) or (s (e ID !)). In the first\n\t *  case, the ambiguous sequence is fully contained only by the root.\n\t *  In the second case, the ambiguous sequences fully contained within just\n\t *  e, as in: (e ID !).\n\t *\n\t *  Rather than trying to optimize this and make\n\t *  some intelligent decisions for optimization purposes, I settled on\n\t *  just re-parsing the whole input and then using\n\t *  {link Trees#getRootOfSubtreeEnclosingRegion} to find the minimal\n\t *  subtree that contains the ambiguous sequence. I originally tried to\n\t *  record the call stack at the point the parser detected and ambiguity but\n\t *  left recursive rules create a parse tree stack that does not reflect\n\t *  the actual call stack. That impedance mismatch was enough to make\n\t *  it it challenging to restart the parser at a deeply nested rule\n\t *  invocation.\n\t *\n\t *  Only parser interpreters can override decisions so as to avoid inserting\n\t *  override checking code in the critical ALL(*) prediction execution path.\n\t *\n\t *  @since 4.5\n\t */\n\tpublic addDecisionOverride(decision: number, tokenIndex: number, forcedAlt: number): void {\n\t\tthis.overrideDecision = decision;\n\t\tthis.overrideDecisionInputIndex = tokenIndex;\n\t\tthis.overrideDecisionAlt = forcedAlt;\n\t}\n\n\tget overrideDecisionRoot(): InterpreterRuleContext | undefined {\n\t\treturn this._overrideDecisionRoot;\n\t}\n\n\t/** Rely on the error handler for this parser but, if no tokens are consumed\n\t *  to recover, add an error node. Otherwise, nothing is seen in the parse\n\t *  tree.\n\t */\n\tprotected recover(e: RecognitionException): void {\n\t\tlet i: number = this._input.index;\n\t\tthis.errorHandler.recover(this, e);\n\t\tif (this._input.index === i) {\n\t\t\t// no input consumed, better add an error node\n\t\t\tlet tok: Token | undefined = e.getOffendingToken();\n\t\t\tif (!tok) {\n\t\t\t\tthrow new Error(\"Expected exception to have an offending token\");\n\t\t\t}\n\n\t\t\tlet source = tok.tokenSource;\n\t\t\tlet stream = source !== undefined ? source.inputStream : undefined;\n\t\t\tlet sourcePair = { source, stream };\n\n\t\t\tif (e instanceof InputMismatchException) {\n\t\t\t\tlet expectedTokens = e.expectedTokens;\n\t\t\t\tif (expectedTokens === undefined) {\n\t\t\t\t\tthrow new Error(\"Expected the exception to provide expected tokens\");\n\t\t\t\t}\n\n\t\t\t\tlet expectedTokenType: number = Token.INVALID_TYPE;\n\t\t\t\tif (!expectedTokens.isNil) {\n\t\t\t\t\t// get any element\n\t\t\t\t\texpectedTokenType = expectedTokens.minElement;\n\t\t\t\t}\n\n\t\t\t\tlet errToken: Token =\n\t\t\t\t\tthis.tokenFactory.create(sourcePair,\n\t\t\t\t\t\texpectedTokenType, tok.text,\n\t\t\t\t\t\tToken.DEFAULT_CHANNEL,\n\t\t\t\t\t\t-1, -1, // invalid start/stop\n\t\t\t\t\t\ttok.line, tok.charPositionInLine);\n\t\t\t\tthis._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));\n\t\t\t}\n\t\t\telse { // NoViableAlt\n\t\t\t\tlet source = tok.tokenSource;\n\t\t\t\tlet errToken: Token =\n\t\t\t\t\tthis.tokenFactory.create(sourcePair,\n\t\t\t\t\t\tToken.INVALID_TYPE, tok.text,\n\t\t\t\t\t\tToken.DEFAULT_CHANNEL,\n\t\t\t\t\t\t-1, -1, // invalid start/stop\n\t\t\t\t\t\ttok.line, tok.charPositionInLine);\n\t\t\t\tthis._ctx.addErrorNode(this.createErrorNode(this._ctx, errToken));\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected recoverInline(): Token {\n\t\treturn this._errHandler.recoverInline(this);\n\t}\n\n\t/** Return the root of the parse, which can be useful if the parser\n\t *  bails out. You still can access the top node. Note that,\n\t *  because of the way left recursive rules add children, it's possible\n\t *  that the root will not have any children if the start rule immediately\n\t *  called and left recursive rule that fails.\n\t *\n\t * @since 4.5.1\n\t */\n\tget rootContext(): InterpreterRuleContext {\n\t\treturn this._rootContext;\n\t}\n}\n"]}