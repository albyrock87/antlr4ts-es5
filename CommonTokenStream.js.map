{"version":3,"sources":["CommonTokenStream.js","../src/CommonTokenStream.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","BufferedTokenStream_1","require","Decorators_1","Token_1","CommonTokenStream","tokenSource","channel","Token","DEFAULT_CHANNEL","nextTokenOnChannel","k","p","undefined","n","previousTokenOnChannel","tokens","lazyInit","RangeError","tryLB","sync","fill","t","type","EOF","BufferedTokenStream","Override","prototype","NotNull"],"mappings":"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","file":"CommonTokenStream.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:50.3953157-07:00\nconst BufferedTokenStream_1 = require(\"./BufferedTokenStream\");\nconst Decorators_1 = require(\"./Decorators\");\nconst Token_1 = require(\"./Token\");\n/**\n * This class extends {@link BufferedTokenStream} with functionality to filter\n * token streams to tokens on a particular channel (tokens where\n * {@link Token#getChannel} returns a particular value).\n *\n * This token stream provides access to all tokens by index or when calling\n * methods like {@link #getText}. The channel filtering is only used for code\n * accessing tokens via the lookahead methods {@link #LA}, {@link #LT}, and\n * {@link #LB}.\n *\n * By default, tokens are placed on the default channel\n * ({@link Token#DEFAULT_CHANNEL}), but may be reassigned by using the\n * `->channel(HIDDEN)` lexer command, or by using an embedded action to\n * call {@link Lexer#setChannel}.\n *\n * Note: lexer rules which use the `->skip` lexer command or call\n * {@link Lexer#skip} do not produce tokens at all, so input text matched by\n * such a rule will not be available as part of the token stream, regardless of\n * channel.\n */\nlet CommonTokenStream = class CommonTokenStream extends BufferedTokenStream_1.BufferedTokenStream {\n    /**\n     * Constructs a new {@link CommonTokenStream} using the specified token\n     * source and filtering tokens to the specified channel. Only tokens whose\n     * {@link Token#getChannel} matches `channel` or have the\n     * `Token.type` equal to {@link Token#EOF} will be returned by the\n     * token stream lookahead methods.\n     *\n     * @param tokenSource The token source.\n     * @param channel The channel to use for filtering tokens.\n     */\n    constructor(tokenSource, channel = Token_1.Token.DEFAULT_CHANNEL) {\n        super(tokenSource);\n        this.channel = channel;\n    }\n    adjustSeekIndex(i) {\n        return this.nextTokenOnChannel(i, this.channel);\n    }\n    tryLB(k) {\n        if ((this.p - k) < 0) {\n            return undefined;\n        }\n        let i = this.p;\n        let n = 1;\n        // find k good tokens looking backwards\n        while (n <= k && i > 0) {\n            // skip off-channel tokens\n            i = this.previousTokenOnChannel(i - 1, this.channel);\n            n++;\n        }\n        if (i < 0) {\n            return undefined;\n        }\n        return this.tokens[i];\n    }\n    tryLT(k) {\n        //System.out.println(\"enter LT(\"+k+\")\");\n        this.lazyInit();\n        if (k === 0) {\n            throw new RangeError(\"0 is not a valid lookahead index\");\n        }\n        if (k < 0) {\n            return this.tryLB(-k);\n        }\n        let i = this.p;\n        let n = 1; // we know tokens[p] is a good one\n        // find k good tokens\n        while (n < k) {\n            // skip off-channel tokens, but make sure to not look past EOF\n            if (this.sync(i + 1)) {\n                i = this.nextTokenOnChannel(i + 1, this.channel);\n            }\n            n++;\n        }\n        //\t\tif ( i>range ) range = i;\n        return this.tokens[i];\n    }\n    /** Count EOF just once. */\n    getNumberOfOnChannelTokens() {\n        let n = 0;\n        this.fill();\n        for (let t of this.tokens) {\n            if (t.channel === this.channel) {\n                n++;\n            }\n            if (t.type === Token_1.Token.EOF) {\n                break;\n            }\n        }\n        return n;\n    }\n};\n__decorate([\n    Decorators_1.Override\n], CommonTokenStream.prototype, \"adjustSeekIndex\", null);\n__decorate([\n    Decorators_1.Override\n], CommonTokenStream.prototype, \"tryLB\", null);\n__decorate([\n    Decorators_1.Override\n], CommonTokenStream.prototype, \"tryLT\", null);\nCommonTokenStream = __decorate([\n    __param(0, Decorators_1.NotNull)\n], CommonTokenStream);\nexports.CommonTokenStream = CommonTokenStream;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:50.3953157-07:00\n\nimport { BufferedTokenStream } from \"./BufferedTokenStream\";\nimport { NotNull, Override } from \"./Decorators\";\nimport { Token } from \"./Token\";\nimport { TokenSource } from \"./TokenSource\";\n\n/**\n * This class extends {@link BufferedTokenStream} with functionality to filter\n * token streams to tokens on a particular channel (tokens where\n * {@link Token#getChannel} returns a particular value).\n *\n * This token stream provides access to all tokens by index or when calling\n * methods like {@link #getText}. The channel filtering is only used for code\n * accessing tokens via the lookahead methods {@link #LA}, {@link #LT}, and\n * {@link #LB}.\n *\n * By default, tokens are placed on the default channel\n * ({@link Token#DEFAULT_CHANNEL}), but may be reassigned by using the\n * `->channel(HIDDEN)` lexer command, or by using an embedded action to\n * call {@link Lexer#setChannel}.\n *\n * Note: lexer rules which use the `->skip` lexer command or call\n * {@link Lexer#skip} do not produce tokens at all, so input text matched by\n * such a rule will not be available as part of the token stream, regardless of\n * channel.\n */\nexport class CommonTokenStream extends BufferedTokenStream {\n\t/**\n\t * Specifies the channel to use for filtering tokens.\n\t *\n\t * The default value is {@link Token#DEFAULT_CHANNEL}, which matches the\n\t * default channel assigned to tokens created by the lexer.\n\t */\n\tprotected channel: number;\n\n\t/**\n\t * Constructs a new {@link CommonTokenStream} using the specified token\n\t * source and filtering tokens to the specified channel. Only tokens whose\n\t * {@link Token#getChannel} matches `channel` or have the\n\t * `Token.type` equal to {@link Token#EOF} will be returned by the\n\t * token stream lookahead methods.\n\t *\n\t * @param tokenSource The token source.\n\t * @param channel The channel to use for filtering tokens.\n\t */\n\tconstructor(@NotNull tokenSource: TokenSource, channel: number = Token.DEFAULT_CHANNEL) {\n\t\tsuper(tokenSource);\n\t\tthis.channel = channel;\n\t}\n\n\t@Override\n\tprotected adjustSeekIndex(i: number): number {\n\t\treturn this.nextTokenOnChannel(i, this.channel);\n\t}\n\n\t@Override\n\tprotected tryLB(k: number): Token | undefined {\n\t\tif ((this.p - k) < 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet i: number = this.p;\n\t\tlet n: number = 1;\n\t\t// find k good tokens looking backwards\n\t\twhile (n <= k && i > 0) {\n\t\t\t// skip off-channel tokens\n\t\t\ti = this.previousTokenOnChannel(i - 1, this.channel);\n\t\t\tn++;\n\t\t}\n\n\t\tif (i < 0) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this.tokens[i];\n\t}\n\n\t@Override\n\tpublic tryLT(k: number): Token | undefined {\n\t\t//System.out.println(\"enter LT(\"+k+\")\");\n\t\tthis.lazyInit();\n\t\tif (k === 0) {\n\t\t\tthrow new RangeError(\"0 is not a valid lookahead index\");\n\t\t}\n\n\t\tif (k < 0) {\n\t\t\treturn this.tryLB(-k);\n\t\t}\n\n\t\tlet i: number = this.p;\n\t\tlet n: number = 1; // we know tokens[p] is a good one\n\t\t// find k good tokens\n\t\twhile (n < k) {\n\t\t\t// skip off-channel tokens, but make sure to not look past EOF\n\t\t\tif (this.sync(i + 1)) {\n\t\t\t\ti = this.nextTokenOnChannel(i + 1, this.channel);\n\t\t\t}\n\t\t\tn++;\n\t\t}\n\n\t\t//\t\tif ( i>range ) range = i;\n\t\treturn this.tokens[i];\n\t}\n\n\t/** Count EOF just once. */\n\tpublic getNumberOfOnChannelTokens(): number {\n\t\tlet n: number = 0;\n\t\tthis.fill();\n\t\tfor (let t of this.tokens) {\n\t\t\tif (t.channel === this.channel) {\n\t\t\t\tn++;\n\t\t\t}\n\n\t\t\tif (t.type === Token.EOF) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn n;\n\t}\n}\n"]}