{"version":3,"sources":["Token.js","../src/Token.ts"],"names":["Object","defineProperty","exports","value","IntStream_1","require","Token","INVALID_TYPE","EPSILON","MIN_USER_TOKEN_TYPE","EOF","IntStream","DEFAULT_CHANNEL","HIDDEN_CHANNEL","MIN_USER_CHANNEL_VALUE"],"mappings":"AAAA;ACAA;;;;;ADKAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;ACGA,IAAAC,WAAA,GAAAC,OAAA,CAAA,aAAA,CAAA;;AA8DA,IAAiBC,KAAjB;;AAAA,CAAA,UAAiBA,KAAjB,EAAsB;AACRA,EAAAA,KAAA,CAAAC,YAAA,GAAuB,CAAvB;AAEb;;;;AAGaD,EAAAA,KAAA,CAAAE,OAAA,GAAkB,CAAC,CAAnB;AAEAF,EAAAA,KAAA,CAAAG,mBAAA,GAA8B,CAA9B;AAEAH,EAAAA,KAAA,CAAAI,GAAA,GAAcN,WAAA,CAAAO,SAAA,CAAUD,GAAxB;AAEb;;;;;AAIaJ,EAAAA,KAAA,CAAAM,eAAA,GAA0B,CAA1B;AAEb;;;;AAGaN,EAAAA,KAAA,CAAAO,cAAA,GAAyB,CAAzB;AAEb;;;;;;;;;;;AAUaP,EAAAA,KAAA,CAAAQ,sBAAA,GAAiC,CAAjC;AACb,CAlCD,EAAiBR,KAAK,GAALJ,OAAA,CAAAI,KAAA,KAAAJ,OAAA,CAAAI,KAAA,GAAK,EAAL,CAAjB","file":"Token.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst IntStream_1 = require(\"./IntStream\");\nvar Token;\n(function (Token) {\n    Token.INVALID_TYPE = 0;\n    /** During lookahead operations, this \"token\" signifies we hit rule end ATN state\n     *  and did not follow it despite needing to.\n     */\n    Token.EPSILON = -2;\n    Token.MIN_USER_TOKEN_TYPE = 1;\n    Token.EOF = IntStream_1.IntStream.EOF;\n    /** All tokens go to the parser (unless skip() is called in that rule)\n     *  on a particular \"channel\".  The parser tunes to a particular channel\n     *  so that whitespace etc... can go to the parser on a \"hidden\" channel.\n     */\n    Token.DEFAULT_CHANNEL = 0;\n    /** Anything on different channel than DEFAULT_CHANNEL is not parsed\n     *  by parser.\n     */\n    Token.HIDDEN_CHANNEL = 1;\n    /**\n     * This is the minimum constant value which can be assigned to a\n     * user-defined token channel.\n     *\n     * The non-negative numbers less than {@link #MIN_USER_CHANNEL_VALUE} are\n     * assigned to the predefined channels {@link #DEFAULT_CHANNEL} and\n     * {@link #HIDDEN_CHANNEL}.\n     *\n     * @see `Token.channel`\n     */\n    Token.MIN_USER_CHANNEL_VALUE = 2;\n})(Token = exports.Token || (exports.Token = {}));\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:57.7862802-07:00\n\nimport { CharStream } from \"./CharStream\";\nimport { IntStream } from \"./IntStream\";\nimport { TokenSource } from \"./TokenSource\";\nimport { TokenStream } from \"./TokenStream\";\n\n/** A token has properties: text, type, line, character position in the line\n *  (so we can ignore tabs), token channel, index, and source from which\n *  we obtained this token.\n */\nexport interface Token {\n\t/**\n\t * Get the text of the token.\n\t */\n\treadonly text: string | undefined;\n\n\t/** Get the token type of the token */\n\treadonly type: number;\n\n\t/** The line number on which the 1st character of this token was matched,\n\t *  line=1..n\n\t */\n\treadonly line: number;\n\n\t/** The index of the first character of this token relative to the\n\t *  beginning of the line at which it occurs, 0..n-1\n\t */\n\treadonly charPositionInLine: number;\n\n\t/** Return the channel this token. Each token can arrive at the parser\n\t *  on a different channel, but the parser only \"tunes\" to a single channel.\n\t *  The parser ignores everything not on DEFAULT_CHANNEL.\n\t */\n\treadonly channel: number;\n\n\t/** An index from 0..n-1 of the token object in the input stream.\n\t *  This must be valid in order to print token streams and\n\t *  use TokenRewriteStream.\n\t *\n\t *  Return -1 to indicate that this token was conjured up since\n\t *  it doesn't have a valid index.\n\t */\n\treadonly tokenIndex: number;\n\n\t/** The starting character index of the token\n\t *  This method is optional; return -1 if not implemented.\n\t */\n\treadonly startIndex: number;\n\n\t/** The last character index of the token.\n\t *  This method is optional; return -1 if not implemented.\n\t */\n\treadonly stopIndex: number;\n\n\t/** Gets the {@link TokenSource} which created this token.\n\t */\n\treadonly tokenSource: TokenSource | undefined;\n\n\t/**\n\t * Gets the {@link CharStream} from which this token was derived.\n\t */\n\treadonly inputStream: CharStream | undefined;\n}\n\nexport namespace Token {\n\texport const INVALID_TYPE: number = 0;\n\n\t/** During lookahead operations, this \"token\" signifies we hit rule end ATN state\n\t *  and did not follow it despite needing to.\n\t */\n\texport const EPSILON: number = -2;\n\n\texport const MIN_USER_TOKEN_TYPE: number = 1;\n\n\texport const EOF: number = IntStream.EOF;\n\n\t/** All tokens go to the parser (unless skip() is called in that rule)\n\t *  on a particular \"channel\".  The parser tunes to a particular channel\n\t *  so that whitespace etc... can go to the parser on a \"hidden\" channel.\n\t */\n\texport const DEFAULT_CHANNEL: number = 0;\n\n\t/** Anything on different channel than DEFAULT_CHANNEL is not parsed\n\t *  by parser.\n\t */\n\texport const HIDDEN_CHANNEL: number = 1;\n\n\t/**\n\t * This is the minimum constant value which can be assigned to a\n\t * user-defined token channel.\n\t *\n\t * The non-negative numbers less than {@link #MIN_USER_CHANNEL_VALUE} are\n\t * assigned to the predefined channels {@link #DEFAULT_CHANNEL} and\n\t * {@link #HIDDEN_CHANNEL}.\n\t *\n\t * @see `Token.channel`\n\t */\n\texport const MIN_USER_CHANNEL_VALUE: number = 2;\n}\n"]}