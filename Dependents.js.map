{"version":3,"sources":["Dependents.js","../src/Dependents.ts"],"names":["Object","defineProperty","exports","value","Dependents"],"mappings":"AAAA;ACAA;;;;;ADKAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C,E,CCAA;;AAEA;;;;;AAIA,IAAYC,UAAZ;;AAAA,CAAA,UAAYA,UAAZ,EAAsB;AAErB;;;AAGAA,EAAAA,UAAA,CAAAA,UAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACA;;;;;AAIAA,EAAAA,UAAA,CAAAA,UAAA,CAAA,SAAA,CAAA,GAAA,CAAA,CAAA,GAAA,SAAA;AACA;;;;;AAIAA,EAAAA,UAAA,CAAAA,UAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACA;;;;;AAIAA,EAAAA,UAAA,CAAAA,UAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA;;;;;AAIAA,EAAAA,UAAA,CAAAA,UAAA,CAAA,aAAA,CAAA,GAAA,CAAA,CAAA,GAAA,aAAA;AACA;;;;;AAIAA,EAAAA,UAAA,CAAAA,UAAA,CAAA,UAAA,CAAA,GAAA,CAAA,CAAA,GAAA,UAAA;AACA;;;;;;AAKAA,EAAAA,UAAA,CAAAA,UAAA,CAAA,qBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,qBAAA;AACA;;;;;;AAKAA,EAAAA,UAAA,CAAAA,UAAA,CAAA,oBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,oBAAA;AACA;;;;;;;;;AAQAA,EAAAA,UAAA,CAAAA,UAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AACA;;;;;;;;;AAQAA,EAAAA,UAAA,CAAAA,UAAA,CAAA,WAAA,CAAA,GAAA,CAAA,CAAA,GAAA,WAAA;AACA,CA7DD,EAAYA,UAAU,GAAVF,OAAA,CAAAE,UAAA,KAAAF,OAAA,CAAAE,UAAA,GAAU,EAAV,CAAZ","file":"Dependents.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:51.1349829-07:00\n/**\n *\n * @author Sam Harwell\n */\nvar Dependents;\n(function (Dependents) {\n    /**\n     * The element is dependent upon the specified rule.\n     */\n    Dependents[Dependents[\"SELF\"] = 0] = \"SELF\";\n    /**\n     * The element is dependent upon the set of the specified rule's parents\n     * (rules which directly reference it).\n     */\n    Dependents[Dependents[\"PARENTS\"] = 1] = \"PARENTS\";\n    /**\n     * The element is dependent upon the set of the specified rule's children\n     * (rules which it directly references).\n     */\n    Dependents[Dependents[\"CHILDREN\"] = 2] = \"CHILDREN\";\n    /**\n     * The element is dependent upon the set of the specified rule's ancestors\n     * (the transitive closure of `PARENTS` rules).\n     */\n    Dependents[Dependents[\"ANCESTORS\"] = 3] = \"ANCESTORS\";\n    /**\n     * The element is dependent upon the set of the specified rule's descendants\n     * (the transitive closure of `CHILDREN` rules).\n     */\n    Dependents[Dependents[\"DESCENDANTS\"] = 4] = \"DESCENDANTS\";\n    /**\n     * The element is dependent upon the set of the specified rule's siblings\n     * (the union of `CHILDREN` of its `PARENTS`).\n     */\n    Dependents[Dependents[\"SIBLINGS\"] = 5] = \"SIBLINGS\";\n    /**\n     * The element is dependent upon the set of the specified rule's preceeding\n     * siblings (the union of `CHILDREN` of its `PARENTS` which\n     * appear before a reference to the rule).\n     */\n    Dependents[Dependents[\"PRECEEDING_SIBLINGS\"] = 6] = \"PRECEEDING_SIBLINGS\";\n    /**\n     * The element is dependent upon the set of the specified rule's following\n     * siblings (the union of `CHILDREN` of its `PARENTS` which\n     * appear after a reference to the rule).\n     */\n    Dependents[Dependents[\"FOLLOWING_SIBLINGS\"] = 7] = \"FOLLOWING_SIBLINGS\";\n    /**\n     * The element is dependent upon the set of the specified rule's preceeding\n     * elements (rules which might end before the start of the specified rule\n     * while parsing). This is calculated by taking the\n     * `PRECEEDING_SIBLINGS` of the rule and each of its\n     * `ANCESTORS`, along with the `DESCENDANTS` of those\n     * elements.\n     */\n    Dependents[Dependents[\"PRECEEDING\"] = 8] = \"PRECEEDING\";\n    /**\n     * The element is dependent upon the set of the specified rule's following\n     * elements (rules which might start after the end of the specified rule\n     * while parsing). This is calculated by taking the\n     * `FOLLOWING_SIBLINGS` of the rule and each of its\n     * `ANCESTORS`, along with the `DESCENDANTS` of those\n     * elements.\n     */\n    Dependents[Dependents[\"FOLLOWING\"] = 9] = \"FOLLOWING\";\n})(Dependents = exports.Dependents || (exports.Dependents = {}));\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:51.1349829-07:00\n\n/**\n *\n * @author Sam Harwell\n */\nexport enum Dependents {\n\n\t/**\n\t * The element is dependent upon the specified rule.\n\t */\n\tSELF,\n\t/**\n\t * The element is dependent upon the set of the specified rule's parents\n\t * (rules which directly reference it).\n\t */\n\tPARENTS,\n\t/**\n\t * The element is dependent upon the set of the specified rule's children\n\t * (rules which it directly references).\n\t */\n\tCHILDREN,\n\t/**\n\t * The element is dependent upon the set of the specified rule's ancestors\n\t * (the transitive closure of `PARENTS` rules).\n\t */\n\tANCESTORS,\n\t/**\n\t * The element is dependent upon the set of the specified rule's descendants\n\t * (the transitive closure of `CHILDREN` rules).\n\t */\n\tDESCENDANTS,\n\t/**\n\t * The element is dependent upon the set of the specified rule's siblings\n\t * (the union of `CHILDREN` of its `PARENTS`).\n\t */\n\tSIBLINGS,\n\t/**\n\t * The element is dependent upon the set of the specified rule's preceeding\n\t * siblings (the union of `CHILDREN` of its `PARENTS` which\n\t * appear before a reference to the rule).\n\t */\n\tPRECEEDING_SIBLINGS,\n\t/**\n\t * The element is dependent upon the set of the specified rule's following\n\t * siblings (the union of `CHILDREN` of its `PARENTS` which\n\t * appear after a reference to the rule).\n\t */\n\tFOLLOWING_SIBLINGS,\n\t/**\n\t * The element is dependent upon the set of the specified rule's preceeding\n\t * elements (rules which might end before the start of the specified rule\n\t * while parsing). This is calculated by taking the\n\t * `PRECEEDING_SIBLINGS` of the rule and each of its\n\t * `ANCESTORS`, along with the `DESCENDANTS` of those\n\t * elements.\n\t */\n\tPRECEEDING,\n\t/**\n\t * The element is dependent upon the set of the specified rule's following\n\t * elements (rules which might start after the end of the specified rule\n\t * while parsing). This is calculated by taking the\n\t * `FOLLOWING_SIBLINGS` of the rule and each of its\n\t * `ANCESTORS`, along with the `DESCENDANTS` of those\n\t * elements.\n\t */\n\tFOLLOWING,\n}\n"]}