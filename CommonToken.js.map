{"version":3,"sources":["CommonToken.js","../src/CommonToken.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","Interval_1","require","Decorators_1","Token_1","CommonToken","type","text","source","EMPTY_SOURCE","channel","Token","DEFAULT_CHANNEL","start","stop","_line","_charPositionInLine","_channel","index","_text","_type","line","charPositionInLine","recognizer","channelStr","txt","replace","typeString","String","vocabulary","getDisplayName","tokenIndex","input","inputStream","undefined","n","size","getText","Interval","of","stream","oldToken","result","startIndex","stopIndex","tokenSource","NotNull","prototype","Override"],"mappings":"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","file":"CommonToken.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Interval_1 = require(\"./misc/Interval\");\nconst Decorators_1 = require(\"./Decorators\");\nconst Token_1 = require(\"./Token\");\nlet CommonToken = class CommonToken {\n    constructor(type, text, source = CommonToken.EMPTY_SOURCE, channel = Token_1.Token.DEFAULT_CHANNEL, start = 0, stop = 0) {\n        /**\n         * This is the backing field for {@link #getLine} and {@link #setLine}.\n         */\n        this._line = 0;\n        /**\n         * This is the backing field for {@link #getCharPositionInLine} and\n         * {@link #setCharPositionInLine}.\n         */\n        this._charPositionInLine = -1; // set to invalid position\n        /**\n         * This is the backing field for {@link #getChannel} and\n         * {@link #setChannel}.\n         */\n        this._channel = Token_1.Token.DEFAULT_CHANNEL;\n        /**\n         * This is the backing field for `tokenIndex`.\n         */\n        this.index = -1;\n        this._text = text;\n        this._type = type;\n        this.source = source;\n        this._channel = channel;\n        this.start = start;\n        this.stop = stop;\n        if (source.source != null) {\n            this._line = source.source.line;\n            this._charPositionInLine = source.source.charPositionInLine;\n        }\n    }\n    /**\n     * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n     *\n     * If `oldToken` is also a {@link CommonToken} instance, the newly\n     * constructed token will share a reference to the {@link #text} field and\n     * the {@link Tuple2} stored in {@link #source}. Otherwise, {@link #text} will\n     * be assigned the result of calling {@link #getText}, and {@link #source}\n     * will be constructed from the result of {@link Token#getTokenSource} and\n     * {@link Token#getInputStream}.\n     *\n     * @param oldToken The token to copy.\n     */\n    static fromToken(oldToken) {\n        let result = new CommonToken(oldToken.type, undefined, CommonToken.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);\n        result._line = oldToken.line;\n        result.index = oldToken.tokenIndex;\n        result._charPositionInLine = oldToken.charPositionInLine;\n        if (oldToken instanceof CommonToken) {\n            result._text = oldToken._text;\n            result.source = oldToken.source;\n        }\n        else {\n            result._text = oldToken.text;\n            result.source = { source: oldToken.tokenSource, stream: oldToken.inputStream };\n        }\n        return result;\n    }\n    get type() {\n        return this._type;\n    }\n    // @Override\n    set type(type) {\n        this._type = type;\n    }\n    get line() {\n        return this._line;\n    }\n    // @Override\n    set line(line) {\n        this._line = line;\n    }\n    get text() {\n        if (this._text != null) {\n            return this._text;\n        }\n        let input = this.inputStream;\n        if (input == null) {\n            return undefined;\n        }\n        let n = input.size;\n        if (this.start < n && this.stop < n) {\n            return input.getText(Interval_1.Interval.of(this.start, this.stop));\n        }\n        else {\n            return \"<EOF>\";\n        }\n    }\n    /**\n     * Explicitly set the text for this token. If {code text} is not\n     * `undefined`, then {@link #getText} will return this value rather than\n     * extracting the text from the input.\n     *\n     * @param text The explicit text of the token, or `undefined` if the text\n     * should be obtained from the input along with the start and stop indexes\n     * of the token.\n     */\n    // @Override\n    set text(text) {\n        this._text = text;\n    }\n    get charPositionInLine() {\n        return this._charPositionInLine;\n    }\n    // @Override\n    set charPositionInLine(charPositionInLine) {\n        this._charPositionInLine = charPositionInLine;\n    }\n    get channel() {\n        return this._channel;\n    }\n    // @Override\n    set channel(channel) {\n        this._channel = channel;\n    }\n    get startIndex() {\n        return this.start;\n    }\n    set startIndex(start) {\n        this.start = start;\n    }\n    get stopIndex() {\n        return this.stop;\n    }\n    set stopIndex(stop) {\n        this.stop = stop;\n    }\n    get tokenIndex() {\n        return this.index;\n    }\n    // @Override\n    set tokenIndex(index) {\n        this.index = index;\n    }\n    get tokenSource() {\n        return this.source.source;\n    }\n    get inputStream() {\n        return this.source.stream;\n    }\n    toString(recognizer) {\n        let channelStr = \"\";\n        if (this._channel > 0) {\n            channelStr = \",channel=\" + this._channel;\n        }\n        let txt = this.text;\n        if (txt != null) {\n            txt = txt.replace(/\\n/g, \"\\\\n\");\n            txt = txt.replace(/\\r/g, \"\\\\r\");\n            txt = txt.replace(/\\t/g, \"\\\\t\");\n        }\n        else {\n            txt = \"<no text>\";\n        }\n        let typeString = String(this._type);\n        if (recognizer) {\n            typeString = recognizer.vocabulary.getDisplayName(this._type);\n        }\n        return \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" + txt + \"',<\" + typeString + \">\" + channelStr + \",\" + this._line + \":\" + this.charPositionInLine + \"]\";\n    }\n};\n/**\n * An empty {@link Tuple2} which is used as the default value of\n * {@link #source} for tokens that do not have a source.\n */\nCommonToken.EMPTY_SOURCE = { source: undefined, stream: undefined };\n__decorate([\n    Decorators_1.NotNull\n], CommonToken.prototype, \"source\", void 0);\n__decorate([\n    Decorators_1.Override\n], CommonToken.prototype, \"type\", null);\n__decorate([\n    Decorators_1.Override\n], CommonToken.prototype, \"line\", null);\n__decorate([\n    Decorators_1.Override\n], CommonToken.prototype, \"text\", null);\n__decorate([\n    Decorators_1.Override\n], CommonToken.prototype, \"charPositionInLine\", null);\n__decorate([\n    Decorators_1.Override\n], CommonToken.prototype, \"channel\", null);\n__decorate([\n    Decorators_1.Override\n], CommonToken.prototype, \"startIndex\", null);\n__decorate([\n    Decorators_1.Override\n], CommonToken.prototype, \"stopIndex\", null);\n__decorate([\n    Decorators_1.Override\n], CommonToken.prototype, \"tokenIndex\", null);\n__decorate([\n    Decorators_1.Override\n], CommonToken.prototype, \"tokenSource\", null);\n__decorate([\n    Decorators_1.Override\n], CommonToken.prototype, \"inputStream\", null);\n__decorate([\n    Decorators_1.Override\n], CommonToken.prototype, \"toString\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], CommonToken, \"fromToken\", null);\nCommonToken = __decorate([\n    __param(2, Decorators_1.NotNull)\n], CommonToken);\nexports.CommonToken = CommonToken;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:50.1614404-07:00\n\nimport { ATNSimulator } from \"./atn/ATNSimulator\";\nimport { CharStream } from \"./CharStream\";\nimport { Interval } from \"./misc/Interval\";\nimport { NotNull, Override } from \"./Decorators\";\nimport { Recognizer } from \"./Recognizer\";\nimport { Token } from \"./Token\";\nimport { TokenSource } from \"./TokenSource\";\nimport { WritableToken } from \"./WritableToken\";\n\nexport class CommonToken implements WritableToken {\n\t/**\n\t * An empty {@link Tuple2} which is used as the default value of\n\t * {@link #source} for tokens that do not have a source.\n\t */\n\tprotected static readonly EMPTY_SOURCE: { source?: TokenSource, stream?: CharStream } =\n\t\t{ source: undefined, stream: undefined };\n\n\t/**\n\t * This is the backing field for `type`.\n\t */\n\tprivate _type: number;\n\t/**\n\t * This is the backing field for {@link #getLine} and {@link #setLine}.\n\t */\n\tprivate _line: number = 0;\n\t/**\n\t * This is the backing field for {@link #getCharPositionInLine} and\n\t * {@link #setCharPositionInLine}.\n\t */\n\tprivate _charPositionInLine: number = -1; // set to invalid position\n\t/**\n\t * This is the backing field for {@link #getChannel} and\n\t * {@link #setChannel}.\n\t */\n\tprivate _channel: number = Token.DEFAULT_CHANNEL;\n\t/**\n\t * This is the backing field for {@link #getTokenSource} and\n\t * {@link #getInputStream}.\n\t *\n\t * These properties share a field to reduce the memory footprint of\n\t * {@link CommonToken}. Tokens created by a {@link CommonTokenFactory} from\n\t * the same source and input stream share a reference to the same\n\t * {@link Tuple2} containing these values.\n\t */\n\t@NotNull\n\tprotected source: { source?: TokenSource, stream?: CharStream };\n\n\t/**\n\t * This is the backing field for {@link #getText} when the token text is\n\t * explicitly set in the constructor or via {@link #setText}.\n\t *\n\t * @see `text`\n\t */\n\tprivate _text?: string;\n\n\t/**\n\t * This is the backing field for `tokenIndex`.\n\t */\n\tprotected index: number = -1;\n\n\t/**\n\t * This is the backing field for `startIndex`.\n\t */\n\tprotected start: number;\n\n\t/**\n\t * This is the backing field for `stopIndex`.\n\t */\n\tprivate stop: number;\n\n\tconstructor(type: number, text?: string, @NotNull source: { source?: TokenSource, stream?: CharStream } = CommonToken.EMPTY_SOURCE, channel: number = Token.DEFAULT_CHANNEL, start: number = 0, stop: number = 0) {\n\t\tthis._text = text;\n\t\tthis._type = type;\n\t\tthis.source = source;\n\t\tthis._channel = channel;\n\t\tthis.start = start;\n\t\tthis.stop = stop;\n\t\tif (source.source != null) {\n\t\t\tthis._line = source.source.line;\n\t\t\tthis._charPositionInLine = source.source.charPositionInLine;\n\t\t}\n\t}\n\n\t/**\n\t * Constructs a new {@link CommonToken} as a copy of another {@link Token}.\n\t *\n\t * If `oldToken` is also a {@link CommonToken} instance, the newly\n\t * constructed token will share a reference to the {@link #text} field and\n\t * the {@link Tuple2} stored in {@link #source}. Otherwise, {@link #text} will\n\t * be assigned the result of calling {@link #getText}, and {@link #source}\n\t * will be constructed from the result of {@link Token#getTokenSource} and\n\t * {@link Token#getInputStream}.\n\t *\n\t * @param oldToken The token to copy.\n\t */\n\tpublic static fromToken(@NotNull oldToken: Token): CommonToken {\n\t\tlet result: CommonToken = new CommonToken(oldToken.type, undefined, CommonToken.EMPTY_SOURCE, oldToken.channel, oldToken.startIndex, oldToken.stopIndex);\n\t\tresult._line = oldToken.line;\n\t\tresult.index = oldToken.tokenIndex;\n\t\tresult._charPositionInLine = oldToken.charPositionInLine;\n\n\t\tif (oldToken instanceof CommonToken) {\n\t\t\tresult._text = oldToken._text;\n\t\t\tresult.source = oldToken.source;\n\t\t} else {\n\t\t\tresult._text = oldToken.text;\n\t\t\tresult.source = { source: oldToken.tokenSource, stream: oldToken.inputStream };\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t@Override\n\tget type(): number {\n\t\treturn this._type;\n\t}\n\n\t// @Override\n\tset type(type: number) {\n\t\tthis._type = type;\n\t}\n\n\t@Override\n\tget line(): number {\n\t\treturn this._line;\n\t}\n\n\t// @Override\n\tset line(line: number) {\n\t\tthis._line = line;\n\t}\n\n\t@Override\n\tget text(): string | undefined {\n\t\tif (this._text != null) {\n\t\t\treturn this._text;\n\t\t}\n\n\t\tlet input: CharStream | undefined = this.inputStream;\n\t\tif (input == null) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet n: number = input.size;\n\t\tif (this.start < n && this.stop < n) {\n\t\t\treturn input.getText(Interval.of(this.start, this.stop));\n\t\t} else {\n\t\t\treturn \"<EOF>\";\n\t\t}\n\t}\n\n\t/**\n\t * Explicitly set the text for this token. If {code text} is not\n\t * `undefined`, then {@link #getText} will return this value rather than\n\t * extracting the text from the input.\n\t *\n\t * @param text The explicit text of the token, or `undefined` if the text\n\t * should be obtained from the input along with the start and stop indexes\n\t * of the token.\n\t */\n\t// @Override\n\tset text(text: string | undefined) {\n\t\tthis._text = text;\n\t}\n\n\t@Override\n\tget charPositionInLine(): number {\n\t\treturn this._charPositionInLine;\n\t}\n\n\t// @Override\n\tset charPositionInLine(charPositionInLine: number) {\n\t\tthis._charPositionInLine = charPositionInLine;\n\t}\n\n\t@Override\n\tget channel(): number {\n\t\treturn this._channel;\n\t}\n\n\t// @Override\n\tset channel(channel: number) {\n\t\tthis._channel = channel;\n\t}\n\n\t@Override\n\tget startIndex(): number {\n\t\treturn this.start;\n\t}\n\n\tset startIndex(start: number) {\n\t\tthis.start = start;\n\t}\n\n\t@Override\n\tget stopIndex(): number {\n\t\treturn this.stop;\n\t}\n\n\tset stopIndex(stop: number) {\n\t\tthis.stop = stop;\n\t}\n\n\t@Override\n\tget tokenIndex(): number {\n\t\treturn this.index;\n\t}\n\n\t// @Override\n\tset tokenIndex(index: number) {\n\t\tthis.index = index;\n\t}\n\n\t@Override\n\tget tokenSource(): TokenSource | undefined {\n\t\treturn this.source.source;\n\t}\n\n\t@Override\n\tget inputStream(): CharStream | undefined {\n\t\treturn this.source.stream;\n\t}\n\n\tpublic toString(): string;\n\tpublic toString<TSymbol, ATNInterpreter extends ATNSimulator>(recognizer: Recognizer<TSymbol, ATNInterpreter> | undefined): string;\n\n\t@Override\n\tpublic toString<TSymbol, ATNInterpreter extends ATNSimulator>(recognizer?: Recognizer<TSymbol, ATNInterpreter>): string {\n\t\tlet channelStr: string = \"\";\n\t\tif (this._channel > 0) {\n\t\t\tchannelStr = \",channel=\" + this._channel;\n\t\t}\n\n\t\tlet txt: string | undefined = this.text;\n\t\tif (txt != null) {\n\t\t\ttxt = txt.replace(/\\n/g, \"\\\\n\");\n\t\t\ttxt = txt.replace(/\\r/g, \"\\\\r\");\n\t\t\ttxt = txt.replace(/\\t/g, \"\\\\t\");\n\t\t} else {\n\t\t\ttxt = \"<no text>\";\n\t\t}\n\n\t\tlet typeString = String(this._type);\n\t\tif (recognizer) {\n\t\t\ttypeString = recognizer.vocabulary.getDisplayName(this._type);\n\t\t}\n\n\t\treturn \"[@\" + this.tokenIndex + \",\" + this.start + \":\" + this.stop + \"='\" + txt + \"',<\" + typeString + \">\" + channelStr + \",\" + this._line + \":\" + this.charPositionInLine + \"]\";\n\t}\n}\n"]}