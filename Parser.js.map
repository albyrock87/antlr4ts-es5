{"version":3,"sources":["Parser.js","../src/Parser.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","exports","Utils","require","ATNDeserializationOptions_1","ATNDeserializer_1","DefaultErrorStrategy_1","ErrorNode_1","IntegerStack_1","Lexer_1","Decorators_1","ParseInfo_1","ParserATNSimulator_1","ProxyParserErrorListener_1","Recognizer_1","TerminalNode_1","Token_1","TraceListener","ruleNames","tokenStream","ctx","console","log","ruleIndex","LT","text","node","parent","ruleContext","token","symbol","Override","prototype","Parser","input","_errHandler","DefaultErrorStrategy","_precedenceStack","IntegerStack","_buildParseTrees","_parseListeners","_syntaxErrors","matchedEOF","push","inputStream","resetInput","undefined","seek","reset","_ctx","isTrace","clear","interpreter","ttype","t","currentToken","type","Token","EOF","reportMatch","consume","recoverInline","tokenIndex","addErrorNode","createErrorNode","listener","TypeError","index","findIndex","l","splice","enterEveryRule","enterRule","exitRule","exitEveryRule","serializedAtn","serializedATN","Error","bypassAltsAtnCache","get","deserializationOptions","ATNDeserializationOptions","isGenerateRuleBypassTransitions","ATNDeserializer","deserialize","toCharArray","set","pattern","patternRuleIndex","lexer","tokenSource","Lexer","currentLexer","m","matcher","ParseTreePatternMatcher","compile","msg","offendingToken","line","charPositionInLine","getErrorListenerDispatch","syntaxError","o","hasListener","inErrorRecoveryMode","visitErrorNode","createTerminalNode","addChild","visitTerminal","TerminalNode","ErrorNode","_parent","localctx","state","_start","_input","addContextToParseTree","triggerEnterRuleEvent","factoredContext","getChild","childCount","removeLastChild","_stop","tryLT","triggerExitRuleEvent","invokingState","altNum","altNumber","precedence","previous","_parentctx","pop","retctx","p","peek","ProxyParserErrorListener","getErrorListeners","context","atn","s","states","following","nextTokens","contains","EPSILON","rt","transition","followState","getExpectedTokens","ruleName","getRuleIndexMap","stack","_interp","decisionToDFA","dfa","toString","vocabulary","seenOne","isEmpty","decision","process","stdout","write","profile","interp","ProfilingATNSimulator","ParserATNSimulator","setPredictionMode","getPredictionMode","buildParseTrees","tokenFactory","handler","sourceName","ParseInfo","trace","_tracer","removeParseListener","addParseListener","Recognizer","Map","NotNull","Nullable"],"mappings":"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","file":"Parser.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Utils = require(\"./misc/Utils\");\nconst ATNDeserializationOptions_1 = require(\"./atn/ATNDeserializationOptions\");\nconst ATNDeserializer_1 = require(\"./atn/ATNDeserializer\");\nconst DefaultErrorStrategy_1 = require(\"./DefaultErrorStrategy\");\nconst ErrorNode_1 = require(\"./tree/ErrorNode\");\nconst IntegerStack_1 = require(\"./misc/IntegerStack\");\nconst Lexer_1 = require(\"./Lexer\");\nconst Decorators_1 = require(\"./Decorators\");\nconst ParseInfo_1 = require(\"./atn/ParseInfo\");\nconst ParserATNSimulator_1 = require(\"./atn/ParserATNSimulator\");\nconst ProxyParserErrorListener_1 = require(\"./ProxyParserErrorListener\");\nconst Recognizer_1 = require(\"./Recognizer\");\nconst TerminalNode_1 = require(\"./tree/TerminalNode\");\nconst Token_1 = require(\"./Token\");\nclass TraceListener {\n    constructor(ruleNames, tokenStream) {\n        this.ruleNames = ruleNames;\n        this.tokenStream = tokenStream;\n    }\n    enterEveryRule(ctx) {\n        console.log(\"enter   \" + this.ruleNames[ctx.ruleIndex] +\n            \", LT(1)=\" + this.tokenStream.LT(1).text);\n    }\n    exitEveryRule(ctx) {\n        console.log(\"exit    \" + this.ruleNames[ctx.ruleIndex] +\n            \", LT(1)=\" + this.tokenStream.LT(1).text);\n    }\n    visitErrorNode(node) {\n        // intentionally empty\n    }\n    visitTerminal(node) {\n        let parent = node.parent.ruleContext;\n        let token = node.symbol;\n        console.log(\"consume \" + token + \" rule \" + this.ruleNames[parent.ruleIndex]);\n    }\n}\n__decorate([\n    Decorators_1.Override\n], TraceListener.prototype, \"enterEveryRule\", null);\n__decorate([\n    Decorators_1.Override\n], TraceListener.prototype, \"exitEveryRule\", null);\n__decorate([\n    Decorators_1.Override\n], TraceListener.prototype, \"visitErrorNode\", null);\n__decorate([\n    Decorators_1.Override\n], TraceListener.prototype, \"visitTerminal\", null);\n/** This is all the parsing support code essentially; most of it is error recovery stuff. */\nclass Parser extends Recognizer_1.Recognizer {\n    constructor(input) {\n        super();\n        /**\n         * The error handling strategy for the parser. The default value is a new\n         * instance of {@link DefaultErrorStrategy}.\n         *\n         * @see #getErrorHandler\n         * @see #setErrorHandler\n         */\n        this._errHandler = new DefaultErrorStrategy_1.DefaultErrorStrategy();\n        this._precedenceStack = new IntegerStack_1.IntegerStack();\n        /**\n         * Specifies whether or not the parser should construct a parse tree during\n         * the parsing process. The default value is `true`.\n         *\n         * @see `buildParseTree`\n         */\n        this._buildParseTrees = true;\n        /**\n         * The list of {@link ParseTreeListener} listeners registered to receive\n         * events during the parse.\n         *\n         * @see #addParseListener\n         */\n        this._parseListeners = [];\n        /**\n         * The number of syntax errors reported during parsing. This value is\n         * incremented each time {@link #notifyErrorListeners} is called.\n         */\n        this._syntaxErrors = 0;\n        /** Indicates parser has match()ed EOF token. See {@link #exitRule()}. */\n        this.matchedEOF = false;\n        this._precedenceStack.push(0);\n        this.inputStream = input;\n    }\n    reset(resetInput) {\n        // Note: this method executes when not parsing, so _ctx can be undefined\n        if (resetInput === undefined || resetInput) {\n            this.inputStream.seek(0);\n        }\n        this._errHandler.reset(this);\n        this._ctx = undefined;\n        this._syntaxErrors = 0;\n        this.matchedEOF = false;\n        this.isTrace = false;\n        this._precedenceStack.clear();\n        this._precedenceStack.push(0);\n        let interpreter = this.interpreter;\n        if (interpreter != null) {\n            interpreter.reset();\n        }\n    }\n    /**\n     * Match current input symbol against `ttype`. If the symbol type\n     * matches, {@link ANTLRErrorStrategy#reportMatch} and {@link #consume} are\n     * called to complete the match process.\n     *\n     * If the symbol type does not match,\n     * {@link ANTLRErrorStrategy#recoverInline} is called on the current error\n     * strategy to attempt recovery. If {@link #getBuildParseTree} is\n     * `true` and the token index of the symbol returned by\n     * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to\n     * the parse tree by calling {@link #createErrorNode(ParserRuleContext, Token)} then\n     * {@link ParserRuleContext#addErrorNode(ErrorNode)}.\n     *\n     * @param ttype the token type to match\n     * @returns the matched symbol\n     * @ if the current input symbol did not match\n     * `ttype` and the error strategy could not recover from the\n     * mismatched symbol\n     */\n    match(ttype) {\n        let t = this.currentToken;\n        if (t.type === ttype) {\n            if (ttype === Token_1.Token.EOF) {\n                this.matchedEOF = true;\n            }\n            this._errHandler.reportMatch(this);\n            this.consume();\n        }\n        else {\n            t = this._errHandler.recoverInline(this);\n            if (this._buildParseTrees && t.tokenIndex === -1) {\n                // we must have conjured up a new token during single token insertion\n                // if it's not the current symbol\n                this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));\n            }\n        }\n        return t;\n    }\n    /**\n     * Match current input symbol as a wildcard. If the symbol type matches\n     * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy#reportMatch}\n     * and {@link #consume} are called to complete the match process.\n     *\n     * If the symbol type does not match,\n     * {@link ANTLRErrorStrategy#recoverInline} is called on the current error\n     * strategy to attempt recovery. If {@link #getBuildParseTree} is\n     * `true` and the token index of the symbol returned by\n     * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to\n     * the parse tree by calling {@link Parser#createErrorNode(ParserRuleContext, Token)} then\n     * {@link ParserRuleContext#addErrorNode(ErrorNode)}.\n     *\n     * @returns the matched symbol\n     * @ if the current input symbol did not match\n     * a wildcard and the error strategy could not recover from the mismatched\n     * symbol\n     */\n    matchWildcard() {\n        let t = this.currentToken;\n        if (t.type > 0) {\n            this._errHandler.reportMatch(this);\n            this.consume();\n        }\n        else {\n            t = this._errHandler.recoverInline(this);\n            if (this._buildParseTrees && t.tokenIndex === -1) {\n                // we must have conjured up a new token during single token insertion\n                // if it's not the current symbol\n                this._ctx.addErrorNode(this.createErrorNode(this._ctx, t));\n            }\n        }\n        return t;\n    }\n    /**\n     * Track the {@link ParserRuleContext} objects during the parse and hook\n     * them up using the {@link ParserRuleContext#children} list so that it\n     * forms a parse tree. The {@link ParserRuleContext} returned from the start\n     * rule represents the root of the parse tree.\n     *\n     * Note that if we are not building parse trees, rule contexts only point\n     * upwards. When a rule exits, it returns the context but that gets garbage\n     * collected if nobody holds a reference. It points upwards but nobody\n     * points at it.\n     *\n     * When we build parse trees, we are adding all of these contexts to\n     * {@link ParserRuleContext#children} list. Contexts are then not candidates\n     * for garbage collection.\n     */\n    set buildParseTree(buildParseTrees) {\n        this._buildParseTrees = buildParseTrees;\n    }\n    /**\n     * Gets whether or not a complete parse tree will be constructed while\n     * parsing. This property is `true` for a newly constructed parser.\n     *\n     * @returns `true` if a complete parse tree will be constructed while\n     * parsing, otherwise `false`\n     */\n    get buildParseTree() {\n        return this._buildParseTrees;\n    }\n    getParseListeners() {\n        return this._parseListeners;\n    }\n    /**\n     * Registers `listener` to receive events during the parsing process.\n     *\n     * To support output-preserving grammar transformations (including but not\n     * limited to left-recursion removal, automated left-factoring, and\n     * optimized code generation), calls to listener methods during the parse\n     * may differ substantially from calls made by\n     * {@link ParseTreeWalker#DEFAULT} used after the parse is complete. In\n     * particular, rule entry and exit events may occur in a different order\n     * during the parse than after the parser. In addition, calls to certain\n     * rule entry methods may be omitted.\n     *\n     * With the following specific exceptions, calls to listener events are\n     * *deterministic*, i.e. for identical input the calls to listener\n     * methods will be the same.\n     *\n     * * Alterations to the grammar used to generate code may change the\n     *   behavior of the listener calls.\n     * * Alterations to the command line options passed to ANTLR 4 when\n     *   generating the parser may change the behavior of the listener calls.\n     * * Changing the version of the ANTLR Tool used to generate the parser\n     *   may change the behavior of the listener calls.\n     *\n     * @param listener the listener to add\n     *\n     * @throws {@link TypeError} if `listener` is `undefined`\n     */\n    addParseListener(listener) {\n        if (listener == null) {\n            throw new TypeError(\"listener cannot be null\");\n        }\n        this._parseListeners.push(listener);\n    }\n    /**\n     * Remove `listener` from the list of parse listeners.\n     *\n     * If `listener` is `undefined` or has not been added as a parse\n     * listener, this method does nothing.\n     *\n     * @see #addParseListener\n     *\n     * @param listener the listener to remove\n     */\n    removeParseListener(listener) {\n        let index = this._parseListeners.findIndex((l) => l === listener);\n        if (index !== -1) {\n            this._parseListeners.splice(index, 1);\n        }\n    }\n    /**\n     * Remove all parse listeners.\n     *\n     * @see #addParseListener\n     */\n    removeParseListeners() {\n        this._parseListeners.length = 0;\n    }\n    /**\n     * Notify any parse listeners of an enter rule event.\n     *\n     * @see #addParseListener\n     */\n    triggerEnterRuleEvent() {\n        for (let listener of this._parseListeners) {\n            if (listener.enterEveryRule) {\n                listener.enterEveryRule(this._ctx);\n            }\n            this._ctx.enterRule(listener);\n        }\n    }\n    /**\n     * Notify any parse listeners of an exit rule event.\n     *\n     * @see #addParseListener\n     */\n    triggerExitRuleEvent() {\n        // reverse order walk of listeners\n        for (let i = this._parseListeners.length - 1; i >= 0; i--) {\n            let listener = this._parseListeners[i];\n            this._ctx.exitRule(listener);\n            if (listener.exitEveryRule) {\n                listener.exitEveryRule(this._ctx);\n            }\n        }\n    }\n    /**\n     * Gets the number of syntax errors reported during parsing. This value is\n     * incremented each time {@link #notifyErrorListeners} is called.\n     *\n     * @see #notifyErrorListeners\n     */\n    get numberOfSyntaxErrors() {\n        return this._syntaxErrors;\n    }\n    get tokenFactory() {\n        return this._input.tokenSource.tokenFactory;\n    }\n    /**\n     * The ATN with bypass alternatives is expensive to create so we create it\n     * lazily.\n     *\n     * @ if the current parser does not\n     * implement the `serializedATN` property.\n     */\n    getATNWithBypassAlts() {\n        let serializedAtn = this.serializedATN;\n        if (serializedAtn == null) {\n            throw new Error(\"The current parser does not support an ATN with bypass alternatives.\");\n        }\n        let result = Parser.bypassAltsAtnCache.get(serializedAtn);\n        if (result == null) {\n            let deserializationOptions = new ATNDeserializationOptions_1.ATNDeserializationOptions();\n            deserializationOptions.isGenerateRuleBypassTransitions = true;\n            result = new ATNDeserializer_1.ATNDeserializer(deserializationOptions).deserialize(Utils.toCharArray(serializedAtn));\n            Parser.bypassAltsAtnCache.set(serializedAtn, result);\n        }\n        return result;\n    }\n    compileParseTreePattern(pattern, patternRuleIndex, lexer) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!lexer) {\n                if (this.inputStream) {\n                    let tokenSource = this.inputStream.tokenSource;\n                    if (tokenSource instanceof Lexer_1.Lexer) {\n                        lexer = tokenSource;\n                    }\n                }\n                if (!lexer) {\n                    throw new Error(\"Parser can't discover a lexer to use\");\n                }\n            }\n            let currentLexer = lexer;\n            let m = yield Promise.resolve().then(() => require(\"./tree/pattern/ParseTreePatternMatcher\"));\n            let matcher = new m.ParseTreePatternMatcher(currentLexer, this);\n            return matcher.compile(pattern, patternRuleIndex);\n        });\n    }\n    get errorHandler() {\n        return this._errHandler;\n    }\n    set errorHandler(handler) {\n        this._errHandler = handler;\n    }\n    get inputStream() {\n        return this._input;\n    }\n    /** Set the token stream and reset the parser. */\n    set inputStream(input) {\n        this.reset(false);\n        this._input = input;\n    }\n    /** Match needs to return the current input symbol, which gets put\n     *  into the label for the associated token ref; e.g., x=ID.\n     */\n    get currentToken() {\n        return this._input.LT(1);\n    }\n    notifyErrorListeners(msg, offendingToken, e) {\n        if (offendingToken === undefined) {\n            offendingToken = this.currentToken;\n        }\n        else if (offendingToken === null) {\n            offendingToken = undefined;\n        }\n        this._syntaxErrors++;\n        let line = -1;\n        let charPositionInLine = -1;\n        if (offendingToken != null) {\n            line = offendingToken.line;\n            charPositionInLine = offendingToken.charPositionInLine;\n        }\n        let listener = this.getErrorListenerDispatch();\n        if (listener.syntaxError) {\n            listener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);\n        }\n    }\n    /**\n     * Consume and return the [current symbol](`currentToken`).\n     *\n     * E.g., given the following input with `A` being the current\n     * lookahead symbol, this function moves the cursor to `B` and returns\n     * `A`.\n     *\n     * ```\n     * A B\n     * ^\n     * ```\n     *\n     * If the parser is not in error recovery mode, the consumed symbol is added\n     * to the parse tree using {@link ParserRuleContext#addChild(TerminalNode)}, and\n     * {@link ParseTreeListener#visitTerminal} is called on any parse listeners.\n     * If the parser *is* in error recovery mode, the consumed symbol is\n     * added to the parse tree using {@link #createErrorNode(ParserRuleContext, Token)} then\n     * {@link ParserRuleContext#addErrorNode(ErrorNode)} and\n     * {@link ParseTreeListener#visitErrorNode} is called on any parse\n     * listeners.\n     */\n    consume() {\n        let o = this.currentToken;\n        if (o.type !== Parser.EOF) {\n            this.inputStream.consume();\n        }\n        let hasListener = this._parseListeners.length !== 0;\n        if (this._buildParseTrees || hasListener) {\n            if (this._errHandler.inErrorRecoveryMode(this)) {\n                let node = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));\n                if (hasListener) {\n                    for (let listener of this._parseListeners) {\n                        if (listener.visitErrorNode) {\n                            listener.visitErrorNode(node);\n                        }\n                    }\n                }\n            }\n            else {\n                let node = this.createTerminalNode(this._ctx, o);\n                this._ctx.addChild(node);\n                if (hasListener) {\n                    for (let listener of this._parseListeners) {\n                        if (listener.visitTerminal) {\n                            listener.visitTerminal(node);\n                        }\n                    }\n                }\n            }\n        }\n        return o;\n    }\n    /**\n     * How to create a token leaf node associated with a parent.\n     * Typically, the terminal node to create is not a function of the parent.\n     *\n     * @since 4.7\n     */\n    createTerminalNode(parent, t) {\n        return new TerminalNode_1.TerminalNode(t);\n    }\n    /**\n     * How to create an error node, given a token, associated with a parent.\n     * Typically, the error node to create is not a function of the parent.\n     *\n     * @since 4.7\n     */\n    createErrorNode(parent, t) {\n        return new ErrorNode_1.ErrorNode(t);\n    }\n    addContextToParseTree() {\n        let parent = this._ctx._parent;\n        // add current context to parent if we have a parent\n        if (parent != null) {\n            parent.addChild(this._ctx);\n        }\n    }\n    /**\n     * Always called by generated parsers upon entry to a rule. Access field\n     * {@link #_ctx} get the current context.\n     */\n    enterRule(localctx, state, ruleIndex) {\n        this.state = state;\n        this._ctx = localctx;\n        this._ctx._start = this._input.LT(1);\n        if (this._buildParseTrees) {\n            this.addContextToParseTree();\n        }\n        this.triggerEnterRuleEvent();\n    }\n    enterLeftFactoredRule(localctx, state, ruleIndex) {\n        this.state = state;\n        if (this._buildParseTrees) {\n            let factoredContext = this._ctx.getChild(this._ctx.childCount - 1);\n            this._ctx.removeLastChild();\n            factoredContext._parent = localctx;\n            localctx.addChild(factoredContext);\n        }\n        this._ctx = localctx;\n        this._ctx._start = this._input.LT(1);\n        if (this._buildParseTrees) {\n            this.addContextToParseTree();\n        }\n        this.triggerEnterRuleEvent();\n    }\n    exitRule() {\n        if (this.matchedEOF) {\n            // if we have matched EOF, it cannot consume past EOF so we use LT(1) here\n            this._ctx._stop = this._input.LT(1); // LT(1) will be end of file\n        }\n        else {\n            this._ctx._stop = this._input.tryLT(-1); // stop node is what we just matched\n        }\n        // trigger event on _ctx, before it reverts to parent\n        this.triggerExitRuleEvent();\n        this.state = this._ctx.invokingState;\n        this._ctx = this._ctx._parent;\n    }\n    enterOuterAlt(localctx, altNum) {\n        localctx.altNumber = altNum;\n        // if we have new localctx, make sure we replace existing ctx\n        // that is previous child of parse tree\n        if (this._buildParseTrees && this._ctx !== localctx) {\n            let parent = this._ctx._parent;\n            if (parent != null) {\n                parent.removeLastChild();\n                parent.addChild(localctx);\n            }\n        }\n        this._ctx = localctx;\n    }\n    /**\n     * Get the precedence level for the top-most precedence rule.\n     *\n     * @returns The precedence level for the top-most precedence rule, or -1 if\n     * the parser context is not nested within a precedence rule.\n     */\n    get precedence() {\n        if (this._precedenceStack.isEmpty) {\n            return -1;\n        }\n        return this._precedenceStack.peek();\n    }\n    enterRecursionRule(localctx, state, ruleIndex, precedence) {\n        this.state = state;\n        this._precedenceStack.push(precedence);\n        this._ctx = localctx;\n        this._ctx._start = this._input.LT(1);\n        this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n    }\n    /** Like {@link #enterRule} but for recursive rules.\n     *  Make the current context the child of the incoming localctx.\n     */\n    pushNewRecursionContext(localctx, state, ruleIndex) {\n        let previous = this._ctx;\n        previous._parent = localctx;\n        previous.invokingState = state;\n        previous._stop = this._input.tryLT(-1);\n        this._ctx = localctx;\n        this._ctx._start = previous._start;\n        if (this._buildParseTrees) {\n            this._ctx.addChild(previous);\n        }\n        this.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n    }\n    unrollRecursionContexts(_parentctx) {\n        this._precedenceStack.pop();\n        this._ctx._stop = this._input.tryLT(-1);\n        let retctx = this._ctx; // save current ctx (return value)\n        // unroll so _ctx is as it was before call to recursive method\n        if (this._parseListeners.length > 0) {\n            while (this._ctx !== _parentctx) {\n                this.triggerExitRuleEvent();\n                this._ctx = this._ctx._parent;\n            }\n        }\n        else {\n            this._ctx = _parentctx;\n        }\n        // hook into tree\n        retctx._parent = _parentctx;\n        if (this._buildParseTrees && _parentctx != null) {\n            // add return ctx into invoking rule's tree\n            _parentctx.addChild(retctx);\n        }\n    }\n    getInvokingContext(ruleIndex) {\n        let p = this._ctx;\n        while (p && p.ruleIndex !== ruleIndex) {\n            p = p._parent;\n        }\n        return p;\n    }\n    get context() {\n        return this._ctx;\n    }\n    set context(ctx) {\n        this._ctx = ctx;\n    }\n    precpred(localctx, precedence) {\n        return precedence >= this._precedenceStack.peek();\n    }\n    getErrorListenerDispatch() {\n        return new ProxyParserErrorListener_1.ProxyParserErrorListener(this.getErrorListeners());\n    }\n    inContext(context) {\n        // TODO: useful in parser?\n        return false;\n    }\n    /**\n     * Checks whether or not `symbol` can follow the current state in the\n     * ATN. The behavior of this method is equivalent to the following, but is\n     * implemented such that the complete context-sensitive follow set does not\n     * need to be explicitly constructed.\n     *\n     * ```\n     * return getExpectedTokens().contains(symbol);\n     * ```\n     *\n     * @param symbol the symbol type to check\n     * @returns `true` if `symbol` can follow the current state in\n     * the ATN, otherwise `false`.\n     */\n    isExpectedToken(symbol) {\n        //   \t\treturn interpreter.atn.nextTokens(_ctx);\n        let atn = this.interpreter.atn;\n        let ctx = this._ctx;\n        let s = atn.states[this.state];\n        let following = atn.nextTokens(s);\n        if (following.contains(symbol)) {\n            return true;\n        }\n        //        System.out.println(\"following \"+s+\"=\"+following);\n        if (!following.contains(Token_1.Token.EPSILON)) {\n            return false;\n        }\n        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {\n            let invokingState = atn.states[ctx.invokingState];\n            let rt = invokingState.transition(0);\n            following = atn.nextTokens(rt.followState);\n            if (following.contains(symbol)) {\n                return true;\n            }\n            ctx = ctx._parent;\n        }\n        if (following.contains(Token_1.Token.EPSILON) && symbol === Token_1.Token.EOF) {\n            return true;\n        }\n        return false;\n    }\n    get isMatchedEOF() {\n        return this.matchedEOF;\n    }\n    /**\n     * Computes the set of input symbols which could follow the current parser\n     * state and context, as given by {@link #getState} and {@link #getContext},\n     * respectively.\n     *\n     * @see ATN#getExpectedTokens(int, RuleContext)\n     */\n    getExpectedTokens() {\n        return this.atn.getExpectedTokens(this.state, this.context);\n    }\n    getExpectedTokensWithinCurrentRule() {\n        let atn = this.interpreter.atn;\n        let s = atn.states[this.state];\n        return atn.nextTokens(s);\n    }\n    /** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */\n    getRuleIndex(ruleName) {\n        let ruleIndex = this.getRuleIndexMap().get(ruleName);\n        if (ruleIndex != null) {\n            return ruleIndex;\n        }\n        return -1;\n    }\n    get ruleContext() { return this._ctx; }\n    /** Return List&lt;String&gt; of the rule names in your parser instance\n     *  leading up to a call to the current rule.  You could override if\n     *  you want more details such as the file/line info of where\n     *  in the ATN a rule is invoked.\n     *\n     *  This is very useful for error messages.\n     */\n    getRuleInvocationStack(ctx = this._ctx) {\n        let p = ctx; // Workaround for Microsoft/TypeScript#14487\n        let ruleNames = this.ruleNames;\n        let stack = [];\n        while (p != null) {\n            // compute what follows who invoked us\n            let ruleIndex = p.ruleIndex;\n            if (ruleIndex < 0) {\n                stack.push(\"n/a\");\n            }\n            else {\n                stack.push(ruleNames[ruleIndex]);\n            }\n            p = p._parent;\n        }\n        return stack;\n    }\n    /** For debugging and other purposes. */\n    getDFAStrings() {\n        let s = [];\n        for (let dfa of this._interp.atn.decisionToDFA) {\n            s.push(dfa.toString(this.vocabulary, this.ruleNames));\n        }\n        return s;\n    }\n    /** For debugging and other purposes. */\n    dumpDFA() {\n        let seenOne = false;\n        for (let dfa of this._interp.atn.decisionToDFA) {\n            if (!dfa.isEmpty) {\n                if (seenOne) {\n                    console.log();\n                }\n                console.log(\"Decision \" + dfa.decision + \":\");\n                process.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));\n                seenOne = true;\n            }\n        }\n    }\n    get sourceName() {\n        return this._input.sourceName;\n    }\n    get parseInfo() {\n        return Promise.resolve().then(() => require(\"./atn/ProfilingATNSimulator\")).then((m) => {\n            let interp = this.interpreter;\n            if (interp instanceof m.ProfilingATNSimulator) {\n                return new ParseInfo_1.ParseInfo(interp);\n            }\n            return undefined;\n        });\n    }\n    /**\n     * @since 4.3\n     */\n    setProfile(profile) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let m = yield Promise.resolve().then(() => require(\"./atn/ProfilingATNSimulator\"));\n            let interp = this.interpreter;\n            if (profile) {\n                if (!(interp instanceof m.ProfilingATNSimulator)) {\n                    this.interpreter = new m.ProfilingATNSimulator(this);\n                }\n            }\n            else if (interp instanceof m.ProfilingATNSimulator) {\n                this.interpreter = new ParserATNSimulator_1.ParserATNSimulator(this.atn, this);\n            }\n            this.interpreter.setPredictionMode(interp.getPredictionMode());\n        });\n    }\n    /** During a parse is sometimes useful to listen in on the rule entry and exit\n     *  events as well as token matches. This is for quick and dirty debugging.\n     */\n    set isTrace(trace) {\n        if (!trace) {\n            if (this._tracer) {\n                this.removeParseListener(this._tracer);\n                this._tracer = undefined;\n            }\n        }\n        else {\n            if (this._tracer) {\n                this.removeParseListener(this._tracer);\n            }\n            else {\n                this._tracer = new TraceListener(this.ruleNames, this._input);\n            }\n            this.addParseListener(this._tracer);\n        }\n    }\n    /**\n     * Gets whether a {@link TraceListener} is registered as a parse listener\n     * for the parser.\n     */\n    get isTrace() {\n        return this._tracer != null;\n    }\n}\n/**\n * This field maps from the serialized ATN string to the deserialized {@link ATN} with\n * bypass alternatives.\n *\n * @see ATNDeserializationOptions.isGenerateRuleBypassTransitions\n */\nParser.bypassAltsAtnCache = new Map();\n__decorate([\n    Decorators_1.NotNull\n], Parser.prototype, \"_errHandler\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], Parser.prototype, \"match\", null);\n__decorate([\n    Decorators_1.NotNull\n], Parser.prototype, \"matchWildcard\", null);\n__decorate([\n    Decorators_1.NotNull\n], Parser.prototype, \"getParseListeners\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], Parser.prototype, \"addParseListener\", null);\n__decorate([\n    Decorators_1.NotNull\n], Parser.prototype, \"getATNWithBypassAlts\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], Parser.prototype, \"errorHandler\", null);\n__decorate([\n    Decorators_1.Override\n], Parser.prototype, \"inputStream\", null);\n__decorate([\n    Decorators_1.NotNull\n], Parser.prototype, \"currentToken\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], Parser.prototype, \"enterRule\", null);\n__decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.Nullable)\n], Parser.prototype, \"precpred\", null);\n__decorate([\n    Decorators_1.Override\n], Parser.prototype, \"getErrorListenerDispatch\", null);\n__decorate([\n    Decorators_1.NotNull\n], Parser.prototype, \"getExpectedTokens\", null);\n__decorate([\n    Decorators_1.NotNull\n], Parser.prototype, \"getExpectedTokensWithinCurrentRule\", null);\n__decorate([\n    Decorators_1.Override\n], Parser.prototype, \"parseInfo\", null);\nexports.Parser = Parser;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:52.4399193-07:00\n\nimport * as assert from \"assert\";\nimport * as Utils from \"./misc/Utils\";\n\nimport { ANTLRErrorListener } from \"./ANTLRErrorListener\";\nimport { ANTLRErrorStrategy } from \"./ANTLRErrorStrategy\";\nimport { ATN } from \"./atn/ATN\";\nimport { ATNDeserializationOptions } from \"./atn/ATNDeserializationOptions\";\nimport { ATNDeserializer } from \"./atn/ATNDeserializer\";\nimport { ATNSimulator } from \"./atn/ATNSimulator\";\nimport { ATNState } from \"./atn/ATNState\";\nimport { DefaultErrorStrategy } from \"./DefaultErrorStrategy\";\nimport { DFA } from \"./dfa/DFA\";\nimport { ErrorNode } from \"./tree/ErrorNode\";\nimport { IntegerStack } from \"./misc/IntegerStack\";\nimport { IntervalSet } from \"./misc/IntervalSet\";\nimport { IntStream } from \"./IntStream\";\nimport { Lexer } from \"./Lexer\";\nimport { Override, NotNull, Nullable } from \"./Decorators\";\nimport { ParseInfo } from \"./atn/ParseInfo\";\nimport { ParserATNSimulator } from \"./atn/ParserATNSimulator\";\nimport { ParserErrorListener } from \"./ParserErrorListener\";\nimport { ParserRuleContext } from \"./ParserRuleContext\";\nimport { ParseTreeListener } from \"./tree/ParseTreeListener\";\nimport { ParseTreePattern } from \"./tree/pattern/ParseTreePattern\";\nimport { ProxyParserErrorListener } from \"./ProxyParserErrorListener\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { Recognizer } from \"./Recognizer\";\nimport { RuleContext } from \"./RuleContext\";\nimport { RuleTransition } from \"./atn/RuleTransition\";\nimport { TerminalNode } from \"./tree/TerminalNode\";\nimport { Token } from \"./Token\";\nimport { TokenFactory } from \"./TokenFactory\";\nimport { TokenSource } from \"./TokenSource\";\nimport { TokenStream } from \"./TokenStream\";\n\nclass TraceListener implements ParseTreeListener {\n\tconstructor(private ruleNames: string[], private tokenStream: TokenStream) {\n\t}\n\n\t@Override\n\tpublic enterEveryRule(ctx: ParserRuleContext): void {\n\t\tconsole.log(\"enter   \" + this.ruleNames[ctx.ruleIndex] +\n\t\t\t\", LT(1)=\" + this.tokenStream.LT(1).text);\n\t}\n\n\t@Override\n\tpublic exitEveryRule(ctx: ParserRuleContext): void {\n\t\tconsole.log(\"exit    \" + this.ruleNames[ctx.ruleIndex] +\n\t\t\t\", LT(1)=\" + this.tokenStream.LT(1).text);\n\t}\n\n\t@Override\n\tpublic visitErrorNode(node: ErrorNode): void {\n\t\t// intentionally empty\n\t}\n\n\t@Override\n\tpublic visitTerminal(node: TerminalNode): void {\n\t\tlet parent = node.parent!.ruleContext;\n\t\tlet token: Token = node.symbol;\n\t\tconsole.log(\"consume \" + token + \" rule \" + this.ruleNames[parent.ruleIndex]);\n\t}\n}\n\n/** This is all the parsing support code essentially; most of it is error recovery stuff. */\nexport abstract class Parser extends Recognizer<Token, ParserATNSimulator> {\n\t/**\n\t * This field maps from the serialized ATN string to the deserialized {@link ATN} with\n\t * bypass alternatives.\n\t *\n\t * @see ATNDeserializationOptions.isGenerateRuleBypassTransitions\n\t */\n\tprivate static readonly bypassAltsAtnCache = new Map<string, ATN>();\n\n\t/**\n\t * The error handling strategy for the parser. The default value is a new\n\t * instance of {@link DefaultErrorStrategy}.\n\t *\n\t * @see #getErrorHandler\n\t * @see #setErrorHandler\n\t */\n\t@NotNull\n\tprotected _errHandler: ANTLRErrorStrategy = new DefaultErrorStrategy();\n\n\t/**\n\t * The input stream.\n\t *\n\t * @see #getInputStream\n\t * @see #setInputStream\n\t */\n\tprotected _input: TokenStream;\n\n\tprotected readonly _precedenceStack: IntegerStack = new IntegerStack();\n\n\t/**\n\t * The {@link ParserRuleContext} object for the currently executing rule.\n\t *\n\t * This is always non-undefined during the parsing process.\n\t */\n\tprotected _ctx: ParserRuleContext;\n\n\t/**\n\t * Specifies whether or not the parser should construct a parse tree during\n\t * the parsing process. The default value is `true`.\n\t *\n\t * @see `buildParseTree`\n\t */\n\tprivate _buildParseTrees: boolean = true;\n\n\t/**\n\t * When {@link #setTrace}`(true)` is called, a reference to the\n\t * {@link TraceListener} is stored here so it can be easily removed in a\n\t * later call to {@link #setTrace}`(false)`. The listener itself is\n\t * implemented as a parser listener so this field is not directly used by\n\t * other parser methods.\n\t */\n\tprivate _tracer: TraceListener | undefined;\n\n\t/**\n\t * The list of {@link ParseTreeListener} listeners registered to receive\n\t * events during the parse.\n\t *\n\t * @see #addParseListener\n\t */\n\tprotected _parseListeners: ParseTreeListener[] = [];\n\n\t/**\n\t * The number of syntax errors reported during parsing. This value is\n\t * incremented each time {@link #notifyErrorListeners} is called.\n\t */\n\tprotected _syntaxErrors: number = 0;\n\n\t/** Indicates parser has match()ed EOF token. See {@link #exitRule()}. */\n\tprotected matchedEOF: boolean = false;\n\n\tconstructor(input: TokenStream) {\n\t\tsuper();\n\t\tthis._precedenceStack.push(0);\n\t\tthis.inputStream = input;\n\t}\n\n\t/** reset the parser's state */\n\tpublic reset(): void;\n\tpublic reset(resetInput: boolean): void;\n\tpublic reset(resetInput?: boolean): void {\n\t\t// Note: this method executes when not parsing, so _ctx can be undefined\n\t\tif (resetInput === undefined || resetInput) {\n\t\t\tthis.inputStream.seek(0);\n\t\t}\n\n\t\tthis._errHandler.reset(this);\n\t\tthis._ctx = undefined as any;\n\t\tthis._syntaxErrors = 0;\n\t\tthis.matchedEOF = false;\n\t\tthis.isTrace = false;\n\t\tthis._precedenceStack.clear();\n\t\tthis._precedenceStack.push(0);\n\t\tlet interpreter: ATNSimulator = this.interpreter;\n\t\tif (interpreter != null) {\n\t\t\tinterpreter.reset();\n\t\t}\n\t}\n\n\t/**\n\t * Match current input symbol against `ttype`. If the symbol type\n\t * matches, {@link ANTLRErrorStrategy#reportMatch} and {@link #consume} are\n\t * called to complete the match process.\n\t *\n\t * If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy#recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link #getBuildParseTree} is\n\t * `true` and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link #createErrorNode(ParserRuleContext, Token)} then\n\t * {@link ParserRuleContext#addErrorNode(ErrorNode)}.\n\t *\n\t * @param ttype the token type to match\n\t * @returns the matched symbol\n\t * @ if the current input symbol did not match\n\t * `ttype` and the error strategy could not recover from the\n\t * mismatched symbol\n\t */\n\t@NotNull\n\tpublic match(ttype: number): Token {\n\t\tlet t: Token = this.currentToken;\n\t\tif (t.type === ttype) {\n\t\t\tif (ttype === Token.EOF) {\n\t\t\t\tthis.matchedEOF = true;\n\t\t\t}\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t}\n\t\telse {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this._buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(this.createErrorNode(this._ctx, t));\n\t\t\t}\n\t\t}\n\t\treturn t;\n\t}\n\n\t/**\n\t * Match current input symbol as a wildcard. If the symbol type matches\n\t * (i.e. has a value greater than 0), {@link ANTLRErrorStrategy#reportMatch}\n\t * and {@link #consume} are called to complete the match process.\n\t *\n\t * If the symbol type does not match,\n\t * {@link ANTLRErrorStrategy#recoverInline} is called on the current error\n\t * strategy to attempt recovery. If {@link #getBuildParseTree} is\n\t * `true` and the token index of the symbol returned by\n\t * {@link ANTLRErrorStrategy#recoverInline} is -1, the symbol is added to\n\t * the parse tree by calling {@link Parser#createErrorNode(ParserRuleContext, Token)} then\n\t * {@link ParserRuleContext#addErrorNode(ErrorNode)}.\n\t *\n\t * @returns the matched symbol\n\t * @ if the current input symbol did not match\n\t * a wildcard and the error strategy could not recover from the mismatched\n\t * symbol\n\t */\n\t@NotNull\n\tpublic matchWildcard(): Token {\n\t\tlet t: Token = this.currentToken;\n\t\tif (t.type > 0) {\n\t\t\tthis._errHandler.reportMatch(this);\n\t\t\tthis.consume();\n\t\t}\n\t\telse {\n\t\t\tt = this._errHandler.recoverInline(this);\n\t\t\tif (this._buildParseTrees && t.tokenIndex === -1) {\n\t\t\t\t// we must have conjured up a new token during single token insertion\n\t\t\t\t// if it's not the current symbol\n\t\t\t\tthis._ctx.addErrorNode(this.createErrorNode(this._ctx, t));\n\t\t\t}\n\t\t}\n\n\t\treturn t;\n\t}\n\n\t/**\n\t * Track the {@link ParserRuleContext} objects during the parse and hook\n\t * them up using the {@link ParserRuleContext#children} list so that it\n\t * forms a parse tree. The {@link ParserRuleContext} returned from the start\n\t * rule represents the root of the parse tree.\n\t *\n\t * Note that if we are not building parse trees, rule contexts only point\n\t * upwards. When a rule exits, it returns the context but that gets garbage\n\t * collected if nobody holds a reference. It points upwards but nobody\n\t * points at it.\n\t *\n\t * When we build parse trees, we are adding all of these contexts to\n\t * {@link ParserRuleContext#children} list. Contexts are then not candidates\n\t * for garbage collection.\n\t */\n\tset buildParseTree(buildParseTrees: boolean) {\n\t\tthis._buildParseTrees = buildParseTrees;\n\t}\n\n\t/**\n\t * Gets whether or not a complete parse tree will be constructed while\n\t * parsing. This property is `true` for a newly constructed parser.\n\t *\n\t * @returns `true` if a complete parse tree will be constructed while\n\t * parsing, otherwise `false`\n\t */\n\tget buildParseTree(): boolean {\n\t\treturn this._buildParseTrees;\n\t}\n\n\t@NotNull\n\tpublic getParseListeners(): ParseTreeListener[] {\n\t\treturn this._parseListeners;\n\t}\n\n\t/**\n\t * Registers `listener` to receive events during the parsing process.\n\t *\n\t * To support output-preserving grammar transformations (including but not\n\t * limited to left-recursion removal, automated left-factoring, and\n\t * optimized code generation), calls to listener methods during the parse\n\t * may differ substantially from calls made by\n\t * {@link ParseTreeWalker#DEFAULT} used after the parse is complete. In\n\t * particular, rule entry and exit events may occur in a different order\n\t * during the parse than after the parser. In addition, calls to certain\n\t * rule entry methods may be omitted.\n\t *\n\t * With the following specific exceptions, calls to listener events are\n\t * *deterministic*, i.e. for identical input the calls to listener\n\t * methods will be the same.\n\t *\n\t * * Alterations to the grammar used to generate code may change the\n\t *   behavior of the listener calls.\n\t * * Alterations to the command line options passed to ANTLR 4 when\n\t *   generating the parser may change the behavior of the listener calls.\n\t * * Changing the version of the ANTLR Tool used to generate the parser\n\t *   may change the behavior of the listener calls.\n\t *\n\t * @param listener the listener to add\n\t *\n\t * @throws {@link TypeError} if `listener` is `undefined`\n\t */\n\tpublic addParseListener(@NotNull listener: ParseTreeListener): void {\n\t\tif (listener == null) {\n\t\t\tthrow new TypeError(\"listener cannot be null\");\n\t\t}\n\n\t\tthis._parseListeners.push(listener);\n\t}\n\n\t/**\n\t * Remove `listener` from the list of parse listeners.\n\t *\n\t * If `listener` is `undefined` or has not been added as a parse\n\t * listener, this method does nothing.\n\t *\n\t * @see #addParseListener\n\t *\n\t * @param listener the listener to remove\n\t */\n\tpublic removeParseListener(listener: ParseTreeListener): void {\n\t\tlet index = this._parseListeners.findIndex((l) => l === listener);\n\t\tif (index !== -1) {\n\t\t\tthis._parseListeners.splice(index, 1);\n\t\t}\n\t}\n\n\n\t/**\n\t * Remove all parse listeners.\n\t *\n\t * @see #addParseListener\n\t */\n\tpublic removeParseListeners(): void {\n\t\tthis._parseListeners.length = 0;\n\t}\n\n\t/**\n\t * Notify any parse listeners of an enter rule event.\n\t *\n\t * @see #addParseListener\n\t */\n\tprotected triggerEnterRuleEvent(): void {\n\t\tfor (let listener of this._parseListeners) {\n\t\t\tif (listener.enterEveryRule) {\n\t\t\t\tlistener.enterEveryRule(this._ctx);\n\t\t\t}\n\n\t\t\tthis._ctx.enterRule(listener);\n\t\t}\n\t}\n\n\t/**\n\t * Notify any parse listeners of an exit rule event.\n\t *\n\t * @see #addParseListener\n\t */\n\tprotected triggerExitRuleEvent(): void {\n\t\t// reverse order walk of listeners\n\t\tfor (let i = this._parseListeners.length - 1; i >= 0; i--) {\n\t\t\tlet listener: ParseTreeListener = this._parseListeners[i];\n\t\t\tthis._ctx.exitRule(listener);\n\t\t\tif (listener.exitEveryRule) {\n\t\t\t\tlistener.exitEveryRule(this._ctx);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Gets the number of syntax errors reported during parsing. This value is\n\t * incremented each time {@link #notifyErrorListeners} is called.\n\t *\n\t * @see #notifyErrorListeners\n\t */\n\tget numberOfSyntaxErrors(): number {\n\t\treturn this._syntaxErrors;\n\t}\n\n\tget tokenFactory(): TokenFactory {\n\t\treturn this._input.tokenSource.tokenFactory;\n\t}\n\n\t/**\n\t * The ATN with bypass alternatives is expensive to create so we create it\n\t * lazily.\n\t *\n\t * @ if the current parser does not\n\t * implement the `serializedATN` property.\n\t */\n\t@NotNull\n\tpublic getATNWithBypassAlts(): ATN {\n\t\tlet serializedAtn: string = this.serializedATN;\n\t\tif (serializedAtn == null) {\n\t\t\tthrow new Error(\"The current parser does not support an ATN with bypass alternatives.\");\n\t\t}\n\n\t\tlet result = Parser.bypassAltsAtnCache.get(serializedAtn);\n\t\tif (result == null) {\n\t\t\tlet deserializationOptions: ATNDeserializationOptions = new ATNDeserializationOptions();\n\t\t\tdeserializationOptions.isGenerateRuleBypassTransitions = true;\n\t\t\tresult = new ATNDeserializer(deserializationOptions).deserialize(Utils.toCharArray(serializedAtn));\n\t\t\tParser.bypassAltsAtnCache.set(serializedAtn, result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * The preferred method of getting a tree pattern. For example, here's a\n\t * sample use:\n\t *\n\t * ```\n\t * let t: ParseTree = parser.expr();\n\t * let p: ParseTreePattern = await parser.compileParseTreePattern(\"<ID>+0\", MyParser.RULE_expr);\n\t * let m: ParseTreeMatch = p.match(t);\n\t * let id: string = m.get(\"ID\");\n\t * ```\n\t */\n\tpublic compileParseTreePattern(pattern: string, patternRuleIndex: number): Promise<ParseTreePattern>;\n\n\t/**\n\t * The same as {@link #compileParseTreePattern(String, int)} but specify a\n\t * {@link Lexer} rather than trying to deduce it from this parser.\n\t */\n\tpublic compileParseTreePattern(pattern: string, patternRuleIndex: number, lexer?: Lexer): Promise<ParseTreePattern>;\n\n\tpublic async compileParseTreePattern(pattern: string, patternRuleIndex: number, lexer?: Lexer): Promise<ParseTreePattern> {\n\t\tif (!lexer) {\n\t\t\tif (this.inputStream) {\n\t\t\t\tlet tokenSource = this.inputStream.tokenSource;\n\t\t\t\tif (tokenSource instanceof Lexer) {\n\t\t\t\t\tlexer = tokenSource;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!lexer) {\n\t\t\t\tthrow new Error(\"Parser can't discover a lexer to use\");\n\t\t\t}\n\t\t}\n\n\t\tlet currentLexer = lexer;\n\t\tlet m = await import(\"./tree/pattern/ParseTreePatternMatcher\");\n\t\tlet matcher = new m.ParseTreePatternMatcher(currentLexer, this);\n\t\treturn matcher.compile(pattern, patternRuleIndex);\n\t}\n\n\t@NotNull\n\tget errorHandler(): ANTLRErrorStrategy {\n\t\treturn this._errHandler;\n\t}\n\n\tset errorHandler(@NotNull handler: ANTLRErrorStrategy) {\n\t\tthis._errHandler = handler;\n\t}\n\n\t@Override\n\tget inputStream(): TokenStream {\n\t\treturn this._input;\n\t}\n\n\t/** Set the token stream and reset the parser. */\n\tset inputStream(input: TokenStream) {\n\t\tthis.reset(false);\n\t\tthis._input = input;\n\t}\n\n\t/** Match needs to return the current input symbol, which gets put\n\t *  into the label for the associated token ref; e.g., x=ID.\n\t */\n\t@NotNull\n\tget currentToken(): Token {\n\t\treturn this._input.LT(1);\n\t}\n\n\tpublic notifyErrorListeners(/*@NotNull*/ msg: string): void;\n\tpublic notifyErrorListeners(/*@NotNull*/ msg: string, /*@NotNull*/ offendingToken: Token | null, e: RecognitionException | undefined): void;\n\n\tpublic notifyErrorListeners(msg: string, offendingToken?: Token | null, e?: RecognitionException | undefined): void {\n\t\tif (offendingToken === undefined) {\n\t\t\toffendingToken = this.currentToken;\n\t\t} else if (offendingToken === null) {\n\t\t\toffendingToken = undefined;\n\t\t}\n\n\t\tthis._syntaxErrors++;\n\t\tlet line: number = -1;\n\t\tlet charPositionInLine: number = -1;\n\t\tif (offendingToken != null) {\n\t\t\tline = offendingToken.line;\n\t\t\tcharPositionInLine = offendingToken.charPositionInLine;\n\t\t}\n\n\t\tlet listener = this.getErrorListenerDispatch();\n\t\tif (listener.syntaxError) {\n\t\t\tlistener.syntaxError(this, offendingToken, line, charPositionInLine, msg, e);\n\t\t}\n\t}\n\n\t/**\n\t * Consume and return the [current symbol](`currentToken`).\n\t *\n\t * E.g., given the following input with `A` being the current\n\t * lookahead symbol, this function moves the cursor to `B` and returns\n\t * `A`.\n\t *\n\t * ```\n\t * A B\n\t * ^\n\t * ```\n\t *\n\t * If the parser is not in error recovery mode, the consumed symbol is added\n\t * to the parse tree using {@link ParserRuleContext#addChild(TerminalNode)}, and\n\t * {@link ParseTreeListener#visitTerminal} is called on any parse listeners.\n\t * If the parser *is* in error recovery mode, the consumed symbol is\n\t * added to the parse tree using {@link #createErrorNode(ParserRuleContext, Token)} then\n\t * {@link ParserRuleContext#addErrorNode(ErrorNode)} and\n\t * {@link ParseTreeListener#visitErrorNode} is called on any parse\n\t * listeners.\n\t */\n\tpublic consume(): Token {\n\t\tlet o: Token = this.currentToken;\n\t\tif (o.type !== Parser.EOF) {\n\t\t\tthis.inputStream.consume();\n\t\t}\n\t\tlet hasListener: boolean = this._parseListeners.length !== 0;\n\t\tif (this._buildParseTrees || hasListener) {\n\t\t\tif (this._errHandler.inErrorRecoveryMode(this)) {\n\t\t\t\tlet node: ErrorNode = this._ctx.addErrorNode(this.createErrorNode(this._ctx, o));\n\t\t\t\tif (hasListener) {\n\t\t\t\t\tfor (let listener of this._parseListeners) {\n\t\t\t\t\t\tif (listener.visitErrorNode) {\n\t\t\t\t\t\t\tlistener.visitErrorNode(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet node: TerminalNode = this.createTerminalNode(this._ctx, o);\n\t\t\t\tthis._ctx.addChild(node);\n\t\t\t\tif (hasListener) {\n\t\t\t\t\tfor (let listener of this._parseListeners) {\n\t\t\t\t\t\tif (listener.visitTerminal) {\n\t\t\t\t\t\t\tlistener.visitTerminal(node);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn o;\n\t}\n\n\t/**\n\t * How to create a token leaf node associated with a parent.\n\t * Typically, the terminal node to create is not a function of the parent.\n\t *\n\t * @since 4.7\n\t */\n\tpublic createTerminalNode(parent: ParserRuleContext, t: Token): TerminalNode {\n\t\treturn new TerminalNode(t);\n\t}\n\n\t/**\n\t * How to create an error node, given a token, associated with a parent.\n\t * Typically, the error node to create is not a function of the parent.\n\t *\n\t * @since 4.7\n\t */\n\tpublic createErrorNode(parent: ParserRuleContext, t: Token): ErrorNode {\n\t\treturn new ErrorNode(t);\n\t}\n\n\tprotected addContextToParseTree(): void {\n\t\tlet parent = this._ctx._parent as ParserRuleContext | undefined;\n\t\t// add current context to parent if we have a parent\n\t\tif (parent != null) {\n\t\t\tparent.addChild(this._ctx);\n\t\t}\n\t}\n\n\t/**\n\t * Always called by generated parsers upon entry to a rule. Access field\n\t * {@link #_ctx} get the current context.\n\t */\n\tpublic enterRule(@NotNull localctx: ParserRuleContext, state: number, ruleIndex: number): void {\n\t\tthis.state = state;\n\t\tthis._ctx = localctx;\n\t\tthis._ctx._start = this._input.LT(1);\n\t\tif (this._buildParseTrees) {\n\t\t\tthis.addContextToParseTree();\n\t\t}\n\t\tthis.triggerEnterRuleEvent();\n\t}\n\n\tpublic enterLeftFactoredRule(localctx: ParserRuleContext, state: number, ruleIndex: number): void {\n\t\tthis.state = state;\n\t\tif (this._buildParseTrees) {\n\t\t\tlet factoredContext = this._ctx.getChild(this._ctx.childCount - 1) as ParserRuleContext;\n\t\t\tthis._ctx.removeLastChild();\n\t\t\tfactoredContext._parent = localctx;\n\t\t\tlocalctx.addChild(factoredContext);\n\t\t}\n\n\t\tthis._ctx = localctx;\n\t\tthis._ctx._start = this._input.LT(1);\n\t\tif (this._buildParseTrees) {\n\t\t\tthis.addContextToParseTree();\n\t\t}\n\n\t\tthis.triggerEnterRuleEvent();\n\t}\n\n\tpublic exitRule(): void {\n\t\tif (this.matchedEOF) {\n\t\t\t// if we have matched EOF, it cannot consume past EOF so we use LT(1) here\n\t\t\tthis._ctx._stop = this._input.LT(1); // LT(1) will be end of file\n\t\t}\n\t\telse {\n\t\t\tthis._ctx._stop = this._input.tryLT(-1); // stop node is what we just matched\n\t\t}\n\t\t// trigger event on _ctx, before it reverts to parent\n\t\tthis.triggerExitRuleEvent();\n\t\tthis.state = this._ctx.invokingState;\n\t\tthis._ctx = this._ctx._parent as ParserRuleContext;\n\t}\n\n\tpublic enterOuterAlt(localctx: ParserRuleContext, altNum: number): void {\n\t\tlocalctx.altNumber = altNum;\n\t\t// if we have new localctx, make sure we replace existing ctx\n\t\t// that is previous child of parse tree\n\t\tif (this._buildParseTrees && this._ctx !== localctx) {\n\t\t\tlet parent = this._ctx._parent as ParserRuleContext | undefined;\n\t\t\tif (parent != null) {\n\t\t\t\tparent.removeLastChild();\n\t\t\t\tparent.addChild(localctx);\n\t\t\t}\n\t\t}\n\t\tthis._ctx = localctx;\n\t}\n\n\t/**\n\t * Get the precedence level for the top-most precedence rule.\n\t *\n\t * @returns The precedence level for the top-most precedence rule, or -1 if\n\t * the parser context is not nested within a precedence rule.\n\t */\n\tget precedence(): number {\n\t\tif (this._precedenceStack.isEmpty) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn this._precedenceStack.peek();\n\t}\n\n\tpublic enterRecursionRule(localctx: ParserRuleContext, state: number, ruleIndex: number, precedence: number): void {\n\t\tthis.state = state;\n\t\tthis._precedenceStack.push(precedence);\n\t\tthis._ctx = localctx;\n\t\tthis._ctx._start = this._input.LT(1);\n\t\tthis.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n\t}\n\n\t/** Like {@link #enterRule} but for recursive rules.\n\t *  Make the current context the child of the incoming localctx.\n\t */\n\tpublic pushNewRecursionContext(localctx: ParserRuleContext, state: number, ruleIndex: number): void {\n\t\tlet previous: ParserRuleContext = this._ctx;\n\t\tprevious._parent = localctx;\n\t\tprevious.invokingState = state;\n\t\tprevious._stop = this._input.tryLT(-1);\n\n\t\tthis._ctx = localctx;\n\t\tthis._ctx._start = previous._start;\n\t\tif (this._buildParseTrees) {\n\t\t\tthis._ctx.addChild(previous);\n\t\t}\n\n\t\tthis.triggerEnterRuleEvent(); // simulates rule entry for left-recursive rules\n\t}\n\n\tpublic unrollRecursionContexts(_parentctx: ParserRuleContext): void {\n\t\tthis._precedenceStack.pop();\n\t\tthis._ctx._stop = this._input.tryLT(-1);\n\t\tlet retctx: ParserRuleContext = this._ctx; // save current ctx (return value)\n\n\t\t// unroll so _ctx is as it was before call to recursive method\n\t\tif (this._parseListeners.length > 0) {\n\t\t\twhile (this._ctx !== _parentctx) {\n\t\t\t\tthis.triggerExitRuleEvent();\n\t\t\t\tthis._ctx = this._ctx._parent as ParserRuleContext;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis._ctx = _parentctx;\n\t\t}\n\n\t\t// hook into tree\n\t\tretctx._parent = _parentctx;\n\n\t\tif (this._buildParseTrees && _parentctx != null) {\n\t\t\t// add return ctx into invoking rule's tree\n\t\t\t_parentctx.addChild(retctx);\n\t\t}\n\t}\n\n\tpublic getInvokingContext(ruleIndex: number): ParserRuleContext | undefined {\n\t\tlet p = this._ctx;\n\t\twhile (p && p.ruleIndex !== ruleIndex) {\n\t\t\tp = p._parent as ParserRuleContext;\n\t\t}\n\t\treturn p;\n\t}\n\n\tget context(): ParserRuleContext {\n\t\treturn this._ctx;\n\t}\n\n\tset context(ctx: ParserRuleContext) {\n\t\tthis._ctx = ctx;\n\t}\n\n\t@Override\n\tpublic precpred(@Nullable localctx: RuleContext, precedence: number): boolean {\n\t\treturn precedence >= this._precedenceStack.peek();\n\t}\n\n\t@Override\n\tpublic getErrorListenerDispatch(): ParserErrorListener {\n\t\treturn new ProxyParserErrorListener(this.getErrorListeners());\n\t}\n\n\tpublic inContext(context: string): boolean {\n\t\t// TODO: useful in parser?\n\t\treturn false;\n\t}\n\n\t/**\n\t * Checks whether or not `symbol` can follow the current state in the\n\t * ATN. The behavior of this method is equivalent to the following, but is\n\t * implemented such that the complete context-sensitive follow set does not\n\t * need to be explicitly constructed.\n\t *\n\t * ```\n\t * return getExpectedTokens().contains(symbol);\n\t * ```\n\t *\n\t * @param symbol the symbol type to check\n\t * @returns `true` if `symbol` can follow the current state in\n\t * the ATN, otherwise `false`.\n\t */\n\tpublic isExpectedToken(symbol: number): boolean {\n//   \t\treturn interpreter.atn.nextTokens(_ctx);\n\t\tlet atn: ATN = this.interpreter.atn;\n\t\tlet ctx: ParserRuleContext = this._ctx;\n\t\tlet s: ATNState = atn.states[this.state];\n\t\tlet following: IntervalSet = atn.nextTokens(s);\n\t\tif (following.contains(symbol)) {\n\t\t\treturn true;\n\t\t}\n//        System.out.println(\"following \"+s+\"=\"+following);\n\t\tif (!following.contains(Token.EPSILON)) {\n\t\t\treturn false;\n\t\t}\n\n\t\twhile (ctx != null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n\t\t\tlet invokingState: ATNState = atn.states[ctx.invokingState];\n\t\t\tlet rt = invokingState.transition(0) as RuleTransition;\n\t\t\tfollowing = atn.nextTokens(rt.followState);\n\t\t\tif (following.contains(symbol)) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tctx = ctx._parent as ParserRuleContext;\n\t\t}\n\n\t\tif (following.contains(Token.EPSILON) && symbol === Token.EOF) {\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget isMatchedEOF(): boolean {\n\t\treturn this.matchedEOF;\n\t}\n\n\t/**\n\t * Computes the set of input symbols which could follow the current parser\n\t * state and context, as given by {@link #getState} and {@link #getContext},\n\t * respectively.\n\t *\n\t * @see ATN#getExpectedTokens(int, RuleContext)\n\t */\n\t@NotNull\n\tpublic getExpectedTokens(): IntervalSet {\n\t\treturn this.atn.getExpectedTokens(this.state, this.context);\n\t}\n\n\t@NotNull\n\tpublic getExpectedTokensWithinCurrentRule(): IntervalSet {\n\t\tlet atn: ATN = this.interpreter.atn;\n\t\tlet s: ATNState = atn.states[this.state];\n\t\treturn atn.nextTokens(s);\n\t}\n\n\t/** Get a rule's index (i.e., `RULE_ruleName` field) or -1 if not found. */\n\tpublic getRuleIndex(ruleName: string): number {\n\t\tlet ruleIndex = this.getRuleIndexMap().get(ruleName);\n\t\tif (ruleIndex != null) {\n\t\t\treturn ruleIndex;\n\t\t}\n\t\treturn -1;\n\t}\n\n\tget ruleContext(): ParserRuleContext { return this._ctx; }\n\n\t/** Return List&lt;String&gt; of the rule names in your parser instance\n\t *  leading up to a call to the current rule.  You could override if\n\t *  you want more details such as the file/line info of where\n\t *  in the ATN a rule is invoked.\n\t *\n\t *  This is very useful for error messages.\n\t */\n\n\tpublic getRuleInvocationStack(ctx: RuleContext = this._ctx): string[] {\n\t\tlet p: RuleContext | undefined = ctx;  \t\t// Workaround for Microsoft/TypeScript#14487\n\t\tlet ruleNames: string[] = this.ruleNames;\n\t\tlet stack: string[] = [];\n\t\twhile (p != null) {\n\t\t\t// compute what follows who invoked us\n\t\t\tlet ruleIndex: number = p.ruleIndex;\n\t\t\tif (ruleIndex < 0) {\n\t\t\t\tstack.push(\"n/a\");\n\t\t\t} else {\n\t\t\t\tstack.push(ruleNames[ruleIndex]);\n\t\t\t}\n\t\t\tp = p._parent as RuleContext;\n\t\t}\n\t\treturn stack;\n\t}\n\n\t/** For debugging and other purposes. */\n\tpublic getDFAStrings(): string[] {\n\t\tlet s: string[] = [];\n\t\tfor (let dfa of this._interp.atn.decisionToDFA) {\n\t\t\ts.push(dfa.toString(this.vocabulary, this.ruleNames));\n\t\t}\n\t\treturn s;\n\t}\n\n\t/** For debugging and other purposes. */\n\tpublic dumpDFA(): void {\n\t\tlet seenOne: boolean = false;\n\t\tfor (let dfa of this._interp.atn.decisionToDFA) {\n\t\t\tif (!dfa.isEmpty) {\n\t\t\t\tif (seenOne) {\n\t\t\t\t\tconsole.log();\n\t\t\t\t}\n\t\t\t\tconsole.log(\"Decision \" + dfa.decision + \":\");\n\t\t\t\tprocess.stdout.write(dfa.toString(this.vocabulary, this.ruleNames));\n\t\t\t\tseenOne = true;\n\t\t\t}\n\t\t}\n\t}\n\n\tget sourceName(): string {\n\t\treturn this._input.sourceName;\n\t}\n\n\t@Override\n\tget parseInfo(): Promise<ParseInfo | undefined> {\n\t\treturn import(\"./atn/ProfilingATNSimulator\").then((m) => {\n\t\t\tlet interp: ParserATNSimulator = this.interpreter;\n\t\t\tif (interp instanceof m.ProfilingATNSimulator) {\n\t\t\t\treturn new ParseInfo(interp);\n\t\t\t}\n\n\t\t\treturn undefined;\n\t\t});\n\t}\n\n\t/**\n\t * @since 4.3\n\t */\n\tpublic async setProfile(profile: boolean): Promise<void> {\n\t\tlet m = await import(\"./atn/ProfilingATNSimulator\");\n\t\tlet interp: ParserATNSimulator = this.interpreter;\n\t\tif (profile) {\n\t\t\tif (!(interp instanceof m.ProfilingATNSimulator)) {\n\t\t\t\tthis.interpreter = new m.ProfilingATNSimulator(this);\n\t\t\t}\n\t\t} else if (interp instanceof m.ProfilingATNSimulator) {\n\t\t\tthis.interpreter = new ParserATNSimulator(this.atn, this);\n\t\t}\n\n\t\tthis.interpreter.setPredictionMode(interp.getPredictionMode());\n\t}\n\n\t/** During a parse is sometimes useful to listen in on the rule entry and exit\n\t *  events as well as token matches. This is for quick and dirty debugging.\n\t */\n\tset isTrace(trace: boolean) {\n\t\tif (!trace) {\n\t\t\tif (this._tracer) {\n\t\t\t\tthis.removeParseListener(this._tracer);\n\t\t\t\tthis._tracer = undefined;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (this._tracer) {\n\t\t\t\tthis.removeParseListener(this._tracer);\n\t\t\t} else {\n\t\t\t\tthis._tracer = new TraceListener(this.ruleNames, this._input);\n\t\t\t}\n\n\t\t\tthis.addParseListener(this._tracer);\n\t\t}\n\t}\n\n\t/**\n\t * Gets whether a {@link TraceListener} is registered as a parse listener\n\t * for the parser.\n\t */\n\tget isTrace(): boolean {\n\t\treturn this._tracer != null;\n\t}\n}\n"]}