{"version":3,"sources":["dfa/DFA.js","../src/dfa/DFA.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","Array2DHashSet_1","require","ATNConfigSet_1","DFASerializer_1","DFAState_1","LexerDFASerializer_1","Decorators_1","ObjectEqualityComparator_1","StarLoopEntryState_1","VocabularyImpl_1","DFA","atnStartState","decision","states","Array2DHashSet","ObjectEqualityComparator","INSTANCE","nextStateNumber","atn","Error","isPrecedenceDfa","StarLoopEntryState","precedenceRuleDecision","s0","DFAState","ATNConfigSet","s0full","precedenceDfa","precedence","fullContext","getTarget","startState","setTarget","state","stateNumber","getOrAdd","vocabulary","ruleNames","VocabularyImpl","EMPTY_VOCABULARY","serializer","DFASerializer","toString","LexerDFASerializer","getEdgeMap","size","NotNull","prototype"],"mappings":"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","file":"DFA.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:38.3567094-07:00\nconst Array2DHashSet_1 = require(\"../misc/Array2DHashSet\");\nconst ATNConfigSet_1 = require(\"../atn/ATNConfigSet\");\nconst DFASerializer_1 = require(\"./DFASerializer\");\nconst DFAState_1 = require(\"./DFAState\");\nconst LexerDFASerializer_1 = require(\"./LexerDFASerializer\");\nconst Decorators_1 = require(\"../Decorators\");\nconst ObjectEqualityComparator_1 = require(\"../misc/ObjectEqualityComparator\");\nconst StarLoopEntryState_1 = require(\"../atn/StarLoopEntryState\");\nconst VocabularyImpl_1 = require(\"../VocabularyImpl\");\nlet DFA = class DFA {\n    constructor(atnStartState, decision = 0) {\n        /**\n         * A set of all states in the `DFA`.\n         *\n         * Note that this collection of states holds the DFA states for both SLL and LL prediction. Only the start state\n         * needs to be differentiated for these cases, which is tracked by the `s0` and `s0full` fields.\n         */\n        this.states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n        this.nextStateNumber = 0;\n        if (!atnStartState.atn) {\n            throw new Error(\"The ATNState must be associated with an ATN\");\n        }\n        this.atnStartState = atnStartState;\n        this.atn = atnStartState.atn;\n        this.decision = decision;\n        // Precedence DFAs are associated with the special precedence decision created for left-recursive rules which\n        // evaluate their alternatives using a precedence hierarchy. When such a decision is encountered, we mark this\n        // DFA instance as a precedence DFA and initialize the initial states s0 and s0full to special DFAState\n        // instances which use outgoing edges to link to the actual start state used for each precedence level.\n        let isPrecedenceDfa = false;\n        if (atnStartState instanceof StarLoopEntryState_1.StarLoopEntryState) {\n            if (atnStartState.precedenceRuleDecision) {\n                isPrecedenceDfa = true;\n                this.s0 = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());\n                this.s0full = new DFAState_1.DFAState(new ATNConfigSet_1.ATNConfigSet());\n            }\n        }\n        this.precedenceDfa = isPrecedenceDfa;\n    }\n    /**\n     * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special\n     * start state {@link #s0} which is not stored in {@link #states}. The\n     * {@link DFAState#edges} array for this start state contains outgoing edges\n     * supplying individual start states corresponding to specific precedence\n     * values.\n     *\n     * @returns `true` if this is a precedence DFA; otherwise,\n     * `false`.\n     * @see Parser.precedence\n     */\n    get isPrecedenceDfa() {\n        return this.precedenceDfa;\n    }\n    /**\n     * Get the start state for a specific precedence value.\n     *\n     * @param precedence The current precedence.\n     * @returns The start state corresponding to the specified precedence, or\n     * `undefined` if no start state exists for the specified precedence.\n     *\n     * @ if this is not a precedence DFA.\n     * @see `isPrecedenceDfa`\n     */\n    getPrecedenceStartState(precedence, fullContext) {\n        if (!this.isPrecedenceDfa) {\n            throw new Error(\"Only precedence DFAs may contain a precedence start state.\");\n        }\n        // s0 and s0full are never null for a precedence DFA\n        if (fullContext) {\n            return this.s0full.getTarget(precedence);\n        }\n        else {\n            return this.s0.getTarget(precedence);\n        }\n    }\n    /**\n     * Set the start state for a specific precedence value.\n     *\n     * @param precedence The current precedence.\n     * @param startState The start state corresponding to the specified\n     * precedence.\n     *\n     * @ if this is not a precedence DFA.\n     * @see `isPrecedenceDfa`\n     */\n    setPrecedenceStartState(precedence, fullContext, startState) {\n        if (!this.isPrecedenceDfa) {\n            throw new Error(\"Only precedence DFAs may contain a precedence start state.\");\n        }\n        if (precedence < 0) {\n            return;\n        }\n        if (fullContext) {\n            // s0full is never null for a precedence DFA\n            this.s0full.setTarget(precedence, startState);\n        }\n        else {\n            // s0 is never null for a precedence DFA\n            this.s0.setTarget(precedence, startState);\n        }\n    }\n    get isEmpty() {\n        if (this.isPrecedenceDfa) {\n            // s0 and s0full are never null for a precedence DFA\n            return this.s0.getEdgeMap().size === 0 && this.s0full.getEdgeMap().size === 0;\n        }\n        return this.s0 == null && this.s0full == null;\n    }\n    get isContextSensitive() {\n        if (this.isPrecedenceDfa) {\n            // s0full is never null for a precedence DFA\n            return this.s0full.getEdgeMap().size > 0;\n        }\n        return this.s0full != null;\n    }\n    addState(state) {\n        state.stateNumber = this.nextStateNumber++;\n        return this.states.getOrAdd(state);\n    }\n    toString(vocabulary, ruleNames) {\n        if (!vocabulary) {\n            vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;\n        }\n        if (!this.s0) {\n            return \"\";\n        }\n        let serializer;\n        if (ruleNames) {\n            serializer = new DFASerializer_1.DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);\n        }\n        else {\n            serializer = new DFASerializer_1.DFASerializer(this, vocabulary);\n        }\n        return serializer.toString();\n    }\n    toLexerString() {\n        if (!this.s0) {\n            return \"\";\n        }\n        let serializer = new LexerDFASerializer_1.LexerDFASerializer(this);\n        return serializer.toString();\n    }\n};\n__decorate([\n    Decorators_1.NotNull\n], DFA.prototype, \"states\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], DFA.prototype, \"atnStartState\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], DFA.prototype, \"atn\", void 0);\nDFA = __decorate([\n    __param(0, Decorators_1.NotNull)\n], DFA);\nexports.DFA = DFA;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:38.3567094-07:00\n\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\nimport { ATN } from \"../atn/ATN\";\nimport { ATNConfigSet } from \"../atn/ATNConfigSet\";\nimport { ATNState } from \"../atn/ATNState\";\nimport { ATNType } from \"../atn/ATNType\";\nimport { DecisionState } from \"../atn/DecisionState\";\nimport { DFASerializer } from \"./DFASerializer\";\nimport { DFAState } from \"./DFAState\";\nimport { LexerATNSimulator } from \"../atn/LexerATNSimulator\";\nimport { LexerDFASerializer } from \"./LexerDFASerializer\";\nimport { NotNull } from \"../Decorators\";\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\nimport { StarLoopEntryState } from \"../atn/StarLoopEntryState\";\nimport { Token } from \"../Token\";\nimport { TokensStartState } from \"../atn/TokensStartState\";\nimport { Vocabulary } from \"../Vocabulary\";\nimport { VocabularyImpl } from \"../VocabularyImpl\";\n\nexport class DFA {\n\t/**\n\t * A set of all states in the `DFA`.\n\t *\n\t * Note that this collection of states holds the DFA states for both SLL and LL prediction. Only the start state\n\t * needs to be differentiated for these cases, which is tracked by the `s0` and `s0full` fields.\n\t */\n\t@NotNull\n\tpublic readonly states: Array2DHashSet<DFAState> = new Array2DHashSet<DFAState>(ObjectEqualityComparator.INSTANCE);\n\n\tpublic s0: DFAState | undefined;\n\n\tpublic s0full: DFAState | undefined;\n\n\tpublic readonly decision: number;\n\n\t/** From which ATN state did we create this DFA? */\n\t@NotNull\n\tpublic atnStartState: ATNState;\n\t/**\n\t * Note: this field is accessed as `atnStartState.atn` in other targets. The TypeScript target keeps a separate copy\n\t * to avoid a number of additional null/undefined checks each time the ATN is accessed.\n\t */\n\t@NotNull\n\tpublic atn: ATN;\n\n\tprivate nextStateNumber: number = 0;\n\n\t/**\n\t * `true` if this DFA is for a precedence decision; otherwise,\n\t * `false`. This is the backing field for {@link #isPrecedenceDfa}.\n\t */\n\tprivate precedenceDfa: boolean;\n\n\t/**\n\t * Constructs a `DFA` instance associated with a lexer mode.\n\t *\n\t * The start state for a `DFA` constructed with this constructor should be a `TokensStartState`, which is the start\n\t * state for a lexer mode. The prediction made by this DFA determines the lexer rule which matches the current\n\t * input.\n\t *\n\t * @param atnStartState The start state for the mode.\n\t */\n\tconstructor(atnStartState: TokensStartState);\n\t/**\n\t * Constructs a `DFA` instance associated with a decision.\n\t *\n\t * @param atnStartState The decision associated with this DFA.\n\t * @param decision The decision number.\n\t */\n\tconstructor(atnStartState: DecisionState, decision: number);\n\tconstructor(@NotNull atnStartState: ATNState, decision: number = 0) {\n\t\tif (!atnStartState.atn) {\n\t\t\tthrow new Error(\"The ATNState must be associated with an ATN\");\n\t\t}\n\n\t\tthis.atnStartState = atnStartState;\n\t\tthis.atn = atnStartState.atn;\n\t\tthis.decision = decision;\n\n\t\t// Precedence DFAs are associated with the special precedence decision created for left-recursive rules which\n\t\t// evaluate their alternatives using a precedence hierarchy. When such a decision is encountered, we mark this\n\t\t// DFA instance as a precedence DFA and initialize the initial states s0 and s0full to special DFAState\n\t\t// instances which use outgoing edges to link to the actual start state used for each precedence level.\n\t\tlet isPrecedenceDfa: boolean = false;\n\t\tif (atnStartState instanceof StarLoopEntryState) {\n\t\t\tif (atnStartState.precedenceRuleDecision) {\n\t\t\t\tisPrecedenceDfa = true;\n\t\t\t\tthis.s0 = new DFAState(new ATNConfigSet());\n\t\t\t\tthis.s0full = new DFAState(new ATNConfigSet());\n\t\t\t}\n\t\t}\n\n\t\tthis.precedenceDfa = isPrecedenceDfa;\n\t}\n\n\t/**\n\t * Gets whether this DFA is a precedence DFA. Precedence DFAs use a special\n\t * start state {@link #s0} which is not stored in {@link #states}. The\n\t * {@link DFAState#edges} array for this start state contains outgoing edges\n\t * supplying individual start states corresponding to specific precedence\n\t * values.\n\t *\n\t * @returns `true` if this is a precedence DFA; otherwise,\n\t * `false`.\n\t * @see Parser.precedence\n\t */\n\tget isPrecedenceDfa(): boolean {\n\t\treturn this.precedenceDfa;\n\t}\n\n\t/**\n\t * Get the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @returns The start state corresponding to the specified precedence, or\n\t * `undefined` if no start state exists for the specified precedence.\n\t *\n\t * @ if this is not a precedence DFA.\n\t * @see `isPrecedenceDfa`\n\t */\n\tpublic getPrecedenceStartState(precedence: number, fullContext: boolean): DFAState | undefined {\n\t\tif (!this.isPrecedenceDfa) {\n\t\t\tthrow new Error(\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\n\t\t// s0 and s0full are never null for a precedence DFA\n\t\tif (fullContext) {\n\t\t\treturn (this.s0full as DFAState).getTarget(precedence);\n\t\t}\n\t\telse {\n\t\t\treturn (this.s0 as DFAState).getTarget(precedence);\n\t\t}\n\t}\n\n\t/**\n\t * Set the start state for a specific precedence value.\n\t *\n\t * @param precedence The current precedence.\n\t * @param startState The start state corresponding to the specified\n\t * precedence.\n\t *\n\t * @ if this is not a precedence DFA.\n\t * @see `isPrecedenceDfa`\n\t */\n\tpublic setPrecedenceStartState(precedence: number, fullContext: boolean, startState: DFAState): void {\n\t\tif (!this.isPrecedenceDfa) {\n\t\t\tthrow new Error(\"Only precedence DFAs may contain a precedence start state.\");\n\t\t}\n\n\t\tif (precedence < 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (fullContext) {\n\t\t\t// s0full is never null for a precedence DFA\n\t\t\t(this.s0full as DFAState).setTarget(precedence, startState);\n\t\t}\n\t\telse {\n\t\t\t// s0 is never null for a precedence DFA\n\t\t\t(this.s0 as DFAState).setTarget(precedence, startState);\n\t\t}\n\t}\n\n\tget isEmpty(): boolean {\n\t\tif (this.isPrecedenceDfa) {\n\t\t\t// s0 and s0full are never null for a precedence DFA\n\t\t\treturn this.s0!.getEdgeMap().size === 0 && this.s0full!.getEdgeMap().size === 0;\n\t\t}\n\n\t\treturn this.s0 == null && this.s0full == null;\n\t}\n\n\tget isContextSensitive(): boolean {\n\t\tif (this.isPrecedenceDfa) {\n\t\t\t// s0full is never null for a precedence DFA\n\t\t\treturn (this.s0full as DFAState).getEdgeMap().size > 0;\n\t\t}\n\n\t\treturn this.s0full != null;\n\t}\n\n\tpublic addState(state: DFAState): DFAState {\n\t\tstate.stateNumber = this.nextStateNumber++;\n\t\treturn this.states.getOrAdd(state);\n\t}\n\n\tpublic toString(): string;\n\tpublic toString(/*@NotNull*/ vocabulary: Vocabulary): string;\n\tpublic toString(/*@NotNull*/ vocabulary: Vocabulary, ruleNames: string[] | undefined): string;\n\tpublic toString(vocabulary?: Vocabulary, ruleNames?: string[]): string {\n\t\tif (!vocabulary) {\n\t\t\tvocabulary = VocabularyImpl.EMPTY_VOCABULARY;\n\t\t}\n\n\t\tif (!this.s0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tlet serializer: DFASerializer;\n\t\tif (ruleNames) {\n\t\t\tserializer = new DFASerializer(this, vocabulary, ruleNames, this.atnStartState.atn);\n\t\t} else {\n\t\t\tserializer = new DFASerializer(this, vocabulary);\n\t\t}\n\n\t\treturn serializer.toString();\n\t}\n\n\tpublic toLexerString(): string {\n\t\tif (!this.s0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tlet serializer: DFASerializer = new LexerDFASerializer(this);\n\t\treturn serializer.toString();\n\t}\n}\n"]}