{"version":3,"sources":["dfa/DFASerializer.js","../src/dfa/DFASerializer.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","ATNSimulator_1","require","Decorators_1","PredictionContext_1","Recognizer_1","VocabularyImpl_1","DFASerializer","dfa","vocabulary","ruleNames","atn","Recognizer","VocabularyImpl","EMPTY_VOCABULARY","s0","buf","states","Array","toArray","sort","o1","o2","stateNumber","s","edges","getEdgeMap","edgeKeys","keys","a","b","contextEdges","getContextEdgeMap","contextEdgeKeys","entry","get","ATNSimulator","ERROR","isContextSymbol","contextSymbol","getStateString","getEdgeLabel","t","isContextSensitive","getContextLabel","output","PredictionContext","EMPTY_FULL_STATE_KEY","EMPTY_LOCAL_STATE_KEY","state","ruleIndex","String","getDisplayName","n","stateStr","isAcceptState","predicates","prediction","configs","config","reachesIntoOuterContext","NotNull","prototype","Override"],"mappings":"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","file":"DFASerializer.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ATNSimulator_1 = require(\"../atn/ATNSimulator\");\nconst Decorators_1 = require(\"../Decorators\");\nconst PredictionContext_1 = require(\"../atn/PredictionContext\");\nconst Recognizer_1 = require(\"../Recognizer\");\nconst VocabularyImpl_1 = require(\"../VocabularyImpl\");\n/** A DFA walker that knows how to dump them to serialized strings. */\nclass DFASerializer {\n    constructor(dfa, vocabulary, ruleNames, atn) {\n        if (vocabulary instanceof Recognizer_1.Recognizer) {\n            ruleNames = vocabulary.ruleNames;\n            atn = vocabulary.atn;\n            vocabulary = vocabulary.vocabulary;\n        }\n        else if (!vocabulary) {\n            vocabulary = VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;\n        }\n        this.dfa = dfa;\n        this.vocabulary = vocabulary;\n        this.ruleNames = ruleNames;\n        this.atn = atn;\n    }\n    toString() {\n        if (!this.dfa.s0) {\n            return \"\";\n        }\n        let buf = \"\";\n        if (this.dfa.states) {\n            let states = new Array(...this.dfa.states.toArray());\n            states.sort((o1, o2) => o1.stateNumber - o2.stateNumber);\n            for (let s of states) {\n                let edges = s.getEdgeMap();\n                let edgeKeys = [...edges.keys()].sort((a, b) => a - b);\n                let contextEdges = s.getContextEdgeMap();\n                let contextEdgeKeys = [...contextEdges.keys()].sort((a, b) => a - b);\n                for (let entry of edgeKeys) {\n                    let value = edges.get(entry);\n                    if ((value == null || value === ATNSimulator_1.ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {\n                        continue;\n                    }\n                    let contextSymbol = false;\n                    buf += (this.getStateString(s)) + (\"-\") + (this.getEdgeLabel(entry)) + (\"->\");\n                    if (s.isContextSymbol(entry)) {\n                        buf += (\"!\");\n                        contextSymbol = true;\n                    }\n                    let t = value;\n                    if (t && t.stateNumber !== ATNSimulator_1.ATNSimulator.ERROR.stateNumber) {\n                        buf += (this.getStateString(t)) + (\"\\n\");\n                    }\n                    else if (contextSymbol) {\n                        buf += (\"ctx\\n\");\n                    }\n                }\n                if (s.isContextSensitive) {\n                    for (let entry of contextEdgeKeys) {\n                        buf += (this.getStateString(s))\n                            + (\"-\")\n                            + (this.getContextLabel(entry))\n                            + (\"->\")\n                            + (this.getStateString(contextEdges.get(entry)))\n                            + (\"\\n\");\n                    }\n                }\n            }\n        }\n        let output = buf;\n        if (output.length === 0) {\n            return \"\";\n        }\n        //return Utils.sortLinesInString(output);\n        return output;\n    }\n    getContextLabel(i) {\n        if (i === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n            return \"ctx:EMPTY_FULL\";\n        }\n        else if (i === PredictionContext_1.PredictionContext.EMPTY_LOCAL_STATE_KEY) {\n            return \"ctx:EMPTY_LOCAL\";\n        }\n        if (this.atn && i > 0 && i <= this.atn.states.length) {\n            let state = this.atn.states[i];\n            let ruleIndex = state.ruleIndex;\n            if (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {\n                return \"ctx:\" + String(i) + \"(\" + this.ruleNames[ruleIndex] + \")\";\n            }\n        }\n        return \"ctx:\" + String(i);\n    }\n    getEdgeLabel(i) {\n        return this.vocabulary.getDisplayName(i);\n    }\n    getStateString(s) {\n        if (s === ATNSimulator_1.ATNSimulator.ERROR) {\n            return \"ERROR\";\n        }\n        let n = s.stateNumber;\n        let stateStr = \"s\" + n;\n        if (s.isAcceptState) {\n            if (s.predicates) {\n                stateStr = \":s\" + n + \"=>\" + s.predicates;\n            }\n            else {\n                stateStr = \":s\" + n + \"=>\" + s.prediction;\n            }\n        }\n        if (s.isContextSensitive) {\n            stateStr += \"*\";\n            for (let config of s.configs) {\n                if (config.reachesIntoOuterContext) {\n                    stateStr += \"*\";\n                    break;\n                }\n            }\n        }\n        return stateStr;\n    }\n}\n__decorate([\n    Decorators_1.NotNull\n], DFASerializer.prototype, \"dfa\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], DFASerializer.prototype, \"vocabulary\", void 0);\n__decorate([\n    Decorators_1.Override\n], DFASerializer.prototype, \"toString\", null);\nexports.DFASerializer = DFASerializer;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:38.5097925-07:00\n\nimport { ATN } from \"../atn/ATN\";\nimport { ATNSimulator } from \"../atn/ATNSimulator\";\nimport { ATNState } from \"../atn/ATNState\";\nimport { DFA } from \"./DFA\";\nimport { DFAState } from \"./DFAState\";\nimport { NotNull, Override } from \"../Decorators\";\nimport { PredictionContext } from \"../atn/PredictionContext\";\nimport { Recognizer } from \"../Recognizer\";\nimport { Vocabulary } from \"../Vocabulary\";\nimport { VocabularyImpl } from \"../VocabularyImpl\";\n\n/** A DFA walker that knows how to dump them to serialized strings. */\nexport class DFASerializer {\n\t@NotNull\n\tprivate dfa: DFA;\n\t@NotNull\n\tprivate vocabulary: Vocabulary;\n\n\tpublic ruleNames?: string[];\n\n\tpublic atn?: ATN;\n\n\tconstructor(/*@NotNull*/ dfa: DFA, /*@NotNull*/ vocabulary: Vocabulary);\n\tconstructor(/*@NotNull*/ dfa: DFA, /*@Nullable*/ parser: Recognizer<any, any> | undefined);\n\tconstructor(/*@NotNull*/ dfa: DFA, /*@NotNull*/ vocabulary: Vocabulary, /*@Nullable*/ ruleNames: string[] | undefined, /*@Nullable*/ atn: ATN | undefined);\n\tconstructor(dfa: DFA, vocabulary: Vocabulary | Recognizer<any, any> | undefined, ruleNames?: string[], atn?: ATN) {\n\t\tif (vocabulary instanceof Recognizer) {\n\t\t\truleNames = vocabulary.ruleNames;\n\t\t\tatn = vocabulary.atn;\n\t\t\tvocabulary = vocabulary.vocabulary;\n\t\t} else if (!vocabulary) {\n\t\t\tvocabulary = VocabularyImpl.EMPTY_VOCABULARY;\n\t\t}\n\n\t\tthis.dfa = dfa;\n\t\tthis.vocabulary = vocabulary;\n\t\tthis.ruleNames = ruleNames;\n\t\tthis.atn = atn;\n\t}\n\n\t@Override\n\tpublic toString(): string {\n\t\tif (!this.dfa.s0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tlet buf = \"\";\n\n\t\tif (this.dfa.states) {\n\t\t\tlet states: DFAState[] = new Array<DFAState>(...this.dfa.states.toArray());\n\t\t\tstates.sort((o1, o2) => o1.stateNumber - o2.stateNumber);\n\n\t\t\tfor (let s of states) {\n\t\t\t\tlet edges: Map<number, DFAState> = s.getEdgeMap();\n\t\t\t\tlet edgeKeys = [...edges.keys()].sort((a, b) => a - b);\n\t\t\t\tlet contextEdges: Map<number, DFAState> = s.getContextEdgeMap();\n\t\t\t\tlet contextEdgeKeys = [...contextEdges.keys()].sort((a, b) => a - b);\n\t\t\t\tfor (let entry of edgeKeys) {\n\t\t\t\t\tlet value = edges.get(entry);\n\t\t\t\t\tif ((value == null || value === ATNSimulator.ERROR) && !s.isContextSymbol(entry)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet contextSymbol: boolean = false;\n\t\t\t\t\tbuf += (this.getStateString(s)) + (\"-\") + (this.getEdgeLabel(entry)) + (\"->\");\n\t\t\t\t\tif (s.isContextSymbol(entry)) {\n\t\t\t\t\t\tbuf += (\"!\");\n\t\t\t\t\t\tcontextSymbol = true;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet t: DFAState | undefined = value;\n\t\t\t\t\tif (t && t.stateNumber !== ATNSimulator.ERROR.stateNumber) {\n\t\t\t\t\t\tbuf += (this.getStateString(t)) + (\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t\telse if (contextSymbol) {\n\t\t\t\t\t\tbuf += (\"ctx\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (s.isContextSensitive) {\n\t\t\t\t\tfor (let entry of contextEdgeKeys) {\n\t\t\t\t\t\tbuf += (this.getStateString(s))\n\t\t\t\t\t\t\t+ (\"-\")\n\t\t\t\t\t\t\t+ (this.getContextLabel(entry))\n\t\t\t\t\t\t\t+ (\"->\")\n\t\t\t\t\t\t\t+ (this.getStateString(contextEdges.get(entry)!))\n\t\t\t\t\t\t\t+ (\"\\n\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlet output: string = buf;\n\t\tif (output.length === 0) {\n\t\t\treturn \"\";\n\t\t}\n\t\t//return Utils.sortLinesInString(output);\n\t\treturn output;\n\t}\n\n\tprotected getContextLabel(i: number): string {\n\t\tif (i === PredictionContext.EMPTY_FULL_STATE_KEY) {\n\t\t\treturn \"ctx:EMPTY_FULL\";\n\t\t}\n\t\telse if (i === PredictionContext.EMPTY_LOCAL_STATE_KEY) {\n\t\t\treturn \"ctx:EMPTY_LOCAL\";\n\t\t}\n\n\t\tif (this.atn && i > 0 && i <= this.atn.states.length) {\n\t\t\tlet state: ATNState = this.atn.states[i];\n\t\t\tlet ruleIndex: number = state.ruleIndex;\n\t\t\tif (this.ruleNames && ruleIndex >= 0 && ruleIndex < this.ruleNames.length) {\n\t\t\t\treturn \"ctx:\" + String(i) + \"(\" + this.ruleNames[ruleIndex] + \")\";\n\t\t\t}\n\t\t}\n\n\t\treturn \"ctx:\" + String(i);\n\t}\n\n\tprotected getEdgeLabel(i: number): string {\n\t\treturn this.vocabulary.getDisplayName(i);\n\t}\n\n\tpublic getStateString(s: DFAState): string {\n\t\tif (s === ATNSimulator.ERROR) {\n\t\t\treturn \"ERROR\";\n\t\t}\n\n\t\tlet n: number = s.stateNumber;\n\t\tlet stateStr: string = \"s\" + n;\n\t\tif (s.isAcceptState) {\n\t\t\tif (s.predicates) {\n\t\t\t\tstateStr = \":s\" + n + \"=>\" + s.predicates;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tstateStr = \":s\" + n + \"=>\" + s.prediction;\n\t\t\t}\n\t\t}\n\n\t\tif (s.isContextSensitive) {\n\t\t\tstateStr += \"*\";\n\t\t\tfor (let config of s.configs) {\n\t\t\t\tif (config.reachesIntoOuterContext) {\n\t\t\t\t\tstateStr += \"*\";\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn stateStr;\n\t}\n}\n"]}