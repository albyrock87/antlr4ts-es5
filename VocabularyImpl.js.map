{"version":3,"sources":["VocabularyImpl.js","../src/VocabularyImpl.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","Decorators_1","require","Token_1","VocabularyImpl","literalNames","symbolicNames","displayNames","_maxTokenType","Math","max","tokenType","undefined","Token","EOF","displayName","literalName","getLiteralName","symbolicName","getSymbolicName","String","EMPTY_VOCABULARY","NotNull","prototype","Override"],"mappings":"AAAA;ACAA;;;;;;;;;;;;;ADKA,IAAIA,UAAU,GAAI,UAAQ,SAAKA,UAAd,IAA6B,UAAUC,UAAV,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AACnF,MAAIC,CAAC,GAAGC,SAAS,CAACC,MAAlB;AAAA,MAA0BC,CAAC,GAAGH,CAAC,GAAG,CAAJ,GAAQH,MAAR,GAAiBE,IAAI,KAAK,IAAT,GAAgBA,IAAI,GAAGK,MAAM,CAACC,wBAAP,CAAgCR,MAAhC,EAAwCC,GAAxC,CAAvB,GAAsEC,IAArH;AAAA,MAA2HO,CAA3H;AACA,MAAI,QAAOC,OAAP,0DAAOA,OAAP,OAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAA/D,EAA2EL,CAAC,GAAGI,OAAO,CAACC,QAAR,CAAiBZ,UAAjB,EAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,IAA1C,CAAJ,CAA3E,KACK,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAX,GAAoB,CAAjC,EAAoCO,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C;AAAiD,QAAIH,CAAC,GAAGV,UAAU,CAACa,CAAD,CAAlB,EAAuBN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACH,CAAD,CAAT,GAAeH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACT,MAAD,EAASC,GAAT,EAAcK,CAAd,CAAT,GAA4BG,CAAC,CAACT,MAAD,EAASC,GAAT,CAA7C,KAA+DK,CAAnE;AAAxE;AACL,SAAOH,CAAC,GAAG,CAAJ,IAASG,CAAT,IAAcC,MAAM,CAACM,cAAP,CAAsBb,MAAtB,EAA8BC,GAA9B,EAAmCK,CAAnC,CAAd,EAAqDA,CAA5D;AACH,CALD;;AAMAC,MAAM,CAACM,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C,E,CCNA;;AAEA,IAAAC,YAAA,GAAAC,OAAA,CAAA,cAAA,CAAA;;AACA,IAAAC,OAAA,GAAAD,OAAA,CAAA,SAAA,CAAA;AAGA;;;;;;;;IAMAE,c;;;AAoBC;;;;;;;;;;;;;;;;;AAiBA,0BAAYC,YAAZ,EAAqDC,aAArD,EAA+FC,YAA/F,EAAsI;AAAA;AACrI,SAAKF,YAAL,GAAoBA,YAApB;AACA,SAAKC,aAAL,GAAqBA,aAArB;AACA,SAAKC,YAAL,GAAoBA,YAApB,CAHqI,CAIrI;;AACA,SAAKC,aAAL,GACCC,IAAI,CAACC,GAAL,CAAS,KAAKH,YAAL,CAAkBjB,MAA3B,EACCmB,IAAI,CAACC,GAAL,CAAS,KAAKL,YAAL,CAAkBf,MAA3B,EAAmC,KAAKgB,aAAL,CAAmBhB,MAAtD,CADD,IACkE,CAFnE;AAGA;;;;mCAQqBqB,S,EAAiB;AACtC,UAAIA,SAAS,IAAI,CAAb,IAAkBA,SAAS,GAAG,KAAKN,YAAL,CAAkBf,MAApD,EAA4D;AAC3D,eAAO,KAAKe,YAAL,CAAkBM,SAAlB,CAAP;AACA;;AAED,aAAOC,SAAP;AACA;;;oCAGsBD,S,EAAiB;AACvC,UAAIA,SAAS,IAAI,CAAb,IAAkBA,SAAS,GAAG,KAAKL,aAAL,CAAmBhB,MAArD,EAA6D;AAC5D,eAAO,KAAKgB,aAAL,CAAmBK,SAAnB,CAAP;AACA;;AAED,UAAIA,SAAS,KAAKR,OAAA,CAAAU,KAAA,CAAMC,GAAxB,EAA6B;AAC5B,eAAO,KAAP;AACA;;AAED,aAAOF,SAAP;AACA;;;mCAIqBD,S,EAAiB;AACtC,UAAIA,SAAS,IAAI,CAAb,IAAkBA,SAAS,GAAG,KAAKJ,YAAL,CAAkBjB,MAApD,EAA4D;AAC3D,YAAIyB,WAAW,GAAG,KAAKR,YAAL,CAAkBI,SAAlB,CAAlB;;AACA,YAAII,WAAJ,EAAiB;AAChB,iBAAOA,WAAP;AACA;AACD;;AAED,UAAIC,WAAW,GAAG,KAAKC,cAAL,CAAoBN,SAApB,CAAlB;;AACA,UAAIK,WAAJ,EAAiB;AAChB,eAAOA,WAAP;AACA;;AAED,UAAIE,YAAY,GAAG,KAAKC,eAAL,CAAqBR,SAArB,CAAnB;;AACA,UAAIO,YAAJ,EAAkB;AACjB,eAAOA,YAAP;AACA;;AAED,aAAOE,MAAM,CAACT,SAAD,CAAb;AACA;;;wBA/Ce;AACf,aAAO,KAAKH,aAAZ;AACA;;;;AAjDD;;;;;;;;;AAQuBJ,cAAA,CAAAiB,gBAAA,GAAmC,IAAIjB,cAAJ,CAAmB,EAAnB,EAAuB,EAAvB,EAA2B,EAA3B,CAAnC;;AAGvBrB,UAAA,CAAA,CADCkB,YAAA,CAAAqB,OACD,CAAA,EDgEElB,cAAc,CAACmB,SChEjB,EDgE4B,cChE5B,EDgE4C,KAAK,CChEjD,CAAA;;AAEAxC,UAAA,CAAA,CADCkB,YAAA,CAAAqB,OACD,CAAA,EDiEElB,cAAc,CAACmB,SCjEjB,EDiE4B,eCjE5B,EDiE6C,KAAK,CCjElD,CAAA;;AAEAxC,UAAA,CAAA,CADCkB,YAAA,CAAAqB,OACD,CAAA,EDkEElB,cAAc,CAACmB,SClEjB,EDkE4B,cClE5B,EDkE4C,KAAK,CClEjD,CAAA;;AAgCAxC,UAAA,CAAA,CADCkB,YAAA,CAAAuB,QACD,CAAA,EDqCEpB,cAAc,CAACmB,SCrCjB,EDqC4B,cCrC5B,EDqC4C,ICrC5C,CAAA;;AAKAxC,UAAA,CAAA,CADCkB,YAAA,CAAAuB,QACD,CAAA,EDmCEpB,cAAc,CAACmB,SCnCjB,EDmC4B,gBCnC5B,EDmC8C,ICnC9C,CAAA;;AASAxC,UAAA,CAAA,CADCkB,YAAA,CAAAuB,QACD,CAAA,ED6BEpB,cAAc,CAACmB,SC7BjB,ED6B4B,iBC7B5B,ED6B+C,IC7B/C,CAAA;;AAcAxC,UAAA,CAAA,CAFCkB,YAAA,CAAAuB,QAED,EADCvB,YAAA,CAAAqB,OACD,CAAA,EDmBElB,cAAc,CAACmB,SCnBjB,EDmB4B,gBCnB5B,EDmB8C,ICnB9C,CAAA;;AAnEAxC,UAAA,CAAA,CADCkB,YAAA,CAAAqB,OACD,CAAA,EDyFElB,cCzFF,EDyFkB,kBCzFlB,EDyFsC,KAAK,CCzF3C,CAAA;;AATDL,OAAA,CAAAK,cAAA,GAAAA,cAAA","file":"VocabularyImpl.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:59.5829654-07:00\nconst Decorators_1 = require(\"./Decorators\");\nconst Token_1 = require(\"./Token\");\n/**\n * This class provides a default implementation of the {@link Vocabulary}\n * interface.\n *\n * @author Sam Harwell\n */\nclass VocabularyImpl {\n    /**\n     * Constructs a new instance of {@link VocabularyImpl} from the specified\n     * literal, symbolic, and display token names.\n     *\n     * @param literalNames The literal names assigned to tokens, or an empty array\n     * if no literal names are assigned.\n     * @param symbolicNames The symbolic names assigned to tokens, or\n     * an empty array if no symbolic names are assigned.\n     * @param displayNames The display names assigned to tokens, or an empty array\n     * to use the values in `literalNames` and `symbolicNames` as\n     * the source of display names, as described in\n     * {@link #getDisplayName(int)}.\n     *\n     * @see #getLiteralName(int)\n     * @see #getSymbolicName(int)\n     * @see #getDisplayName(int)\n     */\n    constructor(literalNames, symbolicNames, displayNames) {\n        this.literalNames = literalNames;\n        this.symbolicNames = symbolicNames;\n        this.displayNames = displayNames;\n        // See note here on -1 part: https://github.com/antlr/antlr4/pull/1146\n        this._maxTokenType =\n            Math.max(this.displayNames.length, Math.max(this.literalNames.length, this.symbolicNames.length)) - 1;\n    }\n    get maxTokenType() {\n        return this._maxTokenType;\n    }\n    getLiteralName(tokenType) {\n        if (tokenType >= 0 && tokenType < this.literalNames.length) {\n            return this.literalNames[tokenType];\n        }\n        return undefined;\n    }\n    getSymbolicName(tokenType) {\n        if (tokenType >= 0 && tokenType < this.symbolicNames.length) {\n            return this.symbolicNames[tokenType];\n        }\n        if (tokenType === Token_1.Token.EOF) {\n            return \"EOF\";\n        }\n        return undefined;\n    }\n    getDisplayName(tokenType) {\n        if (tokenType >= 0 && tokenType < this.displayNames.length) {\n            let displayName = this.displayNames[tokenType];\n            if (displayName) {\n                return displayName;\n            }\n        }\n        let literalName = this.getLiteralName(tokenType);\n        if (literalName) {\n            return literalName;\n        }\n        let symbolicName = this.getSymbolicName(tokenType);\n        if (symbolicName) {\n            return symbolicName;\n        }\n        return String(tokenType);\n    }\n}\n/**\n * Gets an empty {@link Vocabulary} instance.\n *\n * No literal or symbol names are assigned to token types, so\n * {@link #getDisplayName(int)} returns the numeric value for all tokens\n * except {@link Token#EOF}.\n */\nVocabularyImpl.EMPTY_VOCABULARY = new VocabularyImpl([], [], []);\n__decorate([\n    Decorators_1.NotNull\n], VocabularyImpl.prototype, \"literalNames\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], VocabularyImpl.prototype, \"symbolicNames\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], VocabularyImpl.prototype, \"displayNames\", void 0);\n__decorate([\n    Decorators_1.Override\n], VocabularyImpl.prototype, \"maxTokenType\", null);\n__decorate([\n    Decorators_1.Override\n], VocabularyImpl.prototype, \"getLiteralName\", null);\n__decorate([\n    Decorators_1.Override\n], VocabularyImpl.prototype, \"getSymbolicName\", null);\n__decorate([\n    Decorators_1.Override,\n    Decorators_1.NotNull\n], VocabularyImpl.prototype, \"getDisplayName\", null);\n__decorate([\n    Decorators_1.NotNull\n], VocabularyImpl, \"EMPTY_VOCABULARY\", void 0);\nexports.VocabularyImpl = VocabularyImpl;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:59.5829654-07:00\n\nimport { NotNull, Override } from \"./Decorators\";\nimport { Token } from \"./Token\";\nimport { Vocabulary } from \"./Vocabulary\";\n\n/**\n * This class provides a default implementation of the {@link Vocabulary}\n * interface.\n *\n * @author Sam Harwell\n */\nexport class VocabularyImpl implements Vocabulary {\n\t/**\n\t * Gets an empty {@link Vocabulary} instance.\n\t *\n\t * No literal or symbol names are assigned to token types, so\n\t * {@link #getDisplayName(int)} returns the numeric value for all tokens\n\t * except {@link Token#EOF}.\n\t */\n\t@NotNull\n\tpublic static readonly EMPTY_VOCABULARY: VocabularyImpl = new VocabularyImpl([], [], []);\n\n\t@NotNull\n\tprivate readonly literalNames: Array<string | undefined>;\n\t@NotNull\n\tprivate readonly symbolicNames: Array<string | undefined>;\n\t@NotNull\n\tprivate readonly displayNames: Array<string | undefined>;\n\n\tprivate _maxTokenType: number;\n\n\t/**\n\t * Constructs a new instance of {@link VocabularyImpl} from the specified\n\t * literal, symbolic, and display token names.\n\t *\n\t * @param literalNames The literal names assigned to tokens, or an empty array\n\t * if no literal names are assigned.\n\t * @param symbolicNames The symbolic names assigned to tokens, or\n\t * an empty array if no symbolic names are assigned.\n\t * @param displayNames The display names assigned to tokens, or an empty array\n\t * to use the values in `literalNames` and `symbolicNames` as\n\t * the source of display names, as described in\n\t * {@link #getDisplayName(int)}.\n\t *\n\t * @see #getLiteralName(int)\n\t * @see #getSymbolicName(int)\n\t * @see #getDisplayName(int)\n\t */\n\tconstructor(literalNames: Array<string | undefined>, symbolicNames: Array<string | undefined>, displayNames: Array<string | undefined>) {\n\t\tthis.literalNames = literalNames;\n\t\tthis.symbolicNames = symbolicNames;\n\t\tthis.displayNames = displayNames;\n\t\t// See note here on -1 part: https://github.com/antlr/antlr4/pull/1146\n\t\tthis._maxTokenType =\n\t\t\tMath.max(this.displayNames.length,\n\t\t\t\tMath.max(this.literalNames.length, this.symbolicNames.length)) - 1;\n\t}\n\n\t@Override\n\tget maxTokenType(): number {\n\t\treturn this._maxTokenType;\n\t}\n\n\t@Override\n\tpublic getLiteralName(tokenType: number): string | undefined {\n\t\tif (tokenType >= 0 && tokenType < this.literalNames.length) {\n\t\t\treturn this.literalNames[tokenType];\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t@Override\n\tpublic getSymbolicName(tokenType: number): string | undefined {\n\t\tif (tokenType >= 0 && tokenType < this.symbolicNames.length) {\n\t\t\treturn this.symbolicNames[tokenType];\n\t\t}\n\n\t\tif (tokenType === Token.EOF) {\n\t\t\treturn \"EOF\";\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t@Override\n\t@NotNull\n\tpublic getDisplayName(tokenType: number): string {\n\t\tif (tokenType >= 0 && tokenType < this.displayNames.length) {\n\t\t\tlet displayName = this.displayNames[tokenType];\n\t\t\tif (displayName) {\n\t\t\t\treturn displayName;\n\t\t\t}\n\t\t}\n\n\t\tlet literalName = this.getLiteralName(tokenType);\n\t\tif (literalName) {\n\t\t\treturn literalName;\n\t\t}\n\n\t\tlet symbolicName = this.getSymbolicName(tokenType);\n\t\tif (symbolicName) {\n\t\t\treturn symbolicName;\n\t\t}\n\n\t\treturn String(tokenType);\n\t}\n}\n"]}