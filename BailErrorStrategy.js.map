{"version":3,"sources":["BailErrorStrategy.js","../src/BailErrorStrategy.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","DefaultErrorStrategy_1","require","InputMismatchException_1","Decorators_1","ParseCancellationException_1","BailErrorStrategy","recognizer","e","context","parent","exception","ParseCancellationException","InputMismatchException","DefaultErrorStrategy","Override","prototype"],"mappings":"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","file":"BailErrorStrategy.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:49.2855056-07:00\nconst DefaultErrorStrategy_1 = require(\"./DefaultErrorStrategy\");\nconst InputMismatchException_1 = require(\"./InputMismatchException\");\nconst Decorators_1 = require(\"./Decorators\");\nconst ParseCancellationException_1 = require(\"./misc/ParseCancellationException\");\n/**\n * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors\n * by immediately canceling the parse operation with a\n * {@link ParseCancellationException}. The implementation ensures that the\n * {@link ParserRuleContext#exception} field is set for all parse tree nodes\n * that were not completed prior to encountering the error.\n *\n * This error strategy is useful in the following scenarios.\n *\n * * **Two-stage parsing:** This error strategy allows the first\n *   stage of two-stage parsing to immediately terminate if an error is\n *   encountered, and immediately fall back to the second stage. In addition to\n *   avoiding wasted work by attempting to recover from errors here, the empty\n *   implementation of {@link BailErrorStrategy#sync} improves the performance of\n *   the first stage.\n * * **Silent validation:** When syntax errors are not being\n *   reported or logged, and the parse result is simply ignored if errors occur,\n *   the {@link BailErrorStrategy} avoids wasting work on recovering from errors\n *   when the result will be ignored either way.\n *\n * ```\n * myparser.errorHandler = new BailErrorStrategy();\n * ```\n *\n * @see Parser.errorHandler\n */\nclass BailErrorStrategy extends DefaultErrorStrategy_1.DefaultErrorStrategy {\n    /** Instead of recovering from exception `e`, re-throw it wrapped\n     *  in a {@link ParseCancellationException} so it is not caught by the\n     *  rule function catches.  Use {@link Exception#getCause()} to get the\n     *  original {@link RecognitionException}.\n     */\n    recover(recognizer, e) {\n        for (let context = recognizer.context; context; context = context.parent) {\n            context.exception = e;\n        }\n        throw new ParseCancellationException_1.ParseCancellationException(e);\n    }\n    /** Make sure we don't attempt to recover inline; if the parser\n     *  successfully recovers, it won't throw an exception.\n     */\n    recoverInline(recognizer) {\n        let e = new InputMismatchException_1.InputMismatchException(recognizer);\n        for (let context = recognizer.context; context; context = context.parent) {\n            context.exception = e;\n        }\n        throw new ParseCancellationException_1.ParseCancellationException(e);\n    }\n    /** Make sure we don't attempt to recover from problems in subrules. */\n    sync(recognizer) {\n        // intentionally empty\n    }\n}\n__decorate([\n    Decorators_1.Override\n], BailErrorStrategy.prototype, \"recover\", null);\n__decorate([\n    Decorators_1.Override\n], BailErrorStrategy.prototype, \"recoverInline\", null);\n__decorate([\n    Decorators_1.Override\n], BailErrorStrategy.prototype, \"sync\", null);\nexports.BailErrorStrategy = BailErrorStrategy;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:49.2855056-07:00\n\nimport { DefaultErrorStrategy } from \"./DefaultErrorStrategy\";\nimport { Parser } from \"./Parser\";\nimport { InputMismatchException } from \"./InputMismatchException\";\nimport { Override } from \"./Decorators\";\nimport { ParseCancellationException } from \"./misc/ParseCancellationException\";\nimport { ParserRuleContext } from \"./ParserRuleContext\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { Token } from \"./Token\";\n\n/**\n * This implementation of {@link ANTLRErrorStrategy} responds to syntax errors\n * by immediately canceling the parse operation with a\n * {@link ParseCancellationException}. The implementation ensures that the\n * {@link ParserRuleContext#exception} field is set for all parse tree nodes\n * that were not completed prior to encountering the error.\n *\n * This error strategy is useful in the following scenarios.\n *\n * * **Two-stage parsing:** This error strategy allows the first\n *   stage of two-stage parsing to immediately terminate if an error is\n *   encountered, and immediately fall back to the second stage. In addition to\n *   avoiding wasted work by attempting to recover from errors here, the empty\n *   implementation of {@link BailErrorStrategy#sync} improves the performance of\n *   the first stage.\n * * **Silent validation:** When syntax errors are not being\n *   reported or logged, and the parse result is simply ignored if errors occur,\n *   the {@link BailErrorStrategy} avoids wasting work on recovering from errors\n *   when the result will be ignored either way.\n *\n * ```\n * myparser.errorHandler = new BailErrorStrategy();\n * ```\n *\n * @see Parser.errorHandler\n */\nexport class BailErrorStrategy extends DefaultErrorStrategy {\n\t/** Instead of recovering from exception `e`, re-throw it wrapped\n\t *  in a {@link ParseCancellationException} so it is not caught by the\n\t *  rule function catches.  Use {@link Exception#getCause()} to get the\n\t *  original {@link RecognitionException}.\n\t */\n\t@Override\n\tpublic recover(recognizer: Parser, e: RecognitionException): void {\n\t\tfor (let context: ParserRuleContext | undefined = recognizer.context; context; context = context.parent) {\n\t\t\tcontext.exception = e;\n\t\t}\n\n\t\tthrow new ParseCancellationException(e);\n\t}\n\n\t/** Make sure we don't attempt to recover inline; if the parser\n\t *  successfully recovers, it won't throw an exception.\n\t */\n\t@Override\n\tpublic recoverInline(recognizer: Parser): Token {\n\t\tlet e = new InputMismatchException(recognizer);\n\t\tfor (let context: ParserRuleContext | undefined = recognizer.context; context; context = context.parent) {\n\t\t\tcontext.exception = e;\n\t\t}\n\n\t\tthrow new ParseCancellationException(e);\n\t}\n\n\t/** Make sure we don't attempt to recover from problems in subrules. */\n\t@Override\n\tpublic sync(recognizer: Parser): void {\n\t\t// intentionally empty\n\t}\n}\n"]}