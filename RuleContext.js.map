{"version":3,"sources":["RuleContext.js","../src/RuleContext.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","ATN_1","require","Recognizer_1","RuleNode_1","Interval_1","Decorators_1","Trees_1","ParserRuleContext_1","RuleContext","parent","invokingState","_parent","n","p","RangeError","visitor","visitChildren","recog","Trees","toStringTree","arg1","stop","ruleNames","Recognizer","ParserRuleContext","emptyContext","buf","isEmpty","ruleIndex","ruleName","toString","Interval","INVALID","childCount","builder","getChild","text","ATN","INVALID_ALT_NUMBER","altNumber","RuleNode","Override","prototype"],"mappings":"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","file":"RuleContext.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:57.3490837-07:00\nconst ATN_1 = require(\"./atn/ATN\");\nconst Recognizer_1 = require(\"./Recognizer\");\nconst RuleNode_1 = require(\"./tree/RuleNode\");\nconst Interval_1 = require(\"./misc/Interval\");\nconst Decorators_1 = require(\"./Decorators\");\nconst Trees_1 = require(\"./tree/Trees\");\nconst ParserRuleContext_1 = require(\"./ParserRuleContext\");\n/** A rule context is a record of a single rule invocation.\n *\n *  We form a stack of these context objects using the parent\n *  pointer. A parent pointer of `undefined` indicates that the current\n *  context is the bottom of the stack. The ParserRuleContext subclass\n *  as a children list so that we can turn this data structure into a\n *  tree.\n *\n *  The root node always has a `undefined` pointer and invokingState of -1.\n *\n *  Upon entry to parsing, the first invoked rule function creates a\n *  context object (a subclass specialized for that rule such as\n *  SContext) and makes it the root of a parse tree, recorded by field\n *  Parser._ctx.\n *\n *  public final SContext s() throws RecognitionException {\n *      SContext _localctx = new SContext(_ctx, state); <-- create new node\n *      enterRule(_localctx, 0, RULE_s);                     <-- push it\n *      ...\n *      exitRule();                                          <-- pop back to _localctx\n *      return _localctx;\n *  }\n *\n *  A subsequent rule invocation of r from the start rule s pushes a\n *  new context object for r whose parent points at s and use invoking\n *  state is the state with r emanating as edge label.\n *\n *  The invokingState fields from a context object to the root\n *  together form a stack of rule indication states where the root\n *  (bottom of the stack) has a -1 sentinel value. If we invoke start\n *  symbol s then call r1, which calls r2, the  would look like\n *  this:\n *\n *     SContext[-1]   <- root node (bottom of the stack)\n *     R1Context[p]   <- p in rule s called r1\n *     R2Context[q]   <- q in rule r1 called r2\n *\n *  So the top of the stack, _ctx, represents a call to the current\n *  rule and it holds the return address from another rule that invoke\n *  to this rule. To invoke a rule, we must always have a current context.\n *\n *  The parent contexts are useful for computing lookahead sets and\n *  getting error information.\n *\n *  These objects are used during parsing and prediction.\n *  For the special case of parsers, we use the subclass\n *  ParserRuleContext.\n *\n *  @see ParserRuleContext\n */\nclass RuleContext extends RuleNode_1.RuleNode {\n    constructor(parent, invokingState) {\n        super();\n        this._parent = parent;\n        this.invokingState = invokingState != null ? invokingState : -1;\n    }\n    static getChildContext(parent, invokingState) {\n        return new RuleContext(parent, invokingState);\n    }\n    depth() {\n        let n = 0;\n        let p = this;\n        while (p) {\n            p = p._parent;\n            n++;\n        }\n        return n;\n    }\n    /** A context is empty if there is no invoking state; meaning nobody called\n     *  current context.\n     */\n    get isEmpty() {\n        return this.invokingState === -1;\n    }\n    // satisfy the ParseTree / SyntaxTree interface\n    get sourceInterval() {\n        return Interval_1.Interval.INVALID;\n    }\n    get ruleContext() { return this; }\n    get parent() { return this._parent; }\n    /** @since 4.7. {@see ParseTree#setParent} comment */\n    setParent(parent) {\n        this._parent = parent;\n    }\n    get payload() { return this; }\n    /** Return the combined text of all child nodes. This method only considers\n     *  tokens which have been added to the parse tree.\n     *\n     *  Since tokens on hidden channels (e.g. whitespace or comments) are not\n     *  added to the parse trees, they will not appear in the output of this\n     *  method.\n     */\n    get text() {\n        if (this.childCount === 0) {\n            return \"\";\n        }\n        let builder = \"\";\n        for (let i = 0; i < this.childCount; i++) {\n            builder += this.getChild(i).text;\n        }\n        return builder.toString();\n    }\n    get ruleIndex() { return -1; }\n    /** For rule associated with this parse tree internal node, return\n     *  the outer alternative number used to match the input. Default\n     *  implementation does not compute nor store this alt num. Create\n     *  a subclass of ParserRuleContext with backing field and set\n     *  option contextSuperClass.\n     *  to set it.\n     *\n     *  @since 4.5.3\n     */\n    get altNumber() { return ATN_1.ATN.INVALID_ALT_NUMBER; }\n    /** Set the outer alternative number for this context node. Default\n     *  implementation does nothing to avoid backing field overhead for\n     *  trees that don't need it.  Create\n     *  a subclass of ParserRuleContext with backing field and set\n     *  option contextSuperClass.\n     *\n     *  @since 4.5.3\n     */\n    set altNumber(altNumber) {\n        // intentionally ignored by the base implementation\n    }\n    getChild(i) {\n        throw new RangeError(\"i must be greater than or equal to 0 and less than childCount\");\n    }\n    get childCount() {\n        return 0;\n    }\n    accept(visitor) {\n        return visitor.visitChildren(this);\n    }\n    toStringTree(recog) {\n        return Trees_1.Trees.toStringTree(this, recog);\n    }\n    toString(arg1, stop) {\n        const ruleNames = (arg1 instanceof Recognizer_1.Recognizer) ? arg1.ruleNames : arg1;\n        stop = stop || ParserRuleContext_1.ParserRuleContext.emptyContext();\n        let buf = \"\";\n        let p = this;\n        buf += (\"[\");\n        while (p && p !== stop) {\n            if (!ruleNames) {\n                if (!p.isEmpty) {\n                    buf += (p.invokingState);\n                }\n            }\n            else {\n                let ruleIndex = p.ruleIndex;\n                let ruleName = (ruleIndex >= 0 && ruleIndex < ruleNames.length)\n                    ? ruleNames[ruleIndex] : ruleIndex.toString();\n                buf += (ruleName);\n            }\n            if (p._parent && (ruleNames || !p._parent.isEmpty)) {\n                buf += (\" \");\n            }\n            p = p._parent;\n        }\n        buf += (\"]\");\n        return buf.toString();\n    }\n}\n__decorate([\n    Decorators_1.Override\n], RuleContext.prototype, \"sourceInterval\", null);\n__decorate([\n    Decorators_1.Override\n], RuleContext.prototype, \"ruleContext\", null);\n__decorate([\n    Decorators_1.Override\n], RuleContext.prototype, \"parent\", null);\n__decorate([\n    Decorators_1.Override\n], RuleContext.prototype, \"setParent\", null);\n__decorate([\n    Decorators_1.Override\n], RuleContext.prototype, \"payload\", null);\n__decorate([\n    Decorators_1.Override\n], RuleContext.prototype, \"text\", null);\n__decorate([\n    Decorators_1.Override\n], RuleContext.prototype, \"getChild\", null);\n__decorate([\n    Decorators_1.Override\n], RuleContext.prototype, \"childCount\", null);\n__decorate([\n    Decorators_1.Override\n], RuleContext.prototype, \"accept\", null);\n__decorate([\n    Decorators_1.Override\n], RuleContext.prototype, \"toStringTree\", null);\nexports.RuleContext = RuleContext;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:57.3490837-07:00\n\nimport { ATN } from \"./atn/ATN\";\nimport { Parser } from \"./Parser\";\nimport { Recognizer } from \"./Recognizer\";\nimport { RuleNode } from \"./tree/RuleNode\";\nimport { ParseTree } from \"./tree/ParseTree\";\nimport { Interval } from \"./misc/Interval\";\nimport { Override } from \"./Decorators\";\nimport { Trees } from \"./tree/Trees\";\nimport { ParseTreeVisitor } from \"./tree/ParseTreeVisitor\";\nimport { ParserRuleContext } from \"./ParserRuleContext\";\n\n/** A rule context is a record of a single rule invocation.\n *\n *  We form a stack of these context objects using the parent\n *  pointer. A parent pointer of `undefined` indicates that the current\n *  context is the bottom of the stack. The ParserRuleContext subclass\n *  as a children list so that we can turn this data structure into a\n *  tree.\n *\n *  The root node always has a `undefined` pointer and invokingState of -1.\n *\n *  Upon entry to parsing, the first invoked rule function creates a\n *  context object (a subclass specialized for that rule such as\n *  SContext) and makes it the root of a parse tree, recorded by field\n *  Parser._ctx.\n *\n *  public final SContext s() throws RecognitionException {\n *      SContext _localctx = new SContext(_ctx, state); <-- create new node\n *      enterRule(_localctx, 0, RULE_s);                     <-- push it\n *      ...\n *      exitRule();                                          <-- pop back to _localctx\n *      return _localctx;\n *  }\n *\n *  A subsequent rule invocation of r from the start rule s pushes a\n *  new context object for r whose parent points at s and use invoking\n *  state is the state with r emanating as edge label.\n *\n *  The invokingState fields from a context object to the root\n *  together form a stack of rule indication states where the root\n *  (bottom of the stack) has a -1 sentinel value. If we invoke start\n *  symbol s then call r1, which calls r2, the  would look like\n *  this:\n *\n *     SContext[-1]   <- root node (bottom of the stack)\n *     R1Context[p]   <- p in rule s called r1\n *     R2Context[q]   <- q in rule r1 called r2\n *\n *  So the top of the stack, _ctx, represents a call to the current\n *  rule and it holds the return address from another rule that invoke\n *  to this rule. To invoke a rule, we must always have a current context.\n *\n *  The parent contexts are useful for computing lookahead sets and\n *  getting error information.\n *\n *  These objects are used during parsing and prediction.\n *  For the special case of parsers, we use the subclass\n *  ParserRuleContext.\n *\n *  @see ParserRuleContext\n */\nexport class RuleContext extends RuleNode {\n\tpublic _parent: RuleContext | undefined;\n\tpublic invokingState: number;\n\n\tconstructor();\n\tconstructor(parent: RuleContext | undefined, invokingState: number);\n\tconstructor(parent?: RuleContext, invokingState?: number) {\n\t\tsuper();\n\t\tthis._parent = parent;\n\t\tthis.invokingState = invokingState != null ? invokingState : -1;\n\t}\n\n\tpublic static getChildContext(parent: RuleContext, invokingState: number): RuleContext {\n\t\treturn new RuleContext(parent, invokingState);\n\t}\n\n\tpublic depth(): number {\n\t\tlet n = 0;\n\t\tlet p: RuleContext | undefined = this;\n\t\twhile (p) {\n\t\t\tp = p._parent;\n\t\t\tn++;\n\t\t}\n\t\treturn n;\n\t}\n\n\t/** A context is empty if there is no invoking state; meaning nobody called\n\t *  current context.\n\t */\n\tget isEmpty(): boolean {\n\t\treturn this.invokingState === -1;\n\t}\n\n\t// satisfy the ParseTree / SyntaxTree interface\n\n\t@Override\n\tget sourceInterval(): Interval {\n\t\treturn Interval.INVALID;\n\t}\n\n\t@Override\n\tget ruleContext(): RuleContext { return this; }\n\n\t@Override\n\tget parent(): RuleContext | undefined { return this._parent; }\n\n\t/** @since 4.7. {@see ParseTree#setParent} comment */\n\t@Override\n\tpublic setParent(parent: RuleContext): void {\n\t\tthis._parent = parent;\n\t}\n\n\t@Override\n\tget payload(): RuleContext { return this; }\n\n\t/** Return the combined text of all child nodes. This method only considers\n\t *  tokens which have been added to the parse tree.\n\t *\n\t *  Since tokens on hidden channels (e.g. whitespace or comments) are not\n\t *  added to the parse trees, they will not appear in the output of this\n\t *  method.\n\t */\n\t@Override\n\tget text(): string {\n\t\tif (this.childCount === 0) {\n\t\t\treturn \"\";\n\t\t}\n\n\t\tlet builder = \"\";\n\t\tfor (let i = 0; i < this.childCount; i++) {\n\t\t\tbuilder += this.getChild(i).text;\n\t\t}\n\n\t\treturn builder.toString();\n\t}\n\n\tget ruleIndex(): number { return -1; }\n\n\t/** For rule associated with this parse tree internal node, return\n\t *  the outer alternative number used to match the input. Default\n\t *  implementation does not compute nor store this alt num. Create\n\t *  a subclass of ParserRuleContext with backing field and set\n\t *  option contextSuperClass.\n\t *  to set it.\n\t *\n\t *  @since 4.5.3\n\t */\n\tget altNumber(): number { return ATN.INVALID_ALT_NUMBER; }\n\n\t/** Set the outer alternative number for this context node. Default\n\t *  implementation does nothing to avoid backing field overhead for\n\t *  trees that don't need it.  Create\n\t *  a subclass of ParserRuleContext with backing field and set\n\t *  option contextSuperClass.\n\t *\n\t *  @since 4.5.3\n\t */\n\tset altNumber(altNumber: number) {\n\t\t// intentionally ignored by the base implementation\n\t}\n\n\t@Override\n\tpublic getChild(i: number): ParseTree {\n\t\tthrow new RangeError(\"i must be greater than or equal to 0 and less than childCount\");\n\t}\n\n\t@Override\n\tget childCount(): number {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic accept<T>(visitor: ParseTreeVisitor<T>): T {\n\t\treturn visitor.visitChildren(this);\n\t}\n\n\t/** Print out a whole tree, not just a node, in LISP format\n\t *  (root child1 .. childN). Print just a node if this is a leaf.\n\t *  We have to know the recognizer so we can get rule names.\n\t */\n\tpublic toStringTree(recog: Parser): string;\n\n\t/** Print out a whole tree, not just a node, in LISP format\n\t *  (root child1 .. childN). Print just a node if this is a leaf.\n\t */\n\tpublic toStringTree(ruleNames: string[] | undefined): string;\n\n\tpublic toStringTree(): string;\n\n\t@Override\n\tpublic toStringTree(recog?: Parser | string[]): string {\n\t\treturn Trees.toStringTree(this, recog);\n\t}\n\n\tpublic toString(): string;\n\tpublic toString(recog: Recognizer<any, any> | undefined): string;\n\tpublic toString(ruleNames: string[] | undefined): string;\n\n\t// // recog undefined unless ParserRuleContext, in which case we use subclass toString(...)\n\tpublic toString(recog: Recognizer<any, any> | undefined, stop: RuleContext | undefined): string;\n\n\tpublic toString(ruleNames: string[] | undefined, stop: RuleContext | undefined): string;\n\n\tpublic toString(\n\t\targ1?: Recognizer<any, any> | string[],\n\t\tstop?: RuleContext)\n\t\t: string {\n\t\tconst ruleNames = (arg1 instanceof Recognizer) ? arg1.ruleNames : arg1;\n\t\tstop = stop || ParserRuleContext.emptyContext();\n\n\t\tlet buf = \"\";\n\t\tlet p: RuleContext | undefined = this;\n\t\tbuf += (\"[\");\n\t\twhile (p && p !== stop) {\n\t\t\tif (!ruleNames) {\n\t\t\t\tif (!p.isEmpty) {\n\t\t\t\t\tbuf += (p.invokingState);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tlet ruleIndex: number = p.ruleIndex;\n\t\t\t\tlet ruleName: string = (ruleIndex >= 0 && ruleIndex < ruleNames.length)\n\t\t\t\t\t? ruleNames[ruleIndex] : ruleIndex.toString();\n\t\t\t\tbuf += (ruleName);\n\t\t\t}\n\n\t\t\tif (p._parent && (ruleNames || !p._parent.isEmpty)) {\n\t\t\t\tbuf += (\" \");\n\t\t\t}\n\n\t\t\tp = p._parent;\n\t\t}\n\n\t\tbuf += (\"]\");\n\t\treturn buf.toString();\n\t}\n}\n"]}