{"version":3,"sources":["CodePointCharStream.js","../src/CodePointCharStream.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","assert","require","IntStream_1","Interval_1","Decorators_1","CodePointCharStream","array","position","remaining","name","_array","_size","_name","_position","LA","IntStream","EOF","RangeError","marker","index","getText","Interval","of","size","offset","Math","sign","interval","startIdx","min","a","len","b","Int32Array","String","fromCodePoint","Array","from","subarray","fromCharCode","codePointBuffer","undefined","UNKNOWN_SOURCE_NAME","Override","prototype"],"mappings":"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","file":"CodePointCharStream.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst IntStream_1 = require(\"./IntStream\");\nconst Interval_1 = require(\"./misc/Interval\");\nconst Decorators_1 = require(\"./Decorators\");\n/**\n * Alternative to {@link ANTLRInputStream} which treats the input\n * as a series of Unicode code points, instead of a series of UTF-16\n * code units.\n *\n * Use this if you need to parse input which potentially contains\n * Unicode values > U+FFFF.\n */\nclass CodePointCharStream {\n    // Use the factory method {@link #fromBuffer(CodePointBuffer)} to\n    // construct instances of this type.\n    constructor(array, position, remaining, name) {\n        // TODO\n        assert(position === 0);\n        this._array = array;\n        this._size = remaining;\n        this._name = name;\n        this._position = 0;\n    }\n    get internalStorage() {\n        return this._array;\n    }\n    static fromBuffer(codePointBuffer, name) {\n        if (name === undefined || name.length === 0) {\n            name = IntStream_1.IntStream.UNKNOWN_SOURCE_NAME;\n        }\n        // Java lacks generics on primitive types.\n        //\n        // To avoid lots of calls to virtual methods in the\n        // very hot codepath of LA() below, we construct one\n        // of three concrete subclasses.\n        //\n        // The concrete subclasses directly access the code\n        // points stored in the underlying array (byte[],\n        // char[], or int[]), so we can avoid lots of virtual\n        // method calls to ByteBuffer.get(offset).\n        return new CodePointCharStream(codePointBuffer.array(), codePointBuffer.position, codePointBuffer.remaining, name);\n    }\n    consume() {\n        if (this._size - this._position === 0) {\n            assert(this.LA(1) === IntStream_1.IntStream.EOF);\n            throw new RangeError(\"cannot consume EOF\");\n        }\n        this._position++;\n    }\n    get index() {\n        return this._position;\n    }\n    get size() {\n        return this._size;\n    }\n    /** mark/release do nothing; we have entire buffer */\n    mark() {\n        return -1;\n    }\n    release(marker) {\n        // No default implementation since this stream buffers the entire input\n    }\n    seek(index) {\n        this._position = index;\n    }\n    get sourceName() {\n        return this._name;\n    }\n    toString() {\n        return this.getText(Interval_1.Interval.of(0, this.size - 1));\n    }\n    LA(i) {\n        let offset;\n        switch (Math.sign(i)) {\n            case -1:\n                offset = this.index + i;\n                if (offset < 0) {\n                    return IntStream_1.IntStream.EOF;\n                }\n                return this._array[offset];\n            case 0:\n                // Undefined\n                return 0;\n            case 1:\n                offset = this.index + i - 1;\n                if (offset >= this.size) {\n                    return IntStream_1.IntStream.EOF;\n                }\n                return this._array[offset];\n        }\n        throw new RangeError(\"Not reached\");\n    }\n    /** Return the UTF-16 encoded string for the given interval */\n    getText(interval) {\n        const startIdx = Math.min(interval.a, this.size);\n        const len = Math.min(interval.b - interval.a + 1, this.size - startIdx);\n        if (this._array instanceof Int32Array) {\n            return String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));\n        }\n        else {\n            return String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));\n        }\n    }\n}\n__decorate([\n    Decorators_1.Override\n], CodePointCharStream.prototype, \"consume\", null);\n__decorate([\n    Decorators_1.Override\n], CodePointCharStream.prototype, \"index\", null);\n__decorate([\n    Decorators_1.Override\n], CodePointCharStream.prototype, \"size\", null);\n__decorate([\n    Decorators_1.Override\n], CodePointCharStream.prototype, \"mark\", null);\n__decorate([\n    Decorators_1.Override\n], CodePointCharStream.prototype, \"release\", null);\n__decorate([\n    Decorators_1.Override\n], CodePointCharStream.prototype, \"seek\", null);\n__decorate([\n    Decorators_1.Override\n], CodePointCharStream.prototype, \"sourceName\", null);\n__decorate([\n    Decorators_1.Override\n], CodePointCharStream.prototype, \"toString\", null);\n__decorate([\n    Decorators_1.Override\n], CodePointCharStream.prototype, \"LA\", null);\n__decorate([\n    Decorators_1.Override\n], CodePointCharStream.prototype, \"getText\", null);\nexports.CodePointCharStream = CodePointCharStream;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\nimport * as assert from \"assert\";\nimport { CharStream } from \"./CharStream\";\nimport { CodePointBuffer } from \"./CodePointBuffer\";\nimport { IntStream } from \"./IntStream\";\nimport { Interval } from \"./misc/Interval\";\nimport { Override } from \"./Decorators\";\n\n/**\n * Alternative to {@link ANTLRInputStream} which treats the input\n * as a series of Unicode code points, instead of a series of UTF-16\n * code units.\n *\n * Use this if you need to parse input which potentially contains\n * Unicode values > U+FFFF.\n */\nexport class CodePointCharStream implements CharStream {\n\tprivate readonly _array: Uint8Array | Uint16Array | Int32Array;\n\tprivate readonly _size: number;\n\tprivate readonly _name: string;\n\n\tprivate _position: number;\n\n\t// Use the factory method {@link #fromBuffer(CodePointBuffer)} to\n\t// construct instances of this type.\n\tprotected constructor(array: Uint8Array | Uint16Array | Int32Array, position: number, remaining: number, name: string) {\n\t\t// TODO\n\t\tassert(position === 0);\n\t\tthis._array = array;\n\t\tthis._size = remaining;\n\t\tthis._name = name;\n\t\tthis._position = 0;\n\t}\n\n\tpublic get internalStorage(): Uint8Array | Uint16Array | Int32Array {\n\t\treturn this._array;\n\t}\n\n\t/**\n\t * Constructs a {@link CodePointCharStream} which provides access\n\t * to the Unicode code points stored in {@code codePointBuffer}.\n\t */\n\tpublic static fromBuffer(codePointBuffer: CodePointBuffer): CodePointCharStream;\n\n\t/**\n\t * Constructs a named {@link CodePointCharStream} which provides access\n\t * to the Unicode code points stored in {@code codePointBuffer}.\n\t */\n\tpublic static fromBuffer(codePointBuffer: CodePointBuffer, name: string): CodePointCharStream;\n\tpublic static fromBuffer(codePointBuffer: CodePointBuffer, name?: string): CodePointCharStream {\n\t\tif (name === undefined || name.length === 0) {\n\t\t\tname = IntStream.UNKNOWN_SOURCE_NAME;\n\t\t}\n\n\t\t// Java lacks generics on primitive types.\n\t\t//\n\t\t// To avoid lots of calls to virtual methods in the\n\t\t// very hot codepath of LA() below, we construct one\n\t\t// of three concrete subclasses.\n\t\t//\n\t\t// The concrete subclasses directly access the code\n\t\t// points stored in the underlying array (byte[],\n\t\t// char[], or int[]), so we can avoid lots of virtual\n\t\t// method calls to ByteBuffer.get(offset).\n\t\treturn new CodePointCharStream(\n\t\t\tcodePointBuffer.array(),\n\t\t\tcodePointBuffer.position,\n\t\t\tcodePointBuffer.remaining,\n\t\t\tname);\n\t}\n\n\t@Override\n\tpublic consume(): void {\n\t\tif (this._size - this._position === 0) {\n\t\t\tassert(this.LA(1) === IntStream.EOF);\n\t\t\tthrow new RangeError(\"cannot consume EOF\");\n\t\t}\n\n\t\tthis._position++;\n\t}\n\n\t@Override\n\tpublic get index(): number {\n\t\treturn this._position;\n\t}\n\n\t@Override\n\tpublic get size(): number {\n\t\treturn this._size;\n\t}\n\n\t/** mark/release do nothing; we have entire buffer */\n\t@Override\n\tpublic mark(): number {\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic release(marker: number): void {\n\t\t// No default implementation since this stream buffers the entire input\n\t}\n\n\t@Override\n\tpublic seek(index: number): void {\n\t\tthis._position = index;\n\t}\n\n\t@Override\n\tpublic get sourceName(): string {\n\t\treturn this._name;\n\t}\n\n\t@Override\n\tpublic toString(): string {\n\t\treturn this.getText(Interval.of(0, this.size - 1));\n\t}\n\n\t@Override\n\tpublic LA(i: number): number {\n\t\tlet offset: number;\n\t\tswitch (Math.sign(i)) {\n\t\t\tcase -1:\n\t\t\t\toffset = this.index + i;\n\t\t\t\tif (offset < 0) {\n\t\t\t\t\treturn IntStream.EOF;\n\t\t\t\t}\n\n\t\t\t\treturn this._array[offset];\n\n\t\t\tcase 0:\n\t\t\t\t// Undefined\n\t\t\t\treturn 0;\n\n\t\t\tcase 1:\n\t\t\t\toffset = this.index + i - 1;\n\t\t\t\tif (offset >= this.size) {\n\t\t\t\t\treturn IntStream.EOF;\n\t\t\t\t}\n\n\t\t\t\treturn this._array[offset];\n\t\t}\n\n\t\tthrow new RangeError(\"Not reached\");\n\t}\n\n\t/** Return the UTF-16 encoded string for the given interval */\n\t@Override\n\tpublic getText(interval: Interval): string {\n\t\tconst startIdx: number = Math.min(interval.a, this.size);\n\t\tconst len: number = Math.min(interval.b - interval.a + 1, this.size - startIdx);\n\n\t\tif (this._array instanceof Int32Array) {\n\t\t\treturn String.fromCodePoint(...Array.from(this._array.subarray(startIdx, startIdx + len)));\n\t\t} else {\n\t\t\treturn String.fromCharCode(...Array.from(this._array.subarray(startIdx, startIdx + len)));\n\t\t}\n\t}\n}\n"]}