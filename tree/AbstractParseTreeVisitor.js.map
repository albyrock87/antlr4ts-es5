{"version":3,"sources":["tree/AbstractParseTreeVisitor.js","../src/tree/AbstractParseTreeVisitor.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","Decorators_1","require","AbstractParseTreeVisitor","tree","accept","node","result","defaultResult","n","childCount","shouldVisitNextChild","getChild","childResult","aggregateResult","aggregate","nextResult","currentResult","Override","NotNull","prototype"],"mappings":"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","file":"AbstractParseTreeVisitor.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Decorators_1 = require(\"../Decorators\");\nclass AbstractParseTreeVisitor {\n    /**\n     * {@inheritDoc}\n     *\n     * The default implementation calls {@link ParseTree#accept} on the\n     * specified tree.\n     */\n    visit(tree) {\n        return tree.accept(this);\n    }\n    /**\n     * {@inheritDoc}\n     *\n     * The default implementation initializes the aggregate result to\n     * {@link #defaultResult defaultResult()}. Before visiting each child, it\n     * calls {@link #shouldVisitNextChild shouldVisitNextChild}; if the result\n     * is `false` no more children are visited and the current aggregate\n     * result is returned. After visiting a child, the aggregate result is\n     * updated by calling {@link #aggregateResult aggregateResult} with the\n     * previous aggregate result and the result of visiting the child.\n     *\n     * The default implementation is not safe for use in visitors that modify\n     * the tree structure. Visitors that modify the tree should override this\n     * method to behave properly in respect to the specific algorithm in use.\n     */\n    visitChildren(node) {\n        let result = this.defaultResult();\n        let n = node.childCount;\n        for (let i = 0; i < n; i++) {\n            if (!this.shouldVisitNextChild(node, result)) {\n                break;\n            }\n            let c = node.getChild(i);\n            let childResult = c.accept(this);\n            result = this.aggregateResult(result, childResult);\n        }\n        return result;\n    }\n    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns the result of\n     * {@link #defaultResult defaultResult}.\n     */\n    visitTerminal(node) {\n        return this.defaultResult();\n    }\n    /**\n     * {@inheritDoc}\n     *\n     * The default implementation returns the result of\n     * {@link #defaultResult defaultResult}.\n     */\n    visitErrorNode(node) {\n        return this.defaultResult();\n    }\n    /**\n     * Aggregates the results of visiting multiple children of a node. After\n     * either all children are visited or {@link #shouldVisitNextChild} returns\n     * `false`, the aggregate value is returned as the result of\n     * {@link #visitChildren}.\n     *\n     * The default implementation returns `nextResult`, meaning\n     * {@link #visitChildren} will return the result of the last child visited\n     * (or return the initial value if the node has no children).\n     *\n     * @param aggregate The previous aggregate value. In the default\n     * implementation, the aggregate value is initialized to\n     * {@link #defaultResult}, which is passed as the `aggregate` argument\n     * to this method after the first child node is visited.\n     * @param nextResult The result of the immediately preceeding call to visit\n     * a child node.\n     *\n     * @returns The updated aggregate result.\n     */\n    aggregateResult(aggregate, nextResult) {\n        return nextResult;\n    }\n    /**\n     * This method is called after visiting each child in\n     * {@link #visitChildren}. This method is first called before the first\n     * child is visited; at that point `currentResult` will be the initial\n     * value (in the default implementation, the initial value is returned by a\n     * call to {@link #defaultResult}. This method is not called after the last\n     * child is visited.\n     *\n     * The default implementation always returns `true`, indicating that\n     * `visitChildren` should only return after all children are visited.\n     * One reason to override this method is to provide a \"short circuit\"\n     * evaluation option for situations where the result of visiting a single\n     * child has the potential to determine the result of the visit operation as\n     * a whole.\n     *\n     * @param node The {@link RuleNode} whose children are currently being\n     * visited.\n     * @param currentResult The current aggregate result of the children visited\n     * to the current point.\n     *\n     * @returns `true` to continue visiting children. Otherwise return\n     * `false` to stop visiting children and immediately return the\n     * current aggregate result from {@link #visitChildren}.\n     */\n    shouldVisitNextChild(node, currentResult) {\n        return true;\n    }\n}\n__decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n], AbstractParseTreeVisitor.prototype, \"visit\", null);\n__decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n], AbstractParseTreeVisitor.prototype, \"visitChildren\", null);\n__decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n], AbstractParseTreeVisitor.prototype, \"visitTerminal\", null);\n__decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n], AbstractParseTreeVisitor.prototype, \"visitErrorNode\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], AbstractParseTreeVisitor.prototype, \"shouldVisitNextChild\", null);\nexports.AbstractParseTreeVisitor = AbstractParseTreeVisitor;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:47.3092279-07:00\n\nimport { ErrorNode } from \"./ErrorNode\";\nimport { NotNull, Override } from \"../Decorators\";\nimport { ParseTree } from \"./ParseTree\";\nimport { ParseTreeVisitor } from \"./ParseTreeVisitor\";\nimport { RuleNode } from \"./RuleNode\";\nimport { TerminalNode } from \"./TerminalNode\";\n\nexport abstract class AbstractParseTreeVisitor<Result> implements ParseTreeVisitor<Result> {\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The default implementation calls {@link ParseTree#accept} on the\n\t * specified tree.\n\t */\n\t@Override\n\tpublic visit(@NotNull tree: ParseTree): Result {\n\t\treturn tree.accept(this);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The default implementation initializes the aggregate result to\n\t * {@link #defaultResult defaultResult()}. Before visiting each child, it\n\t * calls {@link #shouldVisitNextChild shouldVisitNextChild}; if the result\n\t * is `false` no more children are visited and the current aggregate\n\t * result is returned. After visiting a child, the aggregate result is\n\t * updated by calling {@link #aggregateResult aggregateResult} with the\n\t * previous aggregate result and the result of visiting the child.\n\t *\n\t * The default implementation is not safe for use in visitors that modify\n\t * the tree structure. Visitors that modify the tree should override this\n\t * method to behave properly in respect to the specific algorithm in use.\n\t */\n\t@Override\n\tpublic visitChildren(@NotNull node: RuleNode): Result {\n\t\tlet result: Result = this.defaultResult();\n\t\tlet n: number = node.childCount;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tif (!this.shouldVisitNextChild(node, result)) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet c: ParseTree = node.getChild(i);\n\t\t\tlet childResult: Result = c.accept(this);\n\t\t\tresult = this.aggregateResult(result, childResult);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The default implementation returns the result of\n\t * {@link #defaultResult defaultResult}.\n\t */\n\t@Override\n\tpublic visitTerminal(@NotNull node: TerminalNode): Result {\n\t\treturn this.defaultResult();\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * The default implementation returns the result of\n\t * {@link #defaultResult defaultResult}.\n\t */\n\t@Override\n\tpublic visitErrorNode(@NotNull node: ErrorNode): Result {\n\t\treturn this.defaultResult();\n\t}\n\n\t/**\n\t * Gets the default value returned by visitor methods. This value is\n\t * returned by the default implementations of\n\t * {@link #visitTerminal visitTerminal}, {@link #visitErrorNode visitErrorNode}.\n\t * The default implementation of {@link #visitChildren visitChildren}\n\t * initializes its aggregate result to this value.\n\t *\n\t * @returns The default value returned by visitor methods.\n\t */\n\tprotected abstract defaultResult(): Result;\n\n\t/**\n\t * Aggregates the results of visiting multiple children of a node. After\n\t * either all children are visited or {@link #shouldVisitNextChild} returns\n\t * `false`, the aggregate value is returned as the result of\n\t * {@link #visitChildren}.\n\t *\n\t * The default implementation returns `nextResult`, meaning\n\t * {@link #visitChildren} will return the result of the last child visited\n\t * (or return the initial value if the node has no children).\n\t *\n\t * @param aggregate The previous aggregate value. In the default\n\t * implementation, the aggregate value is initialized to\n\t * {@link #defaultResult}, which is passed as the `aggregate` argument\n\t * to this method after the first child node is visited.\n\t * @param nextResult The result of the immediately preceeding call to visit\n\t * a child node.\n\t *\n\t * @returns The updated aggregate result.\n\t */\n\tprotected aggregateResult(aggregate: Result, nextResult: Result): Result {\n\t\treturn nextResult;\n\t}\n\n\t/**\n\t * This method is called after visiting each child in\n\t * {@link #visitChildren}. This method is first called before the first\n\t * child is visited; at that point `currentResult` will be the initial\n\t * value (in the default implementation, the initial value is returned by a\n\t * call to {@link #defaultResult}. This method is not called after the last\n\t * child is visited.\n\t *\n\t * The default implementation always returns `true`, indicating that\n\t * `visitChildren` should only return after all children are visited.\n\t * One reason to override this method is to provide a \"short circuit\"\n\t * evaluation option for situations where the result of visiting a single\n\t * child has the potential to determine the result of the visit operation as\n\t * a whole.\n\t *\n\t * @param node The {@link RuleNode} whose children are currently being\n\t * visited.\n\t * @param currentResult The current aggregate result of the children visited\n\t * to the current point.\n\t *\n\t * @returns `true` to continue visiting children. Otherwise return\n\t * `false` to stop visiting children and immediately return the\n\t * current aggregate result from {@link #visitChildren}.\n\t */\n\tprotected shouldVisitNextChild(@NotNull node: RuleNode, currentResult: Result): boolean {\n\t\treturn true;\n\t}\n}\n"]}