{"version":3,"sources":["tree/Trees.js","../src/tree/Trees.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","ATN_1","require","CommonToken_1","ErrorNode_1","Decorators_1","Parser_1","ParserRuleContext_1","RuleNode_1","TerminalNode_1","Token_1","Utils","Trees","t","arg2","ruleNames","Parser","s","escapeWhitespace","getNodeText","childCount","buf","toStringTree","getChild","payload","text","toString","RuleNode","ruleContext","ruleIndex","ruleName","altNumber","ATN","INVALID_ALT_NUMBER","ErrorNode","TerminalNode","symbol","TypeError","kids","push","ancestors","p","parent","unshift","u","ttype","findAllNodes","index","findTokens","nodes","_findAllNodes","type","ParserRuleContext","recurse","e","n","startTokenIndex","stopTokenIndex","child","getRootOfSubtreeEnclosingRegion","stopToken","stop","start","tokenIndex","undefined","root","startIndex","stopIndex","count","range","sourceInterval","b","a","isAncestorOf","abbrev","CommonToken","Token","INVALID_TYPE","children","pred","findNodeSuchThat","NotNull"],"mappings":"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","file":"Trees.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ATN_1 = require(\"../atn/ATN\");\nconst CommonToken_1 = require(\"../CommonToken\");\nconst ErrorNode_1 = require(\"./ErrorNode\");\nconst Decorators_1 = require(\"../Decorators\");\nconst Parser_1 = require(\"../Parser\");\nconst ParserRuleContext_1 = require(\"../ParserRuleContext\");\nconst RuleNode_1 = require(\"./RuleNode\");\nconst TerminalNode_1 = require(\"./TerminalNode\");\nconst Token_1 = require(\"../Token\");\nconst Utils = require(\"../misc/Utils\");\n/** A set of utility routines useful for all kinds of ANTLR trees. */\nclass Trees {\n    static toStringTree(t, arg2) {\n        let ruleNames;\n        if (arg2 instanceof Parser_1.Parser) {\n            ruleNames = arg2.ruleNames;\n        }\n        else {\n            ruleNames = arg2;\n        }\n        let s = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);\n        if (t.childCount === 0) {\n            return s;\n        }\n        let buf = \"\";\n        buf += (\"(\");\n        s = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);\n        buf += (s);\n        buf += (\" \");\n        for (let i = 0; i < t.childCount; i++) {\n            if (i > 0) {\n                buf += (\" \");\n            }\n            buf += (this.toStringTree(t.getChild(i), ruleNames));\n        }\n        buf += (\")\");\n        return buf;\n    }\n    static getNodeText(t, arg2) {\n        let ruleNames;\n        if (arg2 instanceof Parser_1.Parser) {\n            ruleNames = arg2.ruleNames;\n        }\n        else if (arg2) {\n            ruleNames = arg2;\n        }\n        else {\n            // no recog or rule names\n            let payload = t.payload;\n            if (typeof payload.text === \"string\") {\n                return payload.text;\n            }\n            return t.payload.toString();\n        }\n        if (t instanceof RuleNode_1.RuleNode) {\n            let ruleContext = t.ruleContext;\n            let ruleIndex = ruleContext.ruleIndex;\n            let ruleName = ruleNames[ruleIndex];\n            let altNumber = ruleContext.altNumber;\n            if (altNumber !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n                return ruleName + \":\" + altNumber;\n            }\n            return ruleName;\n        }\n        else if (t instanceof ErrorNode_1.ErrorNode) {\n            return t.toString();\n        }\n        else if (t instanceof TerminalNode_1.TerminalNode) {\n            let symbol = t.symbol;\n            return symbol.text || \"\";\n        }\n        throw new TypeError(\"Unexpected node type\");\n    }\n    static getChildren(t) {\n        let kids = [];\n        for (let i = 0; i < t.childCount; i++) {\n            kids.push(t.getChild(i));\n        }\n        return kids;\n    }\n    static getAncestors(t) {\n        let ancestors = [];\n        let p = t.parent;\n        while (p) {\n            ancestors.unshift(p); // insert at start\n            p = p.parent;\n        }\n        return ancestors;\n    }\n    /** Return true if t is u's parent or a node on path to root from u.\n     *  Use === not equals().\n     *\n     *  @since 4.5.1\n     */\n    static isAncestorOf(t, u) {\n        if (!t || !u || !t.parent) {\n            return false;\n        }\n        let p = u.parent;\n        while (p) {\n            if (t === p) {\n                return true;\n            }\n            p = p.parent;\n        }\n        return false;\n    }\n    static findAllTokenNodes(t, ttype) {\n        return Trees.findAllNodes(t, ttype, true);\n    }\n    static findAllRuleNodes(t, ruleIndex) {\n        return Trees.findAllNodes(t, ruleIndex, false);\n    }\n    static findAllNodes(t, index, findTokens) {\n        let nodes = [];\n        Trees._findAllNodes(t, index, findTokens, nodes);\n        return nodes;\n    }\n    static _findAllNodes(t, index, findTokens, nodes) {\n        // check this node (the root) first\n        if (findTokens && t instanceof TerminalNode_1.TerminalNode) {\n            if (t.symbol.type === index) {\n                nodes.push(t);\n            }\n        }\n        else if (!findTokens && t instanceof ParserRuleContext_1.ParserRuleContext) {\n            if (t.ruleIndex === index) {\n                nodes.push(t);\n            }\n        }\n        // check children\n        for (let i = 0; i < t.childCount; i++) {\n            Trees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n        }\n    }\n    /** Get all descendents; includes t itself.\n     *\n     * @since 4.5.1\n     */\n    static getDescendants(t) {\n        let nodes = [];\n        function recurse(e) {\n            nodes.push(e);\n            const n = e.childCount;\n            for (let i = 0; i < n; i++) {\n                recurse(e.getChild(i));\n            }\n        }\n        recurse(t);\n        return nodes;\n    }\n    /** Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex\n     *  inclusively using postorder traversal.  Recursive depth-first-search.\n     *\n     *  @since 4.5\n     */\n    static getRootOfSubtreeEnclosingRegion(t, startTokenIndex, // inclusive\n    stopTokenIndex) {\n        let n = t.childCount;\n        for (let i = 0; i < n; i++) {\n            let child = t.getChild(i);\n            let r = Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);\n            if (r) {\n                return r;\n            }\n        }\n        if (t instanceof ParserRuleContext_1.ParserRuleContext) {\n            let stopToken = t.stop;\n            if (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?\n                (stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {\n                // note: r.stop==null likely implies that we bailed out of parser and there's nothing to the right\n                return t;\n            }\n        }\n        return undefined;\n    }\n    /** Replace any subtree siblings of root that are completely to left\n     *  or right of lookahead range with a CommonToken(Token.INVALID_TYPE,\"...\")\n     *  node. The source interval for t is not altered to suit smaller range!\n     *\n     *  WARNING: destructive to t.\n     *\n     *  @since 4.5.1\n     */\n    static stripChildrenOutOfRange(t, root, startIndex, stopIndex) {\n        if (!t) {\n            return;\n        }\n        let count = t.childCount;\n        for (let i = 0; i < count; i++) {\n            let child = t.getChild(i);\n            let range = child.sourceInterval;\n            if (child instanceof ParserRuleContext_1.ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {\n                if (Trees.isAncestorOf(child, root)) { // replace only if subtree doesn't have displayed root\n                    let abbrev = new CommonToken_1.CommonToken(Token_1.Token.INVALID_TYPE, \"...\");\n                    t.children[i] = new TerminalNode_1.TerminalNode(abbrev); // HACK access to private\n                }\n            }\n        }\n    }\n    static findNodeSuchThat(t, pred) {\n        // No type check needed as long as users only use one of the available overloads\n        if (pred(t)) {\n            return t;\n        }\n        let n = t.childCount;\n        for (let i = 0; i < n; i++) {\n            let u = Trees.findNodeSuchThat(t.getChild(i), pred);\n            if (u !== undefined) {\n                return u;\n            }\n        }\n        return undefined;\n    }\n}\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], Trees, \"toStringTree\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], Trees, \"getAncestors\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], Trees, \"getRootOfSubtreeEnclosingRegion\", null);\nexports.Trees = Trees;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:48.3187865-07:00\n\nimport { Arrays } from \"../misc/Arrays\";\nimport { ATN } from \"../atn/ATN\";\nimport { CommonToken } from \"../CommonToken\";\nimport { ErrorNode } from \"./ErrorNode\";\nimport { Interval } from \"../misc/Interval\";\nimport { NotNull } from \"../Decorators\";\nimport { Parser } from \"../Parser\";\nimport { ParserRuleContext } from \"../ParserRuleContext\";\nimport { ParseTree } from \"./ParseTree\";\nimport { RuleContext } from \"../RuleContext\";\nimport { RuleNode } from \"./RuleNode\";\nimport { TerminalNode } from \"./TerminalNode\";\nimport { Token } from \"../Token\";\nimport { Tree } from \"./Tree\";\nimport * as Utils from \"../misc/Utils\";\n\n/** A set of utility routines useful for all kinds of ANTLR trees. */\nexport class Trees {\n\t/** Print out a whole tree in LISP form. {@link #getNodeText} is used on the\n\t *  node payloads to get the text for the nodes.  Detect\n\t *  parse trees and extract data appropriately.\n\t */\n\tpublic static toStringTree(/*@NotNull*/ t: Tree): string;\n\n\t/** Print out a whole tree in LISP form. {@link #getNodeText} is used on the\n\t *  node payloads to get the text for the nodes.  Detect\n\t *  parse trees and extract data appropriately.\n\t */\n\tpublic static toStringTree(/*@NotNull*/ t: Tree, recog: Parser | undefined): string;\n\n\t/** Print out a whole tree in LISP form. {@link #getNodeText} is used on the\n\t *  node payloads to get the text for the nodes.\n\t */\n\tpublic static toStringTree(/*@NotNull*/ t: Tree, /*@Nullable*/ ruleNames: string[] | undefined): string;\n\n\tpublic static toStringTree(/*@NotNull*/ t: Tree, arg2?: Parser | string[]): string;\n\tpublic static toStringTree(@NotNull t: Tree, arg2?: Parser | string[]): string {\n\t\tlet ruleNames: string[] | undefined;\n\t\tif (arg2 instanceof Parser) {\n\t\t\truleNames = arg2.ruleNames;\n\t\t} else {\n\t\t\truleNames = arg2;\n\t\t}\n\n\t\tlet s: string = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);\n\t\tif (t.childCount === 0) {\n\t\t\treturn s;\n\t\t}\n\t\tlet buf = \"\";\n\t\tbuf += (\"(\");\n\t\ts = Utils.escapeWhitespace(this.getNodeText(t, ruleNames), false);\n\t\tbuf += (s);\n\t\tbuf += (\" \");\n\t\tfor (let i = 0; i < t.childCount; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tbuf += (\" \");\n\t\t\t}\n\t\t\tbuf += (this.toStringTree(t.getChild(i), ruleNames));\n\t\t}\n\t\tbuf += (\")\");\n\t\treturn buf;\n\t}\n\n\tpublic static getNodeText(/*@NotNull*/ t: Tree, recog: Parser | undefined): string;\n\tpublic static getNodeText(/*@NotNull*/ t: Tree, ruleNames: string[] | undefined): string;\n\tpublic static getNodeText(t: Tree, arg2: Parser | string[] | undefined): string {\n\t\tlet ruleNames: string[] | undefined;\n\t\tif (arg2 instanceof Parser) {\n\t\t\truleNames = arg2.ruleNames;\n\t\t} else if (arg2) {\n\t\t\truleNames = arg2;\n\t\t} else {\n\t\t\t// no recog or rule names\n\t\t\tlet payload = t.payload;\n\t\t\tif (typeof payload.text === \"string\") {\n\t\t\t\treturn payload.text;\n\t\t\t}\n\t\t\treturn t.payload.toString();\n\t\t}\n\n\t\tif (t instanceof RuleNode) {\n\t\t\tlet ruleContext: RuleContext = t.ruleContext;\n\t\t\tlet ruleIndex: number = ruleContext.ruleIndex;\n\t\t\tlet ruleName: string = ruleNames[ruleIndex];\n\t\t\tlet altNumber: number = ruleContext.altNumber;\n\t\t\tif (altNumber !== ATN.INVALID_ALT_NUMBER) {\n\t\t\t\treturn ruleName + \":\" + altNumber;\n\t\t\t}\n\t\t\treturn ruleName;\n\t\t}\n\t\telse if (t instanceof ErrorNode) {\n\t\t\treturn t.toString();\n\t\t}\n\t\telse if (t instanceof TerminalNode) {\n\t\t\tlet symbol = t.symbol;\n\t\t\treturn symbol.text || \"\";\n\t\t}\n\t\tthrow new TypeError(\"Unexpected node type\");\n\t}\n\n\t/** Return ordered list of all children of this node */\n\tpublic static getChildren(t: ParseTree): ParseTree[];\n\tpublic static getChildren(t: Tree): Tree[];\n\tpublic static getChildren(t: Tree): Tree[] {\n\t\tlet kids: Tree[] = [];\n\t\tfor (let i = 0; i < t.childCount; i++) {\n\t\t\tkids.push(t.getChild(i));\n\t\t}\n\t\treturn kids;\n\t}\n\n\t/** Return a list of all ancestors of this node.  The first node of\n\t *  list is the root and the last is the parent of this node.\n\t *\n\t *  @since 4.5.1\n\t */\n\tpublic static getAncestors(t: ParseTree): ParseTree[];\n\tpublic static getAncestors(t: Tree): Tree[];\n\t@NotNull\n\tpublic static getAncestors(@NotNull t: Tree): Tree[] {\n\t\tlet ancestors: Tree[] = [];\n\t\tlet p = t.parent;\n\t\twhile (p) {\n\t\t\tancestors.unshift(p); // insert at start\n\t\t\tp = p.parent;\n\t\t}\n\t\treturn ancestors;\n\t}\n\n\t/** Return true if t is u's parent or a node on path to root from u.\n\t *  Use === not equals().\n\t *\n\t *  @since 4.5.1\n\t */\n\tpublic static isAncestorOf(t: Tree, u: Tree): boolean {\n\t\tif (!t || !u || !t.parent) {\n\t\t\treturn false;\n\t\t}\n\t\tlet p = u.parent;\n\t\twhile (p) {\n\t\t\tif (t === p) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tp = p.parent;\n\t\t}\n\t\treturn false;\n\t}\n\n\tpublic static findAllTokenNodes(t: ParseTree, ttype: number): ParseTree[] {\n\t\treturn Trees.findAllNodes(t, ttype, true);\n\t}\n\n\tpublic static findAllRuleNodes(t: ParseTree, ruleIndex: number): ParseTree[] {\n\t\treturn Trees.findAllNodes(t, ruleIndex, false);\n\t}\n\n\tpublic static findAllNodes(t: ParseTree, index: number, findTokens: boolean): ParseTree[] {\n\t\tlet nodes: ParseTree[] = [];\n\t\tTrees._findAllNodes(t, index, findTokens, nodes);\n\t\treturn nodes;\n\t}\n\n\tpublic static _findAllNodes(t: ParseTree, index: number, findTokens: boolean, nodes: ParseTree[]): void {\n\t\t// check this node (the root) first\n\t\tif (findTokens && t instanceof TerminalNode) {\n\t\t\tif (t.symbol.type === index) {\n\t\t\t\tnodes.push(t);\n\t\t\t}\n\t\t}\n\t\telse if (!findTokens && t instanceof ParserRuleContext) {\n\t\t\tif (t.ruleIndex === index) {\n\t\t\t\tnodes.push(t);\n\t\t\t}\n\t\t}\n\t\t// check children\n\t\tfor (let i = 0; i < t.childCount; i++) {\n\t\t\tTrees._findAllNodes(t.getChild(i), index, findTokens, nodes);\n\t\t}\n\t}\n\n\t/** Get all descendents; includes t itself.\n\t *\n\t * @since 4.5.1\n\t */\n\tpublic static getDescendants(t: ParseTree): ParseTree[] {\n\t\tlet nodes: ParseTree[] = [];\n\n\t\tfunction recurse(e: ParseTree): void {\n\t\t\tnodes.push(e);\n\t\t\tconst n = e.childCount;\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\trecurse(e.getChild(i));\n\t\t\t}\n\t\t}\n\n\t\trecurse(t);\n\t\treturn nodes;\n\t}\n\n\t/** Find smallest subtree of t enclosing range startTokenIndex..stopTokenIndex\n\t *  inclusively using postorder traversal.  Recursive depth-first-search.\n\t *\n\t *  @since 4.5\n\t */\n\tpublic static getRootOfSubtreeEnclosingRegion(\n\t\t@NotNull t: ParseTree,\n\t\tstartTokenIndex: number, // inclusive\n\t\tstopTokenIndex: number, // inclusive\n\t): ParserRuleContext | undefined {\n\t\tlet n: number = t.childCount;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet child: ParseTree = t.getChild(i);\n\t\t\tlet r = Trees.getRootOfSubtreeEnclosingRegion(child, startTokenIndex, stopTokenIndex);\n\t\t\tif (r) {\n\t\t\t\treturn r;\n\t\t\t}\n\t\t}\n\t\tif (t instanceof ParserRuleContext) {\n\t\t\tlet stopToken = t.stop;\n\t\t\tif (startTokenIndex >= t.start.tokenIndex && // is range fully contained in t?\n\t\t\t\t(stopToken == null || stopTokenIndex <= stopToken.tokenIndex)) {\n\t\t\t\t// note: r.stop==null likely implies that we bailed out of parser and there's nothing to the right\n\t\t\t\treturn t;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\t/** Replace any subtree siblings of root that are completely to left\n\t *  or right of lookahead range with a CommonToken(Token.INVALID_TYPE,\"...\")\n\t *  node. The source interval for t is not altered to suit smaller range!\n\t *\n\t *  WARNING: destructive to t.\n\t *\n\t *  @since 4.5.1\n\t */\n\tpublic static stripChildrenOutOfRange(\n\t\tt: ParserRuleContext,\n\t\troot: ParserRuleContext,\n\t\tstartIndex: number,\n\t\tstopIndex: number): void {\n\t\tif (!t) {\n\t\t\treturn;\n\t\t}\n\t\tlet count = t.childCount;\n\t\tfor (let i = 0; i < count; i++) {\n\t\t\tlet child = t.getChild(i);\n\t\t\tlet range: Interval = child.sourceInterval;\n\t\t\tif (child instanceof ParserRuleContext && (range.b < startIndex || range.a > stopIndex)) {\n\t\t\t\tif (Trees.isAncestorOf(child, root)) { // replace only if subtree doesn't have displayed root\n\t\t\t\t\tlet abbrev: CommonToken = new CommonToken(Token.INVALID_TYPE, \"...\");\n\t\t\t\t\tt.children![i] = new TerminalNode(abbrev); // HACK access to private\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Return first node satisfying the pred\n\t *\n\t *  @since 4.5.1\n\t */\n\tpublic static findNodeSuchThat(t: ParseTree, pred: (tree: ParseTree) => boolean): ParseTree | undefined;\n\tpublic static findNodeSuchThat(t: Tree, pred: (tree: Tree) => boolean): Tree | undefined;\n\tpublic static findNodeSuchThat(t: Tree, pred: (tree: ParseTree) => boolean): Tree | undefined {\n\t\t// No type check needed as long as users only use one of the available overloads\n\t\tif (pred(t as ParseTree)) {\n\t\t\treturn t;\n\t\t}\n\n\t\tlet n: number =  t.childCount;\n\t\tfor (let i = 0 ; i < n ; i++){\n\t\t\tlet u = Trees.findNodeSuchThat(t.getChild(i), pred as (tree: Tree) => boolean);\n\t\t\tif (u !== undefined) {\n\t\t\t\treturn u;\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n}\n"]}