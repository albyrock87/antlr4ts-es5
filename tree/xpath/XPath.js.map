{"version":3,"sources":["tree/xpath/XPath.js","../src/tree/xpath/XPath.ts"],"names":["Object","defineProperty","exports","value","CharStreams_1","require","CommonTokenStream_1","LexerNoViableAltException_1","ParserRuleContext_1","Token_1","XPathLexer_1","XPathLexerErrorListener_1","XPathRuleAnywhereElement_1","XPathRuleElement_1","XPathTokenAnywhereElement_1","XPathTokenElement_1","XPathWildcardAnywhereElement_1","XPathWildcardElement_1","XPath","parser","path","elements","split","lexer","XPathLexer","CharStreams","fromString","recover","e","removeErrorListeners","addErrorListener","XPathLexerErrorListener","tokenStream","CommonTokenStream","fill","LexerNoViableAltException","pos","charPositionInLine","msg","message","RangeError","tokens","getTokens","n","length","i","loop","el","next","type","ROOT","ANYWHERE","anywhere","invert","BANG","pathElement","getXPathElement","push","TOKEN_REF","RULE_REF","WILDCARD","Token","EOF","Error","wordToken","word","text","ttype","getTokenType","ruleIndex","getRuleIndex","XPathWildcardAnywhereElement","XPathWildcardElement","STRING","INVALID_TYPE","startIndex","XPathTokenAnywhereElement","XPathTokenElement","XPathRuleAnywhereElement","XPathRuleElement","t","dummyRoot","ParserRuleContext","addChild","work","Set","node","childCount","matching","evaluate","forEach","add","tree","xpath","p","NOT"],"mappings":"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","file":"XPath.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:46.4373888-07:00\nconst CharStreams_1 = require(\"../../CharStreams\");\nconst CommonTokenStream_1 = require(\"../../CommonTokenStream\");\nconst LexerNoViableAltException_1 = require(\"../../LexerNoViableAltException\");\nconst ParserRuleContext_1 = require(\"../../ParserRuleContext\");\nconst Token_1 = require(\"../../Token\");\nconst XPathLexer_1 = require(\"./XPathLexer\");\nconst XPathLexerErrorListener_1 = require(\"./XPathLexerErrorListener\");\nconst XPathRuleAnywhereElement_1 = require(\"./XPathRuleAnywhereElement\");\nconst XPathRuleElement_1 = require(\"./XPathRuleElement\");\nconst XPathTokenAnywhereElement_1 = require(\"./XPathTokenAnywhereElement\");\nconst XPathTokenElement_1 = require(\"./XPathTokenElement\");\nconst XPathWildcardAnywhereElement_1 = require(\"./XPathWildcardAnywhereElement\");\nconst XPathWildcardElement_1 = require(\"./XPathWildcardElement\");\n/**\n * Represent a subset of XPath XML path syntax for use in identifying nodes in\n * parse trees.\n *\n * Split path into words and separators `/` and `//` via ANTLR\n * itself then walk path elements from left to right. At each separator-word\n * pair, find set of nodes. Next stage uses those as work list.\n *\n * The basic interface is\n * {@link XPath#findAll ParseTree.findAll}`(tree, pathString, parser)`.\n * But that is just shorthand for:\n *\n * ```\n * let p = new XPath(parser, pathString);\n * return p.evaluate(tree);\n * ```\n *\n * See `TestXPath` for descriptions. In short, this\n * allows operators:\n *\n * | | |\n * | --- | --- |\n * | `/` | root |\n * | `//` | anywhere |\n * | `!` | invert; this much appear directly after root or anywhere operator |\n *\n * and path elements:\n *\n * | | |\n * | --- | --- |\n * | `ID` | token name |\n * | `'string'` | any string literal token from the grammar |\n * | `expr` | rule name |\n * | `*` | wildcard matching any node |\n *\n * Whitespace is not allowed.\n */\nclass XPath {\n    constructor(parser, path) {\n        this.parser = parser;\n        this.path = path;\n        this.elements = this.split(path);\n        // console.log(this.elements.toString());\n    }\n    // TODO: check for invalid token/rule names, bad syntax\n    split(path) {\n        let lexer = new XPathLexer_1.XPathLexer(CharStreams_1.CharStreams.fromString(path));\n        lexer.recover = (e) => { throw e; };\n        lexer.removeErrorListeners();\n        lexer.addErrorListener(new XPathLexerErrorListener_1.XPathLexerErrorListener());\n        let tokenStream = new CommonTokenStream_1.CommonTokenStream(lexer);\n        try {\n            tokenStream.fill();\n        }\n        catch (e) {\n            if (e instanceof LexerNoViableAltException_1.LexerNoViableAltException) {\n                let pos = lexer.charPositionInLine;\n                let msg = \"Invalid tokens or characters at index \" + pos + \" in path '\" + path + \"' -- \" + e.message;\n                throw new RangeError(msg);\n            }\n            throw e;\n        }\n        let tokens = tokenStream.getTokens();\n        // console.log(\"path=\" + path + \"=>\" + tokens);\n        let elements = [];\n        let n = tokens.length;\n        let i = 0;\n        loop: while (i < n) {\n            let el = tokens[i];\n            let next;\n            switch (el.type) {\n                case XPathLexer_1.XPathLexer.ROOT:\n                case XPathLexer_1.XPathLexer.ANYWHERE:\n                    let anywhere = el.type === XPathLexer_1.XPathLexer.ANYWHERE;\n                    i++;\n                    next = tokens[i];\n                    let invert = next.type === XPathLexer_1.XPathLexer.BANG;\n                    if (invert) {\n                        i++;\n                        next = tokens[i];\n                    }\n                    let pathElement = this.getXPathElement(next, anywhere);\n                    pathElement.invert = invert;\n                    elements.push(pathElement);\n                    i++;\n                    break;\n                case XPathLexer_1.XPathLexer.TOKEN_REF:\n                case XPathLexer_1.XPathLexer.RULE_REF:\n                case XPathLexer_1.XPathLexer.WILDCARD:\n                    elements.push(this.getXPathElement(el, false));\n                    i++;\n                    break;\n                case Token_1.Token.EOF:\n                    break loop;\n                default:\n                    throw new Error(\"Unknowth path element \" + el);\n            }\n        }\n        return elements;\n    }\n    /**\n     * Convert word like `*` or `ID` or `expr` to a path\n     * element. `anywhere` is `true` if `//` precedes the\n     * word.\n     */\n    getXPathElement(wordToken, anywhere) {\n        if (wordToken.type === Token_1.Token.EOF) {\n            throw new Error(\"Missing path element at end of path\");\n        }\n        let word = wordToken.text;\n        if (word == null) {\n            throw new Error(\"Expected wordToken to have text content.\");\n        }\n        let ttype = this.parser.getTokenType(word);\n        let ruleIndex = this.parser.getRuleIndex(word);\n        switch (wordToken.type) {\n            case XPathLexer_1.XPathLexer.WILDCARD:\n                return anywhere ?\n                    new XPathWildcardAnywhereElement_1.XPathWildcardAnywhereElement() :\n                    new XPathWildcardElement_1.XPathWildcardElement();\n            case XPathLexer_1.XPathLexer.TOKEN_REF:\n            case XPathLexer_1.XPathLexer.STRING:\n                if (ttype === Token_1.Token.INVALID_TYPE) {\n                    throw new Error(word + \" at index \" +\n                        wordToken.startIndex +\n                        \" isn't a valid token name\");\n                }\n                return anywhere ?\n                    new XPathTokenAnywhereElement_1.XPathTokenAnywhereElement(word, ttype) :\n                    new XPathTokenElement_1.XPathTokenElement(word, ttype);\n            default:\n                if (ruleIndex === -1) {\n                    throw new Error(word + \" at index \" +\n                        wordToken.startIndex +\n                        \" isn't a valid rule name\");\n                }\n                return anywhere ?\n                    new XPathRuleAnywhereElement_1.XPathRuleAnywhereElement(word, ruleIndex) :\n                    new XPathRuleElement_1.XPathRuleElement(word, ruleIndex);\n        }\n    }\n    static findAll(tree, xpath, parser) {\n        let p = new XPath(parser, xpath);\n        return p.evaluate(tree);\n    }\n    /**\n     * Return a list of all nodes starting at `t` as root that satisfy the\n     * path. The root `/` is relative to the node passed to {@link evaluate}.\n     */\n    evaluate(t) {\n        let dummyRoot = new ParserRuleContext_1.ParserRuleContext();\n        dummyRoot.addChild(t);\n        let work = new Set([dummyRoot]);\n        let i = 0;\n        while (i < this.elements.length) {\n            let next = new Set();\n            for (let node of work) {\n                if (node.childCount > 0) {\n                    // only try to match next element if it has children\n                    // e.g., //func/*/stat might have a token node for which\n                    // we can't go looking for stat nodes.\n                    let matching = this.elements[i].evaluate(node);\n                    matching.forEach(next.add, next);\n                }\n            }\n            i++;\n            work = next;\n        }\n        return work;\n    }\n}\nXPath.WILDCARD = \"*\"; // word not operator/separator\nXPath.NOT = \"!\"; // word for invert operator\nexports.XPath = XPath;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:46.4373888-07:00\n\nimport { CharStreams } from \"../../CharStreams\";\nimport { CommonTokenStream } from \"../../CommonTokenStream\";\nimport { LexerNoViableAltException } from \"../../LexerNoViableAltException\";\nimport { Parser } from \"../../Parser\";\nimport { ParserRuleContext } from \"../../ParserRuleContext\";\nimport { ParseTree } from \"../ParseTree\";\nimport { Token } from \"../../Token\";\nimport { XPathElement } from \"./XPathElement\";\nimport { XPathLexer } from \"./XPathLexer\";\nimport { XPathLexerErrorListener } from \"./XPathLexerErrorListener\";\nimport { XPathRuleAnywhereElement } from \"./XPathRuleAnywhereElement\";\nimport { XPathRuleElement } from \"./XPathRuleElement\";\nimport { XPathTokenAnywhereElement } from \"./XPathTokenAnywhereElement\";\nimport { XPathTokenElement } from \"./XPathTokenElement\";\nimport { XPathWildcardAnywhereElement } from \"./XPathWildcardAnywhereElement\";\nimport { XPathWildcardElement } from \"./XPathWildcardElement\";\n\n/**\n * Represent a subset of XPath XML path syntax for use in identifying nodes in\n * parse trees.\n *\n * Split path into words and separators `/` and `//` via ANTLR\n * itself then walk path elements from left to right. At each separator-word\n * pair, find set of nodes. Next stage uses those as work list.\n *\n * The basic interface is\n * {@link XPath#findAll ParseTree.findAll}`(tree, pathString, parser)`.\n * But that is just shorthand for:\n *\n * ```\n * let p = new XPath(parser, pathString);\n * return p.evaluate(tree);\n * ```\n *\n * See `TestXPath` for descriptions. In short, this\n * allows operators:\n *\n * | | |\n * | --- | --- |\n * | `/` | root |\n * | `//` | anywhere |\n * | `!` | invert; this much appear directly after root or anywhere operator |\n *\n * and path elements:\n *\n * | | |\n * | --- | --- |\n * | `ID` | token name |\n * | `'string'` | any string literal token from the grammar |\n * | `expr` | rule name |\n * | `*` | wildcard matching any node |\n *\n * Whitespace is not allowed.\n */\nexport class XPath {\n\tpublic static readonly WILDCARD: string = \"*\"; // word not operator/separator\n\tpublic static readonly NOT: string = \"!\"; \t   // word for invert operator\n\n\tprotected path: string;\n\tprotected elements: XPathElement[];\n\tprotected parser: Parser;\n\n\tconstructor(parser: Parser, path: string) {\n\t\tthis.parser = parser;\n\t\tthis.path = path;\n\t\tthis.elements = this.split(path);\n\t\t// console.log(this.elements.toString());\n\t}\n\n\t// TODO: check for invalid token/rule names, bad syntax\n\n\tpublic split(path: string): XPathElement[] {\n\t\tlet lexer = new XPathLexer(CharStreams.fromString(path));\n\t\tlexer.recover = (e: LexerNoViableAltException) => { throw e; };\n\n\t\tlexer.removeErrorListeners();\n\t\tlexer.addErrorListener(new XPathLexerErrorListener());\n\t\tlet tokenStream = new CommonTokenStream(lexer);\n\t\ttry {\n\t\t\ttokenStream.fill();\n\t\t}\n\t\tcatch (e) {\n\t\t\tif (e instanceof LexerNoViableAltException) {\n\t\t\t\tlet pos: number = lexer.charPositionInLine;\n\t\t\t\tlet msg: string = \"Invalid tokens or characters at index \" + pos + \" in path '\" + path + \"' -- \" + e.message;\n\t\t\t\tthrow new RangeError(msg);\n\t\t\t}\n\t\t\tthrow e;\n\t\t}\n\n\t\tlet tokens: Token[] = tokenStream.getTokens();\n\t\t// console.log(\"path=\" + path + \"=>\" + tokens);\n\t\tlet elements: XPathElement[] = [];\n\t\tlet n: number = tokens.length;\n\t\tlet i: number = 0;\n\t\tloop:\n\t\twhile (i < n) {\n\t\t\tlet el: Token = tokens[i];\n\t\t\tlet next: Token | undefined;\n\t\t\tswitch (el.type) {\n\t\t\t\tcase XPathLexer.ROOT:\n\t\t\t\tcase XPathLexer.ANYWHERE:\n\t\t\t\t\tlet anywhere: boolean = el.type === XPathLexer.ANYWHERE;\n\t\t\t\t\ti++;\n\t\t\t\t\tnext = tokens[i];\n\t\t\t\t\tlet invert: boolean = next.type === XPathLexer.BANG;\n\t\t\t\t\tif (invert) {\n\t\t\t\t\t\ti++;\n\t\t\t\t\t\tnext = tokens[i];\n\t\t\t\t\t}\n\t\t\t\t\tlet pathElement: XPathElement = this.getXPathElement(next, anywhere);\n\t\t\t\t\tpathElement.invert = invert;\n\t\t\t\t\telements.push(pathElement);\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase XPathLexer.TOKEN_REF:\n\t\t\t\tcase XPathLexer.RULE_REF:\n\t\t\t\tcase XPathLexer.WILDCARD:\n\t\t\t\t\telements.push(this.getXPathElement(el, false));\n\t\t\t\t\ti++;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase Token.EOF:\n\t\t\t\t\tbreak loop;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Unknowth path element \" + el);\n\t\t\t}\n\t\t}\n\t\treturn elements;\n\t}\n\n\t/**\n\t * Convert word like `*` or `ID` or `expr` to a path\n\t * element. `anywhere` is `true` if `//` precedes the\n\t * word.\n\t */\n\tprotected getXPathElement(wordToken: Token, anywhere: boolean): XPathElement {\n\t\tif (wordToken.type === Token.EOF) {\n\t\t\tthrow new Error(\"Missing path element at end of path\");\n\t\t}\n\n\t\tlet word = wordToken.text;\n\t\tif (word == null) {\n\t\t\tthrow new Error(\"Expected wordToken to have text content.\");\n\t\t}\n\n\t\tlet ttype: number = this.parser.getTokenType(word);\n\t\tlet ruleIndex: number = this.parser.getRuleIndex(word);\n\t\tswitch (wordToken.type) {\n\t\t\tcase XPathLexer.WILDCARD:\n\t\t\t\treturn anywhere ?\n\t\t\t\t\tnew XPathWildcardAnywhereElement() :\n\t\t\t\t\tnew XPathWildcardElement();\n\t\t\tcase XPathLexer.TOKEN_REF:\n\t\t\tcase XPathLexer.STRING:\n\t\t\t\tif (ttype === Token.INVALID_TYPE) {\n\t\t\t\t\tthrow new Error(word + \" at index \" +\n\t\t\t\t\t\twordToken.startIndex +\n\t\t\t\t\t\t\" isn't a valid token name\");\n\t\t\t\t}\n\t\t\t\treturn anywhere ?\n\t\t\t\t\tnew XPathTokenAnywhereElement(word, ttype) :\n\t\t\t\t\tnew XPathTokenElement(word, ttype);\n\t\t\tdefault:\n\t\t\t\tif (ruleIndex === -1) {\n\t\t\t\t\tthrow new Error(word + \" at index \" +\n\t\t\t\t\t\twordToken.startIndex +\n\t\t\t\t\t\t\" isn't a valid rule name\");\n\t\t\t\t}\n\t\t\t\treturn anywhere ?\n\t\t\t\t\tnew XPathRuleAnywhereElement(word, ruleIndex) :\n\t\t\t\t\tnew XPathRuleElement(word, ruleIndex);\n\t\t}\n\t}\n\n\tpublic static findAll(tree: ParseTree, xpath: string, parser: Parser): Set<ParseTree> {\n\t\tlet p: XPath = new XPath(parser, xpath);\n\t\treturn p.evaluate(tree);\n\t}\n\n\t/**\n\t * Return a list of all nodes starting at `t` as root that satisfy the\n\t * path. The root `/` is relative to the node passed to {@link evaluate}.\n\t */\n\tpublic evaluate(t: ParseTree): Set<ParseTree> {\n\t\tlet dummyRoot = new ParserRuleContext();\n\t\tdummyRoot.addChild(t as ParserRuleContext);\n\n\t\tlet work = new Set<ParseTree>([dummyRoot]);\n\n\t\tlet i: number = 0;\n\t\twhile (i < this.elements.length) {\n\t\t\tlet next = new Set<ParseTree>();\n\t\t\tfor (let node of work) {\n\t\t\t\tif (node.childCount > 0) {\n\t\t\t\t\t// only try to match next element if it has children\n\t\t\t\t\t// e.g., //func/*/stat might have a token node for which\n\t\t\t\t\t// we can't go looking for stat nodes.\n\t\t\t\t\tlet matching = this.elements[i].evaluate(node);\n\t\t\t\t\tmatching.forEach(next.add, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++;\n\t\t\twork = next;\n\t\t}\n\n\t\treturn work;\n\t}\n}\n"]}