{"version":3,"sources":["tree/pattern/ParseTreePatternMatcher.js","../src/tree/pattern/ParseTreePatternMatcher.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","BailErrorStrategy_1","require","CharStreams_1","CommonTokenStream_1","ListTokenSource_1","MultiMap_1","Decorators_1","ParseCancellationException_1","ParserInterpreter_1","ParserRuleContext_1","ParseTreeMatch_1","ParseTreePattern_1","RecognitionException_1","RuleNode_1","RuleTagToken_1","TagChunk_1","TerminalNode_1","TextChunk_1","Token_1","TokenTagToken_1","ParseTreePatternMatcher","lexer","parser","start","stop","escape","escapeRE","_lexer","_parser","escapeLeft","Error","RegExp","replace","tree","pattern","patternRuleIndex","p","compile","matches","labels","MultiMap","mismatchedNode","matchImpl","patternTree","match","ParseTreeMatch","tokenList","tokenize","tokenSrc","ListTokenSource","tokens","CommonTokenStream","parserInterp","ParserInterpreter","grammarFileName","vocabulary","ruleNames","getATNWithBypassAlts","errorHandler","BailErrorStrategy","parse","e","ParseCancellationException","getCause","RecognitionException","CannotInvokeStartRule","LA","Token","EOF","StartRuleDoesNotConsumeFullPattern","ParseTreePattern","TypeError","TerminalNode","symbol","type","TokenTagToken","tokenTagToken","map","tokenName","l","label","text","ParserRuleContext","ruleTagToken","getRuleTagToken","m","ruleContext","ruleIndex","ruleName","childCount","n","childMatch","getChild","t","RuleNode","RuleTagToken","undefined","chunks","split","chunk","TagChunk","tagChunk","firstChar","tag","substr","toUpperCase","ttype","getTokenType","INVALID_TYPE","push","toLowerCase","getRuleIndex","ruleImaginaryTokenType","ruleToTokenType","textChunk","inputStream","CharStreams","fromString","nextToken","buf","starts","stops","indexOf","ntags","substring","TextChunk","ruleOrToken","colon","afterLastTag","unescaped","NotNull","prototype","error"],"mappings":"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","file":"ParseTreePatternMatcher.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// CONVERSTION complete, Burt Harris 10/14/2016\nconst BailErrorStrategy_1 = require(\"../../BailErrorStrategy\");\nconst CharStreams_1 = require(\"../../CharStreams\");\nconst CommonTokenStream_1 = require(\"../../CommonTokenStream\");\nconst ListTokenSource_1 = require(\"../../ListTokenSource\");\nconst MultiMap_1 = require(\"../../misc/MultiMap\");\nconst Decorators_1 = require(\"../../Decorators\");\nconst ParseCancellationException_1 = require(\"../../misc/ParseCancellationException\");\nconst ParserInterpreter_1 = require(\"../../ParserInterpreter\");\nconst ParserRuleContext_1 = require(\"../../ParserRuleContext\");\nconst ParseTreeMatch_1 = require(\"./ParseTreeMatch\");\nconst ParseTreePattern_1 = require(\"./ParseTreePattern\");\nconst RecognitionException_1 = require(\"../../RecognitionException\");\nconst RuleNode_1 = require(\"../RuleNode\");\nconst RuleTagToken_1 = require(\"./RuleTagToken\");\nconst TagChunk_1 = require(\"./TagChunk\");\nconst TerminalNode_1 = require(\"../TerminalNode\");\nconst TextChunk_1 = require(\"./TextChunk\");\nconst Token_1 = require(\"../../Token\");\nconst TokenTagToken_1 = require(\"./TokenTagToken\");\n/**\n * A tree pattern matching mechanism for ANTLR {@link ParseTree}s.\n *\n * Patterns are strings of source input text with special tags representing\n * token or rule references such as:\n *\n * ```\n * <ID> = <expr>;\n * ```\n *\n * Given a pattern start rule such as `statement`, this object constructs\n * a {@link ParseTree} with placeholders for the `ID` and `expr`\n * subtree. Then the {@link #match} routines can compare an actual\n * {@link ParseTree} from a parse with this pattern. Tag `<ID>` matches\n * any `ID` token and tag `<expr>` references the result of the\n * `expr` rule (generally an instance of `ExprContext`.\n *\n * Pattern `x = 0;` is a similar pattern that matches the same pattern\n * except that it requires the identifier to be `x` and the expression to\n * be `0`.\n *\n * The {@link #matches} routines return `true` or `false` based\n * upon a match for the tree rooted at the parameter sent in. The\n * {@link #match} routines return a {@link ParseTreeMatch} object that\n * contains the parse tree, the parse tree pattern, and a map from tag name to\n * matched nodes (more below). A subtree that fails to match, returns with\n * {@link ParseTreeMatch#mismatchedNode} set to the first tree node that did not\n * match.\n *\n * For efficiency, you can compile a tree pattern in string form to a\n * {@link ParseTreePattern} object.\n *\n * See `TestParseTreeMatcher` for lots of examples.\n * {@link ParseTreePattern} has two static helper methods:\n * {@link ParseTreePattern#findAll} and {@link ParseTreePattern#match} that\n * are easy to use but not super efficient because they create new\n * {@link ParseTreePatternMatcher} objects each time and have to compile the\n * pattern in string form before using it.\n *\n * The lexer and parser that you pass into the {@link ParseTreePatternMatcher}\n * constructor are used to parse the pattern in string form. The lexer converts\n * the `<ID> = <expr>;` into a sequence of four tokens (assuming lexer\n * throws out whitespace or puts it on a hidden channel). Be aware that the\n * input stream is reset for the lexer (but not the parser; a\n * {@link ParserInterpreter} is created to parse the input.). Any user-defined\n * fields you have put into the lexer might get changed when this mechanism asks\n * it to scan the pattern string.\n *\n * Normally a parser does not accept token `<expr>` as a valid\n * `expr` but, from the parser passed in, we create a special version of\n * the underlying grammar representation (an {@link ATN}) that allows imaginary\n * tokens representing rules (`<expr>`) to match entire rules. We call\n * these *bypass alternatives*.\n *\n * Delimiters are `<`} and `>`}, with `\\` as the escape string\n * by default, but you can set them to whatever you want using\n * {@link #setDelimiters}. You must escape both start and stop strings\n * `\\<` and `\\>`.\n */\nclass ParseTreePatternMatcher {\n    /**\n     * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and\n     * {@link Parser} object. The lexer input stream is altered for tokenizing\n     * the tree patterns. The parser is used as a convenient mechanism to get\n     * the grammar name, plus token, rule names.\n     */\n    constructor(lexer, parser) {\n        this.start = \"<\";\n        this.stop = \">\";\n        this.escape = \"\\\\\"; // e.g., \\< and \\> must escape BOTH!\n        /**\n         * Regular expression corresponding to escape, for global replace\n         */\n        this.escapeRE = /\\\\/g;\n        this._lexer = lexer;\n        this._parser = parser;\n    }\n    /**\n     * Set the delimiters used for marking rule and token tags within concrete\n     * syntax used by the tree pattern parser.\n     *\n     * @param start The start delimiter.\n     * @param stop The stop delimiter.\n     * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.\n     *\n     * @throws {@link Error} if `start` is not defined or empty.\n     * @throws {@link Error} if `stop` is not defined or empty.\n     */\n    setDelimiters(start, stop, escapeLeft) {\n        if (!start) {\n            throw new Error(\"start cannot be null or empty\");\n        }\n        if (!stop) {\n            throw new Error(\"stop cannot be null or empty\");\n        }\n        this.start = start;\n        this.stop = stop;\n        this.escape = escapeLeft;\n        this.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"g\");\n    }\n    matches(tree, pattern, patternRuleIndex = 0) {\n        if (typeof pattern === \"string\") {\n            let p = this.compile(pattern, patternRuleIndex);\n            return this.matches(tree, p);\n        }\n        else {\n            let labels = new MultiMap_1.MultiMap();\n            let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);\n            return !mismatchedNode;\n        }\n    }\n    // Implementation of match\n    match(tree, pattern, patternRuleIndex = 0) {\n        if (typeof pattern === \"string\") {\n            let p = this.compile(pattern, patternRuleIndex);\n            return this.match(tree, p);\n        }\n        else {\n            let labels = new MultiMap_1.MultiMap();\n            let mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);\n            return new ParseTreeMatch_1.ParseTreeMatch(tree, pattern, labels, mismatchedNode);\n        }\n    }\n    /**\n     * For repeated use of a tree pattern, compile it to a\n     * {@link ParseTreePattern} using this method.\n     */\n    compile(pattern, patternRuleIndex) {\n        let tokenList = this.tokenize(pattern);\n        let tokenSrc = new ListTokenSource_1.ListTokenSource(tokenList);\n        let tokens = new CommonTokenStream_1.CommonTokenStream(tokenSrc);\n        const parser = this._parser;\n        let parserInterp = new ParserInterpreter_1.ParserInterpreter(parser.grammarFileName, parser.vocabulary, parser.ruleNames, parser.getATNWithBypassAlts(), tokens);\n        let tree;\n        try {\n            parserInterp.errorHandler = new BailErrorStrategy_1.BailErrorStrategy();\n            tree = parserInterp.parse(patternRuleIndex);\n            //\t\t\tSystem.out.println(\"pattern tree = \"+tree.toStringTree(parserInterp));\n        }\n        catch (e) {\n            if (e instanceof ParseCancellationException_1.ParseCancellationException) {\n                throw e.getCause();\n            }\n            else if (e instanceof RecognitionException_1.RecognitionException) {\n                throw e;\n            }\n            else if (e instanceof Error) {\n                throw new ParseTreePatternMatcher.CannotInvokeStartRule(e);\n            }\n            else {\n                throw e;\n            }\n        }\n        // Make sure tree pattern compilation checks for a complete parse\n        if (tokens.LA(1) !== Token_1.Token.EOF) {\n            throw new ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();\n        }\n        return new ParseTreePattern_1.ParseTreePattern(this, pattern, patternRuleIndex, tree);\n    }\n    /**\n     * Used to convert the tree pattern string into a series of tokens. The\n     * input stream is reset.\n     */\n    get lexer() {\n        return this._lexer;\n    }\n    /**\n     * Used to collect to the grammar file name, token names, rule names for\n     * used to parse the pattern into a parse tree.\n     */\n    get parser() {\n        return this._parser;\n    }\n    // ---- SUPPORT CODE ----\n    /**\n     * Recursively walk `tree` against `patternTree`, filling\n     * `match.`{@link ParseTreeMatch#labels labels}.\n     *\n     * @returns the first node encountered in `tree` which does not match\n     * a corresponding node in `patternTree`, or `undefined` if the match\n     * was successful. The specific node returned depends on the matching\n     * algorithm used by the implementation, and may be overridden.\n     */\n    matchImpl(tree, patternTree, labels) {\n        if (!tree) {\n            throw new TypeError(\"tree cannot be null\");\n        }\n        if (!patternTree) {\n            throw new TypeError(\"patternTree cannot be null\");\n        }\n        // x and <ID>, x and y, or x and x; or could be mismatched types\n        if (tree instanceof TerminalNode_1.TerminalNode && patternTree instanceof TerminalNode_1.TerminalNode) {\n            let mismatchedNode;\n            // both are tokens and they have same type\n            if (tree.symbol.type === patternTree.symbol.type) {\n                if (patternTree.symbol instanceof TokenTagToken_1.TokenTagToken) { // x and <ID>\n                    let tokenTagToken = patternTree.symbol;\n                    // track label->list-of-nodes for both token name and label (if any)\n                    labels.map(tokenTagToken.tokenName, tree);\n                    const l = tokenTagToken.label;\n                    if (l) {\n                        labels.map(l, tree);\n                    }\n                }\n                else if (tree.text === patternTree.text) {\n                    // x and x\n                }\n                else {\n                    // x and y\n                    if (!mismatchedNode) {\n                        mismatchedNode = tree;\n                    }\n                }\n            }\n            else {\n                if (!mismatchedNode) {\n                    mismatchedNode = tree;\n                }\n            }\n            return mismatchedNode;\n        }\n        if (tree instanceof ParserRuleContext_1.ParserRuleContext\n            && patternTree instanceof ParserRuleContext_1.ParserRuleContext) {\n            let mismatchedNode;\n            // (expr ...) and <expr>\n            let ruleTagToken = this.getRuleTagToken(patternTree);\n            if (ruleTagToken) {\n                let m;\n                if (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {\n                    // track label->list-of-nodes for both rule name and label (if any)\n                    labels.map(ruleTagToken.ruleName, tree);\n                    const l = ruleTagToken.label;\n                    if (l) {\n                        labels.map(l, tree);\n                    }\n                }\n                else {\n                    if (!mismatchedNode) {\n                        mismatchedNode = tree;\n                    }\n                }\n                return mismatchedNode;\n            }\n            // (expr ...) and (expr ...)\n            if (tree.childCount !== patternTree.childCount) {\n                if (!mismatchedNode) {\n                    mismatchedNode = tree;\n                }\n                return mismatchedNode;\n            }\n            let n = tree.childCount;\n            for (let i = 0; i < n; i++) {\n                let childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);\n                if (childMatch) {\n                    return childMatch;\n                }\n            }\n            return mismatchedNode;\n        }\n        // if nodes aren't both tokens or both rule nodes, can't match\n        return tree;\n    }\n    /** Is `t` `(expr <expr>)` subtree? */\n    getRuleTagToken(t) {\n        if (t instanceof RuleNode_1.RuleNode) {\n            if (t.childCount === 1 && t.getChild(0) instanceof TerminalNode_1.TerminalNode) {\n                let c = t.getChild(0);\n                if (c.symbol instanceof RuleTagToken_1.RuleTagToken) {\n                    //\t\t\t\t\tSystem.out.println(\"rule tag subtree \"+t.toStringTree(parser));\n                    return c.symbol;\n                }\n            }\n        }\n        return undefined;\n    }\n    tokenize(pattern) {\n        // split pattern into chunks: sea (raw input) and islands (<ID>, <expr>)\n        let chunks = this.split(pattern);\n        // create token stream from text and tags\n        let tokens = [];\n        for (let chunk of chunks) {\n            if (chunk instanceof TagChunk_1.TagChunk) {\n                let tagChunk = chunk;\n                const firstChar = tagChunk.tag.substr(0, 1);\n                // add special rule token or conjure up new token from name\n                if (firstChar === firstChar.toUpperCase()) {\n                    let ttype = this._parser.getTokenType(tagChunk.tag);\n                    if (ttype === Token_1.Token.INVALID_TYPE) {\n                        throw new Error(\"Unknown token \" + tagChunk.tag + \" in pattern: \" + pattern);\n                    }\n                    let t = new TokenTagToken_1.TokenTagToken(tagChunk.tag, ttype, tagChunk.label);\n                    tokens.push(t);\n                }\n                else if (firstChar === firstChar.toLowerCase()) {\n                    let ruleIndex = this._parser.getRuleIndex(tagChunk.tag);\n                    if (ruleIndex === -1) {\n                        throw new Error(\"Unknown rule \" + tagChunk.tag + \" in pattern: \" + pattern);\n                    }\n                    let ruleImaginaryTokenType = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];\n                    tokens.push(new RuleTagToken_1.RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));\n                }\n                else {\n                    throw new Error(\"invalid tag: \" + tagChunk.tag + \" in pattern: \" + pattern);\n                }\n            }\n            else {\n                let textChunk = chunk;\n                this._lexer.inputStream = CharStreams_1.CharStreams.fromString(textChunk.text);\n                let t = this._lexer.nextToken();\n                while (t.type !== Token_1.Token.EOF) {\n                    tokens.push(t);\n                    t = this._lexer.nextToken();\n                }\n            }\n        }\n        //\t\tSystem.out.println(\"tokens=\"+tokens);\n        return tokens;\n    }\n    /** Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}. */\n    split(pattern) {\n        let p = 0;\n        let n = pattern.length;\n        let chunks = [];\n        let buf;\n        // find all start and stop indexes first, then collect\n        let starts = [];\n        let stops = [];\n        while (p < n) {\n            if (p === pattern.indexOf(this.escape + this.start, p)) {\n                p += this.escape.length + this.start.length;\n            }\n            else if (p === pattern.indexOf(this.escape + this.stop, p)) {\n                p += this.escape.length + this.stop.length;\n            }\n            else if (p === pattern.indexOf(this.start, p)) {\n                starts.push(p);\n                p += this.start.length;\n            }\n            else if (p === pattern.indexOf(this.stop, p)) {\n                stops.push(p);\n                p += this.stop.length;\n            }\n            else {\n                p++;\n            }\n        }\n        //\t\tSystem.out.println(\"\");\n        //\t\tSystem.out.println(starts);\n        //\t\tSystem.out.println(stops);\n        if (starts.length > stops.length) {\n            throw new Error(\"unterminated tag in pattern: \" + pattern);\n        }\n        if (starts.length < stops.length) {\n            throw new Error(\"missing start tag in pattern: \" + pattern);\n        }\n        let ntags = starts.length;\n        for (let i = 0; i < ntags; i++) {\n            if (starts[i] >= stops[i]) {\n                throw new Error(\"tag delimiters out of order in pattern: \" + pattern);\n            }\n        }\n        // collect into chunks now\n        if (ntags === 0) {\n            let text = pattern.substring(0, n);\n            chunks.push(new TextChunk_1.TextChunk(text));\n        }\n        if (ntags > 0 && starts[0] > 0) { // copy text up to first tag into chunks\n            let text = pattern.substring(0, starts[0]);\n            chunks.push(new TextChunk_1.TextChunk(text));\n        }\n        for (let i = 0; i < ntags; i++) {\n            // copy inside of <tag>\n            let tag = pattern.substring(starts[i] + this.start.length, stops[i]);\n            let ruleOrToken = tag;\n            let label;\n            let colon = tag.indexOf(\":\");\n            if (colon >= 0) {\n                label = tag.substring(0, colon);\n                ruleOrToken = tag.substring(colon + 1, tag.length);\n            }\n            chunks.push(new TagChunk_1.TagChunk(ruleOrToken, label));\n            if (i + 1 < ntags) {\n                // copy from end of <tag> to start of next\n                let text = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);\n                chunks.push(new TextChunk_1.TextChunk(text));\n            }\n        }\n        if (ntags > 0) {\n            let afterLastTag = stops[ntags - 1] + this.stop.length;\n            if (afterLastTag < n) { // copy text from end of last tag to end\n                let text = pattern.substring(afterLastTag, n);\n                chunks.push(new TextChunk_1.TextChunk(text));\n            }\n        }\n        // strip out the escape sequences from text chunks but not tags\n        for (let i = 0; i < chunks.length; i++) {\n            let c = chunks[i];\n            if (c instanceof TextChunk_1.TextChunk) {\n                let unescaped = c.text.replace(this.escapeRE, \"\");\n                if (unescaped.length < c.text.length) {\n                    chunks[i] = new TextChunk_1.TextChunk(unescaped);\n                }\n            }\n        }\n        return chunks;\n    }\n}\n__decorate([\n    Decorators_1.NotNull,\n    __param(1, Decorators_1.NotNull)\n], ParseTreePatternMatcher.prototype, \"match\", null);\n__decorate([\n    Decorators_1.NotNull\n], ParseTreePatternMatcher.prototype, \"lexer\", null);\n__decorate([\n    Decorators_1.NotNull\n], ParseTreePatternMatcher.prototype, \"parser\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n], ParseTreePatternMatcher.prototype, \"matchImpl\", null);\nexports.ParseTreePatternMatcher = ParseTreePatternMatcher;\n(function (ParseTreePatternMatcher) {\n    class CannotInvokeStartRule extends Error {\n        constructor(error) {\n            super(`CannotInvokeStartRule: ${error}`);\n            this.error = error;\n        }\n    }\n    ParseTreePatternMatcher.CannotInvokeStartRule = CannotInvokeStartRule;\n    // Fixes https://github.com/antlr/antlr4/issues/413\n    // \"Tree pattern compilation doesn't check for a complete parse\"\n    class StartRuleDoesNotConsumeFullPattern extends Error {\n        constructor() {\n            super(\"StartRuleDoesNotConsumeFullPattern\");\n        }\n    }\n    ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern = StartRuleDoesNotConsumeFullPattern;\n})(ParseTreePatternMatcher = exports.ParseTreePatternMatcher || (exports.ParseTreePatternMatcher = {}));\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// CONVERSTION complete, Burt Harris 10/14/2016\n\nimport { BailErrorStrategy } from \"../../BailErrorStrategy\";\nimport { CharStreams } from \"../../CharStreams\";\nimport { Chunk } from \"./Chunk\";\nimport { CommonTokenStream } from \"../../CommonTokenStream\";\nimport { Lexer } from \"../../Lexer\";\nimport { ListTokenSource } from \"../../ListTokenSource\";\nimport { MultiMap } from \"../../misc/MultiMap\";\nimport { NotNull } from \"../../Decorators\";\nimport { ParseCancellationException } from \"../../misc/ParseCancellationException\";\nimport { Parser } from \"../../Parser\";\nimport { ParserInterpreter } from \"../../ParserInterpreter\";\nimport { ParserRuleContext } from \"../../ParserRuleContext\";\nimport { ParseTree } from \"../ParseTree\";\nimport { ParseTreeMatch } from \"./ParseTreeMatch\";\nimport { ParseTreePattern } from \"./ParseTreePattern\";\nimport { RecognitionException } from \"../../RecognitionException\";\nimport { RuleNode } from \"../RuleNode\";\nimport { RuleTagToken } from \"./RuleTagToken\";\nimport { TagChunk } from \"./TagChunk\";\nimport { TerminalNode } from \"../TerminalNode\";\nimport { TextChunk } from \"./TextChunk\";\nimport { Token } from \"../../Token\";\nimport { TokenTagToken } from \"./TokenTagToken\";\n\n/**\n * A tree pattern matching mechanism for ANTLR {@link ParseTree}s.\n *\n * Patterns are strings of source input text with special tags representing\n * token or rule references such as:\n *\n * ```\n * <ID> = <expr>;\n * ```\n *\n * Given a pattern start rule such as `statement`, this object constructs\n * a {@link ParseTree} with placeholders for the `ID` and `expr`\n * subtree. Then the {@link #match} routines can compare an actual\n * {@link ParseTree} from a parse with this pattern. Tag `<ID>` matches\n * any `ID` token and tag `<expr>` references the result of the\n * `expr` rule (generally an instance of `ExprContext`.\n *\n * Pattern `x = 0;` is a similar pattern that matches the same pattern\n * except that it requires the identifier to be `x` and the expression to\n * be `0`.\n *\n * The {@link #matches} routines return `true` or `false` based\n * upon a match for the tree rooted at the parameter sent in. The\n * {@link #match} routines return a {@link ParseTreeMatch} object that\n * contains the parse tree, the parse tree pattern, and a map from tag name to\n * matched nodes (more below). A subtree that fails to match, returns with\n * {@link ParseTreeMatch#mismatchedNode} set to the first tree node that did not\n * match.\n *\n * For efficiency, you can compile a tree pattern in string form to a\n * {@link ParseTreePattern} object.\n *\n * See `TestParseTreeMatcher` for lots of examples.\n * {@link ParseTreePattern} has two static helper methods:\n * {@link ParseTreePattern#findAll} and {@link ParseTreePattern#match} that\n * are easy to use but not super efficient because they create new\n * {@link ParseTreePatternMatcher} objects each time and have to compile the\n * pattern in string form before using it.\n *\n * The lexer and parser that you pass into the {@link ParseTreePatternMatcher}\n * constructor are used to parse the pattern in string form. The lexer converts\n * the `<ID> = <expr>;` into a sequence of four tokens (assuming lexer\n * throws out whitespace or puts it on a hidden channel). Be aware that the\n * input stream is reset for the lexer (but not the parser; a\n * {@link ParserInterpreter} is created to parse the input.). Any user-defined\n * fields you have put into the lexer might get changed when this mechanism asks\n * it to scan the pattern string.\n *\n * Normally a parser does not accept token `<expr>` as a valid\n * `expr` but, from the parser passed in, we create a special version of\n * the underlying grammar representation (an {@link ATN}) that allows imaginary\n * tokens representing rules (`<expr>`) to match entire rules. We call\n * these *bypass alternatives*.\n *\n * Delimiters are `<`} and `>`}, with `\\` as the escape string\n * by default, but you can set them to whatever you want using\n * {@link #setDelimiters}. You must escape both start and stop strings\n * `\\<` and `\\>`.\n */\nexport class ParseTreePatternMatcher {\n\t/**\n\t * This is the backing field for `lexer`.\n\t */\n\tprivate _lexer: Lexer;\n\n\t/**\n\t * This is the backing field for `parser`.\n\t */\n\tprivate _parser: Parser;\n\n\tprotected start = \"<\";\n\tprotected stop = \">\";\n\tprotected escape = \"\\\\\"; // e.g., \\< and \\> must escape BOTH!\n\n\t/**\n\t * Regular expression corresponding to escape, for global replace\n\t */\n\tprotected escapeRE = /\\\\/g;\n\n\t/**\n\t * Constructs a {@link ParseTreePatternMatcher} or from a {@link Lexer} and\n\t * {@link Parser} object. The lexer input stream is altered for tokenizing\n\t * the tree patterns. The parser is used as a convenient mechanism to get\n\t * the grammar name, plus token, rule names.\n\t */\n\tconstructor(lexer: Lexer, parser: Parser) {\n\t\tthis._lexer = lexer;\n\t\tthis._parser = parser;\n\t}\n\n\t/**\n\t * Set the delimiters used for marking rule and token tags within concrete\n\t * syntax used by the tree pattern parser.\n\t *\n\t * @param start The start delimiter.\n\t * @param stop The stop delimiter.\n\t * @param escapeLeft The escape sequence to use for escaping a start or stop delimiter.\n\t *\n\t * @throws {@link Error} if `start` is not defined or empty.\n\t * @throws {@link Error} if `stop` is not defined or empty.\n\t */\n\tpublic setDelimiters(start: string, stop: string, escapeLeft: string): void {\n\t\tif (!start) {\n\t\t\tthrow new Error(\"start cannot be null or empty\");\n\t\t}\n\n\t\tif (!stop) {\n\t\t\tthrow new Error(\"stop cannot be null or empty\");\n\t\t}\n\n\t\tthis.start = start;\n\t\tthis.stop = stop;\n\t\tthis.escape = escapeLeft;\n\t\tthis.escapeRE = new RegExp(escapeLeft.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\"), \"g\");\n\t}\n\n\t/** Does `pattern` matched as rule `patternRuleIndex` match `tree`? */\n\tpublic matches(tree: ParseTree, pattern: string, patternRuleIndex: number): boolean;\n\n\t/** Does `pattern` matched as rule patternRuleIndex match tree? Pass in a\n\t *  compiled pattern instead of a string representation of a tree pattern.\n\t */\n\tpublic matches(tree: ParseTree, pattern: ParseTreePattern): boolean;\n\n\tpublic matches(tree: ParseTree, pattern: string | ParseTreePattern, patternRuleIndex: number = 0): boolean {\n\t\tif (typeof pattern === \"string\") {\n\t\t\tlet p: ParseTreePattern = this.compile(pattern, patternRuleIndex);\n\t\t\treturn this.matches(tree, p);\n\t\t} else {\n\t\t\tlet labels = new MultiMap<string, ParseTree>();\n\t\t\tlet mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);\n\t\t\treturn !mismatchedNode;\n\t\t}\n\t}\n\n\t/**\n\t * Compare `pattern` matched as rule `patternRuleIndex` against\n\t * `tree` and return a {@link ParseTreeMatch} object that contains the\n\t * matched elements, or the node at which the match failed.\n\t */\n\tpublic match(tree: ParseTree, pattern: string, patternRuleIndex: number): ParseTreeMatch;\n\n\t/**\n\t * Compare `pattern` matched against `tree` and return a\n\t * {@link ParseTreeMatch} object that contains the matched elements, or the\n\t * node at which the match failed. Pass in a compiled pattern instead of a\n\t * string representation of a tree pattern.\n\t */\n\tpublic match(tree: ParseTree, pattern: ParseTreePattern): ParseTreeMatch;\n\n\t// Implementation of match\n\t@NotNull\n\tpublic match(tree: ParseTree, @NotNull pattern: string | ParseTreePattern, patternRuleIndex: number = 0): ParseTreeMatch {\n\t\tif (typeof pattern === \"string\") {\n\t\t\tlet p: ParseTreePattern = this.compile(pattern, patternRuleIndex);\n\t\t\treturn this.match(tree, p);\n\t\t} else {\n\t\t\tlet labels = new MultiMap<string, ParseTree>();\n\t\t\tlet mismatchedNode = this.matchImpl(tree, pattern.patternTree, labels);\n\t\t\treturn new ParseTreeMatch(tree, pattern, labels, mismatchedNode);\n\t\t}\n\t}\n\n\t/**\n\t * For repeated use of a tree pattern, compile it to a\n\t * {@link ParseTreePattern} using this method.\n\t */\n\tpublic compile(pattern: string, patternRuleIndex: number): ParseTreePattern {\n\t\tlet tokenList = this.tokenize(pattern);\n\t\tlet tokenSrc = new ListTokenSource(tokenList);\n\t\tlet tokens = new CommonTokenStream(tokenSrc);\n\t\tconst parser = this._parser;\n\n\t\tlet parserInterp = new ParserInterpreter(\n\t\t\tparser.grammarFileName,\n\t\t\tparser.vocabulary,\n\t\t\tparser.ruleNames,\n\t\t\tparser.getATNWithBypassAlts(),\n\t\t\ttokens);\n\n\t\tlet tree: ParseTree;\n\t\ttry {\n\t\t\tparserInterp.errorHandler = new BailErrorStrategy();\n\t\t\ttree = parserInterp.parse(patternRuleIndex);\n//\t\t\tSystem.out.println(\"pattern tree = \"+tree.toStringTree(parserInterp));\n\t\t} catch (e) {\n\t\t\tif (e instanceof ParseCancellationException) {\n\t\t\t\tthrow e.getCause();\n\t\t\t} else if (e instanceof RecognitionException) {\n\t\t\t\tthrow e;\n\t\t\t} else if (e instanceof Error) {\n\t\t\t\tthrow new ParseTreePatternMatcher.CannotInvokeStartRule(e);\n\t\t\t} else {\n\t\t\t\tthrow e;\n\t\t\t}\n\t\t}\n\n\t\t// Make sure tree pattern compilation checks for a complete parse\n\t\tif (tokens.LA(1) !== Token.EOF) {\n\t\t\tthrow new ParseTreePatternMatcher.StartRuleDoesNotConsumeFullPattern();\n\t\t}\n\n\t\treturn new ParseTreePattern(this, pattern, patternRuleIndex, tree);\n\t}\n\n\t/**\n\t * Used to convert the tree pattern string into a series of tokens. The\n\t * input stream is reset.\n\t */\n\t@NotNull\n\tget lexer(): Lexer {\n\t\treturn this._lexer;\n\t}\n\n\t/**\n\t * Used to collect to the grammar file name, token names, rule names for\n\t * used to parse the pattern into a parse tree.\n\t */\n\t@NotNull\n\tget parser(): Parser {\n\t\treturn this._parser;\n\t}\n\n\t// ---- SUPPORT CODE ----\n\n\t/**\n\t * Recursively walk `tree` against `patternTree`, filling\n\t * `match.`{@link ParseTreeMatch#labels labels}.\n\t *\n\t * @returns the first node encountered in `tree` which does not match\n\t * a corresponding node in `patternTree`, or `undefined` if the match\n\t * was successful. The specific node returned depends on the matching\n\t * algorithm used by the implementation, and may be overridden.\n\t */\n\tprotected matchImpl(\n\t\t@NotNull tree: ParseTree,\n\t\t@NotNull patternTree: ParseTree,\n\t\t@NotNull labels: MultiMap<string, ParseTree>): ParseTree | undefined {\n\t\tif (!tree) {\n\t\t\tthrow new TypeError(\"tree cannot be null\");\n\t\t}\n\n\t\tif (!patternTree) {\n\t\t\tthrow new TypeError(\"patternTree cannot be null\");\n\t\t}\n\n\t\t// x and <ID>, x and y, or x and x; or could be mismatched types\n\t\tif (tree instanceof TerminalNode && patternTree instanceof TerminalNode) {\n\t\t\tlet mismatchedNode: ParseTree | undefined;\n\t\t\t// both are tokens and they have same type\n\t\t\tif (tree.symbol.type === patternTree.symbol.type) {\n\t\t\t\tif (patternTree.symbol instanceof TokenTagToken) { // x and <ID>\n\t\t\t\t\tlet tokenTagToken = patternTree.symbol;\n\t\t\t\t\t// track label->list-of-nodes for both token name and label (if any)\n\t\t\t\t\tlabels.map(tokenTagToken.tokenName, tree);\n\t\t\t\t\tconst l = tokenTagToken.label;\n\t\t\t\t\tif (l) {\n\t\t\t\t\t\tlabels.map(l, tree);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (tree.text === patternTree.text) {\n\t\t\t\t\t// x and x\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// x and y\n\t\t\t\t\tif (!mismatchedNode) {\n\t\t\t\t\t\tmismatchedNode = tree;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (!mismatchedNode) {\n\t\t\t\t\tmismatchedNode = tree;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mismatchedNode;\n\t\t}\n\n\t\tif (tree instanceof ParserRuleContext\n\t\t\t&& patternTree instanceof ParserRuleContext) {\n\t\t\tlet mismatchedNode: ParseTree | undefined;\n\t\t\t// (expr ...) and <expr>\n\t\t\tlet ruleTagToken = this.getRuleTagToken(patternTree);\n\t\t\tif (ruleTagToken) {\n\t\t\t\tlet m: ParseTreeMatch;\n\t\t\t\tif (tree.ruleContext.ruleIndex === patternTree.ruleContext.ruleIndex) {\n\t\t\t\t\t// track label->list-of-nodes for both rule name and label (if any)\n\t\t\t\t\tlabels.map(ruleTagToken.ruleName, tree);\n\t\t\t\t\tconst l = ruleTagToken.label;\n\t\t\t\t\tif (l) {\n\t\t\t\t\t\tlabels.map(l, tree);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!mismatchedNode) {\n\t\t\t\t\t\tmismatchedNode = tree;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn mismatchedNode;\n\t\t\t}\n\n\t\t\t// (expr ...) and (expr ...)\n\t\t\tif (tree.childCount !== patternTree.childCount) {\n\t\t\t\tif (!mismatchedNode) {\n\t\t\t\t\tmismatchedNode = tree;\n\t\t\t\t}\n\n\t\t\t\treturn mismatchedNode;\n\t\t\t}\n\n\t\t\tlet n: number = tree.childCount;\n\t\t\tfor (let i = 0; i < n; i++) {\n\t\t\t\tlet childMatch = this.matchImpl(tree.getChild(i), patternTree.getChild(i), labels);\n\t\t\t\tif (childMatch) {\n\t\t\t\t\treturn childMatch;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn mismatchedNode;\n\t\t}\n\n\t\t// if nodes aren't both tokens or both rule nodes, can't match\n\t\treturn tree;\n\t}\n\n\t/** Is `t` `(expr <expr>)` subtree? */\n\tprotected getRuleTagToken(t: ParseTree): RuleTagToken | undefined {\n\t\tif (t instanceof RuleNode) {\n\t\t\tif (t.childCount === 1 && t.getChild(0) instanceof TerminalNode) {\n\t\t\t\tlet c = t.getChild(0) as TerminalNode;\n\t\t\t\tif (c.symbol instanceof RuleTagToken) {\n//\t\t\t\t\tSystem.out.println(\"rule tag subtree \"+t.toStringTree(parser));\n\t\t\t\t\treturn c.symbol;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tpublic tokenize(pattern: string): Token[] {\n\t\t// split pattern into chunks: sea (raw input) and islands (<ID>, <expr>)\n\t\tlet chunks = this.split(pattern);\n\n\t\t// create token stream from text and tags\n\t\tlet tokens: Token[] = [];\n\n\t\tfor (let chunk of chunks) {\n\t\t\tif (chunk instanceof TagChunk) {\n\t\t\t\tlet tagChunk = chunk;\n\t\t\t\tconst firstChar = tagChunk.tag.substr(0, 1);\n\t\t\t\t// add special rule token or conjure up new token from name\n\t\t\t\tif (firstChar === firstChar.toUpperCase()) {\n\t\t\t\t\tlet ttype: number = this._parser.getTokenType(tagChunk.tag);\n\t\t\t\t\tif (ttype === Token.INVALID_TYPE) {\n\t\t\t\t\t\tthrow new Error(\"Unknown token \" + tagChunk.tag + \" in pattern: \" + pattern);\n\t\t\t\t\t}\n\t\t\t\t\tlet t: TokenTagToken = new TokenTagToken(tagChunk.tag, ttype, tagChunk.label);\n\t\t\t\t\ttokens.push(t);\n\t\t\t\t}\n\t\t\t\telse if (firstChar === firstChar.toLowerCase()) {\n\t\t\t\t\tlet ruleIndex: number = this._parser.getRuleIndex(tagChunk.tag);\n\t\t\t\t\tif (ruleIndex === -1) {\n\t\t\t\t\t\tthrow new Error(\"Unknown rule \" + tagChunk.tag + \" in pattern: \" + pattern);\n\t\t\t\t\t}\n\t\t\t\t\tlet ruleImaginaryTokenType: number = this._parser.getATNWithBypassAlts().ruleToTokenType[ruleIndex];\n\t\t\t\t\ttokens.push(new RuleTagToken(tagChunk.tag, ruleImaginaryTokenType, tagChunk.label));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(\"invalid tag: \" + tagChunk.tag + \" in pattern: \" + pattern);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet textChunk = chunk as TextChunk;\n\t\t\t\tthis._lexer.inputStream = CharStreams.fromString(textChunk.text);\n\t\t\t\tlet t: Token = this._lexer.nextToken();\n\t\t\t\twhile (t.type !== Token.EOF) {\n\t\t\t\t\ttokens.push(t);\n\t\t\t\t\tt = this._lexer.nextToken();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n//\t\tSystem.out.println(\"tokens=\"+tokens);\n\t\treturn tokens;\n\t}\n\n\t/** Split `<ID> = <e:expr> ;` into 4 chunks for tokenizing by {@link #tokenize}. */\n\tpublic split(pattern: string): Chunk[] {\n\t\tlet p: number = 0;\n\t\tlet n: number = pattern.length;\n\t\tlet chunks: Chunk[] = [];\n\t\tlet buf: \"\";\n\t\t// find all start and stop indexes first, then collect\n\t\tlet starts: number[] = [];\n\t\tlet stops: number[] = [];\n\t\twhile (p < n) {\n\t\t\tif (p === pattern.indexOf(this.escape + this.start, p)) {\n\t\t\t\tp += this.escape.length + this.start.length;\n\t\t\t}\n\t\t\telse if (p === pattern.indexOf(this.escape + this.stop, p)) {\n\t\t\t\tp += this.escape.length + this.stop.length;\n\t\t\t}\n\t\t\telse if (p === pattern.indexOf(this.start, p)) {\n\t\t\t\tstarts.push(p);\n\t\t\t\tp += this.start.length;\n\t\t\t}\n\t\t\telse if (p === pattern.indexOf(this.stop, p)) {\n\t\t\t\tstops.push(p);\n\t\t\t\tp += this.stop.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tp++;\n\t\t\t}\n\t\t}\n\n//\t\tSystem.out.println(\"\");\n//\t\tSystem.out.println(starts);\n//\t\tSystem.out.println(stops);\n\t\tif (starts.length > stops.length) {\n\t\t\tthrow new Error(\"unterminated tag in pattern: \" + pattern);\n\t\t}\n\n\t\tif (starts.length < stops.length) {\n\t\t\tthrow new Error(\"missing start tag in pattern: \" + pattern);\n\t\t}\n\n\t\tlet ntags: number = starts.length;\n\t\tfor (let i = 0; i < ntags; i++) {\n\t\t\tif (starts[i] >= stops[i]) {\n\t\t\t\tthrow new Error(\"tag delimiters out of order in pattern: \" + pattern);\n\t\t\t}\n\t\t}\n\n\t\t// collect into chunks now\n\t\tif (ntags === 0) {\n\t\t\tlet text: string = pattern.substring(0, n);\n\t\t\tchunks.push(new TextChunk(text));\n\t\t}\n\n\t\tif (ntags > 0 && starts[0] > 0) { // copy text up to first tag into chunks\n\t\t\tlet text: string = pattern.substring(0, starts[0]);\n\t\t\tchunks.push(new TextChunk(text));\n\t\t}\n\t\tfor (let i = 0; i < ntags; i++) {\n\t\t\t// copy inside of <tag>\n\t\t\tlet tag: string = pattern.substring(starts[i] + this.start.length, stops[i]);\n\t\t\tlet ruleOrToken: string = tag;\n\t\t\tlet label: string | undefined;\n\t\t\tlet colon: number = tag.indexOf(\":\");\n\t\t\tif (colon >= 0) {\n\t\t\t\tlabel = tag.substring(0, colon);\n\t\t\t\truleOrToken = tag.substring(colon + 1, tag.length);\n\t\t\t}\n\t\t\tchunks.push(new TagChunk(ruleOrToken, label));\n\t\t\tif (i + 1 < ntags) {\n\t\t\t\t// copy from end of <tag> to start of next\n\t\t\t\tlet text: string = pattern.substring(stops[i] + this.stop.length, starts[i + 1]);\n\t\t\t\tchunks.push(new TextChunk(text));\n\t\t\t}\n\t\t}\n\t\tif (ntags > 0) {\n\t\t\tlet afterLastTag: number = stops[ntags - 1] + this.stop.length;\n\t\t\tif (afterLastTag < n) { // copy text from end of last tag to end\n\t\t\t\tlet text: string = pattern.substring(afterLastTag, n);\n\t\t\t\tchunks.push(new TextChunk(text));\n\t\t\t}\n\t\t}\n\n\t\t// strip out the escape sequences from text chunks but not tags\n\t\tfor (let i = 0; i < chunks.length; i++) {\n\t\t\tlet c: Chunk = chunks[i];\n\t\t\tif (c instanceof TextChunk) {\n\t\t\t\tlet unescaped: string = c.text.replace(this.escapeRE, \"\");\n\t\t\t\tif (unescaped.length < c.text.length) {\n\t\t\t\t\tchunks[i] = new TextChunk(unescaped);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn chunks;\n\t}\n}\n\nexport namespace ParseTreePatternMatcher {\n\texport class CannotInvokeStartRule extends Error {\n\t\tpublic constructor(public error: Error) {\n\t\t\tsuper(`CannotInvokeStartRule: ${error}`);\n\t\t}\n\t}\n\n\t// Fixes https://github.com/antlr/antlr4/issues/413\n\t// \"Tree pattern compilation doesn't check for a complete parse\"\n\texport class StartRuleDoesNotConsumeFullPattern extends Error {\n\t\tconstructor() {\n\t\t\tsuper(\"StartRuleDoesNotConsumeFullPattern\");\n\t\t}\n\t}\n}\n"]}