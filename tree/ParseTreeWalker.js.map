{"version":3,"sources":["tree/ParseTreeWalker.js","../src/tree/ParseTreeWalker.ts"],"names":["Object","defineProperty","exports","value","ErrorNode_1","require","TerminalNode_1","RuleNode_1","ParseTreeWalker","listener","t","nodeStack","indexStack","currentNode","currentIndex","ErrorNode","visitErrorNode","TerminalNode","visitTerminal","enterRule","childCount","push","getChild","RuleNode","exitRule","length","undefined","last","pop","r","ctx","ruleContext","enterEveryRule","exitEveryRule","DEFAULT"],"mappings":"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","file":"ParseTreeWalker.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst ErrorNode_1 = require(\"./ErrorNode\");\nconst TerminalNode_1 = require(\"./TerminalNode\");\nconst RuleNode_1 = require(\"./RuleNode\");\nclass ParseTreeWalker {\n    walk(listener, t) {\n        let nodeStack = [];\n        let indexStack = [];\n        let currentNode = t;\n        let currentIndex = 0;\n        while (currentNode) {\n            // pre-order visit\n            if (currentNode instanceof ErrorNode_1.ErrorNode) {\n                if (listener.visitErrorNode) {\n                    listener.visitErrorNode(currentNode);\n                }\n            }\n            else if (currentNode instanceof TerminalNode_1.TerminalNode) {\n                if (listener.visitTerminal) {\n                    listener.visitTerminal(currentNode);\n                }\n            }\n            else {\n                this.enterRule(listener, currentNode);\n            }\n            // Move down to first child, if exists\n            if (currentNode.childCount > 0) {\n                nodeStack.push(currentNode);\n                indexStack.push(currentIndex);\n                currentIndex = 0;\n                currentNode = currentNode.getChild(0);\n                continue;\n            }\n            // No child nodes, so walk tree\n            do {\n                // post-order visit\n                if (currentNode instanceof RuleNode_1.RuleNode) {\n                    this.exitRule(listener, currentNode);\n                }\n                // No parent, so no siblings\n                if (nodeStack.length === 0) {\n                    currentNode = undefined;\n                    currentIndex = 0;\n                    break;\n                }\n                // Move to next sibling if possible\n                let last = nodeStack[nodeStack.length - 1];\n                currentIndex++;\n                currentNode = currentIndex < last.childCount ? last.getChild(currentIndex) : undefined;\n                if (currentNode) {\n                    break;\n                }\n                // No next sibling, so move up\n                currentNode = nodeStack.pop();\n                currentIndex = indexStack.pop();\n            } while (currentNode);\n        }\n    }\n    /**\n     * The discovery of a rule node, involves sending two events: the generic\n     * {@link ParseTreeListener#enterEveryRule} and a\n     * {@link RuleContext}-specific event. First we trigger the generic and then\n     * the rule specific. We to them in reverse order upon finishing the node.\n     */\n    enterRule(listener, r) {\n        let ctx = r.ruleContext;\n        if (listener.enterEveryRule) {\n            listener.enterEveryRule(ctx);\n        }\n        ctx.enterRule(listener);\n    }\n    exitRule(listener, r) {\n        let ctx = r.ruleContext;\n        ctx.exitRule(listener);\n        if (listener.exitEveryRule) {\n            listener.exitEveryRule(ctx);\n        }\n    }\n}\nexports.ParseTreeWalker = ParseTreeWalker;\n(function (ParseTreeWalker) {\n    ParseTreeWalker.DEFAULT = new ParseTreeWalker();\n})(ParseTreeWalker = exports.ParseTreeWalker || (exports.ParseTreeWalker = {}));\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:47.8252451-07:00\nimport { ParseTree } from \"./ParseTree\";\nimport { ParseTreeListener } from \"./ParseTreeListener\";\nimport { ErrorNode } from \"./ErrorNode\";\nimport { TerminalNode } from \"./TerminalNode\";\nimport { RuleNode } from \"./RuleNode\";\nimport { ParserRuleContext } from \"../ParserRuleContext\";\n\nexport class ParseTreeWalker {\n\tpublic walk<T extends ParseTreeListener>(listener: T, t: ParseTree): void {\n\t\tlet nodeStack: ParseTree[] = [];\n\t\tlet indexStack: number[] = [];\n\n\t\tlet currentNode: ParseTree | undefined = t;\n\t\tlet currentIndex: number = 0;\n\n\t\twhile (currentNode) {\n\t\t\t// pre-order visit\n\t\t\tif (currentNode instanceof ErrorNode) {\n\t\t\t\tif (listener.visitErrorNode) {\n\t\t\t\t\tlistener.visitErrorNode(currentNode);\n\t\t\t\t}\n\t\t\t} else if (currentNode instanceof TerminalNode) {\n\t\t\t\tif (listener.visitTerminal) {\n\t\t\t\t\tlistener.visitTerminal(currentNode);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.enterRule(listener, currentNode as RuleNode);\n\t\t\t}\n\n\t\t\t// Move down to first child, if exists\n\t\t\tif (currentNode.childCount > 0) {\n\t\t\t\tnodeStack.push(currentNode);\n\t\t\t\tindexStack.push(currentIndex);\n\t\t\t\tcurrentIndex = 0;\n\t\t\t\tcurrentNode = currentNode.getChild(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// No child nodes, so walk tree\n\t\t\tdo {\n\t\t\t\t// post-order visit\n\t\t\t\tif (currentNode instanceof RuleNode) {\n\t\t\t\t\tthis.exitRule(listener, currentNode);\n\t\t\t\t}\n\n\t\t\t\t// No parent, so no siblings\n\t\t\t\tif (nodeStack.length === 0) {\n\t\t\t\t\tcurrentNode = undefined;\n\t\t\t\t\tcurrentIndex = 0;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// Move to next sibling if possible\n\t\t\t\tlet last = nodeStack[nodeStack.length - 1];\n\t\t\t\tcurrentIndex++;\n\t\t\t\tcurrentNode = currentIndex < last.childCount ? last.getChild(currentIndex) : undefined;\n\t\t\t\tif (currentNode) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\t// No next sibling, so move up\n\t\t\t\tcurrentNode = nodeStack.pop();\n\t\t\t\tcurrentIndex = indexStack.pop()!;\n\t\t\t} while (currentNode);\n\t\t}\n\t}\n\n\t/**\n\t * The discovery of a rule node, involves sending two events: the generic\n\t * {@link ParseTreeListener#enterEveryRule} and a\n\t * {@link RuleContext}-specific event. First we trigger the generic and then\n\t * the rule specific. We to them in reverse order upon finishing the node.\n\t */\n\tprotected enterRule(listener: ParseTreeListener, r: RuleNode): void {\n\t\tlet ctx = r.ruleContext as ParserRuleContext;\n\t\tif (listener.enterEveryRule) {\n\t\t\tlistener.enterEveryRule(ctx);\n\t\t}\n\n\t\tctx.enterRule(listener);\n\t}\n\n\tprotected exitRule(listener: ParseTreeListener, r: RuleNode): void {\n\t\tlet ctx = r.ruleContext as ParserRuleContext;\n\t\tctx.exitRule(listener);\n\t\tif (listener.exitEveryRule) {\n\t\t\tlistener.exitEveryRule(ctx);\n\t\t}\n\t}\n}\n\nexport namespace ParseTreeWalker {\n\texport const DEFAULT: ParseTreeWalker = new ParseTreeWalker();\n}\n"]}