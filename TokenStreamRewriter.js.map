{"version":3,"sources":["TokenStreamRewriter.js","../src/TokenStreamRewriter.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","Interval_1","require","Decorators_1","Token_1","TokenStreamRewriter","tokens","programs","Map","set","DEFAULT_PROGRAM_NAME","lastRewriteTokenIndexes","instructionIndex","programName","is","get","slice","MIN_TOKEN_INDEX","rollback","tokenOrIndex","text","index","tokenIndex","op","InsertAfterOp","rewrites","getProgram","push","InsertBeforeOp","replace","from","to","size","RangeError","ReplaceOp","undefined","I","name","initializeProgram","intervalOrProgram","interval","Interval","of","start","a","stop","b","getText","buf","indexToOp","reduceToSingleOperationPerIndex","t","type","Token","EOF","String","execute","values","toString","join","rop","inserts","getKindOfOps","iop","lastIndex","prevReplaces","prevRop","disjoint","Math","min","max","Error","prevInserts","prevIop","catOpText","m","x","y","kind","before","ops","PROGRAM_INIT_SIZE","RewriteOperation","opName","constructor","$index","indexOf","substring","Override","prototype"],"mappings":"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","file":"TokenStreamRewriter.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:58.1768850-07:00\nconst Interval_1 = require(\"./misc/Interval\");\nconst Decorators_1 = require(\"./Decorators\");\nconst Token_1 = require(\"./Token\");\n/**\n * Useful for rewriting out a buffered input token stream after doing some\n * augmentation or other manipulations on it.\n *\n * You can insert stuff, replace, and delete chunks. Note that the operations\n * are done lazily--only if you convert the buffer to a {@link String} with\n * {@link TokenStream#getText()}. This is very efficient because you are not\n * moving data around all the time. As the buffer of tokens is converted to\n * strings, the {@link #getText()} method(s) scan the input token stream and\n * check to see if there is an operation at the current index. If so, the\n * operation is done and then normal {@link String} rendering continues on the\n * buffer. This is like having multiple Turing machine instruction streams\n * (programs) operating on a single input tape. :)\n *\n * This rewriter makes no modifications to the token stream. It does not ask the\n * stream to fill itself up nor does it advance the input cursor. The token\n * stream `TokenStream.index` will return the same value before and\n * after any {@link #getText()} call.\n *\n * The rewriter only works on tokens that you have in the buffer and ignores the\n * current input cursor. If you are buffering tokens on-demand, calling\n * {@link #getText()} halfway through the input will only do rewrites for those\n * tokens in the first half of the file.\n *\n * Since the operations are done lazily at {@link #getText}-time, operations do\n * not screw up the token index values. That is, an insert operation at token\n * index `i` does not change the index values for tokens\n * `i`+1..n-1.\n *\n * Because operations never actually alter the buffer, you may always get the\n * original token stream back without undoing anything. Since the instructions\n * are queued up, you can easily simulate transactions and roll back any changes\n * if there is an error just by removing instructions. For example,\n *\n * ```\n * CharStream input = new ANTLRFileStream(\"input\");\n * TLexer lex = new TLexer(input);\n * CommonTokenStream tokens = new CommonTokenStream(lex);\n * T parser = new T(tokens);\n * TokenStreamRewriter rewriter = new TokenStreamRewriter(tokens);\n * parser.startRule();\n * ```\n *\n * Then in the rules, you can execute (assuming rewriter is visible):\n *\n * ```\n * Token t,u;\n * ...\n * rewriter.insertAfter(t, \"text to put after t\");}\n * rewriter.insertAfter(u, \"text after u\");}\n * System.out.println(rewriter.getText());\n * ```\n *\n * You can also have multiple \"instruction streams\" and get multiple rewrites\n * from a single pass over the input. Just name the instruction streams and use\n * that name again when printing the buffer. This could be useful for generating\n * a C file and also its header file--all from the same buffer:\n *\n * ```\n * rewriter.insertAfter(\"pass1\", t, \"text to put after t\");}\n * rewriter.insertAfter(\"pass2\", u, \"text after u\");}\n * System.out.println(rewriter.getText(\"pass1\"));\n * System.out.println(rewriter.getText(\"pass2\"));\n * ```\n *\n * If you don't use named rewrite streams, a \"default\" stream is used as the\n * first example shows.\n */\nclass TokenStreamRewriter {\n    constructor(tokens) {\n        this.tokens = tokens;\n        this.programs = new Map();\n        this.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);\n        this.lastRewriteTokenIndexes = new Map();\n    }\n    getTokenStream() {\n        return this.tokens;\n    }\n    rollback(instructionIndex, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        let is = this.programs.get(programName);\n        if (is != null) {\n            this.programs.set(programName, is.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));\n        }\n    }\n    deleteProgram(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        this.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, programName);\n    }\n    insertAfter(tokenOrIndex, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        let index;\n        if (typeof tokenOrIndex === \"number\") {\n            index = tokenOrIndex;\n        }\n        else {\n            index = tokenOrIndex.tokenIndex;\n        }\n        // to insert after, just insert before next index (even if past end)\n        let op = new InsertAfterOp(this.tokens, index, text);\n        let rewrites = this.getProgram(programName);\n        op.instructionIndex = rewrites.length;\n        rewrites.push(op);\n    }\n    insertBefore(tokenOrIndex, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        let index;\n        if (typeof tokenOrIndex === \"number\") {\n            index = tokenOrIndex;\n        }\n        else {\n            index = tokenOrIndex.tokenIndex;\n        }\n        let op = new InsertBeforeOp(this.tokens, index, text);\n        let rewrites = this.getProgram(programName);\n        op.instructionIndex = rewrites.length;\n        rewrites.push(op);\n    }\n    replaceSingle(index, text) {\n        if (typeof index === \"number\") {\n            this.replace(index, index, text);\n        }\n        else {\n            this.replace(index, index, text);\n        }\n    }\n    replace(from, to, text, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        if (typeof from !== \"number\") {\n            from = from.tokenIndex;\n        }\n        if (typeof to !== \"number\") {\n            to = to.tokenIndex;\n        }\n        if (from > to || from < 0 || to < 0 || to >= this.tokens.size) {\n            throw new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);\n        }\n        let op = new ReplaceOp(this.tokens, from, to, text);\n        let rewrites = this.getProgram(programName);\n        op.instructionIndex = rewrites.length;\n        rewrites.push(op);\n    }\n    delete(from, to, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        if (to === undefined) {\n            to = from;\n        }\n        if (typeof from === \"number\") {\n            this.replace(from, to, \"\", programName);\n        }\n        else {\n            this.replace(from, to, \"\", programName);\n        }\n    }\n    getLastRewriteTokenIndex(programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        let I = this.lastRewriteTokenIndexes.get(programName);\n        if (I == null) {\n            return -1;\n        }\n        return I;\n    }\n    setLastRewriteTokenIndex(programName, i) {\n        this.lastRewriteTokenIndexes.set(programName, i);\n    }\n    getProgram(name) {\n        let is = this.programs.get(name);\n        if (is == null) {\n            is = this.initializeProgram(name);\n        }\n        return is;\n    }\n    initializeProgram(name) {\n        let is = [];\n        this.programs.set(name, is);\n        return is;\n    }\n    getText(intervalOrProgram, programName = TokenStreamRewriter.DEFAULT_PROGRAM_NAME) {\n        let interval;\n        if (intervalOrProgram instanceof Interval_1.Interval) {\n            interval = intervalOrProgram;\n        }\n        else {\n            interval = Interval_1.Interval.of(0, this.tokens.size - 1);\n        }\n        if (typeof intervalOrProgram === \"string\") {\n            programName = intervalOrProgram;\n        }\n        let rewrites = this.programs.get(programName);\n        let start = interval.a;\n        let stop = interval.b;\n        // ensure start/end are in range\n        if (stop > this.tokens.size - 1) {\n            stop = this.tokens.size - 1;\n        }\n        if (start < 0) {\n            start = 0;\n        }\n        if (rewrites == null || rewrites.length === 0) {\n            return this.tokens.getText(interval); // no instructions to execute\n        }\n        let buf = [];\n        // First, optimize instruction stream\n        let indexToOp = this.reduceToSingleOperationPerIndex(rewrites);\n        // Walk buffer, executing instructions and emitting tokens\n        let i = start;\n        while (i <= stop && i < this.tokens.size) {\n            let op = indexToOp.get(i);\n            indexToOp.delete(i); // remove so any left have index size-1\n            let t = this.tokens.get(i);\n            if (op == null) {\n                // no operation at that index, just dump token\n                if (t.type !== Token_1.Token.EOF) {\n                    buf.push(String(t.text));\n                }\n                i++; // move to next token\n            }\n            else {\n                i = op.execute(buf); // execute operation and skip\n            }\n        }\n        // include stuff after end if it's last index in buffer\n        // So, if they did an insertAfter(lastValidIndex, \"foo\"), include\n        // foo if end==lastValidIndex.\n        if (stop === this.tokens.size - 1) {\n            // Scan any remaining operations after last token\n            // should be included (they will be inserts).\n            for (let op of indexToOp.values()) {\n                if (op.index >= this.tokens.size - 1) {\n                    buf.push(op.text.toString());\n                }\n            }\n        }\n        return buf.join(\"\");\n    }\n    /** We need to combine operations and report invalid operations (like\n     *  overlapping replaces that are not completed nested). Inserts to\n     *  same index need to be combined etc...  Here are the cases:\n     *\n     *  I.i.u I.j.v\t\t\t\t\t\t\t\tleave alone, nonoverlapping\n     *  I.i.u I.i.v\t\t\t\t\t\t\t\tcombine: Iivu\n     *\n     *  R.i-j.u R.x-y.v\t| i-j in x-y\t\t\tdelete first R\n     *  R.i-j.u R.i-j.v\t\t\t\t\t\t\tdelete first R\n     *  R.i-j.u R.x-y.v\t| x-y in i-j\t\t\tERROR\n     *  R.i-j.u R.x-y.v\t| boundaries overlap\tERROR\n     *\n     *  Delete special case of replace (text==undefined):\n     *  D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right)\n     *\n     *  I.i.u R.x-y.v | i in (x+1)-y\t\t\tdelete I (since insert before\n     * \t\t\t\t\t\t\t\t\t\t\twe're not deleting i)\n     *  I.i.u R.x-y.v | i not in (x+1)-y\t\tleave alone, nonoverlapping\n     *  R.x-y.v I.i.u | i in x-y\t\t\t\tERROR\n     *  R.x-y.v I.x.u \t\t\t\t\t\t\tR.x-y.uv (combine, delete I)\n     *  R.x-y.v I.i.u | i not in x-y\t\t\tleave alone, nonoverlapping\n     *\n     *  I.i.u = insert u before op @ index i\n     *  R.x-y.u = replace x-y indexed tokens with u\n     *\n     *  First we need to examine replaces. For any replace op:\n     *\n     * \t\t1. wipe out any insertions before op within that range.\n     * \t\t2. Drop any replace op before that is contained completely within\n     * \t that range.\n     * \t\t3. Throw exception upon boundary overlap with any previous replace.\n     *\n     *  Then we can deal with inserts:\n     *\n     * \t\t1. for any inserts to same index, combine even if not adjacent.\n     * \t\t2. for any prior replace with same left boundary, combine this\n     * \t insert with replace and delete this replace.\n     * \t\t3. throw exception if index in same range as previous replace\n     *\n     *  Don't actually delete; make op undefined in list. Easier to walk list.\n     *  Later we can throw as we add to index &rarr; op map.\n     *\n     *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the\n     *  inserted stuff would be before the replace range. But, if you\n     *  add tokens in front of a method body '{' and then delete the method\n     *  body, I think the stuff before the '{' you added should disappear too.\n     *\n     *  Return a map from token index to operation.\n     */\n    reduceToSingleOperationPerIndex(rewrites) {\n        // console.log(`rewrites=[${Utils.join(rewrites, \", \")}]`);\n        // WALK REPLACES\n        for (let i = 0; i < rewrites.length; i++) {\n            let op = rewrites[i];\n            if (op == null) {\n                continue;\n            }\n            if (!(op instanceof ReplaceOp)) {\n                continue;\n            }\n            let rop = op;\n            // Wipe prior inserts within range\n            let inserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);\n            for (let iop of inserts) {\n                if (iop.index === rop.index) {\n                    // E.g., insert before 2, delete 2..2; update replace\n                    // text to include insert before, kill insert\n                    rewrites[iop.instructionIndex] = undefined;\n                    rop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : \"\");\n                }\n                else if (iop.index > rop.index && iop.index <= rop.lastIndex) {\n                    // delete insert as it's a no-op.\n                    rewrites[iop.instructionIndex] = undefined;\n                }\n            }\n            // Drop any prior replaces contained within\n            let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);\n            for (let prevRop of prevReplaces) {\n                if (prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex) {\n                    // delete replace as it's a no-op.\n                    rewrites[prevRop.instructionIndex] = undefined;\n                    continue;\n                }\n                // throw exception unless disjoint or identical\n                let disjoint = prevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n                // Delete special case of replace (text==null):\n                // D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right)\n                if (prevRop.text == null && rop.text == null && !disjoint) {\n                    // console.log(`overlapping deletes: ${prevRop}, ${rop}`);\n                    rewrites[prevRop.instructionIndex] = undefined; // kill first delete\n                    rop.index = Math.min(prevRop.index, rop.index);\n                    rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);\n                    // console.log(`new rop ${rop}`);\n                }\n                else if (!disjoint) {\n                    throw new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);\n                }\n            }\n        }\n        // WALK INSERTS\n        for (let i = 0; i < rewrites.length; i++) {\n            let op = rewrites[i];\n            if (op == null) {\n                continue;\n            }\n            if (!(op instanceof InsertBeforeOp)) {\n                continue;\n            }\n            let iop = op;\n            // combine current insert with prior if any at same index\n            let prevInserts = this.getKindOfOps(rewrites, InsertBeforeOp, i);\n            for (let prevIop of prevInserts) {\n                if (prevIop.index === iop.index) {\n                    if (prevIop instanceof InsertAfterOp) {\n                        iop.text = this.catOpText(prevIop.text, iop.text);\n                        rewrites[prevIop.instructionIndex] = undefined;\n                    }\n                    else if (prevIop instanceof InsertBeforeOp) { // combine objects\n                        // convert to strings...we're in process of toString'ing\n                        // whole token buffer so no lazy eval issue with any templates\n                        iop.text = this.catOpText(iop.text, prevIop.text);\n                        // delete redundant prior insert\n                        rewrites[prevIop.instructionIndex] = undefined;\n                    }\n                }\n            }\n            // look for replaces where iop.index is in range; error\n            let prevReplaces = this.getKindOfOps(rewrites, ReplaceOp, i);\n            for (let rop of prevReplaces) {\n                if (iop.index === rop.index) {\n                    rop.text = this.catOpText(iop.text, rop.text);\n                    rewrites[i] = undefined; // delete current insert\n                    continue;\n                }\n                if (iop.index >= rop.index && iop.index <= rop.lastIndex) {\n                    throw new Error(`insert op ${iop} within boundaries of previous ${rop}`);\n                }\n            }\n        }\n        // console.log(`rewrites after=[${Utils.join(rewrites, \", \")}]`);\n        let m = new Map();\n        for (let op of rewrites) {\n            if (op == null) {\n                // ignore deleted ops\n                continue;\n            }\n            if (m.get(op.index) != null) {\n                throw new Error(\"should only be one op per index\");\n            }\n            m.set(op.index, op);\n        }\n        // console.log(`index to op: ${m}`);\n        return m;\n    }\n    catOpText(a, b) {\n        let x = \"\";\n        let y = \"\";\n        if (a != null) {\n            x = a.toString();\n        }\n        if (b != null) {\n            y = b.toString();\n        }\n        return x + y;\n    }\n    /** Get all operations before an index of a particular kind */\n    getKindOfOps(rewrites, kind, before) {\n        let ops = [];\n        for (let i = 0; i < before && i < rewrites.length; i++) {\n            let op = rewrites[i];\n            if (op == null) {\n                // ignore deleted\n                continue;\n            }\n            if (op instanceof kind) {\n                ops.push(op);\n            }\n        }\n        return ops;\n    }\n}\nTokenStreamRewriter.DEFAULT_PROGRAM_NAME = \"default\";\nTokenStreamRewriter.PROGRAM_INIT_SIZE = 100;\nTokenStreamRewriter.MIN_TOKEN_INDEX = 0;\nexports.TokenStreamRewriter = TokenStreamRewriter;\n// Define the rewrite operation hierarchy\nclass RewriteOperation {\n    constructor(tokens, index, text) {\n        this.tokens = tokens;\n        this.index = index;\n        this.text = text === undefined ? \"\" : text;\n    }\n    /** Execute the rewrite operation by possibly adding to the buffer.\n     *  Return the index of the next token to operate on.\n     */\n    execute(buf) {\n        return this.index;\n    }\n    toString() {\n        let opName = this.constructor.name;\n        let $index = opName.indexOf(\"$\");\n        opName = opName.substring($index + 1, opName.length);\n        return \"<\" + opName + \"@\" + this.tokens.get(this.index) +\n            \":\\\"\" + this.text + \"\\\">\";\n    }\n}\n__decorate([\n    Decorators_1.Override\n], RewriteOperation.prototype, \"toString\", null);\nexports.RewriteOperation = RewriteOperation;\nclass InsertBeforeOp extends RewriteOperation {\n    constructor(tokens, index, text) {\n        super(tokens, index, text);\n    }\n    execute(buf) {\n        buf.push(this.text.toString());\n        if (this.tokens.get(this.index).type !== Token_1.Token.EOF) {\n            buf.push(String(this.tokens.get(this.index).text));\n        }\n        return this.index + 1;\n    }\n}\n__decorate([\n    Decorators_1.Override\n], InsertBeforeOp.prototype, \"execute\", null);\n/** Distinguish between insert after/before to do the \"insert afters\"\n *  first and then the \"insert befores\" at same index. Implementation\n *  of \"insert after\" is \"insert before index+1\".\n */\nclass InsertAfterOp extends InsertBeforeOp {\n    constructor(tokens, index, text) {\n        super(tokens, index + 1, text); // insert after is insert before index+1\n    }\n}\n/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp\n *  instructions.\n */\nclass ReplaceOp extends RewriteOperation {\n    constructor(tokens, from, to, text) {\n        super(tokens, from, text);\n        this.lastIndex = to;\n    }\n    execute(buf) {\n        if (this.text != null) {\n            buf.push(this.text.toString());\n        }\n        return this.lastIndex + 1;\n    }\n    toString() {\n        if (this.text == null) {\n            return \"<DeleteOp@\" + this.tokens.get(this.index) +\n                \"..\" + this.tokens.get(this.lastIndex) + \">\";\n        }\n        return \"<ReplaceOp@\" + this.tokens.get(this.index) +\n            \"..\" + this.tokens.get(this.lastIndex) + \":\\\"\" + this.text + \"\\\">\";\n    }\n}\n__decorate([\n    Decorators_1.Override\n], ReplaceOp.prototype, \"execute\", null);\n__decorate([\n    Decorators_1.Override\n], ReplaceOp.prototype, \"toString\", null);\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:58.1768850-07:00\n\nimport { Interval } from \"./misc/Interval\";\nimport { Override } from \"./Decorators\";\nimport { Token } from \"./Token\";\nimport { TokenStream } from \"./TokenStream\";\n\nimport * as Utils from \"./misc/Utils\";\n\n/**\n * Useful for rewriting out a buffered input token stream after doing some\n * augmentation or other manipulations on it.\n *\n * You can insert stuff, replace, and delete chunks. Note that the operations\n * are done lazily--only if you convert the buffer to a {@link String} with\n * {@link TokenStream#getText()}. This is very efficient because you are not\n * moving data around all the time. As the buffer of tokens is converted to\n * strings, the {@link #getText()} method(s) scan the input token stream and\n * check to see if there is an operation at the current index. If so, the\n * operation is done and then normal {@link String} rendering continues on the\n * buffer. This is like having multiple Turing machine instruction streams\n * (programs) operating on a single input tape. :)\n *\n * This rewriter makes no modifications to the token stream. It does not ask the\n * stream to fill itself up nor does it advance the input cursor. The token\n * stream `TokenStream.index` will return the same value before and\n * after any {@link #getText()} call.\n *\n * The rewriter only works on tokens that you have in the buffer and ignores the\n * current input cursor. If you are buffering tokens on-demand, calling\n * {@link #getText()} halfway through the input will only do rewrites for those\n * tokens in the first half of the file.\n *\n * Since the operations are done lazily at {@link #getText}-time, operations do\n * not screw up the token index values. That is, an insert operation at token\n * index `i` does not change the index values for tokens\n * `i`+1..n-1.\n *\n * Because operations never actually alter the buffer, you may always get the\n * original token stream back without undoing anything. Since the instructions\n * are queued up, you can easily simulate transactions and roll back any changes\n * if there is an error just by removing instructions. For example,\n *\n * ```\n * CharStream input = new ANTLRFileStream(\"input\");\n * TLexer lex = new TLexer(input);\n * CommonTokenStream tokens = new CommonTokenStream(lex);\n * T parser = new T(tokens);\n * TokenStreamRewriter rewriter = new TokenStreamRewriter(tokens);\n * parser.startRule();\n * ```\n *\n * Then in the rules, you can execute (assuming rewriter is visible):\n *\n * ```\n * Token t,u;\n * ...\n * rewriter.insertAfter(t, \"text to put after t\");}\n * rewriter.insertAfter(u, \"text after u\");}\n * System.out.println(rewriter.getText());\n * ```\n *\n * You can also have multiple \"instruction streams\" and get multiple rewrites\n * from a single pass over the input. Just name the instruction streams and use\n * that name again when printing the buffer. This could be useful for generating\n * a C file and also its header file--all from the same buffer:\n *\n * ```\n * rewriter.insertAfter(\"pass1\", t, \"text to put after t\");}\n * rewriter.insertAfter(\"pass2\", u, \"text after u\");}\n * System.out.println(rewriter.getText(\"pass1\"));\n * System.out.println(rewriter.getText(\"pass2\"));\n * ```\n *\n * If you don't use named rewrite streams, a \"default\" stream is used as the\n * first example shows.\n */\nexport class TokenStreamRewriter {\n\tpublic static readonly DEFAULT_PROGRAM_NAME: string =  \"default\";\n\tpublic static readonly PROGRAM_INIT_SIZE: number =  100;\n\tpublic static readonly MIN_TOKEN_INDEX: number =  0;\n\n\t/** Our source stream */\n\tprotected tokens: TokenStream;\n\n\t/** You may have multiple, named streams of rewrite operations.\n\t *  I'm calling these things \"programs.\"\n\t *  Maps String (name) &rarr; rewrite (List)\n\t */\n\tprotected programs: Map<string, RewriteOperation[]>;\n\n\t/** Map String (program name) &rarr; Integer index */\n\tprotected lastRewriteTokenIndexes: Map<string, number>;\n\n\tconstructor(tokens: TokenStream)  {\n\t\tthis.tokens = tokens;\n\t\tthis.programs = new Map<string, RewriteOperation[]>();\n\t\tthis.programs.set(TokenStreamRewriter.DEFAULT_PROGRAM_NAME, []);\n\t\tthis.lastRewriteTokenIndexes = new Map<string, number>();\n\t}\n\n\tpublic getTokenStream(): TokenStream {\n\t\treturn this.tokens;\n\t}\n\n\tpublic rollback(instructionIndex: number): void;\n\t/** Rollback the instruction stream for a program so that\n\t *  the indicated instruction (via instructionIndex) is no\n\t *  longer in the stream. UNTESTED!\n\t */\n\tpublic rollback(instructionIndex: number, programName: string): void;\n\tpublic rollback(instructionIndex: number, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tlet is: RewriteOperation[] | undefined =  this.programs.get(programName);\n\t\tif ( is != null ) {\n\t\t\tthis.programs.set(programName, is.slice(TokenStreamRewriter.MIN_TOKEN_INDEX, instructionIndex));\n\t\t}\n\t}\n\n\tpublic deleteProgram(): void;\n\n\t/** Reset the program so that no instructions exist */\n\tpublic deleteProgram(programName: string): void;\n\tpublic deleteProgram(programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tthis.rollback(TokenStreamRewriter.MIN_TOKEN_INDEX, programName);\n\t}\n\n\tpublic insertAfter(t: Token, text: {}): void;\n\tpublic insertAfter(index: number, text: {}): void;\n\tpublic insertAfter(t: Token, text: {}, programName: string): void;\n\tpublic insertAfter(index: number, text: {}, programName: string): void;\n\tpublic insertAfter(tokenOrIndex: Token | number, text: {}, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tlet index: number;\n\t\tif (typeof tokenOrIndex === \"number\") {\n\t\t\tindex = tokenOrIndex;\n\t\t} else {\n\t\t\tindex = tokenOrIndex.tokenIndex;\n\t\t}\n\n\t\t// to insert after, just insert before next index (even if past end)\n\t\tlet op = new InsertAfterOp(this.tokens, index, text);\n\t\tlet rewrites: RewriteOperation[] = this.getProgram(programName);\n\t\top.instructionIndex = rewrites.length;\n\t\trewrites.push(op);\n\t}\n\n\tpublic insertBefore(t: Token, text: {}): void;\n\tpublic insertBefore(index: number, text: {}): void;\n\tpublic insertBefore(t: Token, text: {}, programName: string): void;\n\tpublic insertBefore(index: number, text: {}, programName: string): void;\n\tpublic insertBefore(tokenOrIndex: Token | number, text: {}, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tlet index: number;\n\t\tif (typeof tokenOrIndex === \"number\") {\n\t\t\tindex = tokenOrIndex;\n\t\t} else {\n\t\t\tindex = tokenOrIndex.tokenIndex;\n\t\t}\n\n\t\tlet op: RewriteOperation = new InsertBeforeOp(this.tokens, index, text);\n\t\tlet rewrites: RewriteOperation[] = this.getProgram(programName);\n\t\top.instructionIndex = rewrites.length;\n\t\trewrites.push(op);\n\t}\n\n\tpublic replaceSingle(index: number, text: {}): void;\n\tpublic replaceSingle(indexT: Token, text: {}): void;\n\tpublic replaceSingle(index: Token | number, text: {}): void {\n\t\tif (typeof index === \"number\") {\n\t\t\tthis.replace(index, index, text);\n\t\t} else {\n\t\t\tthis.replace(index, index, text);\n\t\t}\n\t}\n\n\tpublic replace(from: number, to: number, text: {}): void;\n\n\tpublic replace(from: Token, to: Token, text: {}): void;\n\n\tpublic replace(from: number, to: number, text: {}, programName: string): void;\n\n\tpublic replace(from: Token, to: Token, text: {}, programName: string): void;\n\n\tpublic replace(from: Token | number, to: Token | number, text: {}, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tif (typeof from !== \"number\") {\n\t\t\tfrom = from.tokenIndex;\n\t\t}\n\n\t\tif (typeof to !== \"number\") {\n\t\t\tto = to.tokenIndex;\n\t\t}\n\n\t\tif ( from > to || from < 0 || to < 0 || to >= this.tokens.size ) {\n\t\t\tthrow new RangeError(`replace: range invalid: ${from}..${to}(size=${this.tokens.size})`);\n\t\t}\n\n\t\tlet op: RewriteOperation =  new ReplaceOp(this.tokens, from, to, text);\n\t\tlet rewrites: RewriteOperation[] = this.getProgram(programName);\n\t\top.instructionIndex = rewrites.length;\n\t\trewrites.push(op);\n\t}\n\n\tpublic delete(index: number): void;\n\n\tpublic delete(from: number, to: number): void;\n\n\tpublic delete(indexT: Token): void;\n\n\tpublic delete(from: Token, to: Token): void;\n\n\tpublic delete(from: number, to: number, programName: string): void;\n\n\tpublic delete(from: Token, to: Token, programName: string): void;\n\n\tpublic delete(from: Token | number, to?: Token | number, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): void {\n\t\tif (to === undefined) {\n\t\t\tto = from;\n\t\t}\n\n\t\tif (typeof from === \"number\") {\n\t\t\tthis.replace(from, to as number, \"\", programName);\n\t\t} else {\n\t\t\tthis.replace(from, to as Token, \"\", programName);\n\t\t}\n\t}\n\n\tprotected getLastRewriteTokenIndex(): number;\n\n\tprotected getLastRewriteTokenIndex(programName: string): number;\n\n\tprotected getLastRewriteTokenIndex(programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): number {\n\t\tlet I: number | undefined = this.lastRewriteTokenIndexes.get(programName);\n\t\tif ( I == null ) {\n\t\t\treturn -1;\n\t\t}\n\n\t\treturn I;\n\t}\n\n\tprotected setLastRewriteTokenIndex(programName: string, i: number): void {\n\t\tthis.lastRewriteTokenIndexes.set(programName, i);\n\t}\n\n\tprotected getProgram(name: string): RewriteOperation[] {\n\t\tlet is: RewriteOperation[] | undefined = this.programs.get(name);\n\t\tif ( is == null ) {\n\t\t\tis = this.initializeProgram(name);\n\t\t}\n\n\t\treturn is;\n\t}\n\n\tprivate initializeProgram(name: string): RewriteOperation[] {\n\t\tlet is: RewriteOperation[] = [];\n\t\tthis.programs.set(name, is);\n\t\treturn is;\n\t}\n\n\t/** Return the text from the original tokens altered per the\n\t *  instructions given to this rewriter.\n\t */\n\tpublic getText(): string;\n\n\t/** Return the text from the original tokens altered per the\n\t *  instructions given to this rewriter in programName.\n\t *\n\t * @since 4.5\n\t */\n\tpublic getText(programName: string): string;\n\n\t/** Return the text associated with the tokens in the interval from the\n\t *  original token stream but with the alterations given to this rewriter.\n\t *  The interval refers to the indexes in the original token stream.\n\t *  We do not alter the token stream in any way, so the indexes\n\t *  and intervals are still consistent. Includes any operations done\n\t *  to the first and last token in the interval. So, if you did an\n\t *  insertBefore on the first token, you would get that insertion.\n\t *  The same is true if you do an insertAfter the stop token.\n\t */\n\tpublic getText(interval: Interval): string;\n\n\tpublic getText(interval: Interval, programName: string): string;\n\n\tpublic getText(intervalOrProgram?: Interval | string, programName: string = TokenStreamRewriter.DEFAULT_PROGRAM_NAME): string {\n\t\tlet interval: Interval;\n\t\tif (intervalOrProgram instanceof Interval) {\n\t\t\tinterval = intervalOrProgram;\n\t\t} else {\n\t\t\tinterval = Interval.of(0, this.tokens.size - 1);\n\t\t}\n\n\t\tif (typeof intervalOrProgram === \"string\") {\n\t\t\tprogramName = intervalOrProgram;\n\t\t}\n\n\t\tlet rewrites: RewriteOperation[] | undefined = this.programs.get(programName);\n\t\tlet start: number =  interval.a;\n\t\tlet stop: number =  interval.b;\n\n\t\t// ensure start/end are in range\n\t\tif ( stop > this.tokens.size - 1 ) {\n\t\t\tstop = this.tokens.size - 1;\n\t\t}\n\t\tif ( start < 0 ) {\n\t\t\tstart = 0;\n\t\t}\n\n\t\tif ( rewrites == null || rewrites.length === 0 ) {\n\t\t\treturn this.tokens.getText(interval); // no instructions to execute\n\t\t}\n\n\t\tlet buf: string[] = [];\n\n\t\t// First, optimize instruction stream\n\t\tlet indexToOp: Map<number, RewriteOperation> = this.reduceToSingleOperationPerIndex(rewrites);\n\n\t\t// Walk buffer, executing instructions and emitting tokens\n\t\tlet i: number =  start;\n\t\twhile ( i <= stop && i < this.tokens.size ) {\n\t\t\tlet op: RewriteOperation | undefined =  indexToOp.get(i);\n\t\t\tindexToOp.delete(i); // remove so any left have index size-1\n\t\t\tlet t: Token = this.tokens.get(i);\n\t\t\tif ( op == null ) {\n\t\t\t\t// no operation at that index, just dump token\n\t\t\t\tif ( t.type !== Token.EOF ) {\n\t\t\t\t\tbuf.push(String(t.text));\n\t\t\t\t}\n\t\t\t\ti++; // move to next token\n\t\t\t}\n\t\t\telse {\n\t\t\t\ti = op.execute(buf); // execute operation and skip\n\t\t\t}\n\t\t}\n\n\t\t// include stuff after end if it's last index in buffer\n\t\t// So, if they did an insertAfter(lastValidIndex, \"foo\"), include\n\t\t// foo if end==lastValidIndex.\n\t\tif ( stop === this.tokens.size - 1 ) {\n\t\t\t// Scan any remaining operations after last token\n\t\t\t// should be included (they will be inserts).\n\t\t\tfor (let op of indexToOp.values()) {\n\t\t\t\tif ( op.index >= this.tokens.size - 1 ) {\n\t\t\t\t\tbuf.push(op.text.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn buf.join(\"\");\n\t}\n\n\t/** We need to combine operations and report invalid operations (like\n\t *  overlapping replaces that are not completed nested). Inserts to\n\t *  same index need to be combined etc...  Here are the cases:\n\t *\n\t *  I.i.u I.j.v\t\t\t\t\t\t\t\tleave alone, nonoverlapping\n\t *  I.i.u I.i.v\t\t\t\t\t\t\t\tcombine: Iivu\n\t *\n\t *  R.i-j.u R.x-y.v\t| i-j in x-y\t\t\tdelete first R\n\t *  R.i-j.u R.i-j.v\t\t\t\t\t\t\tdelete first R\n\t *  R.i-j.u R.x-y.v\t| x-y in i-j\t\t\tERROR\n\t *  R.i-j.u R.x-y.v\t| boundaries overlap\tERROR\n\t *\n\t *  Delete special case of replace (text==undefined):\n\t *  D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right)\n\t *\n\t *  I.i.u R.x-y.v | i in (x+1)-y\t\t\tdelete I (since insert before\n\t * \t\t\t\t\t\t\t\t\t\t\twe're not deleting i)\n\t *  I.i.u R.x-y.v | i not in (x+1)-y\t\tleave alone, nonoverlapping\n\t *  R.x-y.v I.i.u | i in x-y\t\t\t\tERROR\n\t *  R.x-y.v I.x.u \t\t\t\t\t\t\tR.x-y.uv (combine, delete I)\n\t *  R.x-y.v I.i.u | i not in x-y\t\t\tleave alone, nonoverlapping\n\t *\n\t *  I.i.u = insert u before op @ index i\n\t *  R.x-y.u = replace x-y indexed tokens with u\n\t *\n\t *  First we need to examine replaces. For any replace op:\n\t *\n\t * \t\t1. wipe out any insertions before op within that range.\n\t * \t\t2. Drop any replace op before that is contained completely within\n\t * \t that range.\n\t * \t\t3. Throw exception upon boundary overlap with any previous replace.\n\t *\n\t *  Then we can deal with inserts:\n\t *\n\t * \t\t1. for any inserts to same index, combine even if not adjacent.\n\t * \t\t2. for any prior replace with same left boundary, combine this\n\t * \t insert with replace and delete this replace.\n\t * \t\t3. throw exception if index in same range as previous replace\n\t *\n\t *  Don't actually delete; make op undefined in list. Easier to walk list.\n\t *  Later we can throw as we add to index &rarr; op map.\n\t *\n\t *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the\n\t *  inserted stuff would be before the replace range. But, if you\n\t *  add tokens in front of a method body '{' and then delete the method\n\t *  body, I think the stuff before the '{' you added should disappear too.\n\t *\n\t *  Return a map from token index to operation.\n\t */\n\tprotected reduceToSingleOperationPerIndex(rewrites: Array<RewriteOperation | undefined>): Map<number, RewriteOperation> {\n\t\t// console.log(`rewrites=[${Utils.join(rewrites, \", \")}]`);\n\n\t\t// WALK REPLACES\n\t\tfor (let i = 0; i < rewrites.length; i++) {\n\t\t\tlet op: RewriteOperation | undefined = rewrites[i];\n\t\t\tif ( op == null ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( !(op instanceof ReplaceOp) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet rop: ReplaceOp = op;\n\t\t\t// Wipe prior inserts within range\n\t\t\tlet inserts: InsertBeforeOp[] = this.getKindOfOps(rewrites, InsertBeforeOp, i);\n\t\t\tfor (let iop of inserts) {\n\t\t\t\tif ( iop.index === rop.index ) {\n\t\t\t\t\t// E.g., insert before 2, delete 2..2; update replace\n\t\t\t\t\t// text to include insert before, kill insert\n\t\t\t\t\trewrites[iop.instructionIndex] = undefined;\n\t\t\t\t\trop.text = iop.text.toString() + (rop.text != null ? rop.text.toString() : \"\");\n\t\t\t\t}\n\t\t\t\telse if ( iop.index > rop.index && iop.index <= rop.lastIndex ) {\n\t\t\t\t\t// delete insert as it's a no-op.\n\t\t\t\t\trewrites[iop.instructionIndex] = undefined;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Drop any prior replaces contained within\n\t\t\tlet prevReplaces: ReplaceOp[] = this.getKindOfOps(rewrites, ReplaceOp, i);\n\t\t\tfor (let prevRop of prevReplaces) {\n\t\t\t\tif ( prevRop.index >= rop.index && prevRop.lastIndex <= rop.lastIndex ) {\n\t\t\t\t\t// delete replace as it's a no-op.\n\t\t\t\t\trewrites[prevRop.instructionIndex] = undefined;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// throw exception unless disjoint or identical\n\t\t\t\tlet disjoint: boolean =\n\t\t\t\t\tprevRop.lastIndex < rop.index || prevRop.index > rop.lastIndex;\n\t\t\t\t// Delete special case of replace (text==null):\n\t\t\t\t// D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right)\n\t\t\t\tif ( prevRop.text == null && rop.text == null && !disjoint ) {\n\t\t\t\t\t// console.log(`overlapping deletes: ${prevRop}, ${rop}`);\n\t\t\t\t\trewrites[prevRop.instructionIndex] = undefined; // kill first delete\n\t\t\t\t\trop.index = Math.min(prevRop.index, rop.index);\n\t\t\t\t\trop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);\n\t\t\t\t\t// console.log(`new rop ${rop}`);\n\t\t\t\t}\n\t\t\t\telse if ( !disjoint ) {\n\t\t\t\t\tthrow new Error(`replace op boundaries of ${rop} overlap with previous ${prevRop}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// WALK INSERTS\n\t\tfor (let i = 0; i < rewrites.length; i++) {\n\t\t\tlet op: RewriteOperation | undefined = rewrites[i];\n\t\t\tif ( op == null ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( !(op instanceof InsertBeforeOp) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tlet iop: InsertBeforeOp =  op;\n\t\t\t// combine current insert with prior if any at same index\n\t\t\tlet prevInserts: InsertBeforeOp[] = this.getKindOfOps(rewrites, InsertBeforeOp, i);\n\t\t\tfor (let prevIop of prevInserts) {\n\t\t\t\tif ( prevIop.index === iop.index ) {\n\t\t\t\t\tif (prevIop instanceof InsertAfterOp) {\n\t\t\t\t\t\tiop.text = this.catOpText(prevIop.text, iop.text);\n\t\t\t\t\t\trewrites[prevIop.instructionIndex] = undefined;\n\t\t\t\t\t}\n\t\t\t\t\telse if (prevIop instanceof InsertBeforeOp) { // combine objects\n\t\t\t\t\t\t// convert to strings...we're in process of toString'ing\n\t\t\t\t\t\t// whole token buffer so no lazy eval issue with any templates\n\t\t\t\t\t\tiop.text = this.catOpText(iop.text, prevIop.text);\n\t\t\t\t\t\t// delete redundant prior insert\n\t\t\t\t\t\trewrites[prevIop.instructionIndex] = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// look for replaces where iop.index is in range; error\n\t\t\tlet prevReplaces: ReplaceOp[] = this.getKindOfOps(rewrites, ReplaceOp, i);\n\t\t\tfor (let rop of prevReplaces) {\n\t\t\t\tif ( iop.index === rop.index ) {\n\t\t\t\t\trop.text = this.catOpText(iop.text, rop.text);\n\t\t\t\t\trewrites[i] = undefined;\t// delete current insert\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( iop.index >= rop.index && iop.index <= rop.lastIndex ) {\n\t\t\t\t\tthrow new Error(`insert op ${iop} within boundaries of previous ${rop}`);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// console.log(`rewrites after=[${Utils.join(rewrites, \", \")}]`);\n\t\tlet m: Map<number, RewriteOperation> =  new Map<number, RewriteOperation>();\n\t\tfor (let op of rewrites) {\n\t\t\tif ( op == null ) {\n\t\t\t\t// ignore deleted ops\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( m.get(op.index) != null ) {\n\t\t\t\tthrow new Error(\"should only be one op per index\");\n\t\t\t}\n\t\t\tm.set(op.index, op);\n\t\t}\n\t\t// console.log(`index to op: ${m}`);\n\t\treturn m;\n\t}\n\n\tprotected catOpText(a: {}, b: {}): string {\n\t\tlet x: string =  \"\";\n\t\tlet y: string =  \"\";\n\t\tif ( a != null ) {\n\t\t\tx = a.toString();\n\t\t}\n\t\tif ( b != null ) {\n\t\t\ty = b.toString();\n\t\t}\n\t\treturn x + y;\n\t}\n\n\t/** Get all operations before an index of a particular kind */\n\tprotected getKindOfOps<T extends RewriteOperation>(rewrites: Array<RewriteOperation | undefined>, kind: {new(...args: any[]): T}, before: number): T[] {\n\t\tlet ops: T[] = [];\n\t\tfor (let i = 0; i < before && i < rewrites.length; i++) {\n\t\t\tlet op: RewriteOperation | undefined =  rewrites[i];\n\t\t\tif ( op == null ) {\n\t\t\t\t// ignore deleted\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( op instanceof kind ) {\n\t\t\t\tops.push(op);\n\t\t\t}\n\t\t}\n\t\treturn ops;\n\t}\n}\n\n// Define the rewrite operation hierarchy\n\nexport class RewriteOperation {\n\tprotected tokens: TokenStream;\n\t/** What index into rewrites List are we? */\n\tpublic instructionIndex: number;\n\t/** Token buffer index. */\n\tpublic index: number;\n\tpublic text: {};\n\n\tconstructor(tokens: TokenStream, index: number);\n\tconstructor(tokens: TokenStream, index: number, text: {});\n\tconstructor(tokens: TokenStream, index: number, text?: {}) {\n\t\tthis.tokens = tokens;\n\t\tthis.index = index;\n\t\tthis.text = text === undefined ? \"\" : text;\n\t}\n\n\t/** Execute the rewrite operation by possibly adding to the buffer.\n\t *  Return the index of the next token to operate on.\n\t */\n\tpublic execute(buf: string[]): number {\n\t\treturn this.index;\n\t}\n\n\t@Override\n\tpublic toString(): string {\n\t\tlet opName: string = this.constructor.name;\n\t\tlet $index = opName.indexOf(\"$\");\n\t\topName = opName.substring($index + 1, opName.length);\n\t\treturn \"<\" + opName + \"@\" + this.tokens.get(this.index) +\n\t\t\t\t\":\\\"\" + this.text + \"\\\">\";\n\t}\n}\n\nclass InsertBeforeOp extends RewriteOperation {\n\tconstructor(tokens: TokenStream, index: number, text: {}) {\n\t\tsuper(tokens, index, text);\n\t}\n\n\t@Override\n\tpublic execute(buf: string[]): number {\n\t\tbuf.push(this.text.toString());\n\t\tif ( this.tokens.get(this.index).type !== Token.EOF ) {\n\t\t\tbuf.push(String(this.tokens.get(this.index).text));\n\t\t}\n\t\treturn this.index + 1;\n\t}\n}\n\n/** Distinguish between insert after/before to do the \"insert afters\"\n *  first and then the \"insert befores\" at same index. Implementation\n *  of \"insert after\" is \"insert before index+1\".\n */\nclass InsertAfterOp extends InsertBeforeOp {\n\tconstructor(tokens: TokenStream, index: number, text: {}) {\n\t\tsuper(tokens, index + 1, text); // insert after is insert before index+1\n\t}\n}\n\n/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp\n *  instructions.\n */\nclass ReplaceOp extends RewriteOperation {\n\tpublic lastIndex: number;\n\tconstructor(tokens: TokenStream, from: number, to: number, text: {}) {\n\t\tsuper(tokens, from, text);\n\t\tthis.lastIndex = to;\n\t}\n\n\t@Override\n\tpublic execute(buf: string[]): number {\n\t\tif ( this.text != null ) {\n\t\t\tbuf.push(this.text.toString());\n\t\t}\n\t\treturn this.lastIndex + 1;\n\t}\n\n\t@Override\n\tpublic toString(): string {\n\t\tif ( this.text == null ) {\n\t\t\treturn \"<DeleteOp@\" + this.tokens.get(this.index) +\n\t\t\t\t\t\"..\" + this.tokens.get(this.lastIndex) + \">\";\n\t\t}\n\t\treturn \"<ReplaceOp@\" + this.tokens.get(this.index) +\n\t\t\t\t\"..\" + this.tokens.get(this.lastIndex) + \":\\\"\" + this.text + \"\\\">\";\n\t}\n}\n"]}