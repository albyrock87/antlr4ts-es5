{"version":3,"sources":["atn/ATNDeserializer.js","../src/atn/ATNDeserializer.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","ActionTransition_1","require","Array2DHashSet_1","ATN_1","ATNDeserializationOptions_1","ATNStateType_1","AtomTransition_1","BasicBlockStartState_1","BasicState_1","BitSet_1","BlockEndState_1","BlockStartState_1","DecisionState_1","DFA_1","EpsilonTransition_1","IntervalSet_1","InvalidState_1","LexerChannelAction_1","LexerCustomAction_1","LexerModeAction_1","LexerMoreAction_1","LexerPopModeAction_1","LexerPushModeAction_1","LexerSkipAction_1","LexerTypeAction_1","LoopEndState_1","Decorators_1","NotSetTransition_1","ParserATNSimulator_1","PlusBlockStartState_1","PlusLoopbackState_1","PrecedencePredicateTransition_1","PredicateTransition_1","RangeTransition_1","RuleStartState_1","RuleStopState_1","RuleTransition_1","SetTransition_1","StarBlockStartState_1","StarLoopbackState_1","StarLoopEntryState_1","Token_1","TokensStartState_1","UUID_1","WildcardTransition_1","UnicodeDeserializingMode","ATNDeserializer","deserializationOptions","ATNDeserializationOptions","defaultOptions","data","slice","p","version","toInt","SERIALIZED_VERSION","reason","Error","uuid","toUUID","SUPPORTED_UUIDS","findIndex","e","equals","SERIALIZED_UUID","supportsLexerActions","isFeatureSupported","ADDED_LEXER_ACTIONS","grammarType","maxTokenType","atn","ATN","loopBackStateNumbers","endStateNumbers","nstates","stype","ATNStateType","INVALID_TYPE","addState","InvalidState","ruleIndex","s","stateFactory","LOOP_END","loopBackStateNumber","push","BlockStartState","endStateNumber","pair","loopBackState","states","endState","numNonGreedyStates","stateNumber","nonGreedy","numSllDecisions","sll","numPrecedenceStates","isPrecedenceRule","nrules","ruleToTokenType","Int32Array","ruleToStartState","Array","startState","leftFactored","tokenType","Token","EOF","actionIndexIgnored","ruleToStopState","state","RuleStopState","stopState","nmodes","modeToStartState","modeToDFA","DFA","sets","deserializeSets","getUnicodeDeserializer","ADDED_UNICODE_SMP","nedges","src","trg","ttype","arg1","arg2","arg3","trans","edgeFactory","srcState","addTransition","returnTransitionsSet","Array2DHashSet","hashCode","o","returnState","outermostPrecedenceReturn","a","b","returnTransitions","returningToLeftFactored","numberOfTransitions","t","transition","RuleTransition","ruleTransition","returningFromLeftFactored","precedence","current","followState","add","returnTransition","EpsilonTransition","PlusLoopbackState","loopbackState","PlusBlockStartState","StarLoopbackState","StarLoopEntryState","ndecisions","decState","decisionToState","decision","lexerActions","actionType","data1","data2","lexerAction","lexerActionFactory","legacyLexerActions","ActionTransition","actionIndex","LexerCustomAction","setTransition","markPrecedenceDecisions","decisionToDFA","isVerifyATN","verifyATN","isGenerateRuleBypassTransitions","bypassStart","BasicBlockStartState","bypassStop","BlockEndState","defineDecisionState","excludeTransition","undefined","maybeLoopEndState","LoopEndState","epsilonOnlyTransitions","removeTransition","matchState","BasicState","AtomTransition","isOptimize","optimizationCount","inlineSetRules","combineChainedEpsilons","preserveOrder","optimizeSets","identifyTailCalls","unicodeDeserializer","nsets","nintervals","set","IntervalSet","containsEof","j","readUnicode","size","rulePrecedenceDecisions","Map","precedenceRuleDecision","precedenceLoopbackStates","BitSet","precedenceDecision","getTransitions","serializationType","epsilonTransition","checkCondition","stateType","onlyHasEpsilonTransitions","starLoopEntryState","StarBlockStartState","RuleStartState","DecisionState","decisionState","condition","message","type","RangeTransition","rt","pt","PredicateTransition","PrecedencePredicateTransition","SetTransition","NotSetTransition","WildcardTransition","BASIC","RULE_START","BLOCK_START","PLUS_BLOCK_START","STAR_BLOCK_START","TOKEN_START","TokensStartState","RULE_STOP","BLOCK_END","STAR_LOOP_BACK","STAR_LOOP_ENTRY","PLUS_LOOP_BACK","LexerChannelAction","LexerModeAction","LexerMoreAction","INSTANCE","LexerPopModeAction","LexerPushModeAction","LexerSkipAction","LexerTypeAction","feature","actualUuid","featureIndex","mode","toInt32","inlinedCalls","ruleToInlineTransition","middleState","numberOfOptimizedTransitions","getOptimizedTransition","matchTransition","matchTarget","isEpsilon","optimizedTransitions","effective","intermediateState","setRuleIndex","_label","from","to","label","isOptimized","removeOptimizedTransition","addOptimizedTransition","ParserATNSimulator","debug","console","log","removedEdges","nextTransition","intermediate","removedPaths","decisions","setTransitions","epsTransition","contains","blockEndState","minElement","matchSet","intervals","interval","addAll","newTransition","matchInterval","setOptimizedState","tailCall","testTailCall","optimizedTailCall","optimizedPath","reachable","worklist","pop","get","transitionCount","offset","leastSigBits","lessSigBits","moreSigBits","mostSigBits","UUID","BASE_SERIALIZED_UUID","fromString","NotNull","prototype"],"mappings":"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","file":"ATNDeserializer.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:25.9683447-07:00\nconst ActionTransition_1 = require(\"./ActionTransition\");\nconst Array2DHashSet_1 = require(\"../misc/Array2DHashSet\");\nconst ATN_1 = require(\"./ATN\");\nconst ATNDeserializationOptions_1 = require(\"./ATNDeserializationOptions\");\nconst ATNStateType_1 = require(\"./ATNStateType\");\nconst AtomTransition_1 = require(\"./AtomTransition\");\nconst BasicBlockStartState_1 = require(\"./BasicBlockStartState\");\nconst BasicState_1 = require(\"./BasicState\");\nconst BitSet_1 = require(\"../misc/BitSet\");\nconst BlockEndState_1 = require(\"./BlockEndState\");\nconst BlockStartState_1 = require(\"./BlockStartState\");\nconst DecisionState_1 = require(\"./DecisionState\");\nconst DFA_1 = require(\"../dfa/DFA\");\nconst EpsilonTransition_1 = require(\"./EpsilonTransition\");\nconst IntervalSet_1 = require(\"../misc/IntervalSet\");\nconst InvalidState_1 = require(\"./InvalidState\");\nconst LexerChannelAction_1 = require(\"./LexerChannelAction\");\nconst LexerCustomAction_1 = require(\"./LexerCustomAction\");\nconst LexerModeAction_1 = require(\"./LexerModeAction\");\nconst LexerMoreAction_1 = require(\"./LexerMoreAction\");\nconst LexerPopModeAction_1 = require(\"./LexerPopModeAction\");\nconst LexerPushModeAction_1 = require(\"./LexerPushModeAction\");\nconst LexerSkipAction_1 = require(\"./LexerSkipAction\");\nconst LexerTypeAction_1 = require(\"./LexerTypeAction\");\nconst LoopEndState_1 = require(\"./LoopEndState\");\nconst Decorators_1 = require(\"../Decorators\");\nconst NotSetTransition_1 = require(\"./NotSetTransition\");\nconst ParserATNSimulator_1 = require(\"./ParserATNSimulator\");\nconst PlusBlockStartState_1 = require(\"./PlusBlockStartState\");\nconst PlusLoopbackState_1 = require(\"./PlusLoopbackState\");\nconst PrecedencePredicateTransition_1 = require(\"./PrecedencePredicateTransition\");\nconst PredicateTransition_1 = require(\"./PredicateTransition\");\nconst RangeTransition_1 = require(\"./RangeTransition\");\nconst RuleStartState_1 = require(\"./RuleStartState\");\nconst RuleStopState_1 = require(\"./RuleStopState\");\nconst RuleTransition_1 = require(\"./RuleTransition\");\nconst SetTransition_1 = require(\"./SetTransition\");\nconst StarBlockStartState_1 = require(\"./StarBlockStartState\");\nconst StarLoopbackState_1 = require(\"./StarLoopbackState\");\nconst StarLoopEntryState_1 = require(\"./StarLoopEntryState\");\nconst Token_1 = require(\"../Token\");\nconst TokensStartState_1 = require(\"./TokensStartState\");\nconst UUID_1 = require(\"../misc/UUID\");\nconst WildcardTransition_1 = require(\"./WildcardTransition\");\nvar UnicodeDeserializingMode;\n(function (UnicodeDeserializingMode) {\n    UnicodeDeserializingMode[UnicodeDeserializingMode[\"UNICODE_BMP\"] = 0] = \"UNICODE_BMP\";\n    UnicodeDeserializingMode[UnicodeDeserializingMode[\"UNICODE_SMP\"] = 1] = \"UNICODE_SMP\";\n})(UnicodeDeserializingMode || (UnicodeDeserializingMode = {}));\n/**\n *\n * @author Sam Harwell\n */\nclass ATNDeserializer {\n    constructor(deserializationOptions) {\n        if (deserializationOptions == null) {\n            deserializationOptions = ATNDeserializationOptions_1.ATNDeserializationOptions.defaultOptions;\n        }\n        this.deserializationOptions = deserializationOptions;\n    }\n    static get SERIALIZED_VERSION() {\n        /* This value should never change. Updates following this version are\n         * reflected as change in the unique ID SERIALIZED_UUID.\n         */\n        return 3;\n    }\n    /**\n     * Determines if a particular serialized representation of an ATN supports\n     * a particular feature, identified by the {@link UUID} used for serializing\n     * the ATN at the time the feature was first introduced.\n     *\n     * @param feature The {@link UUID} marking the first time the feature was\n     * supported in the serialized ATN.\n     * @param actualUuid The {@link UUID} of the actual serialized ATN which is\n     * currently being deserialized.\n     * @returns `true` if the `actualUuid` value represents a\n     * serialized ATN at or after the feature identified by `feature` was\n     * introduced; otherwise, `false`.\n     */\n    static isFeatureSupported(feature, actualUuid) {\n        let featureIndex = ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));\n        if (featureIndex < 0) {\n            return false;\n        }\n        return ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;\n    }\n    static getUnicodeDeserializer(mode) {\n        if (mode === 0 /* UNICODE_BMP */) {\n            return {\n                readUnicode: (data, p) => {\n                    return ATNDeserializer.toInt(data[p]);\n                },\n                size: 1,\n            };\n        }\n        else {\n            return {\n                readUnicode: (data, p) => {\n                    return ATNDeserializer.toInt32(data, p);\n                },\n                size: 2,\n            };\n        }\n    }\n    deserialize(data) {\n        data = data.slice(0);\n        // Each Uint16 value in data is shifted by +2 at the entry to this method. This is an encoding optimization\n        // targeting the serialized values 0 and -1 (serialized to 0xFFFF), each of which are very common in the\n        // serialized form of the ATN. In the modified UTF-8 that Java uses for compiled string literals, these two\n        // character values have multi-byte forms. By shifting each value by +2, they become characters 2 and 1 prior to\n        // writing the string, each of which have single-byte representations. Since the shift occurs in the tool during\n        // ATN serialization, each target is responsible for adjusting the values during deserialization.\n        //\n        // As a special case, note that the first element of data is not adjusted because it contains the major version\n        // number of the serialized ATN, which was fixed at 3 at the time the value shifting was implemented.\n        for (let i = 1; i < data.length; i++) {\n            data[i] = (data[i] - 2) & 0xFFFF;\n        }\n        let p = 0;\n        let version = ATNDeserializer.toInt(data[p++]);\n        if (version !== ATNDeserializer.SERIALIZED_VERSION) {\n            let reason = `Could not deserialize ATN with version ${version} (expected ${ATNDeserializer.SERIALIZED_VERSION}).`;\n            throw new Error(reason);\n        }\n        let uuid = ATNDeserializer.toUUID(data, p);\n        p += 8;\n        if (ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {\n            let reason = `Could not deserialize ATN with UUID ${uuid} (expected ${ATNDeserializer.SERIALIZED_UUID} or a legacy UUID).`;\n            throw new Error(reason);\n        }\n        let supportsLexerActions = ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, uuid);\n        let grammarType = ATNDeserializer.toInt(data[p++]);\n        let maxTokenType = ATNDeserializer.toInt(data[p++]);\n        let atn = new ATN_1.ATN(grammarType, maxTokenType);\n        //\n        // STATES\n        //\n        let loopBackStateNumbers = [];\n        let endStateNumbers = [];\n        let nstates = ATNDeserializer.toInt(data[p++]);\n        for (let i = 0; i < nstates; i++) {\n            let stype = ATNDeserializer.toInt(data[p++]);\n            // ignore bad type of states\n            if (stype === ATNStateType_1.ATNStateType.INVALID_TYPE) {\n                atn.addState(new InvalidState_1.InvalidState());\n                continue;\n            }\n            let ruleIndex = ATNDeserializer.toInt(data[p++]);\n            if (ruleIndex === 0xFFFF) {\n                ruleIndex = -1;\n            }\n            let s = this.stateFactory(stype, ruleIndex);\n            if (stype === ATNStateType_1.ATNStateType.LOOP_END) { // special case\n                let loopBackStateNumber = ATNDeserializer.toInt(data[p++]);\n                loopBackStateNumbers.push([s, loopBackStateNumber]);\n            }\n            else if (s instanceof BlockStartState_1.BlockStartState) {\n                let endStateNumber = ATNDeserializer.toInt(data[p++]);\n                endStateNumbers.push([s, endStateNumber]);\n            }\n            atn.addState(s);\n        }\n        // delay the assignment of loop back and end states until we know all the state instances have been initialized\n        for (let pair of loopBackStateNumbers) {\n            pair[0].loopBackState = atn.states[pair[1]];\n        }\n        for (let pair of endStateNumbers) {\n            pair[0].endState = atn.states[pair[1]];\n        }\n        let numNonGreedyStates = ATNDeserializer.toInt(data[p++]);\n        for (let i = 0; i < numNonGreedyStates; i++) {\n            let stateNumber = ATNDeserializer.toInt(data[p++]);\n            atn.states[stateNumber].nonGreedy = true;\n        }\n        let numSllDecisions = ATNDeserializer.toInt(data[p++]);\n        for (let i = 0; i < numSllDecisions; i++) {\n            let stateNumber = ATNDeserializer.toInt(data[p++]);\n            atn.states[stateNumber].sll = true;\n        }\n        let numPrecedenceStates = ATNDeserializer.toInt(data[p++]);\n        for (let i = 0; i < numPrecedenceStates; i++) {\n            let stateNumber = ATNDeserializer.toInt(data[p++]);\n            atn.states[stateNumber].isPrecedenceRule = true;\n        }\n        //\n        // RULES\n        //\n        let nrules = ATNDeserializer.toInt(data[p++]);\n        if (atn.grammarType === 0 /* LEXER */) {\n            atn.ruleToTokenType = new Int32Array(nrules);\n        }\n        atn.ruleToStartState = new Array(nrules);\n        for (let i = 0; i < nrules; i++) {\n            let s = ATNDeserializer.toInt(data[p++]);\n            let startState = atn.states[s];\n            startState.leftFactored = ATNDeserializer.toInt(data[p++]) !== 0;\n            atn.ruleToStartState[i] = startState;\n            if (atn.grammarType === 0 /* LEXER */) {\n                let tokenType = ATNDeserializer.toInt(data[p++]);\n                if (tokenType === 0xFFFF) {\n                    tokenType = Token_1.Token.EOF;\n                }\n                atn.ruleToTokenType[i] = tokenType;\n                if (!ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, uuid)) {\n                    // this piece of unused metadata was serialized prior to the\n                    // addition of LexerAction\n                    let actionIndexIgnored = ATNDeserializer.toInt(data[p++]);\n                    if (actionIndexIgnored === 0xFFFF) {\n                        actionIndexIgnored = -1;\n                    }\n                }\n            }\n        }\n        atn.ruleToStopState = new Array(nrules);\n        for (let state of atn.states) {\n            if (!(state instanceof RuleStopState_1.RuleStopState)) {\n                continue;\n            }\n            atn.ruleToStopState[state.ruleIndex] = state;\n            atn.ruleToStartState[state.ruleIndex].stopState = state;\n        }\n        //\n        // MODES\n        //\n        let nmodes = ATNDeserializer.toInt(data[p++]);\n        for (let i = 0; i < nmodes; i++) {\n            let s = ATNDeserializer.toInt(data[p++]);\n            atn.modeToStartState.push(atn.states[s]);\n        }\n        atn.modeToDFA = new Array(nmodes);\n        for (let i = 0; i < nmodes; i++) {\n            atn.modeToDFA[i] = new DFA_1.DFA(atn.modeToStartState[i]);\n        }\n        //\n        // SETS\n        //\n        let sets = [];\n        // First, read all sets with 16-bit Unicode code points <= U+FFFF.\n        p = this.deserializeSets(data, p, sets, ATNDeserializer.getUnicodeDeserializer(0 /* UNICODE_BMP */));\n        // Next, if the ATN was serialized with the Unicode SMP feature,\n        // deserialize sets with 32-bit arguments <= U+10FFFF.\n        if (ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_UNICODE_SMP, uuid)) {\n            p = this.deserializeSets(data, p, sets, ATNDeserializer.getUnicodeDeserializer(1 /* UNICODE_SMP */));\n        }\n        //\n        // EDGES\n        //\n        let nedges = ATNDeserializer.toInt(data[p++]);\n        for (let i = 0; i < nedges; i++) {\n            let src = ATNDeserializer.toInt(data[p]);\n            let trg = ATNDeserializer.toInt(data[p + 1]);\n            let ttype = ATNDeserializer.toInt(data[p + 2]);\n            let arg1 = ATNDeserializer.toInt(data[p + 3]);\n            let arg2 = ATNDeserializer.toInt(data[p + 4]);\n            let arg3 = ATNDeserializer.toInt(data[p + 5]);\n            let trans = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n            // console.log(`EDGE ${trans.constructor.name} ${src}->${trg} ${Transition.serializationNames[ttype]} ${arg1},${arg2},${arg3}`);\n            let srcState = atn.states[src];\n            srcState.addTransition(trans);\n            p += 6;\n        }\n        let returnTransitionsSet = new Array2DHashSet_1.Array2DHashSet({\n            hashCode: (o) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,\n            equals: (a, b) => {\n                return a.stopState === b.stopState\n                    && a.returnState === b.returnState\n                    && a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;\n            },\n        });\n        let returnTransitions = [];\n        for (let state of atn.states) {\n            let returningToLeftFactored = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;\n            for (let i = 0; i < state.numberOfTransitions; i++) {\n                let t = state.transition(i);\n                if (!(t instanceof RuleTransition_1.RuleTransition)) {\n                    continue;\n                }\n                let ruleTransition = t;\n                let returningFromLeftFactored = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;\n                if (!returningFromLeftFactored && returningToLeftFactored) {\n                    continue;\n                }\n                let outermostPrecedenceReturn = -1;\n                if (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {\n                    if (ruleTransition.precedence === 0) {\n                        outermostPrecedenceReturn = ruleTransition.target.ruleIndex;\n                    }\n                }\n                let current = { stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn };\n                if (returnTransitionsSet.add(current)) {\n                    returnTransitions.push(current);\n                }\n            }\n        }\n        // Add all elements from returnTransitions to the ATN\n        for (let returnTransition of returnTransitions) {\n            let transition = new EpsilonTransition_1.EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);\n            atn.ruleToStopState[returnTransition.stopState].addTransition(transition);\n        }\n        for (let state of atn.states) {\n            if (state instanceof BlockStartState_1.BlockStartState) {\n                // we need to know the end state to set its start state\n                if (state.endState == null) {\n                    throw new Error(\"IllegalStateException\");\n                }\n                // block end states can only be associated to a single block start state\n                if (state.endState.startState != null) {\n                    throw new Error(\"IllegalStateException\");\n                }\n                state.endState.startState = state;\n            }\n            if (state instanceof PlusLoopbackState_1.PlusLoopbackState) {\n                let loopbackState = state;\n                for (let i = 0; i < loopbackState.numberOfTransitions; i++) {\n                    let target = loopbackState.transition(i).target;\n                    if (target instanceof PlusBlockStartState_1.PlusBlockStartState) {\n                        target.loopBackState = loopbackState;\n                    }\n                }\n            }\n            else if (state instanceof StarLoopbackState_1.StarLoopbackState) {\n                let loopbackState = state;\n                for (let i = 0; i < loopbackState.numberOfTransitions; i++) {\n                    let target = loopbackState.transition(i).target;\n                    if (target instanceof StarLoopEntryState_1.StarLoopEntryState) {\n                        target.loopBackState = loopbackState;\n                    }\n                }\n            }\n        }\n        //\n        // DECISIONS\n        //\n        let ndecisions = ATNDeserializer.toInt(data[p++]);\n        for (let i = 1; i <= ndecisions; i++) {\n            let s = ATNDeserializer.toInt(data[p++]);\n            let decState = atn.states[s];\n            atn.decisionToState.push(decState);\n            decState.decision = i - 1;\n        }\n        //\n        // LEXER ACTIONS\n        //\n        if (atn.grammarType === 0 /* LEXER */) {\n            if (supportsLexerActions) {\n                atn.lexerActions = new Array(ATNDeserializer.toInt(data[p++]));\n                for (let i = 0; i < atn.lexerActions.length; i++) {\n                    let actionType = ATNDeserializer.toInt(data[p++]);\n                    let data1 = ATNDeserializer.toInt(data[p++]);\n                    if (data1 === 0xFFFF) {\n                        data1 = -1;\n                    }\n                    let data2 = ATNDeserializer.toInt(data[p++]);\n                    if (data2 === 0xFFFF) {\n                        data2 = -1;\n                    }\n                    let lexerAction = this.lexerActionFactory(actionType, data1, data2);\n                    atn.lexerActions[i] = lexerAction;\n                }\n            }\n            else {\n                // for compatibility with older serialized ATNs, convert the old\n                // serialized action index for action transitions to the new\n                // form, which is the index of a LexerCustomAction\n                let legacyLexerActions = [];\n                for (let state of atn.states) {\n                    for (let i = 0; i < state.numberOfTransitions; i++) {\n                        let transition = state.transition(i);\n                        if (!(transition instanceof ActionTransition_1.ActionTransition)) {\n                            continue;\n                        }\n                        let ruleIndex = transition.ruleIndex;\n                        let actionIndex = transition.actionIndex;\n                        let lexerAction = new LexerCustomAction_1.LexerCustomAction(ruleIndex, actionIndex);\n                        state.setTransition(i, new ActionTransition_1.ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));\n                        legacyLexerActions.push(lexerAction);\n                    }\n                }\n                atn.lexerActions = legacyLexerActions;\n            }\n        }\n        this.markPrecedenceDecisions(atn);\n        atn.decisionToDFA = new Array(ndecisions);\n        for (let i = 0; i < ndecisions; i++) {\n            atn.decisionToDFA[i] = new DFA_1.DFA(atn.decisionToState[i], i);\n        }\n        if (this.deserializationOptions.isVerifyATN) {\n            this.verifyATN(atn);\n        }\n        if (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === 1 /* PARSER */) {\n            atn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);\n            for (let i = 0; i < atn.ruleToStartState.length; i++) {\n                atn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n            }\n            for (let i = 0; i < atn.ruleToStartState.length; i++) {\n                let bypassStart = new BasicBlockStartState_1.BasicBlockStartState();\n                bypassStart.ruleIndex = i;\n                atn.addState(bypassStart);\n                let bypassStop = new BlockEndState_1.BlockEndState();\n                bypassStop.ruleIndex = i;\n                atn.addState(bypassStop);\n                bypassStart.endState = bypassStop;\n                atn.defineDecisionState(bypassStart);\n                bypassStop.startState = bypassStart;\n                let endState;\n                let excludeTransition;\n                if (atn.ruleToStartState[i].isPrecedenceRule) {\n                    // wrap from the beginning of the rule to the StarLoopEntryState\n                    endState = undefined;\n                    for (let state of atn.states) {\n                        if (state.ruleIndex !== i) {\n                            continue;\n                        }\n                        if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {\n                            continue;\n                        }\n                        let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;\n                        if (!(maybeLoopEndState instanceof LoopEndState_1.LoopEndState)) {\n                            continue;\n                        }\n                        if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {\n                            endState = state;\n                            break;\n                        }\n                    }\n                    if (!endState) {\n                        throw new Error(\"Couldn't identify final state of the precedence rule prefix section.\");\n                    }\n                    excludeTransition = endState.loopBackState.transition(0);\n                }\n                else {\n                    endState = atn.ruleToStopState[i];\n                }\n                // all non-excluded transitions that currently target end state need to target blockEnd instead\n                for (let state of atn.states) {\n                    for (let i = 0; i < state.numberOfTransitions; i++) {\n                        let transition = state.transition(i);\n                        if (transition === excludeTransition) {\n                            continue;\n                        }\n                        if (transition.target === endState) {\n                            transition.target = bypassStop;\n                        }\n                    }\n                }\n                // all transitions leaving the rule start state need to leave blockStart instead\n                while (atn.ruleToStartState[i].numberOfTransitions > 0) {\n                    let transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);\n                    bypassStart.addTransition(transition);\n                }\n                // link the new states\n                atn.ruleToStartState[i].addTransition(new EpsilonTransition_1.EpsilonTransition(bypassStart));\n                bypassStop.addTransition(new EpsilonTransition_1.EpsilonTransition(endState));\n                let matchState = new BasicState_1.BasicState();\n                atn.addState(matchState);\n                matchState.addTransition(new AtomTransition_1.AtomTransition(bypassStop, atn.ruleToTokenType[i]));\n                bypassStart.addTransition(new EpsilonTransition_1.EpsilonTransition(matchState));\n            }\n            if (this.deserializationOptions.isVerifyATN) {\n                // reverify after modification\n                this.verifyATN(atn);\n            }\n        }\n        if (this.deserializationOptions.isOptimize) {\n            while (true) {\n                let optimizationCount = 0;\n                optimizationCount += ATNDeserializer.inlineSetRules(atn);\n                optimizationCount += ATNDeserializer.combineChainedEpsilons(atn);\n                let preserveOrder = atn.grammarType === 0 /* LEXER */;\n                optimizationCount += ATNDeserializer.optimizeSets(atn, preserveOrder);\n                if (optimizationCount === 0) {\n                    break;\n                }\n            }\n            if (this.deserializationOptions.isVerifyATN) {\n                // reverify after modification\n                this.verifyATN(atn);\n            }\n        }\n        ATNDeserializer.identifyTailCalls(atn);\n        return atn;\n    }\n    deserializeSets(data, p, sets, unicodeDeserializer) {\n        let nsets = ATNDeserializer.toInt(data[p++]);\n        for (let i = 0; i < nsets; i++) {\n            let nintervals = ATNDeserializer.toInt(data[p]);\n            p++;\n            let set = new IntervalSet_1.IntervalSet();\n            sets.push(set);\n            let containsEof = ATNDeserializer.toInt(data[p++]) !== 0;\n            if (containsEof) {\n                set.add(-1);\n            }\n            for (let j = 0; j < nintervals; j++) {\n                let a = unicodeDeserializer.readUnicode(data, p);\n                p += unicodeDeserializer.size;\n                let b = unicodeDeserializer.readUnicode(data, p);\n                p += unicodeDeserializer.size;\n                set.add(a, b);\n            }\n        }\n        return p;\n    }\n    /**\n     * Analyze the {@link StarLoopEntryState} states in the specified ATN to set\n     * the {@link StarLoopEntryState#precedenceRuleDecision} field to the\n     * correct value.\n     *\n     * @param atn The ATN.\n     */\n    markPrecedenceDecisions(atn) {\n        // Map rule index -> precedence decision for that rule\n        let rulePrecedenceDecisions = new Map();\n        for (let state of atn.states) {\n            if (!(state instanceof StarLoopEntryState_1.StarLoopEntryState)) {\n                continue;\n            }\n            /* We analyze the ATN to determine if this ATN decision state is the\n             * decision for the closure block that determines whether a\n             * precedence rule should continue or complete.\n             */\n            if (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\n                let maybeLoopEndState = state.transition(state.numberOfTransitions - 1).target;\n                if (maybeLoopEndState instanceof LoopEndState_1.LoopEndState) {\n                    if (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState_1.RuleStopState) {\n                        rulePrecedenceDecisions.set(state.ruleIndex, state);\n                        state.precedenceRuleDecision = true;\n                        state.precedenceLoopbackStates = new BitSet_1.BitSet(atn.states.length);\n                    }\n                }\n            }\n        }\n        // After marking precedence decisions, we go back through and fill in\n        // StarLoopEntryState.precedenceLoopbackStates.\n        for (let precedenceDecision of rulePrecedenceDecisions) {\n            for (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {\n                if (transition.serializationType !== 1 /* EPSILON */) {\n                    continue;\n                }\n                let epsilonTransition = transition;\n                if (epsilonTransition.outermostPrecedenceReturn !== -1) {\n                    continue;\n                }\n                precedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);\n            }\n        }\n    }\n    verifyATN(atn) {\n        // verify assumptions\n        for (let state of atn.states) {\n            this.checkCondition(state != null, \"ATN states should not be null.\");\n            if (state.stateType === ATNStateType_1.ATNStateType.INVALID_TYPE) {\n                continue;\n            }\n            this.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);\n            if (state instanceof PlusBlockStartState_1.PlusBlockStartState) {\n                this.checkCondition(state.loopBackState != null);\n            }\n            if (state instanceof StarLoopEntryState_1.StarLoopEntryState) {\n                let starLoopEntryState = state;\n                this.checkCondition(starLoopEntryState.loopBackState != null);\n                this.checkCondition(starLoopEntryState.numberOfTransitions === 2);\n                if (starLoopEntryState.transition(0).target instanceof StarBlockStartState_1.StarBlockStartState) {\n                    this.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState_1.LoopEndState);\n                    this.checkCondition(!starLoopEntryState.nonGreedy);\n                }\n                else if (starLoopEntryState.transition(0).target instanceof LoopEndState_1.LoopEndState) {\n                    this.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState_1.StarBlockStartState);\n                    this.checkCondition(starLoopEntryState.nonGreedy);\n                }\n                else {\n                    throw new Error(\"IllegalStateException\");\n                }\n            }\n            if (state instanceof StarLoopbackState_1.StarLoopbackState) {\n                this.checkCondition(state.numberOfTransitions === 1);\n                this.checkCondition(state.transition(0).target instanceof StarLoopEntryState_1.StarLoopEntryState);\n            }\n            if (state instanceof LoopEndState_1.LoopEndState) {\n                this.checkCondition(state.loopBackState != null);\n            }\n            if (state instanceof RuleStartState_1.RuleStartState) {\n                this.checkCondition(state.stopState != null);\n            }\n            if (state instanceof BlockStartState_1.BlockStartState) {\n                this.checkCondition(state.endState != null);\n            }\n            if (state instanceof BlockEndState_1.BlockEndState) {\n                this.checkCondition(state.startState != null);\n            }\n            if (state instanceof DecisionState_1.DecisionState) {\n                let decisionState = state;\n                this.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);\n            }\n            else {\n                this.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState_1.RuleStopState);\n            }\n        }\n    }\n    checkCondition(condition, message) {\n        if (!condition) {\n            throw new Error(\"IllegalStateException: \" + message);\n        }\n    }\n    static inlineSetRules(atn) {\n        let inlinedCalls = 0;\n        let ruleToInlineTransition = new Array(atn.ruleToStartState.length);\n        for (let i = 0; i < atn.ruleToStartState.length; i++) {\n            let startState = atn.ruleToStartState[i];\n            let middleState = startState;\n            while (middleState.onlyHasEpsilonTransitions\n                && middleState.numberOfOptimizedTransitions === 1\n                && middleState.getOptimizedTransition(0).serializationType === 1 /* EPSILON */) {\n                middleState = middleState.getOptimizedTransition(0).target;\n            }\n            if (middleState.numberOfOptimizedTransitions !== 1) {\n                continue;\n            }\n            let matchTransition = middleState.getOptimizedTransition(0);\n            let matchTarget = matchTransition.target;\n            if (matchTransition.isEpsilon\n                || !matchTarget.onlyHasEpsilonTransitions\n                || matchTarget.numberOfOptimizedTransitions !== 1\n                || !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState_1.RuleStopState)) {\n                continue;\n            }\n            switch (matchTransition.serializationType) {\n                case 5 /* ATOM */:\n                case 2 /* RANGE */:\n                case 7 /* SET */:\n                    ruleToInlineTransition[i] = matchTransition;\n                    break;\n                case 8 /* NOT_SET */:\n                case 9 /* WILDCARD */:\n                    // not implemented yet\n                    continue;\n                default:\n                    continue;\n            }\n        }\n        for (let state of atn.states) {\n            if (state.ruleIndex < 0) {\n                continue;\n            }\n            let optimizedTransitions;\n            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\n                let transition = state.getOptimizedTransition(i);\n                if (!(transition instanceof RuleTransition_1.RuleTransition)) {\n                    if (optimizedTransitions != null) {\n                        optimizedTransitions.push(transition);\n                    }\n                    continue;\n                }\n                let ruleTransition = transition;\n                let effective = ruleToInlineTransition[ruleTransition.target.ruleIndex];\n                if (effective == null) {\n                    if (optimizedTransitions != null) {\n                        optimizedTransitions.push(transition);\n                    }\n                    continue;\n                }\n                if (optimizedTransitions == null) {\n                    optimizedTransitions = [];\n                    for (let j = 0; j < i; j++) {\n                        optimizedTransitions.push(state.getOptimizedTransition(i));\n                    }\n                }\n                inlinedCalls++;\n                let target = ruleTransition.followState;\n                let intermediateState = new BasicState_1.BasicState();\n                intermediateState.setRuleIndex(target.ruleIndex);\n                atn.addState(intermediateState);\n                optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(intermediateState));\n                switch (effective.serializationType) {\n                    case 5 /* ATOM */:\n                        intermediateState.addTransition(new AtomTransition_1.AtomTransition(target, effective._label));\n                        break;\n                    case 2 /* RANGE */:\n                        intermediateState.addTransition(new RangeTransition_1.RangeTransition(target, effective.from, effective.to));\n                        break;\n                    case 7 /* SET */:\n                        intermediateState.addTransition(new SetTransition_1.SetTransition(target, effective.label));\n                        break;\n                    default:\n                        throw new Error(\"UnsupportedOperationException\");\n                }\n            }\n            if (optimizedTransitions != null) {\n                if (state.isOptimized) {\n                    while (state.numberOfOptimizedTransitions > 0) {\n                        state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);\n                    }\n                }\n                for (let transition of optimizedTransitions) {\n                    state.addOptimizedTransition(transition);\n                }\n            }\n        }\n        if (ParserATNSimulator_1.ParserATNSimulator.debug) {\n            console.log(\"ATN runtime optimizer removed \" + inlinedCalls + \" rule invocations by inlining sets.\");\n        }\n        return inlinedCalls;\n    }\n    static combineChainedEpsilons(atn) {\n        let removedEdges = 0;\n        for (let state of atn.states) {\n            if (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState_1.RuleStopState) {\n                continue;\n            }\n            let optimizedTransitions;\n            nextTransition: for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\n                let transition = state.getOptimizedTransition(i);\n                let intermediate = transition.target;\n                if (transition.serializationType !== 1 /* EPSILON */\n                    || transition.outermostPrecedenceReturn !== -1\n                    || intermediate.stateType !== ATNStateType_1.ATNStateType.BASIC\n                    || !intermediate.onlyHasEpsilonTransitions) {\n                    if (optimizedTransitions != null) {\n                        optimizedTransitions.push(transition);\n                    }\n                    continue nextTransition;\n                }\n                for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {\n                    if (intermediate.getOptimizedTransition(j).serializationType !== 1 /* EPSILON */\n                        || intermediate.getOptimizedTransition(j).outermostPrecedenceReturn !== -1) {\n                        if (optimizedTransitions != null) {\n                            optimizedTransitions.push(transition);\n                        }\n                        continue nextTransition;\n                    }\n                }\n                removedEdges++;\n                if (optimizedTransitions == null) {\n                    optimizedTransitions = [];\n                    for (let j = 0; j < i; j++) {\n                        optimizedTransitions.push(state.getOptimizedTransition(j));\n                    }\n                }\n                for (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {\n                    let target = intermediate.getOptimizedTransition(j).target;\n                    optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(target));\n                }\n            }\n            if (optimizedTransitions != null) {\n                if (state.isOptimized) {\n                    while (state.numberOfOptimizedTransitions > 0) {\n                        state.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);\n                    }\n                }\n                for (let transition of optimizedTransitions) {\n                    state.addOptimizedTransition(transition);\n                }\n            }\n        }\n        if (ParserATNSimulator_1.ParserATNSimulator.debug) {\n            console.log(\"ATN runtime optimizer removed \" + removedEdges + \" transitions by combining chained epsilon transitions.\");\n        }\n        return removedEdges;\n    }\n    static optimizeSets(atn, preserveOrder) {\n        if (preserveOrder) {\n            // this optimization currently doesn't preserve edge order.\n            return 0;\n        }\n        let removedPaths = 0;\n        let decisions = atn.decisionToState;\n        for (let decision of decisions) {\n            let setTransitions = new IntervalSet_1.IntervalSet();\n            for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {\n                let epsTransition = decision.getOptimizedTransition(i);\n                if (!(epsTransition instanceof EpsilonTransition_1.EpsilonTransition)) {\n                    continue;\n                }\n                if (epsTransition.target.numberOfOptimizedTransitions !== 1) {\n                    continue;\n                }\n                let transition = epsTransition.target.getOptimizedTransition(0);\n                if (!(transition.target instanceof BlockEndState_1.BlockEndState)) {\n                    continue;\n                }\n                if (transition instanceof NotSetTransition_1.NotSetTransition) {\n                    // TODO: not yet implemented\n                    continue;\n                }\n                if (transition instanceof AtomTransition_1.AtomTransition\n                    || transition instanceof RangeTransition_1.RangeTransition\n                    || transition instanceof SetTransition_1.SetTransition) {\n                    setTransitions.add(i);\n                }\n            }\n            if (setTransitions.size <= 1) {\n                continue;\n            }\n            let optimizedTransitions = [];\n            for (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {\n                if (!setTransitions.contains(i)) {\n                    optimizedTransitions.push(decision.getOptimizedTransition(i));\n                }\n            }\n            let blockEndState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;\n            let matchSet = new IntervalSet_1.IntervalSet();\n            for (let interval of setTransitions.intervals) {\n                for (let j = interval.a; j <= interval.b; j++) {\n                    let matchTransition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);\n                    if (matchTransition instanceof NotSetTransition_1.NotSetTransition) {\n                        throw new Error(\"Not yet implemented.\");\n                    }\n                    else {\n                        matchSet.addAll(matchTransition.label);\n                    }\n                }\n            }\n            let newTransition;\n            if (matchSet.intervals.length === 1) {\n                if (matchSet.size === 1) {\n                    newTransition = new AtomTransition_1.AtomTransition(blockEndState, matchSet.minElement);\n                }\n                else {\n                    let matchInterval = matchSet.intervals[0];\n                    newTransition = new RangeTransition_1.RangeTransition(blockEndState, matchInterval.a, matchInterval.b);\n                }\n            }\n            else {\n                newTransition = new SetTransition_1.SetTransition(blockEndState, matchSet);\n            }\n            let setOptimizedState = new BasicState_1.BasicState();\n            setOptimizedState.setRuleIndex(decision.ruleIndex);\n            atn.addState(setOptimizedState);\n            setOptimizedState.addTransition(newTransition);\n            optimizedTransitions.push(new EpsilonTransition_1.EpsilonTransition(setOptimizedState));\n            removedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;\n            if (decision.isOptimized) {\n                while (decision.numberOfOptimizedTransitions > 0) {\n                    decision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);\n                }\n            }\n            for (let transition of optimizedTransitions) {\n                decision.addOptimizedTransition(transition);\n            }\n        }\n        if (ParserATNSimulator_1.ParserATNSimulator.debug) {\n            console.log(\"ATN runtime optimizer removed \" + removedPaths + \" paths by collapsing sets.\");\n        }\n        return removedPaths;\n    }\n    static identifyTailCalls(atn) {\n        for (let state of atn.states) {\n            for (let i = 0; i < state.numberOfTransitions; i++) {\n                let transition = state.transition(i);\n                if (!(transition instanceof RuleTransition_1.RuleTransition)) {\n                    continue;\n                }\n                transition.tailCall = this.testTailCall(atn, transition, false);\n                transition.optimizedTailCall = this.testTailCall(atn, transition, true);\n            }\n            if (!state.isOptimized) {\n                continue;\n            }\n            for (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\n                let transition = state.getOptimizedTransition(i);\n                if (!(transition instanceof RuleTransition_1.RuleTransition)) {\n                    continue;\n                }\n                transition.tailCall = this.testTailCall(atn, transition, false);\n                transition.optimizedTailCall = this.testTailCall(atn, transition, true);\n            }\n        }\n    }\n    static testTailCall(atn, transition, optimizedPath) {\n        if (!optimizedPath && transition.tailCall) {\n            return true;\n        }\n        if (optimizedPath && transition.optimizedTailCall) {\n            return true;\n        }\n        let reachable = new BitSet_1.BitSet(atn.states.length);\n        let worklist = [];\n        worklist.push(transition.followState);\n        while (true) {\n            let state = worklist.pop();\n            if (!state) {\n                break;\n            }\n            if (reachable.get(state.stateNumber)) {\n                continue;\n            }\n            if (state instanceof RuleStopState_1.RuleStopState) {\n                continue;\n            }\n            if (!state.onlyHasEpsilonTransitions) {\n                return false;\n            }\n            let transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;\n            for (let i = 0; i < transitionCount; i++) {\n                let t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);\n                if (t.serializationType !== 1 /* EPSILON */) {\n                    return false;\n                }\n                worklist.push(t.target);\n            }\n        }\n        return true;\n    }\n    static toInt(c) {\n        return c;\n    }\n    static toInt32(data, offset) {\n        return (data[offset] | (data[offset + 1] << 16)) >>> 0;\n    }\n    static toUUID(data, offset) {\n        let leastSigBits = ATNDeserializer.toInt32(data, offset);\n        let lessSigBits = ATNDeserializer.toInt32(data, offset + 2);\n        let moreSigBits = ATNDeserializer.toInt32(data, offset + 4);\n        let mostSigBits = ATNDeserializer.toInt32(data, offset + 6);\n        return new UUID_1.UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);\n    }\n    edgeFactory(atn, type, src, trg, arg1, arg2, arg3, sets) {\n        let target = atn.states[trg];\n        switch (type) {\n            case 1 /* EPSILON */: return new EpsilonTransition_1.EpsilonTransition(target);\n            case 2 /* RANGE */:\n                if (arg3 !== 0) {\n                    return new RangeTransition_1.RangeTransition(target, Token_1.Token.EOF, arg2);\n                }\n                else {\n                    return new RangeTransition_1.RangeTransition(target, arg1, arg2);\n                }\n            case 3 /* RULE */:\n                let rt = new RuleTransition_1.RuleTransition(atn.states[arg1], arg2, arg3, target);\n                return rt;\n            case 4 /* PREDICATE */:\n                let pt = new PredicateTransition_1.PredicateTransition(target, arg1, arg2, arg3 !== 0);\n                return pt;\n            case 10 /* PRECEDENCE */:\n                return new PrecedencePredicateTransition_1.PrecedencePredicateTransition(target, arg1);\n            case 5 /* ATOM */:\n                if (arg3 !== 0) {\n                    return new AtomTransition_1.AtomTransition(target, Token_1.Token.EOF);\n                }\n                else {\n                    return new AtomTransition_1.AtomTransition(target, arg1);\n                }\n            case 6 /* ACTION */:\n                let a = new ActionTransition_1.ActionTransition(target, arg1, arg2, arg3 !== 0);\n                return a;\n            case 7 /* SET */: return new SetTransition_1.SetTransition(target, sets[arg1]);\n            case 8 /* NOT_SET */: return new NotSetTransition_1.NotSetTransition(target, sets[arg1]);\n            case 9 /* WILDCARD */: return new WildcardTransition_1.WildcardTransition(target);\n        }\n        throw new Error(\"The specified transition type is not valid.\");\n    }\n    stateFactory(type, ruleIndex) {\n        let s;\n        switch (type) {\n            case ATNStateType_1.ATNStateType.INVALID_TYPE: return new InvalidState_1.InvalidState();\n            case ATNStateType_1.ATNStateType.BASIC:\n                s = new BasicState_1.BasicState();\n                break;\n            case ATNStateType_1.ATNStateType.RULE_START:\n                s = new RuleStartState_1.RuleStartState();\n                break;\n            case ATNStateType_1.ATNStateType.BLOCK_START:\n                s = new BasicBlockStartState_1.BasicBlockStartState();\n                break;\n            case ATNStateType_1.ATNStateType.PLUS_BLOCK_START:\n                s = new PlusBlockStartState_1.PlusBlockStartState();\n                break;\n            case ATNStateType_1.ATNStateType.STAR_BLOCK_START:\n                s = new StarBlockStartState_1.StarBlockStartState();\n                break;\n            case ATNStateType_1.ATNStateType.TOKEN_START:\n                s = new TokensStartState_1.TokensStartState();\n                break;\n            case ATNStateType_1.ATNStateType.RULE_STOP:\n                s = new RuleStopState_1.RuleStopState();\n                break;\n            case ATNStateType_1.ATNStateType.BLOCK_END:\n                s = new BlockEndState_1.BlockEndState();\n                break;\n            case ATNStateType_1.ATNStateType.STAR_LOOP_BACK:\n                s = new StarLoopbackState_1.StarLoopbackState();\n                break;\n            case ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY:\n                s = new StarLoopEntryState_1.StarLoopEntryState();\n                break;\n            case ATNStateType_1.ATNStateType.PLUS_LOOP_BACK:\n                s = new PlusLoopbackState_1.PlusLoopbackState();\n                break;\n            case ATNStateType_1.ATNStateType.LOOP_END:\n                s = new LoopEndState_1.LoopEndState();\n                break;\n            default:\n                let message = `The specified state type ${type} is not valid.`;\n                throw new Error(message);\n        }\n        s.ruleIndex = ruleIndex;\n        return s;\n    }\n    lexerActionFactory(type, data1, data2) {\n        switch (type) {\n            case 0 /* CHANNEL */:\n                return new LexerChannelAction_1.LexerChannelAction(data1);\n            case 1 /* CUSTOM */:\n                return new LexerCustomAction_1.LexerCustomAction(data1, data2);\n            case 2 /* MODE */:\n                return new LexerModeAction_1.LexerModeAction(data1);\n            case 3 /* MORE */:\n                return LexerMoreAction_1.LexerMoreAction.INSTANCE;\n            case 4 /* POP_MODE */:\n                return LexerPopModeAction_1.LexerPopModeAction.INSTANCE;\n            case 5 /* PUSH_MODE */:\n                return new LexerPushModeAction_1.LexerPushModeAction(data1);\n            case 6 /* SKIP */:\n                return LexerSkipAction_1.LexerSkipAction.INSTANCE;\n            case 7 /* TYPE */:\n                return new LexerTypeAction_1.LexerTypeAction(data1);\n            default:\n                let message = `The specified lexer action type ${type} is not valid.`;\n                throw new Error(message);\n        }\n    }\n}\n/* WARNING: DO NOT MERGE THESE LINES. If UUIDs differ during a merge,\n * resolve the conflict by generating a new ID!\n */\n/**\n * This is the earliest supported serialized UUID.\n */\nATNDeserializer.BASE_SERIALIZED_UUID = UUID_1.UUID.fromString(\"E4178468-DF95-44D0-AD87-F22A5D5FB6D3\");\n/**\n * This UUID indicates an extension of {@link #ADDED_PRECEDENCE_TRANSITIONS}\n * for the addition of lexer actions encoded as a sequence of\n * {@link LexerAction} instances.\n */\nATNDeserializer.ADDED_LEXER_ACTIONS = UUID_1.UUID.fromString(\"AB35191A-1603-487E-B75A-479B831EAF6D\");\n/**\n * This UUID indicates the serialized ATN contains two sets of\n * IntervalSets, where the second set's values are encoded as\n * 32-bit integers to support the full Unicode SMP range up to U+10FFFF.\n */\nATNDeserializer.ADDED_UNICODE_SMP = UUID_1.UUID.fromString(\"C23FEA89-0605-4f51-AFB8-058BCAB8C91B\");\n/**\n * This list contains all of the currently supported UUIDs, ordered by when\n * the feature first appeared in this branch.\n */\nATNDeserializer.SUPPORTED_UUIDS = [\n    ATNDeserializer.BASE_SERIALIZED_UUID,\n    ATNDeserializer.ADDED_LEXER_ACTIONS,\n    ATNDeserializer.ADDED_UNICODE_SMP,\n];\n/**\n * This is the current serialized UUID.\n */\nATNDeserializer.SERIALIZED_UUID = ATNDeserializer.ADDED_UNICODE_SMP;\n__decorate([\n    Decorators_1.NotNull\n], ATNDeserializer.prototype, \"deserializationOptions\", void 0);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ATNDeserializer.prototype, \"deserialize\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ATNDeserializer.prototype, \"markPrecedenceDecisions\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], ATNDeserializer.prototype, \"edgeFactory\", null);\nexports.ATNDeserializer = ATNDeserializer;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:25.9683447-07:00\n\nimport { ActionTransition } from \"./ActionTransition\";\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\nimport { ATN } from \"./ATN\";\nimport { ATNDeserializationOptions } from \"./ATNDeserializationOptions\";\nimport { ATNState } from \"./ATNState\";\nimport { ATNStateType } from \"./ATNStateType\";\nimport { ATNType } from \"./ATNType\";\nimport { AtomTransition } from \"./AtomTransition\";\nimport { BasicBlockStartState } from \"./BasicBlockStartState\";\nimport { BasicState } from \"./BasicState\";\nimport { BitSet } from \"../misc/BitSet\";\nimport { BlockEndState } from \"./BlockEndState\";\nimport { BlockStartState } from \"./BlockStartState\";\nimport { DecisionState } from \"./DecisionState\";\nimport { DFA } from \"../dfa/DFA\";\nimport { EpsilonTransition } from \"./EpsilonTransition\";\nimport { Interval } from \"../misc/Interval\";\nimport { IntervalSet } from \"../misc/IntervalSet\";\nimport { InvalidState } from \"./InvalidState\";\nimport { LexerAction } from \"./LexerAction\";\nimport { LexerActionType } from \"./LexerActionType\";\nimport { LexerChannelAction } from \"./LexerChannelAction\";\nimport { LexerCustomAction } from \"./LexerCustomAction\";\nimport { LexerModeAction } from \"./LexerModeAction\";\nimport { LexerMoreAction } from \"./LexerMoreAction\";\nimport { LexerPopModeAction } from \"./LexerPopModeAction\";\nimport { LexerPushModeAction } from \"./LexerPushModeAction\";\nimport { LexerSkipAction } from \"./LexerSkipAction\";\nimport { LexerTypeAction } from \"./LexerTypeAction\";\nimport { LoopEndState } from \"./LoopEndState\";\nimport { NotNull } from \"../Decorators\";\nimport { NotSetTransition } from \"./NotSetTransition\";\nimport { ParserATNSimulator } from \"./ParserATNSimulator\";\nimport { PlusBlockStartState } from \"./PlusBlockStartState\";\nimport { PlusLoopbackState } from \"./PlusLoopbackState\";\nimport { PrecedencePredicateTransition } from \"./PrecedencePredicateTransition\";\nimport { PredicateTransition } from \"./PredicateTransition\";\nimport { RangeTransition } from \"./RangeTransition\";\nimport { RuleStartState } from \"./RuleStartState\";\nimport { RuleStopState } from \"./RuleStopState\";\nimport { RuleTransition } from \"./RuleTransition\";\nimport { SetTransition } from \"./SetTransition\";\nimport { StarBlockStartState } from \"./StarBlockStartState\";\nimport { StarLoopbackState } from \"./StarLoopbackState\";\nimport { StarLoopEntryState } from \"./StarLoopEntryState\";\nimport { Token } from \"../Token\";\nimport { TokensStartState } from \"./TokensStartState\";\nimport { Transition } from \"./Transition\";\nimport { TransitionType } from \"./TransitionType\";\nimport { UUID } from \"../misc/UUID\";\nimport { WildcardTransition } from \"./WildcardTransition\";\n\ninterface UnicodeDeserializer {\n\t// Wrapper for readInt() or readInt32()\n\treadUnicode(data: Uint16Array, p: number): number;\n\n\t// Work around Java not allowing mutation of captured variables\n\t// by returning amount by which to increment p after each read\n\treadonly size: number;\n}\n\nconst enum UnicodeDeserializingMode {\n\tUNICODE_BMP,\n\tUNICODE_SMP,\n}\n\n/**\n *\n * @author Sam Harwell\n */\nexport class ATNDeserializer {\n\tstatic get SERIALIZED_VERSION(): number {\n\t\t/* This value should never change. Updates following this version are\n\t\t * reflected as change in the unique ID SERIALIZED_UUID.\n\t\t */\n\t\treturn 3;\n\t}\n\n\t/* WARNING: DO NOT MERGE THESE LINES. If UUIDs differ during a merge,\n\t * resolve the conflict by generating a new ID!\n\t */\n\n\t/**\n\t * This is the earliest supported serialized UUID.\n\t */\n\tprivate static readonly BASE_SERIALIZED_UUID: UUID = UUID.fromString(\"E4178468-DF95-44D0-AD87-F22A5D5FB6D3\");\n\t/**\n\t * This UUID indicates an extension of {@link #ADDED_PRECEDENCE_TRANSITIONS}\n\t * for the addition of lexer actions encoded as a sequence of\n\t * {@link LexerAction} instances.\n\t */\n\tprivate static readonly ADDED_LEXER_ACTIONS: UUID = UUID.fromString(\"AB35191A-1603-487E-B75A-479B831EAF6D\");\n\t/**\n\t * This UUID indicates the serialized ATN contains two sets of\n\t * IntervalSets, where the second set's values are encoded as\n\t * 32-bit integers to support the full Unicode SMP range up to U+10FFFF.\n\t */\n\tprivate static readonly ADDED_UNICODE_SMP: UUID = UUID.fromString(\"C23FEA89-0605-4f51-AFB8-058BCAB8C91B\");\n\t/**\n\t * This list contains all of the currently supported UUIDs, ordered by when\n\t * the feature first appeared in this branch.\n\t */\n\tprivate static readonly SUPPORTED_UUIDS: UUID[] = [\n\t\tATNDeserializer.BASE_SERIALIZED_UUID,\n\t\tATNDeserializer.ADDED_LEXER_ACTIONS,\n\t\tATNDeserializer.ADDED_UNICODE_SMP,\n\t];\n\n\t/**\n\t * This is the current serialized UUID.\n\t */\n\tprivate static readonly SERIALIZED_UUID: UUID = ATNDeserializer.ADDED_UNICODE_SMP;\n\n\t@NotNull\n\tprivate readonly deserializationOptions: ATNDeserializationOptions;\n\n\tconstructor(deserializationOptions?: ATNDeserializationOptions) {\n\t\tif (deserializationOptions == null) {\n\t\t\tdeserializationOptions = ATNDeserializationOptions.defaultOptions;\n\t\t}\n\n\t\tthis.deserializationOptions = deserializationOptions;\n\t}\n\n\t/**\n\t * Determines if a particular serialized representation of an ATN supports\n\t * a particular feature, identified by the {@link UUID} used for serializing\n\t * the ATN at the time the feature was first introduced.\n\t *\n\t * @param feature The {@link UUID} marking the first time the feature was\n\t * supported in the serialized ATN.\n\t * @param actualUuid The {@link UUID} of the actual serialized ATN which is\n\t * currently being deserialized.\n\t * @returns `true` if the `actualUuid` value represents a\n\t * serialized ATN at or after the feature identified by `feature` was\n\t * introduced; otherwise, `false`.\n\t */\n\tprotected static isFeatureSupported(feature: UUID, actualUuid: UUID): boolean {\n\t\tlet featureIndex: number = ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(feature));\n\t\tif (featureIndex < 0) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(actualUuid)) >= featureIndex;\n\t}\n\n\tprivate static getUnicodeDeserializer(mode: UnicodeDeserializingMode): UnicodeDeserializer {\n\t\tif (mode === UnicodeDeserializingMode.UNICODE_BMP) {\n\t\t\treturn {\n\t\t\t\treadUnicode: (data: Uint16Array, p: number): number => {\n\t\t\t\t\treturn ATNDeserializer.toInt(data[p]);\n\t\t\t\t},\n\t\t\t\tsize: 1,\n\t\t\t};\n\t\t} else {\n\t\t\treturn {\n\t\t\t\treadUnicode: (data: Uint16Array, p: number): number => {\n\t\t\t\t\treturn ATNDeserializer.toInt32(data, p);\n\t\t\t\t},\n\t\t\t\tsize: 2,\n\t\t\t};\n\t\t}\n\t}\n\n\tpublic deserialize(@NotNull data: Uint16Array): ATN {\n\t\tdata = data.slice(0);\n\n\t\t// Each Uint16 value in data is shifted by +2 at the entry to this method. This is an encoding optimization\n\t\t// targeting the serialized values 0 and -1 (serialized to 0xFFFF), each of which are very common in the\n\t\t// serialized form of the ATN. In the modified UTF-8 that Java uses for compiled string literals, these two\n\t\t// character values have multi-byte forms. By shifting each value by +2, they become characters 2 and 1 prior to\n\t\t// writing the string, each of which have single-byte representations. Since the shift occurs in the tool during\n\t\t// ATN serialization, each target is responsible for adjusting the values during deserialization.\n\t\t//\n\t\t// As a special case, note that the first element of data is not adjusted because it contains the major version\n\t\t// number of the serialized ATN, which was fixed at 3 at the time the value shifting was implemented.\n\t\tfor (let i = 1; i < data.length; i++) {\n\t\t\tdata[i] = (data[i] - 2) & 0xFFFF;\n\t\t}\n\n\t\tlet p: number = 0;\n\t\tlet version: number = ATNDeserializer.toInt(data[p++]);\n\t\tif (version !== ATNDeserializer.SERIALIZED_VERSION) {\n\t\t\tlet reason = `Could not deserialize ATN with version ${version} (expected ${ATNDeserializer.SERIALIZED_VERSION}).`;\n\t\t\tthrow new Error(reason);\n\t\t}\n\n\t\tlet uuid: UUID = ATNDeserializer.toUUID(data, p);\n\t\tp += 8;\n\t\tif (ATNDeserializer.SUPPORTED_UUIDS.findIndex((e) => e.equals(uuid)) < 0) {\n\t\t\tlet reason = `Could not deserialize ATN with UUID ${uuid} (expected ${ATNDeserializer.SERIALIZED_UUID} or a legacy UUID).`;\n\t\t\tthrow new Error(reason);\n\t\t}\n\n\t\tlet supportsLexerActions: boolean = ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, uuid);\n\n\t\tlet grammarType: ATNType = ATNDeserializer.toInt(data[p++]);\n\t\tlet maxTokenType: number = ATNDeserializer.toInt(data[p++]);\n\t\tlet atn: ATN = new ATN(grammarType, maxTokenType);\n\n\t\t//\n\t\t// STATES\n\t\t//\n\t\tlet loopBackStateNumbers: Array<[LoopEndState, number]> = [];\n\t\tlet endStateNumbers: Array<[BlockStartState, number]> = [];\n\t\tlet nstates: number = ATNDeserializer.toInt(data[p++]);\n\t\tfor (let i = 0; i < nstates; i++) {\n\t\t\tlet stype: ATNStateType = ATNDeserializer.toInt(data[p++]);\n\t\t\t// ignore bad type of states\n\t\t\tif (stype === ATNStateType.INVALID_TYPE) {\n\t\t\t\tatn.addState(new InvalidState());\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet ruleIndex: number = ATNDeserializer.toInt(data[p++]);\n\t\t\tif (ruleIndex === 0xFFFF) {\n\t\t\t\truleIndex = -1;\n\t\t\t}\n\n\t\t\tlet s: ATNState = this.stateFactory(stype, ruleIndex);\n\t\t\tif (stype === ATNStateType.LOOP_END) { // special case\n\t\t\t\tlet loopBackStateNumber: number = ATNDeserializer.toInt(data[p++]);\n\t\t\t\tloopBackStateNumbers.push([s as LoopEndState, loopBackStateNumber]);\n\t\t\t}\n\t\t\telse if (s instanceof BlockStartState) {\n\t\t\t\tlet endStateNumber: number = ATNDeserializer.toInt(data[p++]);\n\t\t\t\tendStateNumbers.push([s, endStateNumber]);\n\t\t\t}\n\t\t\tatn.addState(s);\n\t\t}\n\n\t\t// delay the assignment of loop back and end states until we know all the state instances have been initialized\n\t\tfor (let pair of loopBackStateNumbers) {\n\t\t\tpair[0].loopBackState = atn.states[pair[1]];\n\t\t}\n\n\t\tfor (let pair of endStateNumbers) {\n\t\t\tpair[0].endState = atn.states[pair[1]] as BlockEndState;\n\t\t}\n\n\t\tlet numNonGreedyStates: number = ATNDeserializer.toInt(data[p++]);\n\t\tfor (let i = 0; i < numNonGreedyStates; i++) {\n\t\t\tlet stateNumber: number = ATNDeserializer.toInt(data[p++]);\n\t\t\t(atn.states[stateNumber] as DecisionState).nonGreedy = true;\n\t\t}\n\n\t\tlet numSllDecisions: number = ATNDeserializer.toInt(data[p++]);\n\t\tfor (let i = 0; i < numSllDecisions; i++) {\n\t\t\tlet stateNumber: number = ATNDeserializer.toInt(data[p++]);\n\t\t\t(atn.states[stateNumber] as DecisionState).sll = true;\n\t\t}\n\n\t\tlet numPrecedenceStates: number = ATNDeserializer.toInt(data[p++]);\n\t\tfor (let i = 0; i < numPrecedenceStates; i++) {\n\t\t\tlet stateNumber: number = ATNDeserializer.toInt(data[p++]);\n\t\t\t(atn.states[stateNumber] as RuleStartState).isPrecedenceRule = true;\n\t\t}\n\n\t\t//\n\t\t// RULES\n\t\t//\n\t\tlet nrules: number = ATNDeserializer.toInt(data[p++]);\n\t\tif (atn.grammarType === ATNType.LEXER) {\n\t\t\tatn.ruleToTokenType = new Int32Array(nrules);\n\t\t}\n\n\t\tatn.ruleToStartState = new Array<RuleStartState>(nrules);\n\t\tfor (let i = 0; i < nrules; i++) {\n\t\t\tlet s: number = ATNDeserializer.toInt(data[p++]);\n\t\t\tlet startState: RuleStartState = atn.states[s] as RuleStartState;\n\t\t\tstartState.leftFactored = ATNDeserializer.toInt(data[p++]) !== 0;\n\t\t\tatn.ruleToStartState[i] = startState;\n\t\t\tif (atn.grammarType === ATNType.LEXER) {\n\t\t\t\tlet tokenType: number = ATNDeserializer.toInt(data[p++]);\n\t\t\t\tif (tokenType === 0xFFFF) {\n\t\t\t\t\ttokenType = Token.EOF;\n\t\t\t\t}\n\n\t\t\t\tatn.ruleToTokenType[i] = tokenType;\n\n\t\t\t\tif (!ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_LEXER_ACTIONS, uuid)) {\n\t\t\t\t\t// this piece of unused metadata was serialized prior to the\n\t\t\t\t\t// addition of LexerAction\n\t\t\t\t\tlet actionIndexIgnored: number = ATNDeserializer.toInt(data[p++]);\n\t\t\t\t\tif (actionIndexIgnored === 0xFFFF) {\n\t\t\t\t\t\tactionIndexIgnored = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tatn.ruleToStopState = new Array<RuleStopState>(nrules);\n\t\tfor (let state of atn.states) {\n\t\t\tif (!(state instanceof RuleStopState)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tatn.ruleToStopState[state.ruleIndex] = state;\n\t\t\tatn.ruleToStartState[state.ruleIndex].stopState = state;\n\t\t}\n\n\t\t//\n\t\t// MODES\n\t\t//\n\t\tlet nmodes: number = ATNDeserializer.toInt(data[p++]);\n\t\tfor (let i = 0; i < nmodes; i++) {\n\t\t\tlet s: number = ATNDeserializer.toInt(data[p++]);\n\t\t\tatn.modeToStartState.push(atn.states[s] as TokensStartState);\n\t\t}\n\n\t\tatn.modeToDFA = new Array<DFA>(nmodes);\n\t\tfor (let i = 0; i < nmodes; i++) {\n\t\t\tatn.modeToDFA[i] = new DFA(atn.modeToStartState[i]);\n\t\t}\n\n\t\t//\n\t\t// SETS\n\t\t//\n\t\tlet sets: IntervalSet[] = [];\n\n\t\t// First, read all sets with 16-bit Unicode code points <= U+FFFF.\n\t\tp = this.deserializeSets(data, p, sets, ATNDeserializer.getUnicodeDeserializer(UnicodeDeserializingMode.UNICODE_BMP));\n\n\t\t// Next, if the ATN was serialized with the Unicode SMP feature,\n\t\t// deserialize sets with 32-bit arguments <= U+10FFFF.\n\t\tif (ATNDeserializer.isFeatureSupported(ATNDeserializer.ADDED_UNICODE_SMP, uuid)) {\n\t\t\tp = this.deserializeSets(data, p, sets, ATNDeserializer.getUnicodeDeserializer(UnicodeDeserializingMode.UNICODE_SMP));\n\t\t}\n\n\t\t//\n\t\t// EDGES\n\t\t//\n\t\tlet nedges: number = ATNDeserializer.toInt(data[p++]);\n\t\tfor (let i = 0; i < nedges; i++) {\n\t\t\tlet src: number = ATNDeserializer.toInt(data[p]);\n\t\t\tlet trg: number = ATNDeserializer.toInt(data[p + 1]);\n\t\t\tlet ttype: number = ATNDeserializer.toInt(data[p + 2]);\n\t\t\tlet arg1: number = ATNDeserializer.toInt(data[p + 3]);\n\t\t\tlet arg2: number = ATNDeserializer.toInt(data[p + 4]);\n\t\t\tlet arg3: number = ATNDeserializer.toInt(data[p + 5]);\n\t\t\tlet trans: Transition = this.edgeFactory(atn, ttype, src, trg, arg1, arg2, arg3, sets);\n\t\t\t// console.log(`EDGE ${trans.constructor.name} ${src}->${trg} ${Transition.serializationNames[ttype]} ${arg1},${arg2},${arg3}`);\n\t\t\tlet srcState: ATNState = atn.states[src];\n\t\t\tsrcState.addTransition(trans);\n\t\t\tp += 6;\n\t\t}\n\n\t\t// edges for rule stop states can be derived, so they aren't serialized\n\t\tinterface T { stopState: number; returnState: number; outermostPrecedenceReturn: number; }\n\t\tlet returnTransitionsSet = new Array2DHashSet<T>({\n\t\t\thashCode: (o: T) => o.stopState ^ o.returnState ^ o.outermostPrecedenceReturn,\n\n\t\t\tequals: (a: T, b: T): boolean => {\n\t\t\t\treturn a.stopState === b.stopState\n\t\t\t\t\t&& a.returnState === b.returnState\n\t\t\t\t\t&& a.outermostPrecedenceReturn === b.outermostPrecedenceReturn;\n\t\t\t},\n\t\t});\n\t\tlet returnTransitions: T[] = [];\n\t\tfor (let state of atn.states) {\n\t\t\tlet returningToLeftFactored: boolean = state.ruleIndex >= 0 && atn.ruleToStartState[state.ruleIndex].leftFactored;\n\t\t\tfor (let i = 0; i < state.numberOfTransitions; i++) {\n\t\t\t\tlet t: Transition = state.transition(i);\n\t\t\t\tif (!(t instanceof RuleTransition)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet ruleTransition: RuleTransition = t;\n\t\t\t\tlet returningFromLeftFactored: boolean = atn.ruleToStartState[ruleTransition.target.ruleIndex].leftFactored;\n\t\t\t\tif (!returningFromLeftFactored && returningToLeftFactored) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet outermostPrecedenceReturn: number = -1;\n\t\t\t\tif (atn.ruleToStartState[ruleTransition.target.ruleIndex].isPrecedenceRule) {\n\t\t\t\t\tif (ruleTransition.precedence === 0) {\n\t\t\t\t\t\toutermostPrecedenceReturn = ruleTransition.target.ruleIndex;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet current = { stopState: ruleTransition.target.ruleIndex, returnState: ruleTransition.followState.stateNumber, outermostPrecedenceReturn };\n\t\t\t\tif (returnTransitionsSet.add(current)) {\n\t\t\t\t\treturnTransitions.push(current);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Add all elements from returnTransitions to the ATN\n\t\tfor (let returnTransition of returnTransitions) {\n\t\t\tlet transition = new EpsilonTransition(atn.states[returnTransition.returnState], returnTransition.outermostPrecedenceReturn);\n\t\t\tatn.ruleToStopState[returnTransition.stopState].addTransition(transition);\n\t\t}\n\n\t\tfor (let state of atn.states) {\n\t\t\tif (state instanceof BlockStartState) {\n\t\t\t\t// we need to know the end state to set its start state\n\t\t\t\tif (state.endState == null) {\n\t\t\t\t\tthrow new Error(\"IllegalStateException\");\n\t\t\t\t}\n\n\t\t\t\t// block end states can only be associated to a single block start state\n\t\t\t\tif (state.endState.startState != null) {\n\t\t\t\t\tthrow new Error(\"IllegalStateException\");\n\t\t\t\t}\n\n\t\t\t\tstate.endState.startState = state;\n\t\t\t}\n\n\t\t\tif (state instanceof PlusLoopbackState) {\n\t\t\t\tlet loopbackState: PlusLoopbackState = state;\n\t\t\t\tfor (let i = 0; i < loopbackState.numberOfTransitions; i++) {\n\t\t\t\t\tlet target: ATNState = loopbackState.transition(i).target;\n\t\t\t\t\tif (target instanceof PlusBlockStartState) {\n\t\t\t\t\t\ttarget.loopBackState = loopbackState;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (state instanceof StarLoopbackState) {\n\t\t\t\tlet loopbackState: StarLoopbackState = state;\n\t\t\t\tfor (let i = 0; i < loopbackState.numberOfTransitions; i++) {\n\t\t\t\t\tlet target: ATNState = loopbackState.transition(i).target;\n\t\t\t\t\tif (target instanceof StarLoopEntryState) {\n\t\t\t\t\t\ttarget.loopBackState = loopbackState;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t//\n\t\t// DECISIONS\n\t\t//\n\t\tlet ndecisions: number = ATNDeserializer.toInt(data[p++]);\n\t\tfor (let i = 1; i <= ndecisions; i++) {\n\t\t\tlet s: number = ATNDeserializer.toInt(data[p++]);\n\t\t\tlet decState: DecisionState = atn.states[s] as DecisionState;\n\t\t\tatn.decisionToState.push(decState);\n\t\t\tdecState.decision = i - 1;\n\t\t}\n\n\t\t//\n\t\t// LEXER ACTIONS\n\t\t//\n\t\tif (atn.grammarType === ATNType.LEXER) {\n\t\t\tif (supportsLexerActions) {\n\t\t\t\tatn.lexerActions = new Array<LexerAction>(ATNDeserializer.toInt(data[p++]));\n\t\t\t\tfor (let i = 0; i < atn.lexerActions.length; i++) {\n\t\t\t\t\tlet actionType: LexerActionType = ATNDeserializer.toInt(data[p++]);\n\t\t\t\t\tlet data1: number = ATNDeserializer.toInt(data[p++]);\n\t\t\t\t\tif (data1 === 0xFFFF) {\n\t\t\t\t\t\tdata1 = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet data2: number = ATNDeserializer.toInt(data[p++]);\n\t\t\t\t\tif (data2 === 0xFFFF) {\n\t\t\t\t\t\tdata2 = -1;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet lexerAction: LexerAction = this.lexerActionFactory(actionType, data1, data2);\n\n\t\t\t\t\tatn.lexerActions[i] = lexerAction;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// for compatibility with older serialized ATNs, convert the old\n\t\t\t\t// serialized action index for action transitions to the new\n\t\t\t\t// form, which is the index of a LexerCustomAction\n\t\t\t\tlet legacyLexerActions: LexerAction[] = [];\n\t\t\t\tfor (let state of atn.states) {\n\t\t\t\t\tfor (let i = 0; i < state.numberOfTransitions; i++) {\n\t\t\t\t\t\tlet transition: Transition = state.transition(i);\n\t\t\t\t\t\tif (!(transition instanceof ActionTransition)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet ruleIndex: number = transition.ruleIndex;\n\t\t\t\t\t\tlet actionIndex: number = transition.actionIndex;\n\t\t\t\t\t\tlet lexerAction: LexerCustomAction = new LexerCustomAction(ruleIndex, actionIndex);\n\t\t\t\t\t\tstate.setTransition(i, new ActionTransition(transition.target, ruleIndex, legacyLexerActions.length, false));\n\t\t\t\t\t\tlegacyLexerActions.push(lexerAction);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tatn.lexerActions = legacyLexerActions;\n\t\t\t}\n\t\t}\n\n\t\tthis.markPrecedenceDecisions(atn);\n\n\t\tatn.decisionToDFA = new Array<DFA>(ndecisions);\n\t\tfor (let i = 0; i < ndecisions; i++) {\n\t\t\tatn.decisionToDFA[i] = new DFA(atn.decisionToState[i], i);\n\t\t}\n\n\t\tif (this.deserializationOptions.isVerifyATN) {\n\t\t\tthis.verifyATN(atn);\n\t\t}\n\n\t\tif (this.deserializationOptions.isGenerateRuleBypassTransitions && atn.grammarType === ATNType.PARSER) {\n\t\t\tatn.ruleToTokenType = new Int32Array(atn.ruleToStartState.length);\n\t\t\tfor (let i = 0; i < atn.ruleToStartState.length; i++) {\n\t\t\t\tatn.ruleToTokenType[i] = atn.maxTokenType + i + 1;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < atn.ruleToStartState.length; i++) {\n\t\t\t\tlet bypassStart: BasicBlockStartState = new BasicBlockStartState();\n\t\t\t\tbypassStart.ruleIndex = i;\n\t\t\t\tatn.addState(bypassStart);\n\n\t\t\t\tlet bypassStop: BlockEndState = new BlockEndState();\n\t\t\t\tbypassStop.ruleIndex = i;\n\t\t\t\tatn.addState(bypassStop);\n\n\t\t\t\tbypassStart.endState = bypassStop;\n\t\t\t\tatn.defineDecisionState(bypassStart);\n\n\t\t\t\tbypassStop.startState = bypassStart;\n\n\t\t\t\tlet endState: ATNState | undefined;\n\t\t\t\tlet excludeTransition: Transition | undefined;\n\t\t\t\tif (atn.ruleToStartState[i].isPrecedenceRule) {\n\t\t\t\t\t// wrap from the beginning of the rule to the StarLoopEntryState\n\t\t\t\t\tendState = undefined;\n\t\t\t\t\tfor (let state of atn.states) {\n\t\t\t\t\t\tif (state.ruleIndex !== i) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!(state instanceof StarLoopEntryState)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet maybeLoopEndState: ATNState = state.transition(state.numberOfTransitions - 1).target;\n\t\t\t\t\t\tif (!(maybeLoopEndState instanceof LoopEndState)) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\n\t\t\t\t\t\t\tendState = state;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!endState) {\n\t\t\t\t\t\tthrow new Error(\"Couldn't identify final state of the precedence rule prefix section.\");\n\t\t\t\t\t}\n\n\t\t\t\t\texcludeTransition = (endState as StarLoopEntryState).loopBackState.transition(0);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tendState = atn.ruleToStopState[i];\n\t\t\t\t}\n\n\t\t\t\t// all non-excluded transitions that currently target end state need to target blockEnd instead\n\t\t\t\tfor (let state of atn.states) {\n\t\t\t\t\tfor (let i = 0; i < state.numberOfTransitions; i++) {\n\t\t\t\t\t\tlet transition = state.transition(i);\n\t\t\t\t\t\tif (transition === excludeTransition) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (transition.target === endState) {\n\t\t\t\t\t\t\ttransition.target = bypassStop;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// all transitions leaving the rule start state need to leave blockStart instead\n\t\t\t\twhile (atn.ruleToStartState[i].numberOfTransitions > 0) {\n\t\t\t\t\tlet transition: Transition = atn.ruleToStartState[i].removeTransition(atn.ruleToStartState[i].numberOfTransitions - 1);\n\t\t\t\t\tbypassStart.addTransition(transition);\n\t\t\t\t}\n\n\t\t\t\t// link the new states\n\t\t\t\tatn.ruleToStartState[i].addTransition(new EpsilonTransition(bypassStart));\n\t\t\t\tbypassStop.addTransition(new EpsilonTransition(endState));\n\n\t\t\t\tlet matchState: ATNState = new BasicState();\n\t\t\t\tatn.addState(matchState);\n\t\t\t\tmatchState.addTransition(new AtomTransition(bypassStop, atn.ruleToTokenType[i]));\n\t\t\t\tbypassStart.addTransition(new EpsilonTransition(matchState));\n\t\t\t}\n\n\t\t\tif (this.deserializationOptions.isVerifyATN) {\n\t\t\t\t// reverify after modification\n\t\t\t\tthis.verifyATN(atn);\n\t\t\t}\n\t\t}\n\n\t\tif (this.deserializationOptions.isOptimize) {\n\t\t\twhile (true) {\n\t\t\t\tlet optimizationCount: number = 0;\n\t\t\t\toptimizationCount += ATNDeserializer.inlineSetRules(atn);\n\t\t\t\toptimizationCount += ATNDeserializer.combineChainedEpsilons(atn);\n\t\t\t\tlet preserveOrder: boolean = atn.grammarType === ATNType.LEXER;\n\t\t\t\toptimizationCount += ATNDeserializer.optimizeSets(atn, preserveOrder);\n\t\t\t\tif (optimizationCount === 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.deserializationOptions.isVerifyATN) {\n\t\t\t\t// reverify after modification\n\t\t\t\tthis.verifyATN(atn);\n\t\t\t}\n\t\t}\n\n\t\tATNDeserializer.identifyTailCalls(atn);\n\n\t\treturn atn;\n\t}\n\n\tprivate deserializeSets(data: Uint16Array, p: number, sets: IntervalSet[], unicodeDeserializer: UnicodeDeserializer): number {\n\t\tlet nsets: number = ATNDeserializer.toInt(data[p++]);\n\t\tfor (let i = 0; i < nsets; i++) {\n\t\t\tlet nintervals: number = ATNDeserializer.toInt(data[p]);\n\t\t\tp++;\n\t\t\tlet set: IntervalSet = new IntervalSet();\n\t\t\tsets.push(set);\n\n\t\t\tlet containsEof: boolean = ATNDeserializer.toInt(data[p++]) !== 0;\n\t\t\tif (containsEof) {\n\t\t\t\tset.add(-1);\n\t\t\t}\n\n\t\t\tfor (let j: number = 0; j < nintervals; j++) {\n\t\t\t\tlet a: number = unicodeDeserializer.readUnicode(data, p);\n\t\t\t\tp += unicodeDeserializer.size;\n\t\t\t\tlet b: number = unicodeDeserializer.readUnicode(data, p);\n\t\t\t\tp += unicodeDeserializer.size;\n\t\t\t\tset.add(a, b);\n\t\t\t}\n\t\t}\n\n\t\treturn p;\n\t}\n\n\t/**\n\t * Analyze the {@link StarLoopEntryState} states in the specified ATN to set\n\t * the {@link StarLoopEntryState#precedenceRuleDecision} field to the\n\t * correct value.\n\t *\n\t * @param atn The ATN.\n\t */\n\tprotected markPrecedenceDecisions(@NotNull atn: ATN): void {\n\t\t// Map rule index -> precedence decision for that rule\n\t\tlet rulePrecedenceDecisions = new Map<number, StarLoopEntryState>();\n\n\t\tfor (let state of atn.states) {\n\t\t\tif (!(state instanceof StarLoopEntryState)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t/* We analyze the ATN to determine if this ATN decision state is the\n\t\t\t * decision for the closure block that determines whether a\n\t\t\t * precedence rule should continue or complete.\n\t\t\t */\n\t\t\tif (atn.ruleToStartState[state.ruleIndex].isPrecedenceRule) {\n\t\t\t\tlet maybeLoopEndState: ATNState = state.transition(state.numberOfTransitions - 1).target;\n\t\t\t\tif (maybeLoopEndState instanceof LoopEndState) {\n\t\t\t\t\tif (maybeLoopEndState.epsilonOnlyTransitions && maybeLoopEndState.transition(0).target instanceof RuleStopState) {\n\t\t\t\t\t\trulePrecedenceDecisions.set(state.ruleIndex, state);\n\t\t\t\t\t\tstate.precedenceRuleDecision = true;\n\t\t\t\t\t\tstate.precedenceLoopbackStates = new BitSet(atn.states.length);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// After marking precedence decisions, we go back through and fill in\n\t\t// StarLoopEntryState.precedenceLoopbackStates.\n\t\tfor (let precedenceDecision of rulePrecedenceDecisions) {\n\t\t\tfor (let transition of atn.ruleToStopState[precedenceDecision[0]].getTransitions()) {\n\t\t\t\tif (transition.serializationType !== TransitionType.EPSILON) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet epsilonTransition = transition as EpsilonTransition;\n\t\t\t\tif (epsilonTransition.outermostPrecedenceReturn !== -1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tprecedenceDecision[1].precedenceLoopbackStates.set(transition.target.stateNumber);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected verifyATN(atn: ATN): void {\n\t\t// verify assumptions\n\t\tfor (let state of atn.states) {\n\t\t\tthis.checkCondition(state != null, \"ATN states should not be null.\");\n\t\t\tif (state.stateType === ATNStateType.INVALID_TYPE) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tthis.checkCondition(state.onlyHasEpsilonTransitions || state.numberOfTransitions <= 1);\n\n\t\t\tif (state instanceof PlusBlockStartState) {\n\t\t\t\tthis.checkCondition(state.loopBackState != null);\n\t\t\t}\n\n\t\t\tif (state instanceof StarLoopEntryState) {\n\t\t\t\tlet starLoopEntryState: StarLoopEntryState = state;\n\t\t\t\tthis.checkCondition(starLoopEntryState.loopBackState != null);\n\t\t\t\tthis.checkCondition(starLoopEntryState.numberOfTransitions === 2);\n\n\t\t\t\tif (starLoopEntryState.transition(0).target instanceof StarBlockStartState) {\n\t\t\t\t\tthis.checkCondition(starLoopEntryState.transition(1).target instanceof LoopEndState);\n\t\t\t\t\tthis.checkCondition(!starLoopEntryState.nonGreedy);\n\t\t\t\t}\n\t\t\t\telse if (starLoopEntryState.transition(0).target instanceof LoopEndState) {\n\t\t\t\t\tthis.checkCondition(starLoopEntryState.transition(1).target instanceof StarBlockStartState);\n\t\t\t\t\tthis.checkCondition(starLoopEntryState.nonGreedy);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new Error(\"IllegalStateException\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state instanceof StarLoopbackState) {\n\t\t\t\tthis.checkCondition(state.numberOfTransitions === 1);\n\t\t\t\tthis.checkCondition(state.transition(0).target instanceof StarLoopEntryState);\n\t\t\t}\n\n\t\t\tif (state instanceof LoopEndState) {\n\t\t\t\tthis.checkCondition(state.loopBackState != null);\n\t\t\t}\n\n\t\t\tif (state instanceof RuleStartState) {\n\t\t\t\tthis.checkCondition(state.stopState != null);\n\t\t\t}\n\n\t\t\tif (state instanceof BlockStartState) {\n\t\t\t\tthis.checkCondition(state.endState != null);\n\t\t\t}\n\n\t\t\tif (state instanceof BlockEndState) {\n\t\t\t\tthis.checkCondition(state.startState != null);\n\t\t\t}\n\n\t\t\tif (state instanceof DecisionState) {\n\t\t\t\tlet decisionState: DecisionState = state;\n\t\t\t\tthis.checkCondition(decisionState.numberOfTransitions <= 1 || decisionState.decision >= 0);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.checkCondition(state.numberOfTransitions <= 1 || state instanceof RuleStopState);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected checkCondition(condition: boolean, message?: string): void {\n\t\tif (!condition) {\n\t\t\tthrow new Error(\"IllegalStateException: \" + message);\n\t\t}\n\t}\n\n\tprivate static inlineSetRules(atn: ATN): number {\n\t\tlet inlinedCalls: number = 0;\n\n\t\tlet ruleToInlineTransition: Transition[] = new Array<Transition>(atn.ruleToStartState.length);\n\t\tfor (let i = 0; i < atn.ruleToStartState.length; i++) {\n\t\t\tlet startState: RuleStartState = atn.ruleToStartState[i];\n\t\t\tlet middleState: ATNState = startState;\n\t\t\twhile (middleState.onlyHasEpsilonTransitions\n\t\t\t\t&& middleState.numberOfOptimizedTransitions === 1\n\t\t\t\t&& middleState.getOptimizedTransition(0).serializationType === TransitionType.EPSILON) {\n\t\t\t\tmiddleState = middleState.getOptimizedTransition(0).target;\n\t\t\t}\n\n\t\t\tif (middleState.numberOfOptimizedTransitions !== 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet matchTransition: Transition = middleState.getOptimizedTransition(0);\n\t\t\tlet matchTarget: ATNState = matchTransition.target;\n\t\t\tif (matchTransition.isEpsilon\n\t\t\t\t|| !matchTarget.onlyHasEpsilonTransitions\n\t\t\t\t|| matchTarget.numberOfOptimizedTransitions !== 1\n\t\t\t\t|| !(matchTarget.getOptimizedTransition(0).target instanceof RuleStopState)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tswitch (matchTransition.serializationType) {\n\t\t\tcase TransitionType.ATOM:\n\t\t\tcase TransitionType.RANGE:\n\t\t\tcase TransitionType.SET:\n\t\t\t\truleToInlineTransition[i] = matchTransition;\n\t\t\t\tbreak;\n\n\t\t\tcase TransitionType.NOT_SET:\n\t\t\tcase TransitionType.WILDCARD:\n\t\t\t\t// not implemented yet\n\t\t\t\tcontinue;\n\n\t\t\tdefault:\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\n\t\tfor (let state of atn.states) {\n\t\t\tif (state.ruleIndex < 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet optimizedTransitions: Transition[] | undefined;\n\t\t\tfor (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\n\t\t\t\tlet transition: Transition = state.getOptimizedTransition(i);\n\t\t\t\tif (!(transition instanceof RuleTransition)) {\n\t\t\t\t\tif (optimizedTransitions != null) {\n\t\t\t\t\t\toptimizedTransitions.push(transition);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet ruleTransition: RuleTransition = transition;\n\t\t\t\tlet effective: Transition = ruleToInlineTransition[ruleTransition.target.ruleIndex];\n\t\t\t\tif (effective == null) {\n\t\t\t\t\tif (optimizedTransitions != null) {\n\t\t\t\t\t\toptimizedTransitions.push(transition);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (optimizedTransitions == null) {\n\t\t\t\t\toptimizedTransitions = [];\n\t\t\t\t\tfor (let j = 0; j < i; j++) {\n\t\t\t\t\t\toptimizedTransitions.push(state.getOptimizedTransition(i));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinlinedCalls++;\n\t\t\t\tlet target: ATNState = ruleTransition.followState;\n\t\t\t\tlet intermediateState: ATNState = new BasicState();\n\t\t\t\tintermediateState.setRuleIndex(target.ruleIndex);\n\t\t\t\tatn.addState(intermediateState);\n\t\t\t\toptimizedTransitions.push(new EpsilonTransition(intermediateState));\n\n\t\t\t\tswitch (effective.serializationType) {\n\t\t\t\tcase TransitionType.ATOM:\n\t\t\t\t\tintermediateState.addTransition(new AtomTransition(target, (effective as AtomTransition)._label));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TransitionType.RANGE:\n\t\t\t\t\tintermediateState.addTransition(new RangeTransition(target, (effective as RangeTransition).from, (effective as RangeTransition).to));\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase TransitionType.SET:\n\t\t\t\t\tintermediateState.addTransition(new SetTransition(target, (effective as SetTransition).label));\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"UnsupportedOperationException\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (optimizedTransitions != null) {\n\t\t\t\tif (state.isOptimized) {\n\t\t\t\t\twhile (state.numberOfOptimizedTransitions > 0) {\n\t\t\t\t\t\tstate.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let transition of optimizedTransitions) {\n\t\t\t\t\tstate.addOptimizedTransition(transition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"ATN runtime optimizer removed \" + inlinedCalls + \" rule invocations by inlining sets.\");\n\t\t}\n\n\t\treturn inlinedCalls;\n\t}\n\n\tprivate static combineChainedEpsilons(atn: ATN): number {\n\t\tlet removedEdges: number = 0;\n\n\t\tfor (let state of atn.states) {\n\t\t\tif (!state.onlyHasEpsilonTransitions || state instanceof RuleStopState) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet optimizedTransitions: Transition[] | undefined;\n\t\t\tnextTransition:\n\t\t\tfor (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\n\t\t\t\tlet transition: Transition = state.getOptimizedTransition(i);\n\t\t\t\tlet intermediate: ATNState = transition.target;\n\t\t\t\tif (transition.serializationType !== TransitionType.EPSILON\n\t\t\t\t\t|| (transition as EpsilonTransition).outermostPrecedenceReturn !== -1\n\t\t\t\t\t|| intermediate.stateType !== ATNStateType.BASIC\n\t\t\t\t\t|| !intermediate.onlyHasEpsilonTransitions) {\n\t\t\t\t\tif (optimizedTransitions != null) {\n\t\t\t\t\t\toptimizedTransitions.push(transition);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue nextTransition;\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {\n\t\t\t\t\tif (intermediate.getOptimizedTransition(j).serializationType !== TransitionType.EPSILON\n\t\t\t\t\t\t|| (intermediate.getOptimizedTransition(j) as EpsilonTransition).outermostPrecedenceReturn !== -1) {\n\t\t\t\t\t\tif (optimizedTransitions != null) {\n\t\t\t\t\t\t\toptimizedTransitions.push(transition);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tcontinue nextTransition;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tremovedEdges++;\n\t\t\t\tif (optimizedTransitions == null) {\n\t\t\t\t\toptimizedTransitions = [];\n\t\t\t\t\tfor (let j = 0; j < i; j++) {\n\t\t\t\t\t\toptimizedTransitions.push(state.getOptimizedTransition(j));\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let j = 0; j < intermediate.numberOfOptimizedTransitions; j++) {\n\t\t\t\t\tlet target: ATNState = intermediate.getOptimizedTransition(j).target;\n\t\t\t\t\toptimizedTransitions.push(new EpsilonTransition(target));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (optimizedTransitions != null) {\n\t\t\t\tif (state.isOptimized) {\n\t\t\t\t\twhile (state.numberOfOptimizedTransitions > 0) {\n\t\t\t\t\t\tstate.removeOptimizedTransition(state.numberOfOptimizedTransitions - 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let transition of optimizedTransitions) {\n\t\t\t\t\tstate.addOptimizedTransition(transition);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"ATN runtime optimizer removed \" + removedEdges + \" transitions by combining chained epsilon transitions.\");\n\t\t}\n\n\t\treturn removedEdges;\n\t}\n\n\tprivate static optimizeSets(atn: ATN, preserveOrder: boolean): number {\n\t\tif (preserveOrder) {\n\t\t\t// this optimization currently doesn't preserve edge order.\n\t\t\treturn 0;\n\t\t}\n\n\t\tlet removedPaths: number = 0;\n\t\tlet decisions: DecisionState[] = atn.decisionToState;\n\t\tfor (let decision of decisions) {\n\t\t\tlet setTransitions: IntervalSet = new IntervalSet();\n\t\t\tfor (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {\n\t\t\t\tlet epsTransition: Transition = decision.getOptimizedTransition(i);\n\t\t\t\tif (!(epsTransition instanceof EpsilonTransition)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (epsTransition.target.numberOfOptimizedTransitions !== 1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet transition: Transition = epsTransition.target.getOptimizedTransition(0);\n\t\t\t\tif (!(transition.target instanceof BlockEndState)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (transition instanceof NotSetTransition) {\n\t\t\t\t\t// TODO: not yet implemented\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (transition instanceof AtomTransition\n\t\t\t\t\t|| transition instanceof RangeTransition\n\t\t\t\t\t|| transition instanceof SetTransition) {\n\t\t\t\t\tsetTransitions.add(i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (setTransitions.size <= 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet optimizedTransitions: Transition[] = [];\n\t\t\tfor (let i = 0; i < decision.numberOfOptimizedTransitions; i++) {\n\t\t\t\tif (!setTransitions.contains(i)) {\n\t\t\t\t\toptimizedTransitions.push(decision.getOptimizedTransition(i));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet blockEndState: ATNState = decision.getOptimizedTransition(setTransitions.minElement).target.getOptimizedTransition(0).target;\n\t\t\tlet matchSet: IntervalSet = new IntervalSet();\n\t\t\tfor (let interval of setTransitions.intervals) {\n\t\t\t\tfor (let j = interval.a; j <= interval.b; j++) {\n\t\t\t\t\tlet matchTransition: Transition = decision.getOptimizedTransition(j).target.getOptimizedTransition(0);\n\t\t\t\t\tif (matchTransition instanceof NotSetTransition) {\n\t\t\t\t\t\tthrow new Error(\"Not yet implemented.\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmatchSet.addAll(matchTransition.label as IntervalSet);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet newTransition: Transition;\n\t\t\tif (matchSet.intervals.length === 1) {\n\t\t\t\tif (matchSet.size === 1) {\n\t\t\t\t\tnewTransition = new AtomTransition(blockEndState, matchSet.minElement);\n\t\t\t\t} else {\n\t\t\t\t\tlet matchInterval: Interval = matchSet.intervals[0];\n\t\t\t\t\tnewTransition = new RangeTransition(blockEndState, matchInterval.a, matchInterval.b);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewTransition = new SetTransition(blockEndState, matchSet);\n\t\t\t}\n\n\t\t\tlet setOptimizedState: ATNState = new BasicState();\n\t\t\tsetOptimizedState.setRuleIndex(decision.ruleIndex);\n\t\t\tatn.addState(setOptimizedState);\n\n\t\t\tsetOptimizedState.addTransition(newTransition);\n\t\t\toptimizedTransitions.push(new EpsilonTransition(setOptimizedState));\n\n\t\t\tremovedPaths += decision.numberOfOptimizedTransitions - optimizedTransitions.length;\n\n\t\t\tif (decision.isOptimized) {\n\t\t\t\twhile (decision.numberOfOptimizedTransitions > 0) {\n\t\t\t\t\tdecision.removeOptimizedTransition(decision.numberOfOptimizedTransitions - 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (let transition of optimizedTransitions) {\n\t\t\t\tdecision.addOptimizedTransition(transition);\n\t\t\t}\n\t\t}\n\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"ATN runtime optimizer removed \" + removedPaths + \" paths by collapsing sets.\");\n\t\t}\n\n\t\treturn removedPaths;\n\t}\n\n\tprivate static identifyTailCalls(atn: ATN): void {\n\t\tfor (let state of atn.states) {\n\t\t\tfor (let i = 0; i < state.numberOfTransitions; i++) {\n\t\t\t\tlet transition = state.transition(i);\n\t\t\t\tif (!(transition instanceof RuleTransition)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttransition.tailCall = this.testTailCall(atn, transition, false);\n\t\t\t\ttransition.optimizedTailCall = this.testTailCall(atn, transition, true);\n\t\t\t}\n\n\t\t\tif (!state.isOptimized) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < state.numberOfOptimizedTransitions; i++) {\n\t\t\t\tlet transition = state.getOptimizedTransition(i);\n\t\t\t\tif (!(transition instanceof RuleTransition)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\ttransition.tailCall = this.testTailCall(atn, transition, false);\n\t\t\t\ttransition.optimizedTailCall = this.testTailCall(atn, transition, true);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static testTailCall(atn: ATN, transition: RuleTransition, optimizedPath: boolean): boolean {\n\t\tif (!optimizedPath && transition.tailCall) {\n\t\t\treturn true;\n\t\t}\n\t\tif (optimizedPath && transition.optimizedTailCall) {\n\t\t\treturn true;\n\t\t}\n\n\t\tlet reachable: BitSet = new BitSet(atn.states.length);\n\t\tlet worklist: ATNState[] = [];\n\t\tworklist.push(transition.followState);\n\t\twhile (true) {\n\t\t\tlet state = worklist.pop();\n\t\t\tif (!state) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (reachable.get(state.stateNumber)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (state instanceof RuleStopState) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!state.onlyHasEpsilonTransitions) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tlet transitionCount = optimizedPath ? state.numberOfOptimizedTransitions : state.numberOfTransitions;\n\t\t\tfor (let i = 0; i < transitionCount; i++) {\n\t\t\t\tlet t = optimizedPath ? state.getOptimizedTransition(i) : state.transition(i);\n\t\t\t\tif (t.serializationType !== TransitionType.EPSILON) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tworklist.push(t.target);\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tprotected static toInt(c: number): number {\n\t\treturn c;\n\t}\n\n\tprotected static toInt32(data: Uint16Array, offset: number): number {\n\t\treturn (data[offset] | (data[offset + 1] << 16)) >>> 0;\n\t}\n\n\tprotected static toUUID(data: Uint16Array, offset: number): UUID {\n\t\tlet leastSigBits: number = ATNDeserializer.toInt32(data, offset);\n\t\tlet lessSigBits: number = ATNDeserializer.toInt32(data, offset + 2);\n\t\tlet moreSigBits: number = ATNDeserializer.toInt32(data, offset + 4);\n\t\tlet mostSigBits: number = ATNDeserializer.toInt32(data, offset + 6);\n\t\treturn new UUID(mostSigBits, moreSigBits, lessSigBits, leastSigBits);\n\t}\n\n\t@NotNull\n\tprotected edgeFactory(\n\t\t@NotNull atn: ATN,\n\t\ttype: TransitionType, src: number, trg: number,\n\t\targ1: number, arg2: number, arg3: number,\n\t\tsets: IntervalSet[]): Transition {\n\t\tlet target: ATNState = atn.states[trg];\n\t\tswitch (type) {\n\t\t\tcase TransitionType.EPSILON: return new EpsilonTransition(target);\n\t\t\tcase TransitionType.RANGE:\n\t\t\t\tif (arg3 !== 0) {\n\t\t\t\t\treturn new RangeTransition(target, Token.EOF, arg2);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new RangeTransition(target, arg1, arg2);\n\t\t\t\t}\n\t\t\tcase TransitionType.RULE:\n\t\t\t\tlet rt: RuleTransition = new RuleTransition(atn.states[arg1] as RuleStartState, arg2, arg3, target);\n\t\t\t\treturn rt;\n\t\t\tcase TransitionType.PREDICATE:\n\t\t\t\tlet pt: PredicateTransition = new PredicateTransition(target, arg1, arg2, arg3 !== 0);\n\t\t\t\treturn pt;\n\t\t\tcase TransitionType.PRECEDENCE:\n\t\t\t\treturn new PrecedencePredicateTransition(target, arg1);\n\t\t\tcase TransitionType.ATOM:\n\t\t\t\tif (arg3 !== 0) {\n\t\t\t\t\treturn new AtomTransition(target, Token.EOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn new AtomTransition(target, arg1);\n\t\t\t\t}\n\t\t\tcase TransitionType.ACTION:\n\t\t\t\tlet a: ActionTransition = new ActionTransition(target, arg1, arg2, arg3 !== 0);\n\t\t\t\treturn a;\n\t\t\tcase TransitionType.SET: return new SetTransition(target, sets[arg1]);\n\t\t\tcase TransitionType.NOT_SET: return new NotSetTransition(target, sets[arg1]);\n\t\t\tcase TransitionType.WILDCARD: return new WildcardTransition(target);\n\t\t}\n\n\t\tthrow new Error(\"The specified transition type is not valid.\");\n\t}\n\n\tprotected stateFactory(type: ATNStateType, ruleIndex: number): ATNState {\n\t\tlet s: ATNState;\n\t\tswitch (type) {\n\t\t\tcase ATNStateType.INVALID_TYPE: return new InvalidState();\n\t\t\tcase ATNStateType.BASIC: s = new BasicState(); break;\n\t\t\tcase ATNStateType.RULE_START: s = new RuleStartState(); break;\n\t\t\tcase ATNStateType.BLOCK_START: s = new BasicBlockStartState(); break;\n\t\t\tcase ATNStateType.PLUS_BLOCK_START: s = new PlusBlockStartState(); break;\n\t\t\tcase ATNStateType.STAR_BLOCK_START: s = new StarBlockStartState(); break;\n\t\t\tcase ATNStateType.TOKEN_START: s = new TokensStartState(); break;\n\t\t\tcase ATNStateType.RULE_STOP: s = new RuleStopState(); break;\n\t\t\tcase ATNStateType.BLOCK_END: s = new BlockEndState(); break;\n\t\t\tcase ATNStateType.STAR_LOOP_BACK: s = new StarLoopbackState(); break;\n\t\t\tcase ATNStateType.STAR_LOOP_ENTRY: s = new StarLoopEntryState(); break;\n\t\t\tcase ATNStateType.PLUS_LOOP_BACK: s = new PlusLoopbackState(); break;\n\t\t\tcase ATNStateType.LOOP_END: s = new LoopEndState(); break;\n\t\t\tdefault:\n\t\t\t\tlet message: string = `The specified state type ${type} is not valid.`;\n\t\t\t\tthrow new Error(message);\n\t\t}\n\n\t\ts.ruleIndex = ruleIndex;\n\t\treturn s;\n\t}\n\n\tprotected lexerActionFactory(type: LexerActionType, data1: number, data2: number): LexerAction {\n\t\tswitch (type) {\n\t\tcase LexerActionType.CHANNEL:\n\t\t\treturn new LexerChannelAction(data1);\n\n\t\tcase LexerActionType.CUSTOM:\n\t\t\treturn new LexerCustomAction(data1, data2);\n\n\t\tcase LexerActionType.MODE:\n\t\t\treturn new LexerModeAction(data1);\n\n\t\tcase LexerActionType.MORE:\n\t\t\treturn LexerMoreAction.INSTANCE;\n\n\t\tcase LexerActionType.POP_MODE:\n\t\t\treturn LexerPopModeAction.INSTANCE;\n\n\t\tcase LexerActionType.PUSH_MODE:\n\t\t\treturn new LexerPushModeAction(data1);\n\n\t\tcase LexerActionType.SKIP:\n\t\t\treturn LexerSkipAction.INSTANCE;\n\n\t\tcase LexerActionType.TYPE:\n\t\t\treturn new LexerTypeAction(data1);\n\n\t\tdefault:\n\t\t\tlet message: string = `The specified lexer action type ${type} is not valid.`;\n\t\t\tthrow new Error(message);\n\t\t}\n\t}\n}\n"]}