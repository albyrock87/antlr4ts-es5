{"version":3,"sources":["atn/ATNConfigSet.js","../src/atn/ATNConfigSet.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","Array2DHashMap_1","require","Array2DHashSet_1","ArrayEqualityComparator_1","ATN_1","ATNConfig_1","BitSet_1","Decorators_1","ObjectEqualityComparator_1","PredictionContext_1","PredictionContextCache_1","SemanticContext_1","assert","Utils","KeyTypeEqualityComparer","state","alt","a","b","INSTANCE","NewKeyedConfigMap","map","Array2DHashMap","ATNConfigSet","set","readonly","_uniqueAlt","_hasSemanticContext","_dipsIntoOuterContext","outermostConfigSet","cachedHashCode","mergedConfigs","unmerged","configs","ATN","INVALID_ALT_NUMBER","undefined","isReadOnly","slice","_conflictInfo","conflictedAlts","clone","alts","BitSet","config","states","Array2DHashSet","ObjectEqualityComparator","add","interpreter","context","atn","getCachedContext","copy","addAll","o","ATNConfig","configKey","getKey","mergedConfig","get","canMerge","contains","Symbol","iterator","e","contextCache","ensureWritable","Error","reachesIntoOuterContext","PredictionContextCache","UNCACHED","addKey","outerContextDepth","Math","max","isPrecedenceFilterSuppressed","joined","PredictionContext","join","updatePropertiesForMergedConfig","unmergedConfig","put","splice","push","updatePropertiesForAddedConfig","SemanticContext","NONE","equals","semanticContext","left","leftKey","right","stateNumber","changed","group","clear","obj","ArrayEqualityComparator","hashCode","showContext","buf","sortedConfigs","sort","o1","o2","toString","localeCompare","isExact","index","conflictInfo","NotNull","prototype","Override"],"mappings":"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","file":"ATNConfigSet.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:25.5488013-07:00\nconst Array2DHashMap_1 = require(\"../misc/Array2DHashMap\");\nconst Array2DHashSet_1 = require(\"../misc/Array2DHashSet\");\nconst ArrayEqualityComparator_1 = require(\"../misc/ArrayEqualityComparator\");\nconst ATN_1 = require(\"./ATN\");\nconst ATNConfig_1 = require(\"./ATNConfig\");\nconst BitSet_1 = require(\"../misc/BitSet\");\nconst Decorators_1 = require(\"../Decorators\");\nconst ObjectEqualityComparator_1 = require(\"../misc/ObjectEqualityComparator\");\nconst PredictionContext_1 = require(\"./PredictionContext\");\nconst PredictionContextCache_1 = require(\"./PredictionContextCache\");\nconst SemanticContext_1 = require(\"./SemanticContext\");\nconst assert = require(\"assert\");\nconst Utils = require(\"../misc/Utils\");\nclass KeyTypeEqualityComparer {\n    hashCode(key) {\n        return key.state ^ key.alt;\n    }\n    equals(a, b) {\n        return a.state === b.state && a.alt === b.alt;\n    }\n}\nKeyTypeEqualityComparer.INSTANCE = new KeyTypeEqualityComparer();\nfunction NewKeyedConfigMap(map) {\n    if (map) {\n        return new Array2DHashMap_1.Array2DHashMap(map);\n    }\n    else {\n        return new Array2DHashMap_1.Array2DHashMap(KeyTypeEqualityComparer.INSTANCE);\n    }\n}\n/**\n * Represents a set of ATN configurations (see `ATNConfig`). As configurations are added to the set, they are merged\n * with other `ATNConfig` instances already in the set when possible using the graph-structured stack.\n *\n * An instance of this class represents the complete set of positions (with context) in an ATN which would be associated\n * with a single DFA state. Its internal representation is more complex than traditional state used for NFA to DFA\n * conversion due to performance requirements (both improving speed and reducing memory overhead) as well as supporting\n * features such as semantic predicates and non-greedy operators in a form to support ANTLR's prediction algorithm.\n *\n * @author Sam Harwell\n */\nclass ATNConfigSet {\n    constructor(set, readonly) {\n        this._uniqueAlt = 0;\n        // Used in parser and lexer. In lexer, it indicates we hit a pred\n        // while computing a closure operation.  Don't make a DFA state from this.\n        this._hasSemanticContext = false;\n        this._dipsIntoOuterContext = false;\n        /**\n         * When `true`, this config set represents configurations where the entire\n         * outer context has been consumed by the ATN interpreter. This prevents the\n         * {@link ParserATNSimulator#closure} from pursuing the global FOLLOW when a\n         * rule stop state is reached with an empty prediction context.\n         *\n         * Note: `outermostConfigSet` and {@link #dipsIntoOuterContext} should never\n         * be true at the same time.\n         */\n        this.outermostConfigSet = false;\n        this.cachedHashCode = -1;\n        if (!set) {\n            this.mergedConfigs = NewKeyedConfigMap();\n            this.unmerged = [];\n            this.configs = [];\n            this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;\n        }\n        else {\n            if (readonly) {\n                this.mergedConfigs = undefined;\n                this.unmerged = undefined;\n            }\n            else if (!set.isReadOnly) {\n                this.mergedConfigs = NewKeyedConfigMap(set.mergedConfigs);\n                this.unmerged = set.unmerged.slice(0);\n            }\n            else {\n                this.mergedConfigs = NewKeyedConfigMap();\n                this.unmerged = [];\n            }\n            this.configs = set.configs.slice(0);\n            this._dipsIntoOuterContext = set._dipsIntoOuterContext;\n            this._hasSemanticContext = set._hasSemanticContext;\n            this.outermostConfigSet = set.outermostConfigSet;\n            if (readonly || !set.isReadOnly) {\n                this._uniqueAlt = set._uniqueAlt;\n                this._conflictInfo = set._conflictInfo;\n            }\n            // if (!readonly && set.isReadOnly) -> addAll is called from clone()\n        }\n    }\n    /**\n     * Get the set of all alternatives represented by configurations in this\n     * set.\n     */\n    getRepresentedAlternatives() {\n        if (this._conflictInfo != null) {\n            return this._conflictInfo.conflictedAlts.clone();\n        }\n        let alts = new BitSet_1.BitSet();\n        for (let config of this) {\n            alts.set(config.alt);\n        }\n        return alts;\n    }\n    get isReadOnly() {\n        return this.mergedConfigs == null;\n    }\n    get isOutermostConfigSet() {\n        return this.outermostConfigSet;\n    }\n    set isOutermostConfigSet(outermostConfigSet) {\n        if (this.outermostConfigSet && !outermostConfigSet) {\n            throw new Error(\"IllegalStateException\");\n        }\n        assert(!outermostConfigSet || !this._dipsIntoOuterContext);\n        this.outermostConfigSet = outermostConfigSet;\n    }\n    getStates() {\n        let states = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n        for (let c of this.configs) {\n            states.add(c.state);\n        }\n        return states;\n    }\n    optimizeConfigs(interpreter) {\n        if (this.configs.length === 0) {\n            return;\n        }\n        for (let config of this.configs) {\n            config.context = interpreter.atn.getCachedContext(config.context);\n        }\n    }\n    clone(readonly) {\n        let copy = new ATNConfigSet(this, readonly);\n        if (!readonly && this.isReadOnly) {\n            copy.addAll(this.configs);\n        }\n        return copy;\n    }\n    get size() {\n        return this.configs.length;\n    }\n    get isEmpty() {\n        return this.configs.length === 0;\n    }\n    contains(o) {\n        if (!(o instanceof ATNConfig_1.ATNConfig)) {\n            return false;\n        }\n        if (this.mergedConfigs && this.unmerged) {\n            let config = o;\n            let configKey = this.getKey(config);\n            let mergedConfig = this.mergedConfigs.get(configKey);\n            if (mergedConfig != null && this.canMerge(config, configKey, mergedConfig)) {\n                return mergedConfig.contains(config);\n            }\n            for (let c of this.unmerged) {\n                if (c.contains(o)) {\n                    return true;\n                }\n            }\n        }\n        else {\n            for (let c of this.configs) {\n                if (c.contains(o)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    *[Symbol.iterator]() {\n        yield* this.configs;\n    }\n    toArray() {\n        return this.configs;\n    }\n    add(e, contextCache) {\n        this.ensureWritable();\n        if (!this.mergedConfigs || !this.unmerged) {\n            throw new Error(\"Covered by ensureWritable but duplicated here for strict null check limitation\");\n        }\n        assert(!this.outermostConfigSet || !e.reachesIntoOuterContext);\n        if (contextCache == null) {\n            contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;\n        }\n        let addKey;\n        let key = this.getKey(e);\n        let mergedConfig = this.mergedConfigs.get(key);\n        addKey = (mergedConfig == null);\n        if (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {\n            mergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);\n            if (e.isPrecedenceFilterSuppressed) {\n                mergedConfig.isPrecedenceFilterSuppressed = true;\n            }\n            let joined = PredictionContext_1.PredictionContext.join(mergedConfig.context, e.context, contextCache);\n            this.updatePropertiesForMergedConfig(e);\n            if (mergedConfig.context === joined) {\n                return false;\n            }\n            mergedConfig.context = joined;\n            return true;\n        }\n        for (let i = 0; i < this.unmerged.length; i++) {\n            let unmergedConfig = this.unmerged[i];\n            if (this.canMerge(e, key, unmergedConfig)) {\n                unmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);\n                if (e.isPrecedenceFilterSuppressed) {\n                    unmergedConfig.isPrecedenceFilterSuppressed = true;\n                }\n                let joined = PredictionContext_1.PredictionContext.join(unmergedConfig.context, e.context, contextCache);\n                this.updatePropertiesForMergedConfig(e);\n                if (unmergedConfig.context === joined) {\n                    return false;\n                }\n                unmergedConfig.context = joined;\n                if (addKey) {\n                    this.mergedConfigs.put(key, unmergedConfig);\n                    this.unmerged.splice(i, 1);\n                }\n                return true;\n            }\n        }\n        this.configs.push(e);\n        if (addKey) {\n            this.mergedConfigs.put(key, e);\n        }\n        else {\n            this.unmerged.push(e);\n        }\n        this.updatePropertiesForAddedConfig(e);\n        return true;\n    }\n    updatePropertiesForMergedConfig(config) {\n        // merged configs can't change the alt or semantic context\n        this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;\n        assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);\n    }\n    updatePropertiesForAddedConfig(config) {\n        if (this.configs.length === 1) {\n            this._uniqueAlt = config.alt;\n        }\n        else if (this._uniqueAlt !== config.alt) {\n            this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;\n        }\n        this._hasSemanticContext = this._hasSemanticContext || !SemanticContext_1.SemanticContext.NONE.equals(config.semanticContext);\n        this._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;\n        assert(!this.outermostConfigSet || !this._dipsIntoOuterContext);\n    }\n    canMerge(left, leftKey, right) {\n        if (left.state.stateNumber !== right.state.stateNumber) {\n            return false;\n        }\n        if (leftKey.alt !== right.alt) {\n            return false;\n        }\n        return left.semanticContext.equals(right.semanticContext);\n    }\n    getKey(e) {\n        return { state: e.state.stateNumber, alt: e.alt };\n    }\n    containsAll(c) {\n        for (let o of c) {\n            if (!(o instanceof ATNConfig_1.ATNConfig)) {\n                return false;\n            }\n            if (!this.contains(o)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    addAll(c, contextCache) {\n        this.ensureWritable();\n        let changed = false;\n        for (let group of c) {\n            if (this.add(group, contextCache)) {\n                changed = true;\n            }\n        }\n        return changed;\n    }\n    clear() {\n        this.ensureWritable();\n        if (!this.mergedConfigs || !this.unmerged) {\n            throw new Error(\"Covered by ensureWritable but duplicated here for strict null check limitation\");\n        }\n        this.mergedConfigs.clear();\n        this.unmerged.length = 0;\n        this.configs.length = 0;\n        this._dipsIntoOuterContext = false;\n        this._hasSemanticContext = false;\n        this._uniqueAlt = ATN_1.ATN.INVALID_ALT_NUMBER;\n        this._conflictInfo = undefined;\n    }\n    equals(obj) {\n        if (this === obj) {\n            return true;\n        }\n        if (!(obj instanceof ATNConfigSet)) {\n            return false;\n        }\n        return this.outermostConfigSet === obj.outermostConfigSet\n            && Utils.equals(this._conflictInfo, obj._conflictInfo)\n            && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);\n    }\n    hashCode() {\n        if (this.isReadOnly && this.cachedHashCode !== -1) {\n            return this.cachedHashCode;\n        }\n        let hashCode = 1;\n        hashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);\n        hashCode = 5 * hashCode ^ ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.hashCode(this.configs);\n        if (this.isReadOnly) {\n            this.cachedHashCode = hashCode;\n        }\n        return hashCode;\n    }\n    toString(showContext) {\n        if (showContext == null) {\n            showContext = false;\n        }\n        let buf = \"\";\n        let sortedConfigs = this.configs.slice(0);\n        sortedConfigs.sort((o1, o2) => {\n            if (o1.alt !== o2.alt) {\n                return o1.alt - o2.alt;\n            }\n            else if (o1.state.stateNumber !== o2.state.stateNumber) {\n                return o1.state.stateNumber - o2.state.stateNumber;\n            }\n            else {\n                return o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());\n            }\n        });\n        buf += (\"[\");\n        for (let i = 0; i < sortedConfigs.length; i++) {\n            if (i > 0) {\n                buf += (\", \");\n            }\n            buf += (sortedConfigs[i].toString(undefined, true, showContext));\n        }\n        buf += (\"]\");\n        if (this._hasSemanticContext) {\n            buf += (\",hasSemanticContext=\") + (this._hasSemanticContext);\n        }\n        if (this._uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n            buf += (\",uniqueAlt=\") + (this._uniqueAlt);\n        }\n        if (this._conflictInfo != null) {\n            buf += (\",conflictingAlts=\") + (this._conflictInfo.conflictedAlts);\n            if (!this._conflictInfo.isExact) {\n                buf += (\"*\");\n            }\n        }\n        if (this._dipsIntoOuterContext) {\n            buf += (\",dipsIntoOuterContext\");\n        }\n        return buf.toString();\n    }\n    get uniqueAlt() {\n        return this._uniqueAlt;\n    }\n    get hasSemanticContext() {\n        return this._hasSemanticContext;\n    }\n    set hasSemanticContext(value) {\n        this.ensureWritable();\n        this._hasSemanticContext = value;\n    }\n    get conflictInfo() {\n        return this._conflictInfo;\n    }\n    set conflictInfo(conflictInfo) {\n        this.ensureWritable();\n        this._conflictInfo = conflictInfo;\n    }\n    get conflictingAlts() {\n        if (this._conflictInfo == null) {\n            return undefined;\n        }\n        return this._conflictInfo.conflictedAlts;\n    }\n    get isExactConflict() {\n        if (this._conflictInfo == null) {\n            return false;\n        }\n        return this._conflictInfo.isExact;\n    }\n    get dipsIntoOuterContext() {\n        return this._dipsIntoOuterContext;\n    }\n    get(index) {\n        return this.configs[index];\n    }\n    ensureWritable() {\n        if (this.isReadOnly) {\n            throw new Error(\"This ATNConfigSet is read only.\");\n        }\n    }\n}\n__decorate([\n    Decorators_1.NotNull\n], ATNConfigSet.prototype, \"getRepresentedAlternatives\", null);\n__decorate([\n    Decorators_1.Override\n], ATNConfigSet.prototype, \"size\", null);\n__decorate([\n    Decorators_1.Override\n], ATNConfigSet.prototype, \"isEmpty\", null);\n__decorate([\n    Decorators_1.Override\n], ATNConfigSet.prototype, \"contains\", null);\n__decorate([\n    Decorators_1.Override\n], ATNConfigSet.prototype, Symbol.iterator, null);\n__decorate([\n    Decorators_1.Override\n], ATNConfigSet.prototype, \"toArray\", null);\n__decorate([\n    Decorators_1.Override\n], ATNConfigSet.prototype, \"containsAll\", null);\n__decorate([\n    Decorators_1.Override\n], ATNConfigSet.prototype, \"clear\", null);\n__decorate([\n    Decorators_1.Override\n], ATNConfigSet.prototype, \"equals\", null);\n__decorate([\n    Decorators_1.Override\n], ATNConfigSet.prototype, \"hashCode\", null);\nexports.ATNConfigSet = ATNConfigSet;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:25.5488013-07:00\n\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\nimport { ArrayEqualityComparator } from \"../misc/ArrayEqualityComparator\";\nimport { ATN } from \"./ATN\";\nimport { ATNConfig } from \"./ATNConfig\";\nimport { ATNSimulator } from \"./ATNSimulator\";\nimport { ATNState } from \"./ATNState\";\nimport { BitSet } from \"../misc/BitSet\";\nimport { ConflictInfo } from \"./ConflictInfo\";\nimport { EqualityComparator } from \"../misc/EqualityComparator\";\nimport { JavaSet } from \"../misc/Stubs\";\nimport { NotNull, Override } from \"../Decorators\";\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\nimport { PredictionContext } from \"./PredictionContext\";\nimport { PredictionContextCache } from \"./PredictionContextCache\";\nimport { SemanticContext } from \"./SemanticContext\";\n\nimport * as assert from \"assert\";\nimport * as Utils from \"../misc/Utils\";\n\ninterface KeyType { state: number; alt: number; }\n\nclass KeyTypeEqualityComparer implements EqualityComparator<KeyType> {\n\tpublic hashCode(key: KeyType) {\n\t\treturn key.state ^ key.alt;\n\t}\n\n\tpublic equals(a: KeyType, b: KeyType) {\n\t\treturn a.state === b.state && a.alt === b.alt;\n\t}\n\n\tpublic static readonly INSTANCE = new KeyTypeEqualityComparer();\n}\n\nfunction NewKeyedConfigMap(map?: Array2DHashMap<KeyType, ATNConfig>) {\n\tif (map) {\n\t\treturn new Array2DHashMap<KeyType, ATNConfig>(map);\n\t} else {\n\t\treturn new Array2DHashMap<KeyType, ATNConfig>(KeyTypeEqualityComparer.INSTANCE);\n\t}\n}\n\n/**\n * Represents a set of ATN configurations (see `ATNConfig`). As configurations are added to the set, they are merged\n * with other `ATNConfig` instances already in the set when possible using the graph-structured stack.\n *\n * An instance of this class represents the complete set of positions (with context) in an ATN which would be associated\n * with a single DFA state. Its internal representation is more complex than traditional state used for NFA to DFA\n * conversion due to performance requirements (both improving speed and reducing memory overhead) as well as supporting\n * features such as semantic predicates and non-greedy operators in a form to support ANTLR's prediction algorithm.\n *\n * @author Sam Harwell\n */\nexport class ATNConfigSet implements JavaSet<ATNConfig> {\n\t/**\n\t * This maps (state, alt) -> merged {@link ATNConfig}. The key does not account for\n\t * the {@link ATNConfig#getSemanticContext} of the value, which is only a problem if a single\n\t * `ATNConfigSet` contains two configs with the same state and alternative\n\t * but different semantic contexts. When this case arises, the first config\n\t * added to this map stays, and the remaining configs are placed in {@link #unmerged}.\n\t *\n\t * This map is only used for optimizing the process of adding configs to the set,\n\t * and is `undefined` for read-only sets stored in the DFA.\n\t */\n\tprivate mergedConfigs?: Array2DHashMap<KeyType, ATNConfig>;\n\n\t/**\n\t * This is an \"overflow\" list holding configs which cannot be merged with one\n\t * of the configs in {@link #mergedConfigs} but have a colliding key. This\n\t * occurs when two configs in the set have the same state and alternative but\n\t * different semantic contexts.\n\t *\n\t * This list is only used for optimizing the process of adding configs to the set,\n\t * and is `undefined` for read-only sets stored in the DFA.\n\t */\n\tprivate unmerged?: ATNConfig[];\n\n\t/**\n\t * This is a list of all configs in this set.\n\t */\n\tprivate configs: ATNConfig[];\n\n\tprivate _uniqueAlt: number = 0;\n\tprivate _conflictInfo?: ConflictInfo;\n\t// Used in parser and lexer. In lexer, it indicates we hit a pred\n\t// while computing a closure operation.  Don't make a DFA state from this.\n\tprivate _hasSemanticContext: boolean = false;\n\tprivate _dipsIntoOuterContext: boolean = false;\n\t/**\n\t * When `true`, this config set represents configurations where the entire\n\t * outer context has been consumed by the ATN interpreter. This prevents the\n\t * {@link ParserATNSimulator#closure} from pursuing the global FOLLOW when a\n\t * rule stop state is reached with an empty prediction context.\n\t *\n\t * Note: `outermostConfigSet` and {@link #dipsIntoOuterContext} should never\n\t * be true at the same time.\n\t */\n\tprivate outermostConfigSet: boolean = false;\n\n\tprivate cachedHashCode: number = -1;\n\n\tconstructor();\n\tconstructor(set: ATNConfigSet, readonly: boolean);\n\tconstructor(set?: ATNConfigSet, readonly?: boolean) {\n\t\tif (!set) {\n\t\t\tthis.mergedConfigs = NewKeyedConfigMap();\n\t\t\tthis.unmerged = [];\n\t\t\tthis.configs = [];\n\n\t\t\tthis._uniqueAlt = ATN.INVALID_ALT_NUMBER;\n\t\t} else {\n\n\t\t\tif (readonly) {\n\t\t\t\tthis.mergedConfigs = undefined;\n\t\t\t\tthis.unmerged = undefined;\n\t\t\t} else if (!set.isReadOnly) {\n\t\t\t\tthis.mergedConfigs = NewKeyedConfigMap(set.mergedConfigs);\n\t\t\t\tthis.unmerged = (set.unmerged as ATNConfig[]).slice(0);\n\t\t\t} else {\n\t\t\t\tthis.mergedConfigs = NewKeyedConfigMap();\n\t\t\t\tthis.unmerged = [];\n\t\t\t}\n\n\t\t\tthis.configs = set.configs.slice(0);\n\n\t\t\tthis._dipsIntoOuterContext = set._dipsIntoOuterContext;\n\t\t\tthis._hasSemanticContext = set._hasSemanticContext;\n\t\t\tthis.outermostConfigSet = set.outermostConfigSet;\n\n\t\t\tif (readonly || !set.isReadOnly) {\n\t\t\t\tthis._uniqueAlt = set._uniqueAlt;\n\t\t\t\tthis._conflictInfo = set._conflictInfo;\n\t\t\t}\n\n\t\t\t// if (!readonly && set.isReadOnly) -> addAll is called from clone()\n\t\t}\n\t}\n\n\t/**\n\t * Get the set of all alternatives represented by configurations in this\n\t * set.\n\t */\n\t@NotNull\n\tpublic getRepresentedAlternatives(): BitSet {\n\t\tif (this._conflictInfo != null) {\n\t\t\treturn this._conflictInfo.conflictedAlts.clone();\n\t\t}\n\n\t\tlet alts: BitSet = new BitSet();\n\t\tfor (let config of this) {\n\t\t\talts.set(config.alt);\n\t\t}\n\n\t\treturn alts;\n\t}\n\n\tget isReadOnly(): boolean {\n\t\treturn this.mergedConfigs == null;\n\t}\n\n\tget isOutermostConfigSet(): boolean {\n\t\treturn this.outermostConfigSet;\n\t}\n\n\tset isOutermostConfigSet(outermostConfigSet: boolean) {\n\t\tif (this.outermostConfigSet && !outermostConfigSet) {\n\t\t\tthrow new Error(\"IllegalStateException\");\n\t\t}\n\n\t\tassert(!outermostConfigSet || !this._dipsIntoOuterContext);\n\t\tthis.outermostConfigSet = outermostConfigSet;\n\t}\n\n\tpublic getStates(): Array2DHashSet<ATNState> {\n\t\tlet states = new Array2DHashSet<ATNState>(ObjectEqualityComparator.INSTANCE);\n\t\tfor (let c of this.configs) {\n\t\t\tstates.add(c.state);\n\t\t}\n\n\t\treturn states;\n\t}\n\n\tpublic optimizeConfigs(interpreter: ATNSimulator): void {\n\t\tif (this.configs.length === 0) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let config of this.configs) {\n\t\t\tconfig.context = interpreter.atn.getCachedContext(config.context);\n\t\t}\n\t}\n\n\tpublic clone(readonly: boolean): ATNConfigSet {\n\t\tlet copy: ATNConfigSet = new ATNConfigSet(this, readonly);\n\t\tif (!readonly && this.isReadOnly) {\n\t\t\tcopy.addAll(this.configs);\n\t\t}\n\n\t\treturn copy;\n\t}\n\n\t@Override\n\tget size(): number {\n\t\treturn this.configs.length;\n\t}\n\n\t@Override\n\tget isEmpty(): boolean {\n\t\treturn this.configs.length === 0;\n\t}\n\n\t@Override\n\tpublic contains(o: any): boolean {\n\t\tif (!(o instanceof ATNConfig)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.mergedConfigs && this.unmerged) {\n\t\t\tlet config: ATNConfig = o;\n\t\t\tlet configKey = this.getKey(config);\n\t\t\tlet mergedConfig = this.mergedConfigs.get(configKey);\n\t\t\tif (mergedConfig != null && this.canMerge(config, configKey, mergedConfig)) {\n\t\t\t\treturn mergedConfig.contains(config);\n\t\t\t}\n\n\t\t\tfor (let c of this.unmerged) {\n\t\t\t\tif (c.contains(o)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor (let c of this.configs) {\n\t\t\t\tif (c.contains(o)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic *[Symbol.iterator](): IterableIterator<ATNConfig> {\n\t\tyield* this.configs;\n\t}\n\n\t@Override\n\tpublic toArray(): ATNConfig[] {\n\t\treturn this.configs;\n\t}\n\n\tpublic add(e: ATNConfig): boolean;\n\tpublic add(e: ATNConfig, contextCache: PredictionContextCache | undefined): boolean;\n\tpublic add(e: ATNConfig, contextCache?: PredictionContextCache): boolean {\n\t\tthis.ensureWritable();\n\t\tif (!this.mergedConfigs || !this.unmerged) {\n\t\t\tthrow new Error(\"Covered by ensureWritable but duplicated here for strict null check limitation\");\n\t\t}\n\n\t\tassert(!this.outermostConfigSet || !e.reachesIntoOuterContext);\n\n\t\tif (contextCache == null) {\n\t\t\tcontextCache = PredictionContextCache.UNCACHED;\n\t\t}\n\n\t\tlet addKey: boolean;\n\t\tlet key = this.getKey(e);\n\t\tlet mergedConfig = this.mergedConfigs.get(key);\n\t\taddKey = (mergedConfig == null);\n\t\tif (mergedConfig != null && this.canMerge(e, key, mergedConfig)) {\n\t\t\tmergedConfig.outerContextDepth = Math.max(mergedConfig.outerContextDepth, e.outerContextDepth);\n\t\t\tif (e.isPrecedenceFilterSuppressed) {\n\t\t\t\tmergedConfig.isPrecedenceFilterSuppressed = true;\n\t\t\t}\n\n\t\t\tlet joined: PredictionContext = PredictionContext.join(mergedConfig.context, e.context, contextCache);\n\t\t\tthis.updatePropertiesForMergedConfig(e);\n\t\t\tif (mergedConfig.context === joined) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tmergedConfig.context = joined;\n\t\t\treturn true;\n\t\t}\n\n\t\tfor (let i = 0; i < this.unmerged.length; i++) {\n\t\t\tlet unmergedConfig: ATNConfig = this.unmerged[i];\n\t\t\tif (this.canMerge(e, key, unmergedConfig)) {\n\t\t\t\tunmergedConfig.outerContextDepth = Math.max(unmergedConfig.outerContextDepth, e.outerContextDepth);\n\t\t\t\tif (e.isPrecedenceFilterSuppressed) {\n\t\t\t\t\tunmergedConfig.isPrecedenceFilterSuppressed = true;\n\t\t\t\t}\n\n\t\t\t\tlet joined: PredictionContext = PredictionContext.join(unmergedConfig.context, e.context, contextCache);\n\t\t\t\tthis.updatePropertiesForMergedConfig(e);\n\t\t\t\tif (unmergedConfig.context === joined) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tunmergedConfig.context = joined;\n\n\t\t\t\tif (addKey) {\n\t\t\t\t\tthis.mergedConfigs.put(key, unmergedConfig);\n\t\t\t\t\tthis.unmerged.splice(i, 1);\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tthis.configs.push(e);\n\t\tif (addKey) {\n\t\t\tthis.mergedConfigs.put(key, e);\n\t\t} else {\n\t\t\tthis.unmerged.push(e);\n\t\t}\n\n\t\tthis.updatePropertiesForAddedConfig(e);\n\t\treturn true;\n\t}\n\n\tprivate updatePropertiesForMergedConfig(config: ATNConfig): void {\n\t\t// merged configs can't change the alt or semantic context\n\t\tthis._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;\n\t\tassert(!this.outermostConfigSet || !this._dipsIntoOuterContext);\n\t}\n\n\tprivate updatePropertiesForAddedConfig(config: ATNConfig): void {\n\t\tif (this.configs.length === 1) {\n\t\t\tthis._uniqueAlt = config.alt;\n\t\t} else if (this._uniqueAlt !== config.alt) {\n\t\t\tthis._uniqueAlt = ATN.INVALID_ALT_NUMBER;\n\t\t}\n\n\t\tthis._hasSemanticContext = this._hasSemanticContext || !SemanticContext.NONE.equals(config.semanticContext);\n\t\tthis._dipsIntoOuterContext = this._dipsIntoOuterContext || config.reachesIntoOuterContext;\n\t\tassert(!this.outermostConfigSet || !this._dipsIntoOuterContext);\n\t}\n\n\tprotected canMerge(left: ATNConfig, leftKey: { state: number, alt: number }, right: ATNConfig): boolean {\n\t\tif (left.state.stateNumber !== right.state.stateNumber) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (leftKey.alt !== right.alt) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn left.semanticContext.equals(right.semanticContext);\n\t}\n\n\tprotected getKey(e: ATNConfig): { state: number, alt: number } {\n\t\treturn { state: e.state.stateNumber, alt: e.alt };\n\t}\n\n\t@Override\n\tpublic containsAll(c: Iterable<any>): boolean {\n\t\tfor (let o of c) {\n\t\t\tif (!(o instanceof ATNConfig)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (!this.contains(o)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n\n\tpublic addAll(c: Iterable<ATNConfig>): boolean;\n\tpublic addAll(c: Iterable<ATNConfig>, contextCache: PredictionContextCache): boolean;\n\tpublic addAll(c: Iterable<ATNConfig>, contextCache?: PredictionContextCache): boolean {\n\t\tthis.ensureWritable();\n\n\t\tlet changed: boolean = false;\n\t\tfor (let group of c) {\n\t\t\tif (this.add(group, contextCache)) {\n\t\t\t\tchanged = true;\n\t\t\t}\n\t\t}\n\n\t\treturn changed;\n\t}\n\n\t@Override\n\tpublic clear(): void {\n\t\tthis.ensureWritable();\n\t\tif (!this.mergedConfigs || !this.unmerged) {\n\t\t\tthrow new Error(\"Covered by ensureWritable but duplicated here for strict null check limitation\");\n\t\t}\n\n\t\tthis.mergedConfigs.clear();\n\t\tthis.unmerged.length = 0;\n\t\tthis.configs.length = 0;\n\n\t\tthis._dipsIntoOuterContext = false;\n\t\tthis._hasSemanticContext = false;\n\t\tthis._uniqueAlt = ATN.INVALID_ALT_NUMBER;\n\t\tthis._conflictInfo = undefined;\n\t}\n\n\t@Override\n\tpublic equals(obj: any): boolean {\n\t\tif (this === obj) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!(obj instanceof ATNConfigSet)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.outermostConfigSet === obj.outermostConfigSet\n\t\t\t&& Utils.equals(this._conflictInfo, obj._conflictInfo)\n\t\t\t&& ArrayEqualityComparator.INSTANCE.equals(this.configs, obj.configs);\n\t}\n\n\t@Override\n\tpublic hashCode(): number {\n\t\tif (this.isReadOnly && this.cachedHashCode !== -1) {\n\t\t\treturn this.cachedHashCode;\n\t\t}\n\n\t\tlet hashCode: number = 1;\n\t\thashCode = 5 * hashCode ^ (this.outermostConfigSet ? 1 : 0);\n\t\thashCode = 5 * hashCode ^ ArrayEqualityComparator.INSTANCE.hashCode(this.configs);\n\n\t\tif (this.isReadOnly) {\n\t\t\tthis.cachedHashCode = hashCode;\n\t\t}\n\n\t\treturn hashCode;\n\t}\n\n\tpublic toString(): string;\n\tpublic toString(showContext: boolean): string;\n\tpublic toString(showContext?: boolean): string {\n\t\tif (showContext == null) {\n\t\t\tshowContext = false;\n\t\t}\n\n\t\tlet buf = \"\";\n\t\tlet sortedConfigs = this.configs.slice(0);\n\t\tsortedConfigs.sort((o1, o2) => {\n\t\t\tif (o1.alt !== o2.alt) {\n\t\t\t\treturn o1.alt - o2.alt;\n\t\t\t}\n\t\t\telse if (o1.state.stateNumber !== o2.state.stateNumber) {\n\t\t\t\treturn o1.state.stateNumber - o2.state.stateNumber;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn o1.semanticContext.toString().localeCompare(o2.semanticContext.toString());\n\t\t\t}\n\t\t});\n\n\t\tbuf += (\"[\");\n\t\tfor (let i = 0; i < sortedConfigs.length; i++) {\n\t\t\tif (i > 0) {\n\t\t\t\tbuf += (\", \");\n\t\t\t}\n\t\t\tbuf += (sortedConfigs[i].toString(undefined, true, showContext));\n\t\t}\n\t\tbuf += (\"]\");\n\n\t\tif (this._hasSemanticContext) {\n\t\t\tbuf += (\",hasSemanticContext=\") + (this._hasSemanticContext);\n\t\t}\n\t\tif (this._uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n\t\t\tbuf += (\",uniqueAlt=\") + (this._uniqueAlt);\n\t\t}\n\t\tif (this._conflictInfo != null) {\n\t\t\tbuf += (\",conflictingAlts=\") + (this._conflictInfo.conflictedAlts);\n\t\t\tif (!this._conflictInfo.isExact) {\n\t\t\t\tbuf += (\"*\");\n\t\t\t}\n\t\t}\n\t\tif (this._dipsIntoOuterContext) {\n\t\t\tbuf += (\",dipsIntoOuterContext\");\n\t\t}\n\t\treturn buf.toString();\n\t}\n\n\tget uniqueAlt(): number {\n\t\treturn this._uniqueAlt;\n\t}\n\n\tget hasSemanticContext(): boolean {\n\t\treturn this._hasSemanticContext;\n\t}\n\n\tset hasSemanticContext(value: boolean) {\n\t\tthis.ensureWritable();\n\t\tthis._hasSemanticContext = value;\n\t}\n\n\tget conflictInfo(): ConflictInfo | undefined {\n\t\treturn this._conflictInfo;\n\t}\n\n\tset conflictInfo(conflictInfo: ConflictInfo | undefined) {\n\t\tthis.ensureWritable();\n\t\tthis._conflictInfo = conflictInfo;\n\t}\n\n\tget conflictingAlts(): BitSet | undefined {\n\t\tif (this._conflictInfo == null) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn this._conflictInfo.conflictedAlts;\n\t}\n\n\tget isExactConflict(): boolean {\n\t\tif (this._conflictInfo == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._conflictInfo.isExact;\n\t}\n\n\tget dipsIntoOuterContext(): boolean {\n\t\treturn this._dipsIntoOuterContext;\n\t}\n\n\tpublic get(index: number): ATNConfig {\n\t\treturn this.configs[index];\n\t}\n\n\tprotected ensureWritable(): void {\n\t\tif (this.isReadOnly) {\n\t\t\tthrow new Error(\"This ATNConfigSet is read only.\");\n\t\t}\n\t}\n}\n"]}