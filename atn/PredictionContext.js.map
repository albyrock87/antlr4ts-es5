{"version":3,"sources":["atn/PredictionContext.js","../src/atn/PredictionContext.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","Array2DHashMap_1","require","Array2DHashSet_1","Arrays_1","MurmurHash_1","Decorators_1","PredictionContextCache_1","assert","INITIAL_HASH","PredictionContext","cachedHashCode","returnContext","contextCache","appendContext","EMPTY_FULL","getChild","returnState","SingletonPredictionContext","recognizer","currentState","stop","result","outer","perm","offset","last","p","stateNumber","localBuffer","isEmpty","index","size","bits","mask","atn","s","states","ruleName","ruleNames","ruleIndex","getReturnState","EMPTY_FULL_STATE_KEY","getParent","push","hash","MurmurHash","initialize","finish","parent","update","parents","returnStates","outerContext","fullContext","EMPTY_LOCAL","_parent","fromRuleContext","state","invokingState","transition","followState","context","addEmptyContext","removeEmptyContext","context0","context1","PredictionContextCache","UNCACHED","isEmptyLocal","context0size","context1size","merged","join","count","parentsList","Array","returnStatesList","leftIndex","rightIndex","canReturnLeft","canReturnRight","slice","ArrayPredictionContext","visited","existing","get","put","changed","getCachedContext","j","putIfAbsent","updated","hashCode","Override","prototype","NotNull","EmptyPredictionContext","calculateEmptyHashCode","Error","suffix","o","calculateHashCode","Arrays","binarySearch","hasEmpty","parents2","returnStates2","appendContextImpl","IdentityHashMap","other","equalsImpl","Array2DHashSet","selfWorkList","otherWorkList","currentSelf","pop","currentOther","operands","IdentityCommutativePredictionContextOperands","add","selfSize","x","equals","y","otherSize","selfParent","otherParent","parentCount","updatedParents","updatedReturnStates","calculateSingleHashCode","EMPTY_LOCAL_STATE_KEY","IdentityEqualityComparator","INSTANCE","Array2DHashMap","obj","a","b"],"mappings":"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","file":"PredictionContext.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:35.3812636-07:00\nconst Array2DHashMap_1 = require(\"../misc/Array2DHashMap\");\nconst Array2DHashSet_1 = require(\"../misc/Array2DHashSet\");\nconst Arrays_1 = require(\"../misc/Arrays\");\nconst MurmurHash_1 = require(\"../misc/MurmurHash\");\nconst Decorators_1 = require(\"../Decorators\");\nconst PredictionContextCache_1 = require(\"./PredictionContextCache\");\nconst assert = require(\"assert\");\nconst INITIAL_HASH = 1;\nclass PredictionContext {\n    constructor(cachedHashCode) {\n        this.cachedHashCode = cachedHashCode;\n    }\n    static calculateEmptyHashCode() {\n        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);\n        hash = MurmurHash_1.MurmurHash.finish(hash, 0);\n        return hash;\n    }\n    static calculateSingleHashCode(parent, returnState) {\n        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);\n        hash = MurmurHash_1.MurmurHash.update(hash, parent);\n        hash = MurmurHash_1.MurmurHash.update(hash, returnState);\n        hash = MurmurHash_1.MurmurHash.finish(hash, 2);\n        return hash;\n    }\n    static calculateHashCode(parents, returnStates) {\n        let hash = MurmurHash_1.MurmurHash.initialize(INITIAL_HASH);\n        for (let parent of parents) {\n            hash = MurmurHash_1.MurmurHash.update(hash, parent);\n        }\n        for (let returnState of returnStates) {\n            hash = MurmurHash_1.MurmurHash.update(hash, returnState);\n        }\n        hash = MurmurHash_1.MurmurHash.finish(hash, 2 * parents.length);\n        return hash;\n    }\n    static fromRuleContext(atn, outerContext, fullContext = true) {\n        if (outerContext.isEmpty) {\n            return fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;\n        }\n        let parent;\n        if (outerContext._parent) {\n            parent = PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);\n        }\n        else {\n            parent = fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;\n        }\n        let state = atn.states[outerContext.invokingState];\n        let transition = state.transition(0);\n        return parent.getChild(transition.followState.stateNumber);\n    }\n    static addEmptyContext(context) {\n        return context.addEmptyContext();\n    }\n    static removeEmptyContext(context) {\n        return context.removeEmptyContext();\n    }\n    static join(context0, context1, contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED) {\n        if (context0 === context1) {\n            return context0;\n        }\n        if (context0.isEmpty) {\n            return PredictionContext.isEmptyLocal(context0) ? context0 : PredictionContext.addEmptyContext(context1);\n        }\n        else if (context1.isEmpty) {\n            return PredictionContext.isEmptyLocal(context1) ? context1 : PredictionContext.addEmptyContext(context0);\n        }\n        let context0size = context0.size;\n        let context1size = context1.size;\n        if (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {\n            let merged = contextCache.join(context0.getParent(0), context1.getParent(0));\n            if (merged === context0.getParent(0)) {\n                return context0;\n            }\n            else if (merged === context1.getParent(0)) {\n                return context1;\n            }\n            else {\n                return merged.getChild(context0.getReturnState(0));\n            }\n        }\n        let count = 0;\n        let parentsList = new Array(context0size + context1size);\n        let returnStatesList = new Array(parentsList.length);\n        let leftIndex = 0;\n        let rightIndex = 0;\n        let canReturnLeft = true;\n        let canReturnRight = true;\n        while (leftIndex < context0size && rightIndex < context1size) {\n            if (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {\n                parentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));\n                returnStatesList[count] = context0.getReturnState(leftIndex);\n                canReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);\n                canReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);\n                leftIndex++;\n                rightIndex++;\n            }\n            else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {\n                parentsList[count] = context0.getParent(leftIndex);\n                returnStatesList[count] = context0.getReturnState(leftIndex);\n                canReturnRight = false;\n                leftIndex++;\n            }\n            else {\n                assert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));\n                parentsList[count] = context1.getParent(rightIndex);\n                returnStatesList[count] = context1.getReturnState(rightIndex);\n                canReturnLeft = false;\n                rightIndex++;\n            }\n            count++;\n        }\n        while (leftIndex < context0size) {\n            parentsList[count] = context0.getParent(leftIndex);\n            returnStatesList[count] = context0.getReturnState(leftIndex);\n            leftIndex++;\n            canReturnRight = false;\n            count++;\n        }\n        while (rightIndex < context1size) {\n            parentsList[count] = context1.getParent(rightIndex);\n            returnStatesList[count] = context1.getReturnState(rightIndex);\n            rightIndex++;\n            canReturnLeft = false;\n            count++;\n        }\n        if (canReturnLeft) {\n            return context0;\n        }\n        else if (canReturnRight) {\n            return context1;\n        }\n        if (count < parentsList.length) {\n            parentsList = parentsList.slice(0, count);\n            returnStatesList = returnStatesList.slice(0, count);\n        }\n        if (parentsList.length === 0) {\n            // if one of them was EMPTY_LOCAL, it would be empty and handled at the beginning of the method\n            return PredictionContext.EMPTY_FULL;\n        }\n        else if (parentsList.length === 1) {\n            return new SingletonPredictionContext(parentsList[0], returnStatesList[0]);\n        }\n        else {\n            return new ArrayPredictionContext(parentsList, returnStatesList);\n        }\n    }\n    static isEmptyLocal(context) {\n        return context === PredictionContext.EMPTY_LOCAL;\n    }\n    static getCachedContext(context, contextCache, visited) {\n        if (context.isEmpty) {\n            return context;\n        }\n        let existing = visited.get(context);\n        if (existing) {\n            return existing;\n        }\n        existing = contextCache.get(context);\n        if (existing) {\n            visited.put(context, existing);\n            return existing;\n        }\n        let changed = false;\n        let parents = new Array(context.size);\n        for (let i = 0; i < parents.length; i++) {\n            let parent = PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);\n            if (changed || parent !== context.getParent(i)) {\n                if (!changed) {\n                    parents = new Array(context.size);\n                    for (let j = 0; j < context.size; j++) {\n                        parents[j] = context.getParent(j);\n                    }\n                    changed = true;\n                }\n                parents[i] = parent;\n            }\n        }\n        if (!changed) {\n            existing = contextCache.putIfAbsent(context, context);\n            visited.put(context, existing != null ? existing : context);\n            return context;\n        }\n        // We know parents.length>0 because context.isEmpty is checked at the beginning of the method.\n        let updated;\n        if (parents.length === 1) {\n            updated = new SingletonPredictionContext(parents[0], context.getReturnState(0));\n        }\n        else {\n            let returnStates = new Array(context.size);\n            for (let i = 0; i < context.size; i++) {\n                returnStates[i] = context.getReturnState(i);\n            }\n            updated = new ArrayPredictionContext(parents, returnStates, context.hashCode());\n        }\n        existing = contextCache.putIfAbsent(updated, updated);\n        visited.put(updated, existing || updated);\n        visited.put(context, existing || updated);\n        return updated;\n    }\n    appendSingleContext(returnContext, contextCache) {\n        return this.appendContext(PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);\n    }\n    getChild(returnState) {\n        return new SingletonPredictionContext(this, returnState);\n    }\n    hashCode() {\n        return this.cachedHashCode;\n    }\n    toStrings(recognizer, currentState, stop = PredictionContext.EMPTY_FULL) {\n        let result = [];\n        outer: for (let perm = 0;; perm++) {\n            let offset = 0;\n            let last = true;\n            let p = this;\n            let stateNumber = currentState;\n            let localBuffer = \"\";\n            localBuffer += \"[\";\n            while (!p.isEmpty && p !== stop) {\n                let index = 0;\n                if (p.size > 0) {\n                    let bits = 1;\n                    while (((1 << bits) >>> 0) < p.size) {\n                        bits++;\n                    }\n                    let mask = ((1 << bits) >>> 0) - 1;\n                    index = (perm >> offset) & mask;\n                    last = last && index >= p.size - 1;\n                    if (index >= p.size) {\n                        continue outer;\n                    }\n                    offset += bits;\n                }\n                if (recognizer) {\n                    if (localBuffer.length > 1) {\n                        // first char is '[', if more than that this isn't the first rule\n                        localBuffer += \" \";\n                    }\n                    let atn = recognizer.atn;\n                    let s = atn.states[stateNumber];\n                    let ruleName = recognizer.ruleNames[s.ruleIndex];\n                    localBuffer += ruleName;\n                }\n                else if (p.getReturnState(index) !== PredictionContext.EMPTY_FULL_STATE_KEY) {\n                    if (!p.isEmpty) {\n                        if (localBuffer.length > 1) {\n                            // first char is '[', if more than that this isn't the first rule\n                            localBuffer += \" \";\n                        }\n                        localBuffer += p.getReturnState(index);\n                    }\n                }\n                stateNumber = p.getReturnState(index);\n                p = p.getParent(index);\n            }\n            localBuffer += \"]\";\n            result.push(localBuffer);\n            if (last) {\n                break;\n            }\n        }\n        return result;\n    }\n}\n__decorate([\n    Decorators_1.Override\n], PredictionContext.prototype, \"hashCode\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)\n], PredictionContext, \"join\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n], PredictionContext, \"getCachedContext\", null);\nexports.PredictionContext = PredictionContext;\nclass EmptyPredictionContext extends PredictionContext {\n    constructor(fullContext) {\n        super(PredictionContext.calculateEmptyHashCode());\n        this.fullContext = fullContext;\n    }\n    get isFullContext() {\n        return this.fullContext;\n    }\n    addEmptyContext() {\n        return this;\n    }\n    removeEmptyContext() {\n        throw new Error(\"Cannot remove the empty context from itself.\");\n    }\n    getParent(index) {\n        throw new Error(\"index out of bounds\");\n    }\n    getReturnState(index) {\n        throw new Error(\"index out of bounds\");\n    }\n    findReturnState(returnState) {\n        return -1;\n    }\n    get size() {\n        return 0;\n    }\n    appendSingleContext(returnContext, contextCache) {\n        return contextCache.getChild(this, returnContext);\n    }\n    appendContext(suffix, contextCache) {\n        return suffix;\n    }\n    get isEmpty() {\n        return true;\n    }\n    get hasEmpty() {\n        return true;\n    }\n    equals(o) {\n        return this === o;\n    }\n    toStrings(recognizer, currentState, stop) {\n        return [\"[]\"];\n    }\n}\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"addEmptyContext\", null);\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"removeEmptyContext\", null);\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"getParent\", null);\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"getReturnState\", null);\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"findReturnState\", null);\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"size\", null);\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"appendSingleContext\", null);\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"appendContext\", null);\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"isEmpty\", null);\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"hasEmpty\", null);\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"equals\", null);\n__decorate([\n    Decorators_1.Override\n], EmptyPredictionContext.prototype, \"toStrings\", null);\nlet ArrayPredictionContext = class ArrayPredictionContext extends PredictionContext {\n    constructor(parents, returnStates, hashCode) {\n        super(hashCode || PredictionContext.calculateHashCode(parents, returnStates));\n        assert(parents.length === returnStates.length);\n        assert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, \"Should be using PredictionContext.EMPTY instead.\");\n        this.parents = parents;\n        this.returnStates = returnStates;\n    }\n    getParent(index) {\n        return this.parents[index];\n    }\n    getReturnState(index) {\n        return this.returnStates[index];\n    }\n    findReturnState(returnState) {\n        return Arrays_1.Arrays.binarySearch(this.returnStates, returnState);\n    }\n    get size() {\n        return this.returnStates.length;\n    }\n    get isEmpty() {\n        return false;\n    }\n    get hasEmpty() {\n        return this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;\n    }\n    addEmptyContext() {\n        if (this.hasEmpty) {\n            return this;\n        }\n        let parents2 = this.parents.slice(0);\n        let returnStates2 = this.returnStates.slice(0);\n        parents2.push(PredictionContext.EMPTY_FULL);\n        returnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);\n        return new ArrayPredictionContext(parents2, returnStates2);\n    }\n    removeEmptyContext() {\n        if (!this.hasEmpty) {\n            return this;\n        }\n        if (this.returnStates.length === 2) {\n            return new SingletonPredictionContext(this.parents[0], this.returnStates[0]);\n        }\n        else {\n            let parents2 = this.parents.slice(0, this.parents.length - 1);\n            let returnStates2 = this.returnStates.slice(0, this.returnStates.length - 1);\n            return new ArrayPredictionContext(parents2, returnStates2);\n        }\n    }\n    appendContext(suffix, contextCache) {\n        return ArrayPredictionContext.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());\n    }\n    static appendContextImpl(context, suffix, visited) {\n        if (suffix.isEmpty) {\n            if (PredictionContext.isEmptyLocal(suffix)) {\n                if (context.hasEmpty) {\n                    return PredictionContext.EMPTY_LOCAL;\n                }\n                throw new Error(\"what to do here?\");\n            }\n            return context;\n        }\n        if (suffix.size !== 1) {\n            throw new Error(\"Appending a tree suffix is not yet supported.\");\n        }\n        let result = visited.get(context);\n        if (!result) {\n            if (context.isEmpty) {\n                result = suffix;\n            }\n            else {\n                let parentCount = context.size;\n                if (context.hasEmpty) {\n                    parentCount--;\n                }\n                let updatedParents = new Array(parentCount);\n                let updatedReturnStates = new Array(parentCount);\n                for (let i = 0; i < parentCount; i++) {\n                    updatedReturnStates[i] = context.getReturnState(i);\n                }\n                for (let i = 0; i < parentCount; i++) {\n                    updatedParents[i] = ArrayPredictionContext.appendContextImpl(context.getParent(i), suffix, visited);\n                }\n                if (updatedParents.length === 1) {\n                    result = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);\n                }\n                else {\n                    assert(updatedParents.length > 1);\n                    result = new ArrayPredictionContext(updatedParents, updatedReturnStates);\n                }\n                if (context.hasEmpty) {\n                    result = PredictionContext.join(result, suffix);\n                }\n            }\n            visited.put(context, result);\n        }\n        return result;\n    }\n    equals(o) {\n        if (this === o) {\n            return true;\n        }\n        else if (!(o instanceof ArrayPredictionContext)) {\n            return false;\n        }\n        if (this.hashCode() !== o.hashCode()) {\n            // can't be same if hash is different\n            return false;\n        }\n        let other = o;\n        return this.equalsImpl(other, new Array2DHashSet_1.Array2DHashSet());\n    }\n    equalsImpl(other, visited) {\n        let selfWorkList = [];\n        let otherWorkList = [];\n        selfWorkList.push(this);\n        otherWorkList.push(other);\n        while (true) {\n            let currentSelf = selfWorkList.pop();\n            let currentOther = otherWorkList.pop();\n            if (!currentSelf || !currentOther) {\n                break;\n            }\n            let operands = new PredictionContextCache_1.PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);\n            if (!visited.add(operands)) {\n                continue;\n            }\n            let selfSize = operands.x.size;\n            if (selfSize === 0) {\n                if (!operands.x.equals(operands.y)) {\n                    return false;\n                }\n                continue;\n            }\n            let otherSize = operands.y.size;\n            if (selfSize !== otherSize) {\n                return false;\n            }\n            for (let i = 0; i < selfSize; i++) {\n                if (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {\n                    return false;\n                }\n                let selfParent = operands.x.getParent(i);\n                let otherParent = operands.y.getParent(i);\n                if (selfParent.hashCode() !== otherParent.hashCode()) {\n                    return false;\n                }\n                if (selfParent !== otherParent) {\n                    selfWorkList.push(selfParent);\n                    otherWorkList.push(otherParent);\n                }\n            }\n        }\n        return true;\n    }\n};\n__decorate([\n    Decorators_1.NotNull\n], ArrayPredictionContext.prototype, \"parents\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], ArrayPredictionContext.prototype, \"returnStates\", void 0);\n__decorate([\n    Decorators_1.Override\n], ArrayPredictionContext.prototype, \"getParent\", null);\n__decorate([\n    Decorators_1.Override\n], ArrayPredictionContext.prototype, \"getReturnState\", null);\n__decorate([\n    Decorators_1.Override\n], ArrayPredictionContext.prototype, \"findReturnState\", null);\n__decorate([\n    Decorators_1.Override\n], ArrayPredictionContext.prototype, \"size\", null);\n__decorate([\n    Decorators_1.Override\n], ArrayPredictionContext.prototype, \"isEmpty\", null);\n__decorate([\n    Decorators_1.Override\n], ArrayPredictionContext.prototype, \"hasEmpty\", null);\n__decorate([\n    Decorators_1.Override\n], ArrayPredictionContext.prototype, \"addEmptyContext\", null);\n__decorate([\n    Decorators_1.Override\n], ArrayPredictionContext.prototype, \"removeEmptyContext\", null);\n__decorate([\n    Decorators_1.Override\n], ArrayPredictionContext.prototype, \"appendContext\", null);\n__decorate([\n    Decorators_1.Override\n], ArrayPredictionContext.prototype, \"equals\", null);\nArrayPredictionContext = __decorate([\n    __param(0, Decorators_1.NotNull)\n], ArrayPredictionContext);\nlet SingletonPredictionContext = class SingletonPredictionContext extends PredictionContext {\n    constructor(parent, returnState) {\n        super(PredictionContext.calculateSingleHashCode(parent, returnState));\n        // assert(returnState != PredictionContext.EMPTY_FULL_STATE_KEY && returnState != PredictionContext.EMPTY_LOCAL_STATE_KEY);\n        this.parent = parent;\n        this.returnState = returnState;\n    }\n    getParent(index) {\n        // assert(index == 0);\n        return this.parent;\n    }\n    getReturnState(index) {\n        // assert(index == 0);\n        return this.returnState;\n    }\n    findReturnState(returnState) {\n        return this.returnState === returnState ? 0 : -1;\n    }\n    get size() {\n        return 1;\n    }\n    get isEmpty() {\n        return false;\n    }\n    get hasEmpty() {\n        return false;\n    }\n    appendContext(suffix, contextCache) {\n        return contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);\n    }\n    addEmptyContext() {\n        let parents = [this.parent, PredictionContext.EMPTY_FULL];\n        let returnStates = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];\n        return new ArrayPredictionContext(parents, returnStates);\n    }\n    removeEmptyContext() {\n        return this;\n    }\n    equals(o) {\n        if (o === this) {\n            return true;\n        }\n        else if (!(o instanceof SingletonPredictionContext)) {\n            return false;\n        }\n        let other = o;\n        if (this.hashCode() !== other.hashCode()) {\n            return false;\n        }\n        return this.returnState === other.returnState\n            && this.parent.equals(other.parent);\n    }\n};\n__decorate([\n    Decorators_1.NotNull\n], SingletonPredictionContext.prototype, \"parent\", void 0);\n__decorate([\n    Decorators_1.Override\n], SingletonPredictionContext.prototype, \"getParent\", null);\n__decorate([\n    Decorators_1.Override\n], SingletonPredictionContext.prototype, \"getReturnState\", null);\n__decorate([\n    Decorators_1.Override\n], SingletonPredictionContext.prototype, \"findReturnState\", null);\n__decorate([\n    Decorators_1.Override\n], SingletonPredictionContext.prototype, \"size\", null);\n__decorate([\n    Decorators_1.Override\n], SingletonPredictionContext.prototype, \"isEmpty\", null);\n__decorate([\n    Decorators_1.Override\n], SingletonPredictionContext.prototype, \"hasEmpty\", null);\n__decorate([\n    Decorators_1.Override\n], SingletonPredictionContext.prototype, \"appendContext\", null);\n__decorate([\n    Decorators_1.Override\n], SingletonPredictionContext.prototype, \"addEmptyContext\", null);\n__decorate([\n    Decorators_1.Override\n], SingletonPredictionContext.prototype, \"removeEmptyContext\", null);\n__decorate([\n    Decorators_1.Override\n], SingletonPredictionContext.prototype, \"equals\", null);\nSingletonPredictionContext = __decorate([\n    __param(0, Decorators_1.NotNull)\n], SingletonPredictionContext);\nexports.SingletonPredictionContext = SingletonPredictionContext;\n(function (PredictionContext) {\n    PredictionContext.EMPTY_LOCAL = new EmptyPredictionContext(false);\n    PredictionContext.EMPTY_FULL = new EmptyPredictionContext(true);\n    PredictionContext.EMPTY_LOCAL_STATE_KEY = -((1 << 31) >>> 0);\n    PredictionContext.EMPTY_FULL_STATE_KEY = ((1 << 31) >>> 0) - 1;\n    class IdentityHashMap extends Array2DHashMap_1.Array2DHashMap {\n        constructor() {\n            super(IdentityEqualityComparator.INSTANCE);\n        }\n    }\n    PredictionContext.IdentityHashMap = IdentityHashMap;\n    class IdentityEqualityComparator {\n        IdentityEqualityComparator() {\n            // intentionally empty\n        }\n        hashCode(obj) {\n            return obj.hashCode();\n        }\n        equals(a, b) {\n            return a === b;\n        }\n    }\n    IdentityEqualityComparator.INSTANCE = new IdentityEqualityComparator();\n    __decorate([\n        Decorators_1.Override\n    ], IdentityEqualityComparator.prototype, \"hashCode\", null);\n    __decorate([\n        Decorators_1.Override\n    ], IdentityEqualityComparator.prototype, \"equals\", null);\n    PredictionContext.IdentityEqualityComparator = IdentityEqualityComparator;\n})(PredictionContext = exports.PredictionContext || (exports.PredictionContext = {}));\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:35.3812636-07:00\n\n\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\nimport { Arrays } from \"../misc/Arrays\";\nimport { ATN } from \"./ATN\";\nimport { ATNState } from \"./ATNState\";\nimport { EqualityComparator } from \"../misc/EqualityComparator\";\nimport { MurmurHash } from \"../misc/MurmurHash\";\nimport { NotNull, Override } from \"../Decorators\";\nimport { Equatable, JavaSet } from \"../misc/Stubs\";\nimport { PredictionContextCache } from \"./PredictionContextCache\";\nimport { Recognizer } from \"../Recognizer\";\nimport { RuleContext } from \"../RuleContext\";\nimport { RuleTransition } from \"./RuleTransition\";\n\nimport * as assert from \"assert\";\n\nconst INITIAL_HASH: number = 1;\n\nexport abstract class PredictionContext implements Equatable {\n\t/**\n\t * Stores the computed hash code of this {@link PredictionContext}. The hash\n\t * code is computed in parts to match the following reference algorithm.\n\t *\n\t * ```\n\t * private int referenceHashCode() {\n\t *   int hash = {@link MurmurHash#initialize MurmurHash.initialize}({@link #INITIAL_HASH});\n\t *\n\t *   for (int i = 0; i &lt; this.size; i++) {\n\t *     hash = {@link MurmurHash#update MurmurHash.update}(hash, {@link #getParent getParent}(i));\n\t *   }\n\t *\n\t *   for (int i = 0; i &lt; this.size; i++) {\n\t *     hash = {@link MurmurHash#update MurmurHash.update}(hash, {@link #getReturnState getReturnState}(i));\n\t *   }\n\t *\n\t *   hash = {@link MurmurHash#finish MurmurHash.finish}(hash, 2 * this.size);\n\t *   return hash;\n\t * }\n\t * ```\n\t */\n\tprivate readonly cachedHashCode: number;\n\n\tconstructor(cachedHashCode: number) {\n\t\tthis.cachedHashCode = cachedHashCode;\n\t}\n\n\tprotected static calculateEmptyHashCode(): number {\n\t\tlet hash: number = MurmurHash.initialize(INITIAL_HASH);\n\t\thash = MurmurHash.finish(hash, 0);\n\t\treturn hash;\n\t}\n\n\tprotected static calculateSingleHashCode(parent: PredictionContext, returnState: number): number {\n\t\tlet hash: number = MurmurHash.initialize(INITIAL_HASH);\n\t\thash = MurmurHash.update(hash, parent);\n\t\thash = MurmurHash.update(hash, returnState);\n\t\thash = MurmurHash.finish(hash, 2);\n\t\treturn hash;\n\t}\n\n\tprotected static calculateHashCode(parents: PredictionContext[], returnStates: number[]): number {\n\t\tlet hash: number = MurmurHash.initialize(INITIAL_HASH);\n\n\t\tfor (let parent of parents) {\n\t\t\thash = MurmurHash.update(hash, parent);\n\t\t}\n\n\t\tfor (let returnState of returnStates) {\n\t\t\thash = MurmurHash.update(hash, returnState);\n\t\t}\n\n\t\thash = MurmurHash.finish(hash, 2 * parents.length);\n\t\treturn hash;\n\t}\n\n\tpublic abstract readonly size: number;\n\n\tpublic abstract getReturnState(index: number): number;\n\n\tpublic abstract findReturnState(returnState: number): number;\n\n\t// @NotNull\n\tpublic abstract getParent(index: number): PredictionContext;\n\n\tprotected abstract addEmptyContext(): PredictionContext;\n\n\tprotected abstract removeEmptyContext(): PredictionContext;\n\n\tpublic static fromRuleContext(atn: ATN, outerContext: RuleContext, fullContext: boolean = true): PredictionContext {\n\t\tif (outerContext.isEmpty) {\n\t\t\treturn fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;\n\t\t}\n\n\t\tlet parent: PredictionContext;\n\t\tif (outerContext._parent) {\n\t\t\tparent = PredictionContext.fromRuleContext(atn, outerContext._parent, fullContext);\n\t\t} else {\n\t\t\tparent = fullContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL;\n\t\t}\n\n\t\tlet state: ATNState = atn.states[outerContext.invokingState];\n\t\tlet transition: RuleTransition = state.transition(0) as RuleTransition;\n\t\treturn parent.getChild(transition.followState.stateNumber);\n\t}\n\n\tprivate static addEmptyContext(context: PredictionContext): PredictionContext {\n\t\treturn context.addEmptyContext();\n\t}\n\n\tprivate static removeEmptyContext(context: PredictionContext): PredictionContext {\n\t\treturn context.removeEmptyContext();\n\t}\n\n\tpublic static join(@NotNull context0: PredictionContext, @NotNull context1: PredictionContext, @NotNull contextCache: PredictionContextCache = PredictionContextCache.UNCACHED): PredictionContext {\n\t\tif (context0 === context1) {\n\t\t\treturn context0;\n\t\t}\n\n\t\tif (context0.isEmpty) {\n\t\t\treturn PredictionContext.isEmptyLocal(context0) ? context0 : PredictionContext.addEmptyContext(context1);\n\t\t} else if (context1.isEmpty) {\n\t\t\treturn PredictionContext.isEmptyLocal(context1) ? context1 : PredictionContext.addEmptyContext(context0);\n\t\t}\n\n\t\tlet context0size: number = context0.size;\n\t\tlet context1size: number = context1.size;\n\t\tif (context0size === 1 && context1size === 1 && context0.getReturnState(0) === context1.getReturnState(0)) {\n\t\t\tlet merged: PredictionContext = contextCache.join(context0.getParent(0), context1.getParent(0));\n\t\t\tif (merged === context0.getParent(0)) {\n\t\t\t\treturn context0;\n\t\t\t} else if (merged === context1.getParent(0)) {\n\t\t\t\treturn context1;\n\t\t\t} else {\n\t\t\t\treturn merged.getChild(context0.getReturnState(0));\n\t\t\t}\n\t\t}\n\n\t\tlet count: number = 0;\n\t\tlet parentsList: PredictionContext[] = new Array<PredictionContext>(context0size + context1size);\n\t\tlet returnStatesList: number[] = new Array<number>(parentsList.length);\n\t\tlet leftIndex: number = 0;\n\t\tlet rightIndex: number = 0;\n\t\tlet canReturnLeft: boolean = true;\n\t\tlet canReturnRight: boolean = true;\n\t\twhile (leftIndex < context0size && rightIndex < context1size) {\n\t\t\tif (context0.getReturnState(leftIndex) === context1.getReturnState(rightIndex)) {\n\t\t\t\tparentsList[count] = contextCache.join(context0.getParent(leftIndex), context1.getParent(rightIndex));\n\t\t\t\treturnStatesList[count] = context0.getReturnState(leftIndex);\n\t\t\t\tcanReturnLeft = canReturnLeft && parentsList[count] === context0.getParent(leftIndex);\n\t\t\t\tcanReturnRight = canReturnRight && parentsList[count] === context1.getParent(rightIndex);\n\t\t\t\tleftIndex++;\n\t\t\t\trightIndex++;\n\t\t\t} else if (context0.getReturnState(leftIndex) < context1.getReturnState(rightIndex)) {\n\t\t\t\tparentsList[count] = context0.getParent(leftIndex);\n\t\t\t\treturnStatesList[count] = context0.getReturnState(leftIndex);\n\t\t\t\tcanReturnRight = false;\n\t\t\t\tleftIndex++;\n\t\t\t} else {\n\t\t\t\tassert(context1.getReturnState(rightIndex) < context0.getReturnState(leftIndex));\n\t\t\t\tparentsList[count] = context1.getParent(rightIndex);\n\t\t\t\treturnStatesList[count] = context1.getReturnState(rightIndex);\n\t\t\t\tcanReturnLeft = false;\n\t\t\t\trightIndex++;\n\t\t\t}\n\n\t\t\tcount++;\n\t\t}\n\n\t\twhile (leftIndex < context0size) {\n\t\t\tparentsList[count] = context0.getParent(leftIndex);\n\t\t\treturnStatesList[count] = context0.getReturnState(leftIndex);\n\t\t\tleftIndex++;\n\t\t\tcanReturnRight = false;\n\t\t\tcount++;\n\t\t}\n\n\t\twhile (rightIndex < context1size) {\n\t\t\tparentsList[count] = context1.getParent(rightIndex);\n\t\t\treturnStatesList[count] = context1.getReturnState(rightIndex);\n\t\t\trightIndex++;\n\t\t\tcanReturnLeft = false;\n\t\t\tcount++;\n\t\t}\n\n\t\tif (canReturnLeft) {\n\t\t\treturn context0;\n\t\t} else if (canReturnRight) {\n\t\t\treturn context1;\n\t\t}\n\n\t\tif (count < parentsList.length) {\n\t\t\tparentsList = parentsList.slice(0, count);\n\t\t\treturnStatesList = returnStatesList.slice(0, count);\n\t\t}\n\n\t\tif (parentsList.length === 0) {\n\t\t\t// if one of them was EMPTY_LOCAL, it would be empty and handled at the beginning of the method\n\t\t\treturn PredictionContext.EMPTY_FULL;\n\t\t} else if (parentsList.length === 1) {\n\t\t\treturn new SingletonPredictionContext(parentsList[0], returnStatesList[0]);\n\t\t} else {\n\t\t\treturn new ArrayPredictionContext(parentsList, returnStatesList);\n\t\t}\n\t}\n\n\tpublic static isEmptyLocal(context: PredictionContext): boolean {\n\t\treturn context === PredictionContext.EMPTY_LOCAL;\n\t}\n\n\tpublic static getCachedContext(\n\t\t@NotNull context: PredictionContext,\n\t\t@NotNull contextCache: Array2DHashMap<PredictionContext, PredictionContext>,\n\t\t@NotNull visited: PredictionContext.IdentityHashMap): PredictionContext {\n\t\tif (context.isEmpty) {\n\t\t\treturn context;\n\t\t}\n\n\t\tlet existing = visited.get(context);\n\t\tif (existing) {\n\t\t\treturn existing;\n\t\t}\n\n\t\texisting = contextCache.get(context);\n\t\tif (existing) {\n\t\t\tvisited.put(context, existing);\n\t\t\treturn existing;\n\t\t}\n\n\t\tlet changed: boolean = false;\n\t\tlet parents: PredictionContext[] = new Array<PredictionContext>(context.size);\n\t\tfor (let i = 0; i < parents.length; i++) {\n\t\t\tlet parent: PredictionContext = PredictionContext.getCachedContext(context.getParent(i), contextCache, visited);\n\t\t\tif (changed || parent !== context.getParent(i)) {\n\t\t\t\tif (!changed) {\n\t\t\t\t\tparents = new Array<PredictionContext>(context.size);\n\t\t\t\t\tfor (let j = 0; j < context.size; j++) {\n\t\t\t\t\t\tparents[j] = context.getParent(j);\n\t\t\t\t\t}\n\n\t\t\t\t\tchanged = true;\n\t\t\t\t}\n\n\t\t\t\tparents[i] = parent;\n\t\t\t}\n\t\t}\n\n\t\tif (!changed) {\n\t\t\texisting = contextCache.putIfAbsent(context, context);\n\t\t\tvisited.put(context, existing != null ? existing : context);\n\t\t\treturn context;\n\t\t}\n\n\t\t// We know parents.length>0 because context.isEmpty is checked at the beginning of the method.\n\t\tlet updated: PredictionContext;\n\t\tif (parents.length === 1) {\n\t\t\tupdated = new SingletonPredictionContext(parents[0], context.getReturnState(0));\n\t\t} else {\n\t\t\tlet returnStates: number[] = new Array<number>(context.size);\n\t\t\tfor (let i = 0; i < context.size; i++) {\n\t\t\t\treturnStates[i] = context.getReturnState(i);\n\t\t\t}\n\n\t\t\tupdated = new ArrayPredictionContext(parents, returnStates, context.hashCode());\n\t\t}\n\n\t\texisting = contextCache.putIfAbsent(updated, updated);\n\t\tvisited.put(updated, existing || updated);\n\t\tvisited.put(context, existing || updated);\n\n\t\treturn updated;\n\t}\n\n\tpublic appendSingleContext(returnContext: number, contextCache: PredictionContextCache): PredictionContext {\n\t\treturn this.appendContext(PredictionContext.EMPTY_FULL.getChild(returnContext), contextCache);\n\t}\n\n\tpublic abstract appendContext(suffix: PredictionContext, contextCache: PredictionContextCache): PredictionContext;\n\n\tpublic getChild(returnState: number): PredictionContext {\n\t\treturn new SingletonPredictionContext(this, returnState);\n\t}\n\n\tpublic abstract readonly isEmpty: boolean;\n\n\tpublic abstract readonly hasEmpty: boolean;\n\n\t@Override\n\tpublic hashCode(): number {\n\t\treturn this.cachedHashCode;\n\t}\n\n\t// @Override\n\tpublic abstract equals(o: any): boolean;\n\n\tpublic toStrings(recognizer: Recognizer<any, any> | undefined, currentState: number, stop: PredictionContext = PredictionContext.EMPTY_FULL): string[] {\n\t\tlet result: string[] = [];\n\n\t\touter:\n\t\tfor (let perm = 0; ; perm++) {\n\t\t\tlet offset: number = 0;\n\t\t\tlet last: boolean = true;\n\t\t\tlet p: PredictionContext = this;\n\t\t\tlet stateNumber: number = currentState;\n\t\t\tlet localBuffer: string = \"\";\n\t\t\tlocalBuffer += \"[\";\n\t\t\twhile (!p.isEmpty && p !== stop) {\n\t\t\t\tlet index: number = 0;\n\t\t\t\tif (p.size > 0) {\n\t\t\t\t\tlet bits: number = 1;\n\t\t\t\t\twhile (((1 << bits) >>> 0) < p.size) {\n\t\t\t\t\t\tbits++;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet mask: number = ((1 << bits) >>> 0) - 1;\n\t\t\t\t\tindex = (perm >> offset) & mask;\n\t\t\t\t\tlast = last && index >= p.size - 1;\n\t\t\t\t\tif (index >= p.size) {\n\t\t\t\t\t\tcontinue outer;\n\t\t\t\t\t}\n\n\t\t\t\t\toffset += bits;\n\t\t\t\t}\n\n\t\t\t\tif (recognizer) {\n\t\t\t\t\tif (localBuffer.length > 1) {\n\t\t\t\t\t\t// first char is '[', if more than that this isn't the first rule\n\t\t\t\t\t\tlocalBuffer += \" \";\n\t\t\t\t\t}\n\n\t\t\t\t\tlet atn: ATN = recognizer.atn;\n\t\t\t\t\tlet s: ATNState = atn.states[stateNumber];\n\t\t\t\t\tlet ruleName: string = recognizer.ruleNames[s.ruleIndex];\n\t\t\t\t\tlocalBuffer += ruleName;\n\t\t\t\t} else if (p.getReturnState(index) !== PredictionContext.EMPTY_FULL_STATE_KEY) {\n\t\t\t\t\tif (!p.isEmpty) {\n\t\t\t\t\t\tif (localBuffer.length > 1) {\n\t\t\t\t\t\t\t// first char is '[', if more than that this isn't the first rule\n\t\t\t\t\t\t\tlocalBuffer += \" \";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlocalBuffer += p.getReturnState(index);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tstateNumber = p.getReturnState(index);\n\t\t\t\tp = p.getParent(index);\n\t\t\t}\n\n\t\t\tlocalBuffer += \"]\";\n\t\t\tresult.push(localBuffer);\n\n\t\t\tif (last) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nclass EmptyPredictionContext extends PredictionContext {\n\tprivate fullContext: boolean;\n\n\tconstructor(fullContext: boolean) {\n\t\tsuper(PredictionContext.calculateEmptyHashCode());\n\t\tthis.fullContext = fullContext;\n\t}\n\n\tget isFullContext(): boolean {\n\t\treturn this.fullContext;\n\t}\n\n\t@Override\n\tprotected addEmptyContext(): PredictionContext {\n\t\treturn this;\n\t}\n\n\t@Override\n\tprotected removeEmptyContext(): PredictionContext {\n\t\tthrow new Error(\"Cannot remove the empty context from itself.\");\n\t}\n\n\t@Override\n\tpublic getParent(index: number): PredictionContext {\n\t\tthrow new Error(\"index out of bounds\");\n\t}\n\n\t@Override\n\tpublic getReturnState(index: number): number {\n\t\tthrow new Error(\"index out of bounds\");\n\t}\n\n\t@Override\n\tpublic findReturnState(returnState: number): number {\n\t\treturn -1;\n\t}\n\n\t@Override\n\tget size(): number {\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic appendSingleContext(returnContext: number, contextCache: PredictionContextCache): PredictionContext {\n\t\treturn contextCache.getChild(this, returnContext);\n\t}\n\n\t@Override\n\tpublic appendContext(suffix: PredictionContext, contextCache: PredictionContextCache): PredictionContext {\n\t\treturn suffix;\n\t}\n\n\t@Override\n\tget isEmpty(): boolean {\n\t\treturn true;\n\t}\n\n\t@Override\n\tget hasEmpty(): boolean {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic equals(o: any): boolean {\n\t\treturn this === o;\n\t}\n\n\t@Override\n\tpublic toStrings(recognizer: any, currentState: number, stop?: PredictionContext): string[] {\n\t\treturn [\"[]\"];\n\t}\n\n}\n\nclass ArrayPredictionContext extends PredictionContext {\n\t@NotNull\n\tpublic parents: PredictionContext[];\n\n\t@NotNull\n\tpublic returnStates: number[];\n\n\tconstructor( @NotNull parents: PredictionContext[], returnStates: number[], hashCode?: number) {\n\t\tsuper(hashCode || PredictionContext.calculateHashCode(parents, returnStates));\n\t\tassert(parents.length === returnStates.length);\n\t\tassert(returnStates.length > 1 || returnStates[0] !== PredictionContext.EMPTY_FULL_STATE_KEY, \"Should be using PredictionContext.EMPTY instead.\");\n\n\t\tthis.parents = parents;\n\t\tthis.returnStates = returnStates;\n\t}\n\n\t@Override\n\tpublic getParent(index: number): PredictionContext {\n\t\treturn this.parents[index];\n\t}\n\n\t@Override\n\tpublic getReturnState(index: number): number {\n\t\treturn this.returnStates[index];\n\t}\n\n\t@Override\n\tpublic findReturnState(returnState: number): number {\n\t\treturn Arrays.binarySearch(this.returnStates, returnState);\n\t}\n\n\t@Override\n\tget size(): number {\n\t\treturn this.returnStates.length;\n\t}\n\n\t@Override\n\tget isEmpty(): boolean {\n\t\treturn false;\n\t}\n\n\t@Override\n\tget hasEmpty(): boolean {\n\t\treturn this.returnStates[this.returnStates.length - 1] === PredictionContext.EMPTY_FULL_STATE_KEY;\n\t}\n\n\t@Override\n\tprotected addEmptyContext(): PredictionContext {\n\t\tif (this.hasEmpty) {\n\t\t\treturn this;\n\t\t}\n\n\t\tlet parents2: PredictionContext[] = this.parents.slice(0);\n\t\tlet returnStates2: number[] = this.returnStates.slice(0);\n\t\tparents2.push(PredictionContext.EMPTY_FULL);\n\t\treturnStates2.push(PredictionContext.EMPTY_FULL_STATE_KEY);\n\t\treturn new ArrayPredictionContext(parents2, returnStates2);\n\t}\n\n\t@Override\n\tprotected removeEmptyContext(): PredictionContext {\n\t\tif (!this.hasEmpty) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this.returnStates.length === 2) {\n\t\t\treturn new SingletonPredictionContext(this.parents[0], this.returnStates[0]);\n\t\t} else {\n\t\t\tlet parents2: PredictionContext[] = this.parents.slice(0, this.parents.length - 1);\n\t\t\tlet returnStates2: number[] = this.returnStates.slice(0, this.returnStates.length - 1);\n\t\t\treturn new ArrayPredictionContext(parents2, returnStates2);\n\t\t}\n\t}\n\n\t@Override\n\tpublic appendContext(suffix: PredictionContext, contextCache: PredictionContextCache): PredictionContext {\n\t\treturn ArrayPredictionContext.appendContextImpl(this, suffix, new PredictionContext.IdentityHashMap());\n\t}\n\n\tprivate static appendContextImpl(context: PredictionContext, suffix: PredictionContext, visited: PredictionContext.IdentityHashMap): PredictionContext {\n\t\tif (suffix.isEmpty) {\n\t\t\tif (PredictionContext.isEmptyLocal(suffix)) {\n\t\t\t\tif (context.hasEmpty) {\n\t\t\t\t\treturn PredictionContext.EMPTY_LOCAL;\n\t\t\t\t}\n\n\t\t\t\tthrow new Error(\"what to do here?\");\n\t\t\t}\n\n\t\t\treturn context;\n\t\t}\n\n\t\tif (suffix.size !== 1) {\n\t\t\tthrow new Error(\"Appending a tree suffix is not yet supported.\");\n\t\t}\n\n\t\tlet result = visited.get(context);\n\t\tif (!result) {\n\t\t\tif (context.isEmpty) {\n\t\t\t\tresult = suffix;\n\t\t\t} else {\n\t\t\t\tlet parentCount: number = context.size;\n\t\t\t\tif (context.hasEmpty) {\n\t\t\t\t\tparentCount--;\n\t\t\t\t}\n\n\t\t\t\tlet updatedParents: PredictionContext[] = new Array<PredictionContext>(parentCount);\n\t\t\t\tlet updatedReturnStates: number[] = new Array<number>(parentCount);\n\t\t\t\tfor (let i = 0; i < parentCount; i++) {\n\t\t\t\t\tupdatedReturnStates[i] = context.getReturnState(i);\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < parentCount; i++) {\n\t\t\t\t\tupdatedParents[i] = ArrayPredictionContext.appendContextImpl(context.getParent(i), suffix, visited);\n\t\t\t\t}\n\n\t\t\t\tif (updatedParents.length === 1) {\n\t\t\t\t\tresult = new SingletonPredictionContext(updatedParents[0], updatedReturnStates[0]);\n\t\t\t\t} else {\n\t\t\t\t\tassert(updatedParents.length > 1);\n\t\t\t\t\tresult = new ArrayPredictionContext(updatedParents, updatedReturnStates);\n\t\t\t\t}\n\n\t\t\t\tif (context.hasEmpty) {\n\t\t\t\t\tresult = PredictionContext.join(result, suffix);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvisited.put(context, result);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic equals(o: any): boolean {\n\t\tif (this === o) {\n\t\t\treturn true;\n\t\t} else if (!(o instanceof ArrayPredictionContext)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.hashCode() !== o.hashCode()) {\n\t\t\t// can't be same if hash is different\n\t\t\treturn false;\n\t\t}\n\n\t\tlet other: ArrayPredictionContext = o;\n\t\treturn this.equalsImpl(other, new Array2DHashSet<PredictionContextCache.IdentityCommutativePredictionContextOperands>());\n\t}\n\n\tprivate equalsImpl(other: ArrayPredictionContext, visited: JavaSet<PredictionContextCache.IdentityCommutativePredictionContextOperands>): boolean {\n\t\tlet selfWorkList: PredictionContext[] = [];\n\t\tlet otherWorkList: PredictionContext[] = [];\n\t\tselfWorkList.push(this);\n\t\totherWorkList.push(other);\n\t\twhile (true) {\n\t\t\tlet currentSelf = selfWorkList.pop();\n\t\t\tlet currentOther = otherWorkList.pop();\n\t\t\tif (!currentSelf || !currentOther) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlet operands: PredictionContextCache.IdentityCommutativePredictionContextOperands = new PredictionContextCache.IdentityCommutativePredictionContextOperands(currentSelf, currentOther);\n\t\t\tif (!visited.add(operands)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet selfSize: number = operands.x.size;\n\t\t\tif (selfSize === 0) {\n\t\t\t\tif (!operands.x.equals(operands.y)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet otherSize: number = operands.y.size;\n\t\t\tif (selfSize !== otherSize) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < selfSize; i++) {\n\t\t\t\tif (operands.x.getReturnState(i) !== operands.y.getReturnState(i)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tlet selfParent: PredictionContext = operands.x.getParent(i);\n\t\t\t\tlet otherParent: PredictionContext = operands.y.getParent(i);\n\t\t\t\tif (selfParent.hashCode() !== otherParent.hashCode()) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tif (selfParent !== otherParent) {\n\t\t\t\t\tselfWorkList.push(selfParent);\n\t\t\t\t\totherWorkList.push(otherParent);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn true;\n\t}\n}\n\nexport class SingletonPredictionContext extends PredictionContext {\n\n\t@NotNull\n\tpublic parent: PredictionContext;\n\tpublic returnState: number;\n\n\tconstructor(@NotNull parent: PredictionContext, returnState: number) {\n\t\tsuper(PredictionContext.calculateSingleHashCode(parent, returnState));\n\t\t// assert(returnState != PredictionContext.EMPTY_FULL_STATE_KEY && returnState != PredictionContext.EMPTY_LOCAL_STATE_KEY);\n\t\tthis.parent = parent;\n\t\tthis.returnState = returnState;\n\t}\n\n\t@Override\n\tpublic getParent(index: number): PredictionContext {\n\t\t// assert(index == 0);\n\t\treturn this.parent;\n\t}\n\n\t@Override\n\tpublic getReturnState(index: number): number {\n\t\t// assert(index == 0);\n\t\treturn this.returnState;\n\t}\n\n\t@Override\n\tpublic findReturnState(returnState: number): number {\n\t\treturn this.returnState === returnState ? 0 : -1;\n\t}\n\n\t@Override\n\tget size(): number {\n\t\treturn 1;\n\t}\n\n\t@Override\n\tget isEmpty(): boolean {\n\t\treturn false;\n\t}\n\n\t@Override\n\tget hasEmpty(): boolean {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic appendContext(suffix: PredictionContext, contextCache: PredictionContextCache): PredictionContext {\n\t\treturn contextCache.getChild(this.parent.appendContext(suffix, contextCache), this.returnState);\n\t}\n\n\t@Override\n\tprotected addEmptyContext(): PredictionContext {\n\t\tlet parents: PredictionContext[] = [this.parent, PredictionContext.EMPTY_FULL];\n\t\tlet returnStates: number[] = [this.returnState, PredictionContext.EMPTY_FULL_STATE_KEY];\n\t\treturn new ArrayPredictionContext(parents, returnStates);\n\t}\n\n\t@Override\n\tprotected removeEmptyContext(): PredictionContext {\n\t\treturn this;\n\t}\n\n\t@Override\n\tpublic equals(o: any): boolean {\n\t\tif (o === this) {\n\t\t\treturn true;\n\t\t} else if (!(o instanceof SingletonPredictionContext)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet other: SingletonPredictionContext = o;\n\t\tif (this.hashCode() !== other.hashCode()) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.returnState === other.returnState\n\t\t\t&& this.parent.equals(other.parent);\n\t}\n}\n\nexport namespace PredictionContext {\n\texport const EMPTY_LOCAL: PredictionContext = new EmptyPredictionContext(false);\n\texport const EMPTY_FULL: PredictionContext = new EmptyPredictionContext(true);\n\texport const EMPTY_LOCAL_STATE_KEY: number = -((1 << 31) >>> 0);\n\texport const EMPTY_FULL_STATE_KEY: number = ((1 << 31) >>> 0) - 1;\n\n\texport class IdentityHashMap extends Array2DHashMap<PredictionContext, PredictionContext> {\n\t\tconstructor() {\n\t\t\tsuper(IdentityEqualityComparator.INSTANCE);\n\t\t}\n\t}\n\n\texport class IdentityEqualityComparator implements EqualityComparator<PredictionContext> {\n\t\tpublic static readonly INSTANCE: IdentityEqualityComparator = new IdentityEqualityComparator();\n\n\t\tprivate IdentityEqualityComparator() {\n\t\t\t// intentionally empty\n\t\t}\n\n\t\t@Override\n\t\tpublic hashCode(obj: PredictionContext): number {\n\t\t\treturn obj.hashCode();\n\t\t}\n\n\t\t@Override\n\t\tpublic equals(a: PredictionContext, b: PredictionContext): boolean {\n\t\t\treturn a === b;\n\t\t}\n\t}\n}\n"]}