{"version":3,"sources":["atn/ProfilingATNSimulator.js","../src/atn/ProfilingATNSimulator.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","AmbiguityInfo_1","require","ATN_1","ATNSimulator_1","ContextSensitivityInfo_1","DecisionInfo_1","ErrorInfo_1","Decorators_1","LookaheadEventInfo_1","ParserATNSimulator_1","PredicateEvalInfo_1","SemanticContext_1","SimulatorState_1","ProfilingATNSimulator","parser","interpreter","atn","_startIndex","_sllStopIndex","_llStopIndex","currentDecision","conflictingAltResolvedBySLL","optimize_ll1","reportAmbiguities","numDecisions","decisionToState","decisions","push","DecisionInfo","input","decision","outerContext","useContext","undefined","_input","index","currentState","ATN","INVALID_ALT_NUMBER","start","process","hrtime","alt","stop","nanoseconds","timeInPrediction","invocations","SLL_k","SLL_TotalLook","SLL_MinLook","Math","min","SLL_MaxLook","SLL_MaxLookEvent","LookaheadEventInfo","LL_k","LL_TotalLook","LL_MinLook","LL_MaxLook","LL_MaxLookEvent","dfa","state","globalContext","previous","t","contextCache","Error","reachState","errors","ErrorInfo","previousD","existingTargetState","SimulatorState","remainingOuterContext","LL_DFATransitions","SLL_DFATransitions","ATNSimulator","ERROR","s","remainingGlobalContext","targetState","LL_ATNTransitions","SLL_ATNTransitions","pred","parserCallStack","result","SemanticContext","PrecedencePredicate","fullContext","stopIndex","predicateEvals","PredicateEvalInfo","prediction","acceptState","startIndex","contextSensitivities","ContextSensitivityInfo","conflictingAlts","conflictState","nextSetBit","s0","configs","getRepresentedAlternatives","LL_Fallback","D","exact","ambigAlts","ambiguities","AmbiguityInfo","ParserATNSimulator","Override","NotNull","prototype"],"mappings":"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","file":"ProfilingATNSimulator.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:36.4188352-07:00\nconst AmbiguityInfo_1 = require(\"./AmbiguityInfo\");\nconst ATN_1 = require(\"./ATN\");\nconst ATNSimulator_1 = require(\"./ATNSimulator\");\nconst ContextSensitivityInfo_1 = require(\"./ContextSensitivityInfo\");\nconst DecisionInfo_1 = require(\"./DecisionInfo\");\nconst ErrorInfo_1 = require(\"./ErrorInfo\");\nconst Decorators_1 = require(\"../Decorators\");\nconst LookaheadEventInfo_1 = require(\"./LookaheadEventInfo\");\nconst ParserATNSimulator_1 = require(\"./ParserATNSimulator\");\nconst PredicateEvalInfo_1 = require(\"./PredicateEvalInfo\");\nconst SemanticContext_1 = require(\"./SemanticContext\");\nconst SimulatorState_1 = require(\"./SimulatorState\");\n/**\n * @since 4.3\n */\nclass ProfilingATNSimulator extends ParserATNSimulator_1.ParserATNSimulator {\n    constructor(parser) {\n        super(parser.interpreter.atn, parser);\n        this._startIndex = 0;\n        this._sllStopIndex = 0;\n        this._llStopIndex = 0;\n        this.currentDecision = 0;\n        /** At the point of LL failover, we record how SLL would resolve the conflict so that\n         *  we can determine whether or not a decision / input pair is context-sensitive.\n         *  If LL gives a different result than SLL's predicted alternative, we have a\n         *  context sensitivity for sure. The converse is not necessarily true, however.\n         *  It's possible that after conflict resolution chooses minimum alternatives,\n         *  SLL could get the same answer as LL. Regardless of whether or not the result indicates\n         *  an ambiguity, it is not treated as a context sensitivity because LL prediction\n         *  was not required in order to produce a correct prediction for this decision and input sequence.\n         *  It may in fact still be a context sensitivity but we don't know by looking at the\n         *  minimum alternatives for the current input.\n         */\n        this.conflictingAltResolvedBySLL = 0;\n        this.optimize_ll1 = false;\n        this.reportAmbiguities = true;\n        this.numDecisions = this.atn.decisionToState.length;\n        this.decisions = [];\n        for (let i = 0; i < this.numDecisions; i++) {\n            this.decisions.push(new DecisionInfo_1.DecisionInfo(i));\n        }\n    }\n    adaptivePredict(input, decision, outerContext, useContext) {\n        if (useContext !== undefined) {\n            return super.adaptivePredict(input, decision, outerContext, useContext);\n        }\n        try {\n            this._input = input;\n            this._startIndex = input.index;\n            // it's possible for SLL to reach a conflict state without consuming any input\n            this._sllStopIndex = this._startIndex - 1;\n            this._llStopIndex = -1;\n            this.currentDecision = decision;\n            this.currentState = undefined;\n            this.conflictingAltResolvedBySLL = ATN_1.ATN.INVALID_ALT_NUMBER;\n            let start = process.hrtime();\n            let alt = super.adaptivePredict(input, decision, outerContext);\n            let stop = process.hrtime();\n            let nanoseconds = (stop[0] - start[0]) * 1000000000;\n            if (nanoseconds === 0) {\n                nanoseconds = stop[1] - start[1];\n            }\n            else {\n                // Add nanoseconds from start to end of that second, plus start of the end second to end\n                nanoseconds += (1000000000 - start[1]) + stop[1];\n            }\n            this.decisions[decision].timeInPrediction += nanoseconds;\n            this.decisions[decision].invocations++;\n            let SLL_k = this._sllStopIndex - this._startIndex + 1;\n            this.decisions[decision].SLL_TotalLook += SLL_k;\n            this.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);\n            if (SLL_k > this.decisions[decision].SLL_MaxLook) {\n                this.decisions[decision].SLL_MaxLook = SLL_k;\n                this.decisions[decision].SLL_MaxLookEvent =\n                    new LookaheadEventInfo_1.LookaheadEventInfo(decision, undefined, alt, input, this._startIndex, this._sllStopIndex, false);\n            }\n            if (this._llStopIndex >= 0) {\n                let LL_k = this._llStopIndex - this._startIndex + 1;\n                this.decisions[decision].LL_TotalLook += LL_k;\n                this.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);\n                if (LL_k > this.decisions[decision].LL_MaxLook) {\n                    this.decisions[decision].LL_MaxLook = LL_k;\n                    this.decisions[decision].LL_MaxLookEvent =\n                        new LookaheadEventInfo_1.LookaheadEventInfo(decision, undefined, alt, input, this._startIndex, this._llStopIndex, true);\n                }\n            }\n            return alt;\n        }\n        finally {\n            this._input = undefined;\n            this.currentDecision = -1;\n        }\n    }\n    getStartState(dfa, input, outerContext, useContext) {\n        let state = super.getStartState(dfa, input, outerContext, useContext);\n        this.currentState = state;\n        return state;\n    }\n    computeStartState(dfa, globalContext, useContext) {\n        let state = super.computeStartState(dfa, globalContext, useContext);\n        this.currentState = state;\n        return state;\n    }\n    computeReachSet(dfa, previous, t, contextCache) {\n        if (this._input === undefined) {\n            throw new Error(\"Invalid state\");\n        }\n        let reachState = super.computeReachSet(dfa, previous, t, contextCache);\n        if (reachState == null) {\n            // no reach on current lookahead symbol. ERROR.\n            this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index));\n        }\n        this.currentState = reachState;\n        return reachState;\n    }\n    getExistingTargetState(previousD, t) {\n        if (this.currentState === undefined || this._input === undefined) {\n            throw new Error(\"Invalid state\");\n        }\n        // this method is called after each time the input position advances\n        if (this.currentState.useContext) {\n            this._llStopIndex = this._input.index;\n        }\n        else {\n            this._sllStopIndex = this._input.index;\n        }\n        let existingTargetState = super.getExistingTargetState(previousD, t);\n        if (existingTargetState != null) {\n            // this method is directly called by execDFA; must construct a SimulatorState\n            // to represent the current state for this case\n            this.currentState = new SimulatorState_1.SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);\n            if (this.currentState.useContext) {\n                this.decisions[this.currentDecision].LL_DFATransitions++;\n            }\n            else {\n                this.decisions[this.currentDecision].SLL_DFATransitions++; // count only if we transition over a DFA state\n            }\n            if (existingTargetState === ATNSimulator_1.ATNSimulator.ERROR) {\n                let state = new SimulatorState_1.SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);\n                this.decisions[this.currentDecision].errors.push(new ErrorInfo_1.ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index));\n            }\n        }\n        return existingTargetState;\n    }\n    computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {\n        let targetState = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);\n        if (useContext) {\n            this.decisions[this.currentDecision].LL_ATNTransitions++;\n        }\n        else {\n            this.decisions[this.currentDecision].SLL_ATNTransitions++;\n        }\n        return targetState;\n    }\n    evalSemanticContextImpl(pred, parserCallStack, alt) {\n        if (this.currentState === undefined || this._input === undefined) {\n            throw new Error(\"Invalid state\");\n        }\n        let result = super.evalSemanticContextImpl(pred, parserCallStack, alt);\n        if (!(pred instanceof SemanticContext_1.SemanticContext.PrecedencePredicate)) {\n            let fullContext = this._llStopIndex >= 0;\n            let stopIndex = fullContext ? this._llStopIndex : this._sllStopIndex;\n            this.decisions[this.currentDecision].predicateEvals.push(new PredicateEvalInfo_1.PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt));\n        }\n        return result;\n    }\n    reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {\n        if (this._input === undefined) {\n            throw new Error(\"Invalid state\");\n        }\n        if (prediction !== this.conflictingAltResolvedBySLL) {\n            this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex));\n        }\n        super.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);\n    }\n    reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {\n        if (conflictingAlts != null) {\n            this.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);\n        }\n        else {\n            this.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);\n        }\n        this.decisions[this.currentDecision].LL_Fallback++;\n        super.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);\n    }\n    reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs) {\n        if (this.currentState === undefined || this._input === undefined) {\n            throw new Error(\"Invalid state\");\n        }\n        let prediction;\n        if (ambigAlts != null) {\n            prediction = ambigAlts.nextSetBit(0);\n        }\n        else {\n            prediction = configs.getRepresentedAlternatives().nextSetBit(0);\n        }\n        if (this.conflictingAltResolvedBySLL !== ATN_1.ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {\n            // Even though this is an ambiguity we are reporting, we can\n            // still detect some context sensitivities.  Both SLL and LL\n            // are showing a conflict, hence an ambiguity, but if they resolve\n            // to different minimum alternatives we have also identified a\n            // context sensitivity.\n            this.decisions[this.currentDecision].contextSensitivities.push(new ContextSensitivityInfo_1.ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex));\n        }\n        this.decisions[this.currentDecision].ambiguities.push(new AmbiguityInfo_1.AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex));\n        super.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);\n    }\n    // ---------------------------------------------------------------------\n    getDecisionInfo() {\n        return this.decisions;\n    }\n    getCurrentState() {\n        return this.currentState;\n    }\n}\n__decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull)\n], ProfilingATNSimulator.prototype, \"adaptivePredict\", null);\n__decorate([\n    Decorators_1.Override\n], ProfilingATNSimulator.prototype, \"getStartState\", null);\n__decorate([\n    Decorators_1.Override\n], ProfilingATNSimulator.prototype, \"computeStartState\", null);\n__decorate([\n    Decorators_1.Override\n], ProfilingATNSimulator.prototype, \"computeReachSet\", null);\n__decorate([\n    Decorators_1.Override\n], ProfilingATNSimulator.prototype, \"getExistingTargetState\", null);\n__decorate([\n    Decorators_1.Override\n], ProfilingATNSimulator.prototype, \"computeTargetState\", null);\n__decorate([\n    Decorators_1.Override\n], ProfilingATNSimulator.prototype, \"evalSemanticContextImpl\", null);\n__decorate([\n    Decorators_1.Override\n], ProfilingATNSimulator.prototype, \"reportContextSensitivity\", null);\n__decorate([\n    Decorators_1.Override\n], ProfilingATNSimulator.prototype, \"reportAttemptingFullContext\", null);\n__decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull), __param(5, Decorators_1.NotNull), __param(6, Decorators_1.NotNull)\n], ProfilingATNSimulator.prototype, \"reportAmbiguity\", null);\nexports.ProfilingATNSimulator = ProfilingATNSimulator;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:36.4188352-07:00\n\nimport { AmbiguityInfo } from \"./AmbiguityInfo\";\nimport { ATN } from \"./ATN\";\nimport { ATNConfigSet } from \"./ATNConfigSet\";\nimport { ATNSimulator } from \"./ATNSimulator\";\nimport { BitSet } from \"../misc/BitSet\";\nimport { ContextSensitivityInfo } from \"./ContextSensitivityInfo\";\nimport { DecisionInfo } from \"./DecisionInfo\";\nimport { DFA } from \"../dfa/DFA\";\nimport { DFAState } from \"../dfa/DFAState\";\nimport { ErrorInfo } from \"./ErrorInfo\";\nimport { NotNull, Override } from \"../Decorators\";\nimport { LookaheadEventInfo } from \"./LookaheadEventInfo\";\nimport { Parser } from \"../Parser\";\nimport { ParserATNSimulator } from \"./ParserATNSimulator\";\nimport { ParserRuleContext } from \"../ParserRuleContext\";\nimport { PredicateEvalInfo } from \"./PredicateEvalInfo\";\nimport { PredictionContextCache } from \"./PredictionContextCache\";\nimport { SemanticContext } from \"./SemanticContext\";\nimport { SimulatorState } from \"./SimulatorState\";\nimport { TokenStream } from \"../TokenStream\";\n\n/**\n * @since 4.3\n */\nexport class ProfilingATNSimulator extends ParserATNSimulator {\n\tprotected decisions: DecisionInfo[];\n\tprotected numDecisions: number;\n\n\tprotected _input: TokenStream | undefined;\n\tprotected _startIndex: number = 0;\n\tprotected _sllStopIndex: number = 0;\n\tprotected _llStopIndex: number = 0;\n\n\tprotected currentDecision: number = 0;\n\tprotected currentState: SimulatorState | undefined;\n\n\t/** At the point of LL failover, we record how SLL would resolve the conflict so that\n\t *  we can determine whether or not a decision / input pair is context-sensitive.\n\t *  If LL gives a different result than SLL's predicted alternative, we have a\n\t *  context sensitivity for sure. The converse is not necessarily true, however.\n\t *  It's possible that after conflict resolution chooses minimum alternatives,\n\t *  SLL could get the same answer as LL. Regardless of whether or not the result indicates\n\t *  an ambiguity, it is not treated as a context sensitivity because LL prediction\n\t *  was not required in order to produce a correct prediction for this decision and input sequence.\n\t *  It may in fact still be a context sensitivity but we don't know by looking at the\n\t *  minimum alternatives for the current input.\n\t */\n\tprotected conflictingAltResolvedBySLL: number = 0;\n\n\tconstructor(parser: Parser) {\n\t\tsuper(parser.interpreter.atn, parser);\n\t\tthis.optimize_ll1 = false;\n\t\tthis.reportAmbiguities = true;\n\t\tthis.numDecisions = this.atn.decisionToState.length;\n\t\tthis.decisions = [];\n\t\tfor (let i = 0; i < this.numDecisions; i++) {\n\t\t\tthis.decisions.push(new DecisionInfo(i));\n\t\t}\n\t}\n\n\tpublic adaptivePredict(/*@NotNull*/ input: TokenStream, decision: number, outerContext: ParserRuleContext | undefined): number;\n\tpublic adaptivePredict(/*@NotNull*/ input: TokenStream, decision: number, outerContext: ParserRuleContext | undefined, useContext: boolean): number;\n\t@Override\n\tpublic adaptivePredict(\n\t\t@NotNull input: TokenStream,\n\t\tdecision: number,\n\t\touterContext: ParserRuleContext | undefined,\n\t\tuseContext?: boolean): number {\n\t\tif (useContext !== undefined) {\n\t\t\treturn super.adaptivePredict(input, decision, outerContext, useContext);\n\t\t}\n\n\t\ttry {\n\t\t\tthis._input = input;\n\t\t\tthis._startIndex = input.index;\n\t\t\t// it's possible for SLL to reach a conflict state without consuming any input\n\t\t\tthis._sllStopIndex = this._startIndex - 1;\n\t\t\tthis._llStopIndex = -1;\n\t\t\tthis.currentDecision = decision;\n\t\t\tthis.currentState = undefined;\n\t\t\tthis.conflictingAltResolvedBySLL = ATN.INVALID_ALT_NUMBER;\n\t\t\tlet start: number[] = process.hrtime();\n\t\t\tlet alt: number = super.adaptivePredict(input, decision, outerContext);\n\t\t\tlet stop: number[] = process.hrtime();\n\n\t\t\tlet nanoseconds: number = (stop[0] - start[0]) * 1000000000;\n\t\t\tif (nanoseconds === 0) {\n\t\t\t\tnanoseconds = stop[1] - start[1];\n\t\t\t} else {\n\t\t\t\t// Add nanoseconds from start to end of that second, plus start of the end second to end\n\t\t\t\tnanoseconds += (1000000000 - start[1]) + stop[1];\n\t\t\t}\n\n\t\t\tthis.decisions[decision].timeInPrediction += nanoseconds;\n\t\t\tthis.decisions[decision].invocations++;\n\n\t\t\tlet SLL_k: number = this._sllStopIndex - this._startIndex + 1;\n\t\t\tthis.decisions[decision].SLL_TotalLook += SLL_k;\n\t\t\tthis.decisions[decision].SLL_MinLook = this.decisions[decision].SLL_MinLook === 0 ? SLL_k : Math.min(this.decisions[decision].SLL_MinLook, SLL_k);\n\t\t\tif (SLL_k > this.decisions[decision].SLL_MaxLook) {\n\t\t\t\tthis.decisions[decision].SLL_MaxLook = SLL_k;\n\t\t\t\tthis.decisions[decision].SLL_MaxLookEvent =\n\t\t\t\t\tnew LookaheadEventInfo(decision, undefined, alt, input, this._startIndex, this._sllStopIndex, false);\n\t\t\t}\n\n\t\t\tif (this._llStopIndex >= 0) {\n\t\t\t\tlet LL_k: number = this._llStopIndex - this._startIndex + 1;\n\t\t\t\tthis.decisions[decision].LL_TotalLook += LL_k;\n\t\t\t\tthis.decisions[decision].LL_MinLook = this.decisions[decision].LL_MinLook === 0 ? LL_k : Math.min(this.decisions[decision].LL_MinLook, LL_k);\n\t\t\t\tif (LL_k > this.decisions[decision].LL_MaxLook) {\n\t\t\t\t\tthis.decisions[decision].LL_MaxLook = LL_k;\n\t\t\t\t\tthis.decisions[decision].LL_MaxLookEvent =\n\t\t\t\t\t\tnew LookaheadEventInfo(decision, undefined, alt, input, this._startIndex, this._llStopIndex, true);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn alt;\n\t\t}\n\t\tfinally {\n\t\t\tthis._input = undefined;\n\t\t\tthis.currentDecision = -1;\n\t\t}\n\t}\n\n\t@Override\n\tprotected getStartState(dfa: DFA, input: TokenStream, outerContext: ParserRuleContext, useContext: boolean): SimulatorState | undefined {\n\t\tlet state: SimulatorState | undefined = super.getStartState(dfa, input, outerContext, useContext);\n\t\tthis.currentState = state;\n\t\treturn state;\n\t}\n\n\t@Override\n\tprotected computeStartState(dfa: DFA, globalContext: ParserRuleContext, useContext: boolean): SimulatorState {\n\t\tlet state: SimulatorState = super.computeStartState(dfa, globalContext, useContext);\n\t\tthis.currentState = state;\n\t\treturn state;\n\t}\n\n\t@Override\n\tprotected computeReachSet(dfa: DFA, previous: SimulatorState, t: number, contextCache: PredictionContextCache): SimulatorState | undefined {\n\t\tif (this._input === undefined) {\n\t\t\tthrow new Error(\"Invalid state\");\n\t\t}\n\n\t\tlet reachState: SimulatorState | undefined = super.computeReachSet(dfa, previous, t, contextCache);\n\t\tif (reachState == null) {\n\t\t\t// no reach on current lookahead symbol. ERROR.\n\t\t\tthis.decisions[this.currentDecision].errors.push(\n\t\t\t\tnew ErrorInfo(this.currentDecision, previous, this._input, this._startIndex, this._input.index),\n\t\t\t);\n\t\t}\n\n\t\tthis.currentState = reachState;\n\t\treturn reachState;\n\t}\n\n\t@Override\n\tprotected getExistingTargetState(previousD: DFAState, t: number): DFAState | undefined {\n\t\tif (this.currentState === undefined || this._input === undefined) {\n\t\t\tthrow new Error(\"Invalid state\");\n\t\t}\n\n\t\t// this method is called after each time the input position advances\n\t\tif (this.currentState.useContext) {\n\t\t\tthis._llStopIndex = this._input.index;\n\t\t}\n\t\telse {\n\t\t\tthis._sllStopIndex = this._input.index;\n\t\t}\n\n\t\tlet existingTargetState: DFAState | undefined = super.getExistingTargetState(previousD, t);\n\t\tif (existingTargetState != null) {\n\t\t\t// this method is directly called by execDFA; must construct a SimulatorState\n\t\t\t// to represent the current state for this case\n\t\t\tthis.currentState = new SimulatorState(this.currentState.outerContext, existingTargetState, this.currentState.useContext, this.currentState.remainingOuterContext);\n\n\t\t\tif (this.currentState.useContext) {\n\t\t\t\tthis.decisions[this.currentDecision].LL_DFATransitions++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.decisions[this.currentDecision].SLL_DFATransitions++; // count only if we transition over a DFA state\n\t\t\t}\n\n\t\t\tif (existingTargetState === ATNSimulator.ERROR) {\n\t\t\t\tlet state: SimulatorState = new SimulatorState(this.currentState.outerContext, previousD, this.currentState.useContext, this.currentState.remainingOuterContext);\n\t\t\t\tthis.decisions[this.currentDecision].errors.push(\n\t\t\t\t\tnew ErrorInfo(this.currentDecision, state, this._input, this._startIndex, this._input.index),\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\n\t\treturn existingTargetState;\n\t}\n\n\t@Override\n\tprotected computeTargetState(dfa: DFA, s: DFAState, remainingGlobalContext: ParserRuleContext, t: number, useContext: boolean, contextCache: PredictionContextCache): [DFAState, ParserRuleContext | undefined] {\n\t\tlet targetState: [DFAState, ParserRuleContext | undefined] = super.computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache);\n\n\t\tif (useContext) {\n\t\t\tthis.decisions[this.currentDecision].LL_ATNTransitions++;\n\t\t}\n\t\telse {\n\t\t\tthis.decisions[this.currentDecision].SLL_ATNTransitions++;\n\t\t}\n\n\t\treturn targetState;\n\t}\n\n\t@Override\n\tprotected evalSemanticContextImpl(pred: SemanticContext, parserCallStack: ParserRuleContext, alt: number): boolean {\n\t\tif (this.currentState === undefined || this._input === undefined) {\n\t\t\tthrow new Error(\"Invalid state\");\n\t\t}\n\n\t\tlet result: boolean = super.evalSemanticContextImpl(pred, parserCallStack, alt);\n\t\tif (!(pred instanceof SemanticContext.PrecedencePredicate)) {\n\t\t\tlet fullContext: boolean = this._llStopIndex >= 0;\n\t\t\tlet stopIndex: number = fullContext ? this._llStopIndex : this._sllStopIndex;\n\t\t\tthis.decisions[this.currentDecision].predicateEvals.push(\n\t\t\t\tnew PredicateEvalInfo(this.currentState, this.currentDecision, this._input, this._startIndex, stopIndex, pred, result, alt),\n\t\t\t);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t@Override\n\tprotected reportContextSensitivity(dfa: DFA, prediction: number, acceptState: SimulatorState, startIndex: number, stopIndex: number): void {\n\t\tif (this._input === undefined) {\n\t\t\tthrow new Error(\"Invalid state\");\n\t\t}\n\n\t\tif (prediction !== this.conflictingAltResolvedBySLL) {\n\t\t\tthis.decisions[this.currentDecision].contextSensitivities.push(\n\t\t\t\tnew ContextSensitivityInfo(this.currentDecision, acceptState, this._input, startIndex, stopIndex),\n\t\t\t);\n\t\t}\n\t\tsuper.reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex);\n\t}\n\n\t@Override\n\tprotected reportAttemptingFullContext(dfa: DFA, conflictingAlts: BitSet, conflictState: SimulatorState, startIndex: number, stopIndex: number): void {\n\t\tif (conflictingAlts != null) {\n\t\t\tthis.conflictingAltResolvedBySLL = conflictingAlts.nextSetBit(0);\n\t\t}\n\t\telse {\n\t\t\tthis.conflictingAltResolvedBySLL = conflictState.s0.configs.getRepresentedAlternatives().nextSetBit(0);\n\t\t}\n\t\tthis.decisions[this.currentDecision].LL_Fallback++;\n\t\tsuper.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex);\n\t}\n\n\t@Override\n\tprotected reportAmbiguity(@NotNull dfa: DFA, D: DFAState, startIndex: number, stopIndex: number, exact: boolean, @NotNull ambigAlts: BitSet, @NotNull configs: ATNConfigSet): void {\n\t\tif (this.currentState === undefined || this._input === undefined) {\n\t\t\tthrow new Error(\"Invalid state\");\n\t\t}\n\n\t\tlet prediction: number;\n\t\tif (ambigAlts != null) {\n\t\t\tprediction = ambigAlts.nextSetBit(0);\n\t\t}\n\t\telse {\n\t\t\tprediction = configs.getRepresentedAlternatives().nextSetBit(0);\n\t\t}\n\t\tif (this.conflictingAltResolvedBySLL !== ATN.INVALID_ALT_NUMBER && prediction !== this.conflictingAltResolvedBySLL) {\n\t\t\t// Even though this is an ambiguity we are reporting, we can\n\t\t\t// still detect some context sensitivities.  Both SLL and LL\n\t\t\t// are showing a conflict, hence an ambiguity, but if they resolve\n\t\t\t// to different minimum alternatives we have also identified a\n\t\t\t// context sensitivity.\n\t\t\tthis.decisions[this.currentDecision].contextSensitivities.push(\n\t\t\t\tnew ContextSensitivityInfo(this.currentDecision, this.currentState, this._input, startIndex, stopIndex),\n\t\t\t);\n\t\t}\n\t\tthis.decisions[this.currentDecision].ambiguities.push(\n\t\t\tnew AmbiguityInfo(this.currentDecision, this.currentState, ambigAlts, this._input, startIndex, stopIndex),\n\t\t);\n\t\tsuper.reportAmbiguity(dfa, D, startIndex, stopIndex, exact, ambigAlts, configs);\n\t}\n\n\t// ---------------------------------------------------------------------\n\n\tpublic getDecisionInfo(): DecisionInfo[] {\n\t\treturn this.decisions;\n\t}\n\n\tpublic getCurrentState(): SimulatorState | undefined {\n\t\treturn this.currentState;\n\t}\n}\n"]}