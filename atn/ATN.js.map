{"version":3,"sources":["atn/ATN.js","../src/atn/ATN.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","Array2DHashMap_1","require","DFA_1","IntervalSet_1","InvalidState_1","LL1Analyzer_1","Decorators_1","ObjectEqualityComparator_1","PredictionContext_1","Token_1","assert","ATN","grammarType","maxTokenType","states","decisionToState","modeNameToStartState","Map","modeToStartState","contextCache","Array2DHashMap","ObjectEqualityComparator","INSTANCE","decisionToDFA","modeToDFA","LL1Table","Array","DFA","clear","context","PredictionContext","getCachedContext","IdentityHashMap","s","ctx","anal","LL1Analyzer","next","LOOK","nextTokenWithinRule","nextTokens","EMPTY_LOCAL","setReadonly","state","atn","stateNumber","push","invalidState","InvalidState","name","set","defineDecisionState","decision","undefined","RangeError","following","contains","Token","EPSILON","expected","IntervalSet","addAll","remove","invokingState","rt","transition","followState","_parent","add","EOF","size","NotNull","prototype","INVALID_ALT_NUMBER"],"mappings":"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","file":"ATN.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:25.1063510-07:00\nconst Array2DHashMap_1 = require(\"../misc/Array2DHashMap\");\nconst DFA_1 = require(\"../dfa/DFA\");\nconst IntervalSet_1 = require(\"../misc/IntervalSet\");\nconst InvalidState_1 = require(\"./InvalidState\");\nconst LL1Analyzer_1 = require(\"./LL1Analyzer\");\nconst Decorators_1 = require(\"../Decorators\");\nconst ObjectEqualityComparator_1 = require(\"../misc/ObjectEqualityComparator\");\nconst PredictionContext_1 = require(\"./PredictionContext\");\nconst Token_1 = require(\"../Token\");\nconst assert = require(\"assert\");\n/** */\nlet ATN = class ATN {\n    /** Used for runtime deserialization of ATNs from strings */\n    constructor(grammarType, maxTokenType) {\n        this.states = [];\n        /** Each subrule/rule is a decision point and we must track them so we\n         *  can go back later and build DFA predictors for them.  This includes\n         *  all the rules, subrules, optional blocks, ()+, ()* etc...\n         */\n        this.decisionToState = [];\n        this.modeNameToStartState = new Map();\n        this.modeToStartState = [];\n        this.contextCache = new Array2DHashMap_1.Array2DHashMap(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n        this.decisionToDFA = [];\n        this.modeToDFA = [];\n        this.LL1Table = new Map();\n        this.grammarType = grammarType;\n        this.maxTokenType = maxTokenType;\n    }\n    clearDFA() {\n        this.decisionToDFA = new Array(this.decisionToState.length);\n        for (let i = 0; i < this.decisionToDFA.length; i++) {\n            this.decisionToDFA[i] = new DFA_1.DFA(this.decisionToState[i], i);\n        }\n        this.modeToDFA = new Array(this.modeToStartState.length);\n        for (let i = 0; i < this.modeToDFA.length; i++) {\n            this.modeToDFA[i] = new DFA_1.DFA(this.modeToStartState[i]);\n        }\n        this.contextCache.clear();\n        this.LL1Table.clear();\n    }\n    get contextCacheSize() {\n        return this.contextCache.size;\n    }\n    getCachedContext(context) {\n        return PredictionContext_1.PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext_1.PredictionContext.IdentityHashMap());\n    }\n    getDecisionToDFA() {\n        assert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);\n        return this.decisionToDFA;\n    }\n    nextTokens(s, ctx) {\n        if (ctx) {\n            let anal = new LL1Analyzer_1.LL1Analyzer(this);\n            let next = anal.LOOK(s, ctx);\n            return next;\n        }\n        else {\n            if (s.nextTokenWithinRule) {\n                return s.nextTokenWithinRule;\n            }\n            s.nextTokenWithinRule = this.nextTokens(s, PredictionContext_1.PredictionContext.EMPTY_LOCAL);\n            s.nextTokenWithinRule.setReadonly(true);\n            return s.nextTokenWithinRule;\n        }\n    }\n    addState(state) {\n        state.atn = this;\n        state.stateNumber = this.states.length;\n        this.states.push(state);\n    }\n    removeState(state) {\n        // just replace the state, don't shift states in list\n        let invalidState = new InvalidState_1.InvalidState();\n        invalidState.atn = this;\n        invalidState.stateNumber = state.stateNumber;\n        this.states[state.stateNumber] = invalidState;\n    }\n    defineMode(name, s) {\n        this.modeNameToStartState.set(name, s);\n        this.modeToStartState.push(s);\n        this.modeToDFA.push(new DFA_1.DFA(s));\n        this.defineDecisionState(s);\n    }\n    defineDecisionState(s) {\n        this.decisionToState.push(s);\n        s.decision = this.decisionToState.length - 1;\n        this.decisionToDFA.push(new DFA_1.DFA(s, s.decision));\n        return s.decision;\n    }\n    getDecisionState(decision) {\n        if (this.decisionToState.length > 0) {\n            return this.decisionToState[decision];\n        }\n        return undefined;\n    }\n    get numberOfDecisions() {\n        return this.decisionToState.length;\n    }\n    /**\n     * Computes the set of input symbols which could follow ATN state number\n     * `stateNumber` in the specified full `context`. This method\n     * considers the complete parser context, but does not evaluate semantic\n     * predicates (i.e. all predicates encountered during the calculation are\n     * assumed true). If a path in the ATN exists from the starting state to the\n     * {@link RuleStopState} of the outermost context without matching any\n     * symbols, {@link Token#EOF} is added to the returned set.\n     *\n     * If `context` is `undefined`, it is treated as\n     * {@link ParserRuleContext#EMPTY}.\n     *\n     * Note that this does NOT give you the set of all tokens that could\n     * appear at a given token position in the input phrase.  In other words, it\n     * does not answer:\n     *\n     * > Given a specific partial input phrase, return the set of all\n     * > tokens that can follow the last token in the input phrase.\n     *\n     * The big difference is that with just the input, the parser could land\n     * right in the middle of a lookahead decision. Getting all\n     * *possible* tokens given a partial input stream is a separate\n     * computation. See https://github.com/antlr/antlr4/issues/1428\n     *\n     * For this function, we are specifying an ATN state and call stack to\n     * compute what token(s) can come next and specifically: outside of a\n     * lookahead decision. That is what you want for error reporting and\n     * recovery upon parse error.\n     *\n     * @param stateNumber the ATN state number\n     * @param context the full parse context\n     * @returns The set of potentially valid input symbols which could follow the\n     * specified state in the specified context.\n     * @ if the ATN does not contain a state with\n     * number `stateNumber`\n     */\n    getExpectedTokens(stateNumber, context) {\n        if (stateNumber < 0 || stateNumber >= this.states.length) {\n            throw new RangeError(\"Invalid state number.\");\n        }\n        let ctx = context;\n        let s = this.states[stateNumber];\n        let following = this.nextTokens(s);\n        if (!following.contains(Token_1.Token.EPSILON)) {\n            return following;\n        }\n        let expected = new IntervalSet_1.IntervalSet();\n        expected.addAll(following);\n        expected.remove(Token_1.Token.EPSILON);\n        while (ctx != null && ctx.invokingState >= 0 && following.contains(Token_1.Token.EPSILON)) {\n            let invokingState = this.states[ctx.invokingState];\n            let rt = invokingState.transition(0);\n            following = this.nextTokens(rt.followState);\n            expected.addAll(following);\n            expected.remove(Token_1.Token.EPSILON);\n            ctx = ctx._parent;\n        }\n        if (following.contains(Token_1.Token.EPSILON)) {\n            expected.add(Token_1.Token.EOF);\n        }\n        return expected;\n    }\n};\n__decorate([\n    Decorators_1.NotNull\n], ATN.prototype, \"states\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], ATN.prototype, \"decisionToState\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], ATN.prototype, \"modeNameToStartState\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], ATN.prototype, \"modeToStartState\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], ATN.prototype, \"decisionToDFA\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], ATN.prototype, \"modeToDFA\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], ATN.prototype, \"nextTokens\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ATN.prototype, \"removeState\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], ATN.prototype, \"defineMode\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ATN.prototype, \"defineDecisionState\", null);\n__decorate([\n    Decorators_1.NotNull\n], ATN.prototype, \"getExpectedTokens\", null);\nATN = __decorate([\n    __param(0, Decorators_1.NotNull)\n], ATN);\nexports.ATN = ATN;\n(function (ATN) {\n    ATN.INVALID_ALT_NUMBER = 0;\n})(ATN = exports.ATN || (exports.ATN = {}));\nexports.ATN = ATN;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:25.1063510-07:00\n\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\nimport { ATNState } from \"./ATNState\";\nimport { ATNType } from \"./ATNType\";\nimport { DecisionState } from \"./DecisionState\";\nimport { DFA } from \"../dfa/DFA\";\nimport { IntervalSet } from \"../misc/IntervalSet\";\nimport { InvalidState } from \"./InvalidState\";\nimport { LexerAction } from \"./LexerAction\";\nimport { LL1Analyzer } from \"./LL1Analyzer\";\nimport { NotNull } from \"../Decorators\";\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\nimport { PredictionContext } from \"./PredictionContext\";\nimport { RuleContext } from \"../RuleContext\";\nimport { RuleStartState } from \"./RuleStartState\";\nimport { RuleStopState } from \"./RuleStopState\";\nimport { RuleTransition } from \"./RuleTransition\";\nimport { Token } from \"../Token\";\nimport { TokensStartState } from \"./TokensStartState\";\n\nimport * as assert from \"assert\";\n\n/** */\nexport class ATN {\n\t@NotNull\n\tpublic readonly states: ATNState[] = [];\n\n\t/** Each subrule/rule is a decision point and we must track them so we\n\t *  can go back later and build DFA predictors for them.  This includes\n\t *  all the rules, subrules, optional blocks, ()+, ()* etc...\n\t */\n\t@NotNull\n\tpublic decisionToState: DecisionState[] = [];\n\n\t/**\n\t * Maps from rule index to starting state number.\n\t */\n\tpublic ruleToStartState: RuleStartState[];\n\n\t/**\n\t * Maps from rule index to stop state number.\n\t */\n\tpublic ruleToStopState: RuleStopState[];\n\n\t@NotNull\n\tpublic modeNameToStartState: Map<string, TokensStartState> =\n\t\tnew Map<string, TokensStartState>();\n\n\t/**\n\t * The type of the ATN.\n\t */\n\tpublic grammarType: ATNType;\n\n\t/**\n\t * The maximum value for any symbol recognized by a transition in the ATN.\n\t */\n\tpublic maxTokenType: number;\n\n\t/**\n\t * For lexer ATNs, this maps the rule index to the resulting token type.\n\t * For parser ATNs, this maps the rule index to the generated bypass token\n\t * type if the\n\t * {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}\n\t * deserialization option was specified; otherwise, this is `undefined`.\n\t */\n\tpublic ruleToTokenType: Int32Array;\n\n\t/**\n\t * For lexer ATNs, this is an array of {@link LexerAction} objects which may\n\t * be referenced by action transitions in the ATN.\n\t */\n\tpublic lexerActions: LexerAction[];\n\n\t@NotNull\n\tpublic modeToStartState: TokensStartState[] = [];\n\n\tprivate contextCache: Array2DHashMap<PredictionContext, PredictionContext> =\n\t\tnew Array2DHashMap<PredictionContext, PredictionContext>(ObjectEqualityComparator.INSTANCE);\n\n\t@NotNull\n\tpublic decisionToDFA: DFA[] = [];\n\t@NotNull\n\tpublic modeToDFA: DFA[] = [];\n\n\tpublic LL1Table: Map<number, number> = new Map<number, number>();\n\n\t/** Used for runtime deserialization of ATNs from strings */\n\tconstructor(@NotNull grammarType: ATNType, maxTokenType: number) {\n\t\tthis.grammarType = grammarType;\n\t\tthis.maxTokenType = maxTokenType;\n\t}\n\n\tpublic clearDFA(): void {\n\t\tthis.decisionToDFA = new Array<DFA>(this.decisionToState.length);\n\t\tfor (let i = 0; i < this.decisionToDFA.length; i++) {\n\t\t\tthis.decisionToDFA[i] = new DFA(this.decisionToState[i], i);\n\t\t}\n\n\t\tthis.modeToDFA = new Array<DFA>(this.modeToStartState.length);\n\t\tfor (let i = 0; i < this.modeToDFA.length; i++) {\n\t\t\tthis.modeToDFA[i] = new DFA(this.modeToStartState[i]);\n\t\t}\n\n\t\tthis.contextCache.clear();\n\t\tthis.LL1Table.clear();\n\t}\n\n\tget contextCacheSize(): number {\n\t\treturn this.contextCache.size;\n\t}\n\n\tpublic getCachedContext(context: PredictionContext): PredictionContext {\n\t\treturn PredictionContext.getCachedContext(context, this.contextCache, new PredictionContext.IdentityHashMap());\n\t}\n\n\tpublic getDecisionToDFA(): DFA[] {\n\t\tassert(this.decisionToDFA != null && this.decisionToDFA.length === this.decisionToState.length);\n\t\treturn this.decisionToDFA;\n\t}\n\n\t/** Compute the set of valid tokens that can occur starting in state `s`.\n\t *  If `ctx` is {@link PredictionContext#EMPTY_LOCAL}, the set of tokens will not include what can follow\n\t *  the rule surrounding `s`. In other words, the set will be\n\t *  restricted to tokens reachable staying within `s`'s rule.\n\t */\n\t// @NotNull\n\tpublic nextTokens(s: ATNState, /*@NotNull*/ ctx: PredictionContext): IntervalSet;\n\n\t/**\n\t * Compute the set of valid tokens that can occur starting in `s` and\n\t * staying in same rule. {@link Token#EPSILON} is in set if we reach end of\n\t * rule.\n\t */\n\t// @NotNull\n\tpublic nextTokens(/*@NotNull*/ s: ATNState): IntervalSet;\n\n\t@NotNull\n\tpublic nextTokens(s: ATNState, ctx?: PredictionContext): IntervalSet {\n\t\tif (ctx) {\n\t\t\tlet anal: LL1Analyzer = new LL1Analyzer(this);\n\t\t\tlet next: IntervalSet = anal.LOOK(s, ctx);\n\t\t\treturn next;\n\t\t} else {\n\t\t\tif (s.nextTokenWithinRule) {\n\t\t\t\treturn s.nextTokenWithinRule;\n\t\t\t}\n\n\t\t\ts.nextTokenWithinRule = this.nextTokens(s, PredictionContext.EMPTY_LOCAL);\n\t\t\ts.nextTokenWithinRule.setReadonly(true);\n\t\t\treturn s.nextTokenWithinRule;\n\t\t}\n\t}\n\n\tpublic addState(state: ATNState): void {\n\t\tstate.atn = this;\n\t\tstate.stateNumber = this.states.length;\n\t\tthis.states.push(state);\n\t}\n\n\tpublic removeState(@NotNull state: ATNState): void {\n\t\t// just replace the state, don't shift states in list\n\t\tlet invalidState = new InvalidState();\n\t\tinvalidState.atn = this;\n\t\tinvalidState.stateNumber = state.stateNumber;\n\t\tthis.states[state.stateNumber] = invalidState;\n\t}\n\n\tpublic defineMode(@NotNull name: string, @NotNull s: TokensStartState): void {\n\t\tthis.modeNameToStartState.set(name, s);\n\t\tthis.modeToStartState.push(s);\n\t\tthis.modeToDFA.push(new DFA(s));\n\t\tthis.defineDecisionState(s);\n\t}\n\n\tpublic defineDecisionState(@NotNull s: DecisionState): number {\n\t\tthis.decisionToState.push(s);\n\t\ts.decision = this.decisionToState.length - 1;\n\t\tthis.decisionToDFA.push(new DFA(s, s.decision));\n\t\treturn s.decision;\n\t}\n\n\tpublic getDecisionState(decision: number): DecisionState | undefined {\n\t\tif (this.decisionToState.length > 0) {\n\t\t\treturn this.decisionToState[decision];\n\t\t}\n\t\treturn undefined;\n\t}\n\n\tget numberOfDecisions(): number {\n\t\treturn this.decisionToState.length;\n\t}\n\n\t/**\n\t * Computes the set of input symbols which could follow ATN state number\n\t * `stateNumber` in the specified full `context`. This method\n\t * considers the complete parser context, but does not evaluate semantic\n\t * predicates (i.e. all predicates encountered during the calculation are\n\t * assumed true). If a path in the ATN exists from the starting state to the\n\t * {@link RuleStopState} of the outermost context without matching any\n\t * symbols, {@link Token#EOF} is added to the returned set.\n\t *\n\t * If `context` is `undefined`, it is treated as\n\t * {@link ParserRuleContext#EMPTY}.\n\t *\n\t * Note that this does NOT give you the set of all tokens that could\n\t * appear at a given token position in the input phrase.  In other words, it\n\t * does not answer:\n\t *\n\t * > Given a specific partial input phrase, return the set of all\n\t * > tokens that can follow the last token in the input phrase.\n\t *\n\t * The big difference is that with just the input, the parser could land\n\t * right in the middle of a lookahead decision. Getting all\n\t * *possible* tokens given a partial input stream is a separate\n\t * computation. See https://github.com/antlr/antlr4/issues/1428\n\t *\n\t * For this function, we are specifying an ATN state and call stack to\n\t * compute what token(s) can come next and specifically: outside of a\n\t * lookahead decision. That is what you want for error reporting and\n\t * recovery upon parse error.\n\t *\n\t * @param stateNumber the ATN state number\n\t * @param context the full parse context\n\t * @returns The set of potentially valid input symbols which could follow the\n\t * specified state in the specified context.\n\t * @ if the ATN does not contain a state with\n\t * number `stateNumber`\n\t */\n\t@NotNull\n\tpublic getExpectedTokens(stateNumber: number, context: RuleContext | undefined): IntervalSet {\n\t\tif (stateNumber < 0 || stateNumber >= this.states.length) {\n\t\t\tthrow new RangeError(\"Invalid state number.\");\n\t\t}\n\n\t\tlet ctx: RuleContext | undefined = context;\n\t\tlet s: ATNState = this.states[stateNumber];\n\t\tlet following: IntervalSet = this.nextTokens(s);\n\t\tif (!following.contains(Token.EPSILON)) {\n\t\t\treturn following;\n\t\t}\n\n\t\tlet expected: IntervalSet = new IntervalSet();\n\t\texpected.addAll(following);\n\t\texpected.remove(Token.EPSILON);\n\t\twhile (ctx != null && ctx.invokingState >= 0 && following.contains(Token.EPSILON)) {\n\t\t\tlet invokingState: ATNState = this.states[ctx.invokingState];\n\t\t\tlet rt: RuleTransition = invokingState.transition(0) as RuleTransition;\n\t\t\tfollowing = this.nextTokens(rt.followState);\n\t\t\texpected.addAll(following);\n\t\t\texpected.remove(Token.EPSILON);\n\t\t\tctx = ctx._parent;\n\t\t}\n\n\t\tif (following.contains(Token.EPSILON)) {\n\t\t\texpected.add(Token.EOF);\n\t\t}\n\n\t\treturn expected;\n\t}\n}\n\nexport namespace ATN {\n\texport const INVALID_ALT_NUMBER: number = 0;\n}\n"]}