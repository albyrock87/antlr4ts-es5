{"version":3,"sources":["atn/ParserATNSimulator.js","../src/atn/ParserATNSimulator.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","AcceptStateInfo_1","require","ActionTransition_1","Array2DHashSet_1","Arrays_1","ATN_1","ATNConfig_1","ATNConfigSet_1","ATNSimulator_1","ATNStateType_1","AtomTransition_1","BitSet_1","ConflictInfo_1","DecisionState_1","DFAState_1","IntegerList_1","Interval_1","IntStream_1","Decorators_1","NotSetTransition_1","NoViableAltException_1","ObjectEqualityComparator_1","ParserRuleContext_1","PredictionContext_1","PredictionContextCache_1","PredictionMode_1","RuleStopState_1","RuleTransition_1","SemanticContext_1","SetTransition_1","SimulatorState_1","Token_1","VocabularyImpl_1","assert","MAX_SHORT_VALUE","MIN_INTEGER_VALUE","ParserATNSimulator","atn","parser","predictionMode","PredictionMode","LL","force_global_context","always_try_local_context","enable_global_context_dfa","optimize_unique_closure","optimize_ll1","optimize_tail_calls","tail_call_preserves_sll","treat_sllk1_conflict_as_ambiguity","reportAmbiguities","userWantsCtxSensitive","_parser","input","decision","outerContext","useContext","undefined","dfa","decisionToDFA","isPrecedenceDfa","isEmpty","ll_1","LA","alt","LL1Table","get","isContextSensitive","SLL","decisionToState","sll","ParserRuleContext","emptyContext","state","getStartState","debug","console","log","getLookaheadName","toString","computeStartState","m","mark","index","execDFA","vocabulary","ruleNames","seek","release","getPrecedenceStartState","precedence","SimulatorState","s0","remainingContext","s0full","skipTailCalls","getContextTarget","getReturnState","parent","startIndex","dfa_debug","s","t","remainingOuterContext","stateNumber","isContextSymbol","next","initialState","execATN","isAcceptState","predicates","prediction","getExistingTargetState","getDisplayName","interval","Interval","of","inputStream","getText","ATNSimulator","ERROR","errorState","handleNoViableAlt","IntStream","EOF","consume","configs","conflictInfo","atnStartState","DecisionState","dipsIntoOuterContext","isExactConflict","conflictingAlts","conflictIndex","evalSemanticContext","cardinality","nextSetBit","conflictState","reportAttemptingFullContext","adaptivePredict","stopIndex","alts","LL_EXACT_AMBIG_DETECTION","noViableAlt","reportAmbiguity","previous","contextCache","PredictionContextCache","nextState","computeReachSet","setDFAEdge","D","ATN","INVALID_ALT_NUMBER","predictedAlt","hasSemanticContext","set","reportContextSensitivity","attemptFullContext","predPredictions","fullContextState","BitSet","maxAlt","config","reachesIntoOuterContext","RuleStopState","Math","max","filteredConfigs","ATNConfigSet","add","altToPred","getPredsForAmbigAlts","getPredicatePredictions","filteredAlts","remainingGlobalContext","result","computeTargetState","getTarget","closureConfigs","toArray","contextElements","reach","stepIntoGlobal","hasMoreContext","isOutermostConfigSet","reachIntermediate","skippedStopStates","getTokenName","context","push","n","numberOfOptimizedTransitions","ti","trans","getOptimizedTransition","getReachableTarget","transform","Token","uniqueAlt","collectPredicates","treatEofAsEpsilon","closure","removeAllConfigsNotInRuleStopState","hasConfigInRuleStopState","clear","nextContextElement","IntegerList","PredictionContext","EMPTY_FULL_STATE_KEY","appendContext","addDFAEdge","allConfigsInRuleStopStates","globalContext","setContextSensitive","p","previousContext","initialContext","EMPTY_FULL","EMPTY_LOCAL","appendSingleContext","numberOfTransitions","transition","ATNConfig","create","addDFAState","applyPrecedenceFilter","setPrecedenceStartState","setContextTarget","statesFromAlt1","Map","configSet","updatedContext","semanticContext","evalPrecedence","isPrecedenceFilterSuppressed","equals","source","ttype","matches","maxTokenType","nalts","getConflictingAltsFromConfigSet","Error","ambigAlts","Array","SemanticContext","or","nPredAlts","NONE","Arrays","pairs","containsPredicate","pred","DFAState","PredPrediction","complete","predictions","pair","evaluatedResult","evalSemanticContextImpl","parserCallStack","eval","sourceConfigs","UNCACHED","currentConfigs","closureBusy","Array2DHashSet","ObjectEqualityComparator","INSTANCE","size","intermediate","closureImpl","hasMoreContexts","depth","hasEmpty","nonEmptySize","newContext","getParent","returnState","states","outerContextDepth","getRuleName","ruleIndex","isEmptyLocal","onlyHasEpsilonTransitions","stateType","ATNStateType","STAR_LOOP_ENTRY","precedenceRuleDecision","precedenceDecision","suppress","j","precedenceLoopbackStates","continueCollecting","ActionTransition","getEpsilonTarget","RuleTransition","newDepth","outermostPrecedenceReturn","optimizedTailCall","isEpsilon","inContext","serializationType","ruleTransition","precedenceTransition","predTransition","actionTransition","actionIndex","pt","getRuleInvocationStack","newSemCtx","and","predicate","predIndex","isCtxDependent","followState","getChild","configset","sort","STATE_ALT_SORT_COMPARATOR","exact","minAlt","currentState","nonStopStateNumber","representedAlts","currentAlt","firstIndexCurrentState","lastIndexCurrentStateMinAlt","joinedCheckContext","join","config2","joinedCheckContext2","lastIndexCurrentStateCurrentAlt","check","ConflictInfo","VocabularyImpl","EMPTY_VOCABULARY","displayName","String","nvae","deadEndConfigs","AtomTransition","_label","SetTransition","not","NotSetTransition","NoViableAltException","LT","fromState","contextTransitions","toConfigs","from","to","setContextSymbol","addDFAContextState","q","setTarget","returnContext","contextConfigs","clone","enableDfa","isReadOnly","optimizeConfigs","proposed","createDFAState","existing","isConflicted","newState","decisionState","getDecisionState","getUniqueAlt","acceptStateInfo","AcceptStateInfo","predicateDFAState","added","addState","retry_debug","listener","getErrorListenerDispatch","acceptState","invokingState","tailCall","o1","o2","diff","NotNull","prototype","Override","Nullable"],"mappings":"AAAA;ACAA;;;;;;;;;;;;;;;;;;;ADKA,IAAIA,UAAU,GAAI,UAAQ,SAAKA,UAAd,IAA6B,UAAUC,UAAV,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AACnF,MAAIC,CAAC,GAAGC,SAAS,CAACC,MAAlB;AAAA,MAA0BC,CAAC,GAAGH,CAAC,GAAG,CAAJ,GAAQH,MAAR,GAAiBE,IAAI,KAAK,IAAT,GAAgBA,IAAI,GAAGK,MAAM,CAACC,wBAAP,CAAgCR,MAAhC,EAAwCC,GAAxC,CAAvB,GAAsEC,IAArH;AAAA,MAA2HO,CAA3H;AACA,MAAI,QAAOC,OAAP,0DAAOA,OAAP,OAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAA/D,EAA2EL,CAAC,GAAGI,OAAO,CAACC,QAAR,CAAiBZ,UAAjB,EAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,IAA1C,CAAJ,CAA3E,KACK,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAX,GAAoB,CAAjC,EAAoCO,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C;AAAiD,QAAIH,CAAC,GAAGV,UAAU,CAACa,CAAD,CAAlB,EAAuBN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACH,CAAD,CAAT,GAAeH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACT,MAAD,EAASC,GAAT,EAAcK,CAAd,CAAT,GAA4BG,CAAC,CAACT,MAAD,EAASC,GAAT,CAA7C,KAA+DK,CAAnE;AAAxE;AACL,SAAOH,CAAC,GAAG,CAAJ,IAASG,CAAT,IAAcC,MAAM,CAACM,cAAP,CAAsBb,MAAtB,EAA8BC,GAA9B,EAAmCK,CAAnC,CAAd,EAAqDA,CAA5D;AACH,CALD;;AAMA,IAAIQ,OAAO,GAAI,UAAQ,SAAKA,OAAd,IAA0B,UAAUC,UAAV,EAAsBC,SAAtB,EAAiC;AACrE,SAAO,UAAUhB,MAAV,EAAkBC,GAAlB,EAAuB;AAAEe,IAAAA,SAAS,CAAChB,MAAD,EAASC,GAAT,EAAcc,UAAd,CAAT;AAAqC,GAArE;AACH,CAFD;;AAGAR,MAAM,CAACM,cAAP,CAAsBI,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C,E,CCTA;;AAEA,IAAAC,iBAAA,GAAAC,OAAA,CAAA,wBAAA,CAAA;;AACA,IAAAC,kBAAA,GAAAD,OAAA,CAAA,oBAAA,CAAA;;AACA,IAAAE,gBAAA,GAAAF,OAAA,CAAA,wBAAA,CAAA;;AACA,IAAAG,QAAA,GAAAH,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAAI,KAAA,GAAAJ,OAAA,CAAA,OAAA,CAAA;;AACA,IAAAK,WAAA,GAAAL,OAAA,CAAA,aAAA,CAAA;;AACA,IAAAM,cAAA,GAAAN,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAAO,cAAA,GAAAP,OAAA,CAAA,gBAAA,CAAA;;AAEA,IAAAQ,cAAA,GAAAR,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAAS,gBAAA,GAAAT,OAAA,CAAA,kBAAA,CAAA;;AACA,IAAAU,QAAA,GAAAV,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAAW,cAAA,GAAAX,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAAY,eAAA,GAAAZ,OAAA,CAAA,iBAAA,CAAA;;AAEA,IAAAa,UAAA,GAAAb,OAAA,CAAA,iBAAA,CAAA;;AAEA,IAAAc,aAAA,GAAAd,OAAA,CAAA,qBAAA,CAAA;;AACA,IAAAe,UAAA,GAAAf,OAAA,CAAA,kBAAA,CAAA;;AACA,IAAAgB,WAAA,GAAAhB,OAAA,CAAA,cAAA,CAAA;;AACA,IAAAiB,YAAA,GAAAjB,OAAA,CAAA,eAAA,CAAA;;AACA,IAAAkB,kBAAA,GAAAlB,OAAA,CAAA,oBAAA,CAAA;;AACA,IAAAmB,sBAAA,GAAAnB,OAAA,CAAA,yBAAA,CAAA;;AACA,IAAAoB,0BAAA,GAAApB,OAAA,CAAA,kCAAA,CAAA;;AAEA,IAAAqB,mBAAA,GAAArB,OAAA,CAAA,sBAAA,CAAA;;AAGA,IAAAsB,mBAAA,GAAAtB,OAAA,CAAA,qBAAA,CAAA;;AACA,IAAAuB,wBAAA,GAAAvB,OAAA,CAAA,0BAAA,CAAA;;AACA,IAAAwB,gBAAA,GAAAxB,OAAA,CAAA,kBAAA,CAAA;;AAEA,IAAAyB,eAAA,GAAAzB,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA0B,gBAAA,GAAA1B,OAAA,CAAA,kBAAA,CAAA;;AACA,IAAA2B,iBAAA,GAAA3B,OAAA,CAAA,mBAAA,CAAA;;AACA,IAAA4B,eAAA,GAAA5B,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA6B,gBAAA,GAAA7B,OAAA,CAAA,kBAAA,CAAA;;AAEA,IAAA8B,OAAA,GAAA9B,OAAA,CAAA,UAAA,CAAA;;AAKA,IAAA+B,gBAAA,GAAA/B,OAAA,CAAA,mBAAA,CAAA;;AAEA,IAAAgC,MAAA,GAAAhC,OAAA,CAAA,QAAA,CAAA;;AAEA,IAAMiC,eAAe,GAAG,MAAxB;AACA,IAAMC,iBAAiB,GAAG,EAAG,KAAK,EAAN,KAAc,CAAhB,CAA1B;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuMA,IAAaC,kBAAkB;AAAA;AAAA;AAAA;;AAqD9B,8BAAqBC,GAArB,EAA+BC,MAA/B,EAA6C;AAAA;;AAAA;AAC5C,8HAAMD,GAAN;AAhDO,UAAAE,cAAA,GAAiCd,gBAAA,CAAAe,cAAA,CAAeC,EAAhD;AACD,UAAAC,oBAAA,GAAgC,KAAhC;AACA,UAAAC,wBAAA,GAAoC,IAApC;AAEP;;;;;;;;;;;;;;AAaO,UAAAC,yBAAA,GAAqC,KAArC;AACA,UAAAC,uBAAA,GAAmC,IAAnC;AACA,UAAAC,YAAA,GAAwB,IAAxB;AACA,UAAAC,mBAAA,GAA+B,IAA/B;AACA,UAAAC,uBAAA,GAAmC,IAAnC;AACA,UAAAC,iCAAA,GAA6C,KAA7C;AAIP;;;;;;;;;;AASO,UAAAC,iBAAA,GAA6B,KAA7B;AAEP;;;;;;;AAMU,UAAAC,qBAAA,GAAiC,IAAjC;AAMT,UAAKC,OAAL,GAAed,MAAf;AAF4C;AAG5C;;AAxD6B;AAAA;AAAA,wCA2DN;AACvB,aAAO,KAAKC,cAAZ;AACA;AA7D6B;AAAA;AAAA,sCA+DIA,cA/DJ,EA+DkC;AAC/D,WAAKA,cAAL,GAAsBA,cAAtB;AACA;AAjE6B;AAAA;AAAA,4BAoElB,CACX;AACA;AAtE6B;AAAA;AAAA,oCA2EpBc,KA3EoB,EA4E7BC,QA5E6B,EA6E7BC,YA7E6B,EA8E7BC,UA9E6B,EA8ET;AACpB,UAAIA,UAAU,KAAKC,SAAnB,EAA8B;AAC7BD,QAAAA,UAAU,GAAG,KAAb;AACA;;AAED,UAAIE,GAAG,GAAQ,KAAKrB,GAAL,CAASsB,aAAT,CAAuBL,QAAvB,CAAf;AACArB,MAAAA,MAAM,CAACyB,GAAG,IAAI,IAAR,CAAN;;AACA,UAAI,KAAKZ,YAAL,IAAqB,CAACY,GAAG,CAACE,eAA1B,IAA6C,CAACF,GAAG,CAACG,OAAtD,EAA+D;AAC9D,YAAIC,IAAI,GAAWT,KAAK,CAACU,EAAN,CAAS,CAAT,CAAnB;;AACA,YAAID,IAAI,IAAI,CAAR,IAAaA,IAAI,IAAI,MAAzB,EAAiC;AAChC,cAAIhF,GAAG,GAAW,CAAEwE,QAAQ,IAAI,EAAb,KAAqB,CAAtB,IAA2BQ,IAA7C;AACA,cAAIE,GAAG,GAAuB,KAAK3B,GAAL,CAAS4B,QAAT,CAAkBC,GAAlB,CAAsBpF,GAAtB,CAA9B;;AACA,cAAIkF,GAAG,IAAI,IAAX,EAAiB;AAChB,mBAAOA,GAAP;AACA;AACD;AACD;;AAED,WAAKN,GAAL,GAAWA,GAAX;;AAEA,UAAI,KAAKhB,oBAAT,EAA+B;AAC9Bc,QAAAA,UAAU,GAAG,IAAb;AACA,OAFD,MAGK,IAAI,CAAC,KAAKb,wBAAV,EAAoC;AACxCa,QAAAA,UAAU,GAAGA,UAAU,IAAIE,GAAG,CAACS,kBAA/B;AACA;;AAED,WAAKhB,qBAAL,GAA6BK,UAAU,IAAK,KAAKjB,cAAL,KAAwBd,gBAAA,CAAAe,cAAA,CAAe4B,GAAvC,IAA8Cb,YAAY,IAAI,IAA9D,IAAsE,CAAC,KAAKlB,GAAL,CAASgC,eAAT,CAAyBf,QAAzB,EAAmCgB,GAAtJ;;AACA,UAAIf,YAAY,IAAI,IAApB,EAA0B;AACzBA,QAAAA,YAAY,GAAGjC,mBAAA,CAAAiD,iBAAA,CAAkBC,YAAlB,EAAf;AACA;;AAED,UAAIC,KAAJ;;AACA,UAAI,CAACf,GAAG,CAACG,OAAT,EAAkB;AACjBY,QAAAA,KAAK,GAAG,KAAKC,aAAL,CAAmBhB,GAAnB,EAAwBL,KAAxB,EAA+BE,YAA/B,EAA6CC,UAA7C,CAAR;AACA;;AAED,UAAIiB,KAAK,IAAI,IAAb,EAAmB;AAClB,YAAIlB,YAAY,IAAI,IAApB,EAA0B;AACzBA,UAAAA,YAAY,GAAGjC,mBAAA,CAAAiD,iBAAA,CAAkBC,YAAlB,EAAf;AACA;;AACD,YAAIpC,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,UAAAA,OAAO,CAACC,GAAR,CAAY,kBAAkBnB,GAAG,CAACJ,QAAtB,GACX,eADW,GACO,KAAKwB,gBAAL,CAAsBzB,KAAtB,CADP,GAEX,iBAFW,GAESE,YAAY,CAACwB,QAAb,CAAsB,KAAK3B,OAA3B,CAFrB;AAGA;;AAEDqB,QAAAA,KAAK,GAAG,KAAKO,iBAAL,CAAuBtB,GAAvB,EAA4BH,YAA5B,EAA0CC,UAA1C,CAAR;AACA;;AAED,UAAIyB,CAAC,GAAW5B,KAAK,CAAC6B,IAAN,EAAhB;AACA,UAAIC,KAAK,GAAW9B,KAAK,CAAC8B,KAA1B;;AACA,UAAI;AACH,YAAInB,IAAG,GAAW,KAAKoB,OAAL,CAAa1B,GAAb,EAAkBL,KAAlB,EAAyB8B,KAAzB,EAAgCV,KAAhC,CAAlB;;AACA,YAAIrC,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,UAAAA,OAAO,CAACC,GAAR,CAAY,2BAA2BnB,GAAG,CAACqB,QAAJ,CAAa,KAAK3B,OAAL,CAAaiC,UAA1B,EAAsC,KAAKjC,OAAL,CAAakC,SAAnD,CAAvC;AACA;;AACD,eAAOtB,IAAP;AACA,OAND,SAOQ;AACP,aAAKN,GAAL,GAAWD,SAAX;AACAJ,QAAAA,KAAK,CAACkC,IAAN,CAAWJ,KAAX;AACA9B,QAAAA,KAAK,CAACmC,OAAN,CAAcP,CAAd;AACA;AACD;AA9I6B;AAAA;AAAA,kCAiJpBvB,GAjJoB,EAkJpBL,KAlJoB,EAmJpBE,YAnJoB,EAoJ7BC,UApJ6B,EAoJV;AAEnB,UAAI,CAACA,UAAL,EAAiB;AAChB,YAAIE,GAAG,CAACE,eAAR,EAAyB;AACxB;AACA;AACA,cAAIa,KAAK,GAAyBf,GAAG,CAAC+B,uBAAJ,CAA4B,KAAKrC,OAAL,CAAasC,UAAzC,EAAqD,KAArD,CAAlC;;AACA,cAAIjB,KAAK,IAAI,IAAb,EAAmB;AAClB,mBAAOhB,SAAP;AACA;;AAED,iBAAO,IAAI3B,gBAAA,CAAA6D,cAAJ,CAAmBpC,YAAnB,EAAiCkB,KAAjC,EAAwC,KAAxC,EAA+ClB,YAA/C,CAAP;AACA,SATD,MAUK;AACJ,cAAIG,GAAG,CAACkC,EAAJ,IAAU,IAAd,EAAoB;AACnB,mBAAOnC,SAAP;AACA;;AAED,iBAAO,IAAI3B,gBAAA,CAAA6D,cAAJ,CAAmBpC,YAAnB,EAAiCG,GAAG,CAACkC,EAArC,EAAyC,KAAzC,EAAgDrC,YAAhD,CAAP;AACA;AACD;;AAED,UAAI,CAAC,KAAKX,yBAAV,EAAqC;AACpC,eAAOa,SAAP;AACA;;AAED,UAAIoC,gBAAgB,GAAkCtC,YAAtD;AACAtB,MAAAA,MAAM,CAACsB,YAAY,IAAI,IAAjB,CAAN;AACA,UAAIqC,EAAJ;;AACA,UAAIlC,GAAG,CAACE,eAAR,EAAyB;AACxBgC,QAAAA,EAAE,GAAGlC,GAAG,CAAC+B,uBAAJ,CAA4B,KAAKrC,OAAL,CAAasC,UAAzC,EAAqD,IAArD,CAAL;AACA,OAFD,MAGK;AACJE,QAAAA,EAAE,GAAGlC,GAAG,CAACoC,MAAT;AACA;;AAED,aAAOD,gBAAgB,IAAI,IAApB,IAA4BD,EAAE,IAAI,IAAlC,IAA0CA,EAAE,CAACzB,kBAApD,EAAwE;AACvE0B,QAAAA,gBAAgB,GAAG,KAAKE,aAAL,CAAmBF,gBAAnB,CAAnB;AACAD,QAAAA,EAAE,GAAGA,EAAE,CAACI,gBAAH,CAAoB,KAAKC,cAAL,CAAoBJ,gBAApB,CAApB,CAAL;;AACA,YAAIA,gBAAgB,CAAChC,OAArB,EAA8B;AAC7B5B,UAAAA,MAAM,CAAC2D,EAAE,IAAI,IAAN,IAAc,CAACA,EAAE,CAACzB,kBAAnB,CAAN;AACA,SAFD,MAGK;AACJ0B,UAAAA,gBAAgB,GAAGA,gBAAgB,CAACK,MAApC;AACA;AACD;;AAED,UAAIN,EAAE,IAAI,IAAV,EAAgB;AACf,eAAOnC,SAAP;AACA;;AAED,aAAO,IAAI3B,gBAAA,CAAA6D,cAAJ,CAAmBpC,YAAnB,EAAiCqC,EAAjC,EAAqCpC,UAArC,EAAiDqC,gBAAjD,CAAP;AACA;AAxM6B;AAAA;AAAA,4BA2MpBnC,GA3MoB,EA4MpBL,KA5MoB,EA4MA8C,UA5MA,EA6MpB1B,KA7MoB,EA6MC;AAC9B,UAAIlB,YAAY,GAAsBkB,KAAK,CAAClB,YAA5C;;AACA,UAAInB,kBAAkB,CAACgE,SAAvB,EAAkC;AACjCxB,QAAAA,OAAO,CAACC,GAAR,CAAY,kBAAkBnB,GAAG,CAACJ,QAAtB,GACX,eADW,GACO,KAAKwB,gBAAL,CAAsBzB,KAAtB,CADP,GAEX,iBAFW,GAESE,YAAY,CAACwB,QAAb,CAAsB,KAAK3B,OAA3B,CAFrB;AAGA;;AACD,UAAIhB,kBAAkB,CAACgE,SAAvB,EAAkC;AACjCxB,QAAAA,OAAO,CAACC,GAAR,CAAYnB,GAAG,CAACqB,QAAJ,CAAa,KAAK3B,OAAL,CAAaiC,UAA1B,EAAsC,KAAKjC,OAAL,CAAakC,SAAnD,CAAZ;AACA;;AACD,UAAIe,CAAC,GAAa5B,KAAK,CAACmB,EAAxB;AAEA,UAAIU,CAAC,GAAWjD,KAAK,CAACU,EAAN,CAAS,CAAT,CAAhB;AACA,UAAIwC,qBAAqB,GAAkC9B,KAAK,CAAC8B,qBAAjE;;AAEA,aAAO,IAAP,EAAa;AACZ,YAAInE,kBAAkB,CAACgE,SAAvB,EAAkC;AACjCxB,UAAAA,OAAO,CAACC,GAAR,CAAY,eAAewB,CAAC,CAACG,WAAjB,GAA+B,UAA/B,GAA4C,KAAK1B,gBAAL,CAAsBzB,KAAtB,CAAxD;AACA;;AACD,YAAIoB,KAAK,CAACjB,UAAV,EAAsB;AACrB,iBAAO6C,CAAC,CAACI,eAAF,CAAkBH,CAAlB,CAAP,EAA6B;AAC5B,gBAAII,IAA0B,SAA9B;;AACA,gBAAIH,qBAAqB,IAAI,IAA7B,EAAmC;AAClCA,cAAAA,qBAAqB,GAAG,KAAKR,aAAL,CAAmBQ,qBAAnB,CAAxB;AACAG,cAAAA,IAAI,GAAGL,CAAC,CAACL,gBAAF,CAAmB,KAAKC,cAAL,CAAoBM,qBAApB,CAAnB,CAAP;AACA;;AAED,gBAAIG,IAAI,IAAI,IAAZ,EAAkB;AACjB;AACA,kBAAIC,YAAY,GAAmB,IAAI7E,gBAAA,CAAA6D,cAAJ,CAAmBlB,KAAK,CAAClB,YAAzB,EAAuC8C,CAAvC,EAA0C5B,KAAK,CAACjB,UAAhD,EAA4D+C,qBAA5D,CAAnC;AACA,qBAAO,KAAKK,OAAL,CAAalD,GAAb,EAAkBL,KAAlB,EAAyB8C,UAAzB,EAAqCQ,YAArC,CAAP;AACA;;AAED1E,YAAAA,MAAM,CAACsE,qBAAqB,IAAI,IAA1B,CAAN;AACAA,YAAAA,qBAAqB,GAAIA,qBAA2C,CAACL,MAArE;AACAG,YAAAA,CAAC,GAAGK,IAAJ;AACA;AACD;;AAED,YAAI,KAAKG,aAAL,CAAmBR,CAAnB,EAAsB5B,KAAK,CAACjB,UAA5B,CAAJ,EAA6C;AAC5C,cAAI6C,CAAC,CAACS,UAAF,IAAgB,IAApB,EAA0B;AACzB,gBAAI1E,kBAAkB,CAACgE,SAAvB,EAAkC;AACjCxB,cAAAA,OAAO,CAACC,GAAR,CAAY,YAAYwB,CAAxB;AACA;AACD,WAJD,MAKK;AACJ,gBAAIjE,kBAAkB,CAACgE,SAAvB,EAAkC;AACjCxB,cAAAA,OAAO,CAACC,GAAR,CAAY,qBAAqBwB,CAAC,CAACU,UAAvB,GAAoC,YAApC,GAAmDV,CAAC,CAACG,WAAjE;AACA;AACD,WAV2C,CAY5C;AACA;AACA;AACA;;;AACA;AACA,SAzCW,CA2CZ;;;AACAvE,QAAAA,MAAM,CAAC,CAAC,KAAK4E,aAAL,CAAmBR,CAAnB,EAAsB5B,KAAK,CAACjB,UAA5B,CAAF,CAAN,CA5CY,CA8CZ;;AACA,YAAI3E,MAAM,GAAyB,KAAKmI,sBAAL,CAA4BX,CAA5B,EAA+BC,CAA/B,CAAnC;;AACA,YAAIzH,MAAM,IAAI,IAAd,EAAoB;AACnB,cAAIuD,kBAAkB,CAACgE,SAAnB,IAAgCE,CAAC,IAAI,CAAzC,EAA4C;AAC3C1B,YAAAA,OAAO,CAACC,GAAR,CAAY,iBAAiB,KAAKzB,OAAL,CAAaiC,UAAb,CAAwB4B,cAAxB,CAAuCX,CAAvC,CAA7B;AACA;;AACD,cAAItC,GAAW,SAAf;;AACA,cAAI5B,kBAAkB,CAACgE,SAAvB,EAAkC;AACjC,gBAAIc,QAAQ,GAAalG,UAAA,CAAAmG,QAAA,CAASC,EAAT,CAAYjB,UAAZ,EAAwB,KAAK/C,OAAL,CAAaiE,WAAb,CAAyBlC,KAAjD,CAAzB;AACAP,YAAAA,OAAO,CAACC,GAAR,CAAY,mBACX,KAAKzB,OAAL,CAAaiE,WAAb,CAAyBC,OAAzB,CAAiCJ,QAAjC,CADW,GAEX,gBAFW,GAEQb,CAAC,CAACG,WAFtB;AAGA;;AAED,cAAIG,aAAY,GAAmB,IAAI7E,gBAAA,CAAA6D,cAAJ,CAAmBpC,YAAnB,EAAiC8C,CAAjC,EAAoC5B,KAAK,CAACjB,UAA1C,EAAsD+C,qBAAtD,CAAnC;;AACAvC,UAAAA,GAAG,GAAG,KAAK4C,OAAL,CAAalD,GAAb,EAAkBL,KAAlB,EAAyB8C,UAAzB,EAAqCQ,aAArC,CAAN;;AACA,cAAIvE,kBAAkB,CAACgE,SAAvB,EAAkC;AACjCxB,YAAAA,OAAO,CAACC,GAAR,CAAY,+BAA+Bb,GAA/B,GAAqC,UAArC,GAAkDN,GAAG,CAACqB,QAAJ,CAAa,KAAK3B,OAAL,CAAaiC,UAA1B,EAAsC,KAAKjC,OAAL,CAAakC,SAAnD,CAA9D,EADiC,CAEjC;AACA,WAjBkB,CAkBnB;;;AACA,cAAIlD,kBAAkB,CAACgE,SAAvB,EAAkC;AACjCxB,YAAAA,OAAO,CAACC,GAAR,CAAY,kBAAkBnB,GAAG,CAACJ,QAAtB,GACX,YADW,GACIU,GADhB;AAEA;;AACD,iBAAOA,GAAP,CAvBmB,CAuBP;AACZ,SAxBD,MAyBK,IAAInF,MAAM,KAAK2B,cAAA,CAAA+G,YAAA,CAAaC,KAA5B,EAAmC;AACvC,cAAIC,UAAU,GAAmB,IAAI3F,gBAAA,CAAA6D,cAAJ,CAAmBpC,YAAnB,EAAiC8C,CAAjC,EAAoC5B,KAAK,CAACjB,UAA1C,EAAsD+C,qBAAtD,CAAjC;AACA,iBAAO,KAAKmB,iBAAL,CAAuBrE,KAAvB,EAA8B8C,UAA9B,EAA0CsB,UAA1C,CAAP;AACA;;AACDpB,QAAAA,CAAC,GAAGxH,MAAJ;;AACA,YAAI,CAAC,KAAKgI,aAAL,CAAmBR,CAAnB,EAAsB5B,KAAK,CAACjB,UAA5B,CAAD,IAA4C8C,CAAC,KAAKrF,WAAA,CAAA0G,SAAA,CAAUC,GAAhE,EAAqE;AACpEvE,UAAAA,KAAK,CAACwE,OAAN;AACAvB,UAAAA,CAAC,GAAGjD,KAAK,CAACU,EAAN,CAAS,CAAT,CAAJ;AACA;AACD,OAjG6B,CAkGhC;AACA;AACA;AACA;;;AAEE,UAAI,CAACU,KAAK,CAACjB,UAAP,IAAqB6C,CAAC,CAACyB,OAAF,CAAUC,YAAV,IAA0B,IAAnD,EAAyD;AACxD,YAAIrE,GAAG,CAACsE,aAAJ,YAA6BnH,eAAA,CAAAoH,aAAjC,EAAgD;AAC/C,cAAI,CAAC,KAAK9E,qBAAN,IACF,CAACkD,CAAC,CAACyB,OAAF,CAAUI,oBAAX,IAAmC7B,CAAC,CAACyB,OAAF,CAAUK,eAD3C,IAEF,KAAKlF,iCAAL,IAA0CI,KAAK,CAAC8B,KAAN,KAAgBgB,UAF5D,EAEyE,CACxE;AACA;AACA;AACA;AACA,WAPD,MAQK;AACJlE,YAAAA,MAAM,CAAC,CAACwC,KAAK,CAACjB,UAAR,CAAN,CADI,CAGJ;AACA;AACA;;AACA,gBAAI4E,eAAJ;AACA,gBAAItB,WAAU,GAA0CT,CAAC,CAACS,UAA1D;;AACA,gBAAIA,WAAU,IAAI,IAAlB,EAAwB;AACvB,kBAAIuB,aAAa,GAAWhF,KAAK,CAAC8B,KAAlC;;AACA,kBAAIkD,aAAa,KAAKlC,UAAtB,EAAkC;AACjC9C,gBAAAA,KAAK,CAACkC,IAAN,CAAWY,UAAX;AACA;;AAEDiC,cAAAA,eAAe,GAAG,KAAKE,mBAAL,CAAyBxB,WAAzB,EAAqCvD,YAArC,EAAmD,IAAnD,CAAlB;;AACA,kBAAI6E,eAAe,CAACG,WAAhB,OAAkC,CAAtC,EAAyC;AACxC,uBAAOH,eAAe,CAACI,UAAhB,CAA2B,CAA3B,CAAP;AACA;;AAED,kBAAIH,aAAa,KAAKlC,UAAtB,EAAkC;AACjC;AACA;AACA9C,gBAAAA,KAAK,CAACkC,IAAN,CAAW8C,aAAX;AACA;AACD;;AAED,gBAAI,KAAKnF,iBAAT,EAA4B;AAC3B,kBAAIuF,aAAa,GAAmB,IAAI3G,gBAAA,CAAA6D,cAAJ,CAAmBpC,YAAnB,EAAiC8C,CAAjC,EAAoC5B,KAAK,CAACjB,UAA1C,EAAsD+C,qBAAtD,CAApC;AACA,mBAAKmC,2BAAL,CAAiChF,GAAjC,EAAsC0E,eAAtC,EAAuDK,aAAvD,EAAsEtC,UAAtE,EAAkF9C,KAAK,CAAC8B,KAAxF;AACA;;AAED9B,YAAAA,KAAK,CAACkC,IAAN,CAAWY,UAAX;AACA,mBAAO,KAAKwC,eAAL,CAAqBtF,KAArB,EAA4BK,GAAG,CAACJ,QAAhC,EAA0CC,YAA1C,EAAwD,IAAxD,CAAP;AACA;AACD;AACD,OApJ6B,CAsJ9B;AACA;;;AACA,UAAIuD,UAAU,GAA0CT,CAAC,CAACS,UAA1D;;AACA,UAAIA,UAAU,IAAI,IAAlB,EAAwB;AACvB,YAAI8B,SAAS,GAAWvF,KAAK,CAAC8B,KAA9B;;AACA,YAAIgB,UAAU,KAAKyC,SAAnB,EAA8B;AAC7BvF,UAAAA,KAAK,CAACkC,IAAN,CAAWY,UAAX;AACA;;AAED,YAAI0C,IAAI,GAAW,KAAKP,mBAAL,CAAyBxB,UAAzB,EAAqCvD,YAArC,EAAmD,KAAKL,iBAAL,IAA0B,KAAKX,cAAL,KAAwBd,gBAAA,CAAAe,cAAA,CAAesG,wBAApH,CAAnB;;AACA,gBAAQD,IAAI,CAACN,WAAL,EAAR;AACA,eAAK,CAAL;AACC,kBAAM,KAAKQ,WAAL,CAAiB1F,KAAjB,EAAwBE,YAAxB,EAAsC8C,CAAC,CAACyB,OAAxC,EAAiD3B,UAAjD,CAAN;;AAED,eAAK,CAAL;AACC,mBAAO0C,IAAI,CAACL,UAAL,CAAgB,CAAhB,CAAP;;AAED;AACC;AACA;AACA,gBAAIrC,UAAU,KAAKyC,SAAnB,EAA8B;AAC7BvF,cAAAA,KAAK,CAACkC,IAAN,CAAWqD,SAAX;AACA;;AAED,iBAAKI,eAAL,CAAqBtF,GAArB,EAA0B2C,CAA1B,EAA6BF,UAA7B,EAAyCyC,SAAzC,EAAoDvC,CAAC,CAACyB,OAAF,CAAUK,eAA9D,EAA+EU,IAA/E,EAAqFxC,CAAC,CAACyB,OAAvF;AACA,mBAAOe,IAAI,CAACL,UAAL,CAAgB,CAAhB,CAAP;AAfD;AAiBA;;AAED,UAAIpG,kBAAkB,CAACgE,SAAvB,EAAkC;AACjCxB,QAAAA,OAAO,CAACC,GAAR,CAAY,kBAAkBnB,GAAG,CAACJ,QAAtB,GACX,YADW,GACI+C,CAAC,CAACU,UADlB;AAEA;;AACD,aAAOV,CAAC,CAACU,UAAT;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;AAvY8B;AAAA;AAAA,kCA4ZNtC,KA5ZM,EA4ZWjB,UA5ZX,EA4Z8B;AAC3D,UAAI,CAACiB,KAAK,CAACoC,aAAX,EAA0B;AACzB,eAAO,KAAP;AACA;;AAED,UAAIpC,KAAK,CAACqD,OAAN,CAAcM,eAAd,IAAiC,IAArC,EAA2C;AAC1C;AACA,eAAO,IAAP;AACA,OAR0D,CAU3D;;;AACA,UAAI5E,UAAU,IAAI,KAAKjB,cAAL,KAAwBd,gBAAA,CAAAe,cAAA,CAAesG,wBAAzD,EAAmF;AAClF,eAAOrE,KAAK,CAACqD,OAAN,CAAcK,eAArB;AACA;;AAED,aAAO,IAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9a8B;AAAA;AAAA,4BA2dpBzE,GA3doB,EA4dpBL,KA5doB,EA4dA8C,UA5dA,EA6dpBQ,YA7doB,EA6dQ;AACrC,UAAIvE,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,sBAAsBnB,GAAG,CAACJ,QAA1B,GAAqC,eAArC,GAAuD,KAAKwB,gBAAL,CAAsBzB,KAAtB,CAAnE;AACA;;AAED,UAAIE,YAAY,GAAsBoD,YAAY,CAACpD,YAAnD;AACA,UAAIC,UAAU,GAAYmD,YAAY,CAACnD,UAAvC;AAEA,UAAI8C,CAAC,GAAWjD,KAAK,CAACU,EAAN,CAAS,CAAT,CAAhB;AAEA,UAAIkF,QAAQ,GAAmBtC,YAA/B;AAEA,UAAIuC,YAAY,GAA2B,IAAI1H,wBAAA,CAAA2H,sBAAJ,EAA3C;;AACA,aAAO,IAAP,EAAa;AAAE;AACd,YAAIC,SAAS,GAA+B,KAAKC,eAAL,CAAqB3F,GAArB,EAA0BuF,QAA1B,EAAoC3C,CAApC,EAAuC4C,YAAvC,CAA5C;;AACA,YAAIE,SAAS,IAAI,IAAjB,EAAuB;AACtB,eAAKE,UAAL,CAAgBL,QAAQ,CAACrD,EAAzB,EAA6BvC,KAAK,CAACU,EAAN,CAAS,CAAT,CAA7B,EAA0CvD,cAAA,CAAA+G,YAAA,CAAaC,KAAvD;AACA,iBAAO,KAAKE,iBAAL,CAAuBrE,KAAvB,EAA8B8C,UAA9B,EAA0C8C,QAA1C,CAAP;AACA;;AAED,YAAIM,CAAC,GAAaH,SAAS,CAACxD,EAA5B,CAPY,CASZ;;AACA3D,QAAAA,MAAM,CAACsH,CAAC,CAAC1C,aAAF,IAAmB0C,CAAC,CAACxC,UAAF,KAAiB1G,KAAA,CAAAmJ,GAAA,CAAIC,kBAAzC,CAAN,CAVY,CAWZ;;AACAxH,QAAAA,MAAM,CAACsH,CAAC,CAAC1C,aAAF,IAAmB0C,CAAC,CAACzB,OAAF,CAAUC,YAAV,IAA0B,IAA9C,CAAN;;AAEA,YAAI,KAAKlB,aAAL,CAAmB0C,CAAnB,EAAsB/F,UAAtB,CAAJ,EAAuC;AACtC,cAAI4E,eAAe,GAAuBmB,CAAC,CAACzB,OAAF,CAAUM,eAApD;AACA,cAAIsB,YAAY,GAAWtB,eAAe,IAAI,IAAnB,GAA0BmB,CAAC,CAACxC,UAA5B,GAAyC1G,KAAA,CAAAmJ,GAAA,CAAIC,kBAAxE;;AACA,cAAIC,YAAY,KAAKrJ,KAAA,CAAAmJ,GAAA,CAAIC,kBAAzB,EAA6C;AAC5C,gBAAI,KAAK3G,YAAL,IACAO,KAAK,CAAC8B,KAAN,KAAgBgB,UADhB,IAEA,CAACzC,GAAG,CAACE,eAFL,IAGAwF,SAAS,CAAC7F,YAAV,KAA2B6F,SAAS,CAAC7C,qBAHrC,IAIA7C,GAAG,CAACJ,QAAJ,IAAgB,CAJhB,IAKA,CAACiG,CAAC,CAACzB,OAAF,CAAU6B,kBALf,EAKmC;AAClC,kBAAIrD,CAAC,IAAI,CAAL,IAAUA,CAAC,IAAIpE,eAAnB,EAAoC;AACnC,oBAAIpD,GAAG,GAAW,CAAE4E,GAAG,CAACJ,QAAJ,IAAgB,EAAjB,KAAyB,CAA1B,IAA+BgD,CAAjD;AACA,qBAAKjE,GAAL,CAAS4B,QAAT,CAAkB2F,GAAlB,CAAsB9K,GAAtB,EAA2B4K,YAA3B;AACA;AACD;;AAED,gBAAIlG,UAAU,IAAI,KAAKb,wBAAvB,EAAiD;AAChD,mBAAKkH,wBAAL,CAA8BnG,GAA9B,EAAmCgG,YAAnC,EAAiDN,SAAjD,EAA4DjD,UAA5D,EAAwE9C,KAAK,CAAC8B,KAA9E;AACA;AACD;;AAEDuE,UAAAA,YAAY,GAAGH,CAAC,CAACxC,UAAjB,CArBsC,CAsB1C;AACA;;AACI,cAAI+C,kBAAkB,GAAY1B,eAAe,IAAI,IAAnB,IAA2B,KAAKjF,qBAAlE;;AACA,cAAI2G,kBAAJ,EAAwB;AACvB;AACA;AACAA,YAAAA,kBAAkB,GAAG,CAACtG,UAAD,KAChB+F,CAAC,CAACzB,OAAF,CAAUI,oBAAV,IAAkC,CAACqB,CAAC,CAACzB,OAAF,CAAUK,eAD7B,MAEhB,CAAC,KAAKlF,iCAAN,IAA2CI,KAAK,CAAC8B,KAAN,KAAgBgB,UAF3C,CAArB;AAGA;;AAED,cAAIoD,CAAC,CAACzB,OAAF,CAAU6B,kBAAd,EAAkC;AACjC,gBAAII,eAAe,GAA0CR,CAAC,CAACzC,UAA/D;;AACA,gBAAIiD,eAAe,IAAI,IAAvB,EAA6B;AAC5B,kBAAI1B,aAAa,GAAWhF,KAAK,CAAC8B,KAAlC;;AACA,kBAAIkD,aAAa,KAAKlC,UAAtB,EAAkC;AACjC9C,gBAAAA,KAAK,CAACkC,IAAN,CAAWY,UAAX;AACA,eAJ2B,CAM5B;;;AACAiC,cAAAA,eAAe,GAAG,KAAKE,mBAAL,CAAyByB,eAAzB,EAA0CxG,YAA1C,EAAwDuG,kBAAkB,IAAI,KAAK5G,iBAAnF,CAAlB;;AACA,sBAAQkF,eAAe,CAACG,WAAhB,EAAR;AACA,qBAAK,CAAL;AACC,wBAAM,KAAKQ,WAAL,CAAiB1F,KAAjB,EAAwBE,YAAxB,EAAsCgG,CAAC,CAACzB,OAAxC,EAAiD3B,UAAjD,CAAN;;AAED,qBAAK,CAAL;AACC,yBAAOiC,eAAe,CAACI,UAAhB,CAA2B,CAA3B,CAAP;;AAED;AACC;AARD;;AAWA,kBAAIH,aAAa,KAAKlC,UAAtB,EAAkC;AACjC;AACA;AACA9C,gBAAAA,KAAK,CAACkC,IAAN,CAAW8C,aAAX;AACA;AACD;AACD;;AAED,cAAI,CAACyB,kBAAL,EAAyB;AACxB,gBAAI1B,eAAe,IAAI,IAAvB,EAA6B;AAC5B,kBAAI,KAAKlF,iBAAL,IAA0BkF,eAAe,CAACG,WAAhB,KAAgC,CAA9D,EAAiE;AAChE,qBAAKS,eAAL,CAAqBtF,GAArB,EAA0B6F,CAA1B,EAA6BpD,UAA7B,EAAyC9C,KAAK,CAAC8B,KAA/C,EAAsDoE,CAAC,CAACzB,OAAF,CAAUK,eAAhE,EAAiFC,eAAjF,EAAkGmB,CAAC,CAACzB,OAApG;AACA;;AAED4B,cAAAA,YAAY,GAAGtB,eAAe,CAACI,UAAhB,CAA2B,CAA3B,CAAf;AACA;;AAED,mBAAOkB,YAAP;AACA,WAVD,MAWK;AACJzH,YAAAA,MAAM,CAAC,CAACuB,UAAF,CAAN;AACAvB,YAAAA,MAAM,CAAC,KAAK4E,aAAL,CAAmB0C,CAAnB,EAAsB,KAAtB,CAAD,CAAN;;AAEA,gBAAInH,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,cAAAA,OAAO,CAACC,GAAR,CAAY,6BAA6BtB,YAAzC;AACA;;AACD,gBAAIyG,gBAAgB,GAAmB,KAAKhF,iBAAL,CAAuBtB,GAAvB,EAA4BH,YAA5B,EAA0C,IAA1C,CAAvC;;AACA,gBAAI,KAAKL,iBAAT,EAA4B;AAC3B,mBAAKwF,2BAAL,CAAiChF,GAAjC,EAAsC0E,eAAtC,EAAuDgB,SAAvD,EAAkEjD,UAAlE,EAA8E9C,KAAK,CAAC8B,KAApF;AACA;;AAED9B,YAAAA,KAAK,CAACkC,IAAN,CAAWY,UAAX;AACA,mBAAO,KAAKS,OAAL,CAAalD,GAAb,EAAkBL,KAAlB,EAAyB8C,UAAzB,EAAqC6D,gBAArC,CAAP;AACA;AACD;;AAEDf,QAAAA,QAAQ,GAAGG,SAAX;;AAEA,YAAI9C,CAAC,KAAKrF,WAAA,CAAA0G,SAAA,CAAUC,GAApB,EAAyB;AACxBvE,UAAAA,KAAK,CAACwE,OAAN;AACAvB,UAAAA,CAAC,GAAGjD,KAAK,CAACU,EAAN,CAAS,CAAT,CAAJ;AACA;AACD;AACD;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3lB8B;AAAA;AAAA,sCA8oBOV,KA9oBP,EA8oB2B8C,UA9oB3B,EA8oBwD8C,QA9oBxD,EA8oBgF;AAC7G,UAAIA,QAAQ,CAACrD,EAAT,IAAe,IAAnB,EAAyB;AACxB,YAAIiD,IAAI,GAAW,IAAIlI,QAAA,CAAAsJ,MAAJ,EAAnB;AACA,YAAIC,MAAM,GAAW,CAArB;AAFwB;AAAA;AAAA;;AAAA;AAGxB,+BAAmBjB,QAAQ,CAACrD,EAAT,CAAYkC,OAA/B,8HAAwC;AAAA,gBAA/BqC,OAA+B;;AACvC,gBAAIA,OAAM,CAACC,uBAAP,IAAkCD,OAAM,CAAC1F,KAAP,YAAwB/C,eAAA,CAAA2I,aAA9D,EAA6E;AAC5ExB,cAAAA,IAAI,CAACe,GAAL,CAASO,OAAM,CAACnG,GAAhB;AACAkG,cAAAA,MAAM,GAAGI,IAAI,CAACC,GAAL,CAASL,MAAT,EAAiBC,OAAM,CAACnG,GAAxB,CAAT;AACA;AACD;AARuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAUxB,gBAAQ6E,IAAI,CAACN,WAAL,EAAR;AACA,eAAK,CAAL;AACC;;AAED,eAAK,CAAL;AACC,mBAAOM,IAAI,CAACL,UAAL,CAAgB,CAAhB,CAAP;;AAED;AACC,gBAAI,CAACS,QAAQ,CAACrD,EAAT,CAAYkC,OAAZ,CAAoB6B,kBAAzB,EAA6C;AAC5C;AACA;AACA,qBAAOd,IAAI,CAACL,UAAL,CAAgB,CAAhB,CAAP;AACA;AAED;;;;;;AAIA,gBAAIgC,eAAe,GAAiB,IAAIjK,cAAA,CAAAkK,YAAJ,EAApC;AAXD;AAAA;AAAA;;AAAA;AAYC,oCAAmBxB,QAAQ,CAACrD,EAAT,CAAYkC,OAA/B,mIAAwC;AAAA,oBAA/BqC,MAA+B;;AACvC,oBAAIA,MAAM,CAACC,uBAAP,IAAkCD,MAAM,CAAC1F,KAAP,YAAwB/C,eAAA,CAAA2I,aAA9D,EAA6E;AAC5EG,kBAAAA,eAAe,CAACE,GAAhB,CAAoBP,MAApB;AACA;AACD;AAED;;;;;;;;;AAlBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA0BC,gBAAIQ,SAAS,GAAkC,KAAKC,oBAAL,CAA0B/B,IAA1B,EAAgC2B,eAAhC,EAAiDN,MAAjD,CAA/C;;AACA,gBAAIS,SAAS,IAAI,IAAjB,EAAuB;AACtB,kBAAI7D,UAAU,GAA0C,KAAK+D,uBAAL,CAA6BhC,IAA7B,EAAmC8B,SAAnC,CAAxD;;AACA,kBAAI7D,UAAU,IAAI,IAAlB,EAAwB;AACvB,oBAAI8B,SAAS,GAAWvF,KAAK,CAAC8B,KAA9B;;AACA,oBAAI;AACH9B,kBAAAA,KAAK,CAACkC,IAAN,CAAWY,UAAX;AACA,sBAAI2E,YAAY,GAAW,KAAKxC,mBAAL,CAAyBxB,UAAzB,EAAqCmC,QAAQ,CAAC1F,YAA9C,EAA4D,KAA5D,CAA3B;;AACA,sBAAI,CAACuH,YAAY,CAACjH,OAAlB,EAA2B;AAC1B,2BAAOiH,YAAY,CAACtC,UAAb,CAAwB,CAAxB,CAAP;AACA;AACD,iBAND,SAOQ;AACPnF,kBAAAA,KAAK,CAACkC,IAAN,CAAWqD,SAAX;AACA;AACD;AACD;;AAED,mBAAOC,IAAI,CAACL,UAAL,CAAgB,CAAhB,CAAP;AAnDD;AAqDA;;AAED,YAAM,KAAKO,WAAL,CAAiB1F,KAAjB,EAAwB4F,QAAQ,CAAC1F,YAAjC,EAA+C0F,QAAQ,CAACrD,EAAT,CAAYkC,OAA3D,EAAoE3B,UAApE,CAAN;AACA;AAjtB6B;AAAA;AAAA,oCAmtBJzC,GAntBI,EAmtBMuF,QAntBN,EAmtBgC3C,CAntBhC,EAmtB2C4C,YAntB3C,EAmtB+E;AAC5G,UAAI1F,UAAU,GAAYyF,QAAQ,CAACzF,UAAnC;AACA,UAAIuH,sBAAsB,GAAkC9B,QAAQ,CAAC1C,qBAArE;AAEA,UAAIF,CAAC,GAAa4C,QAAQ,CAACrD,EAA3B;;AACA,UAAIpC,UAAJ,EAAgB;AACf,eAAO6C,CAAC,CAACI,eAAF,CAAkBH,CAAlB,CAAP,EAA6B;AAC5B,cAAII,IAA0B,SAA9B;;AACA,cAAIqE,sBAAsB,IAAI,IAA9B,EAAoC;AACnCA,YAAAA,sBAAsB,GAAG,KAAKhF,aAAL,CAAmBgF,sBAAnB,CAAzB;AACArE,YAAAA,IAAI,GAAGL,CAAC,CAACL,gBAAF,CAAmB,KAAKC,cAAL,CAAoB8E,sBAApB,CAAnB,CAAP;AACA;;AAED,cAAIrE,IAAI,IAAI,IAAZ,EAAkB;AACjB;AACA;;AAEDzE,UAAAA,MAAM,CAAC8I,sBAAsB,IAAI,IAA3B,CAAN;AACAA,UAAAA,sBAAsB,GAAIA,sBAA4C,CAAC7E,MAAvE;AACAG,UAAAA,CAAC,GAAGK,IAAJ;AACA;AACD;;AAEDzE,MAAAA,MAAM,CAAC,CAAC,KAAK4E,aAAL,CAAmBR,CAAnB,EAAsB7C,UAAtB,CAAF,CAAN;;AACA,UAAI,KAAKqD,aAAL,CAAmBR,CAAnB,EAAsB7C,UAAtB,CAAJ,EAAuC;AACtC,eAAO,IAAI1B,gBAAA,CAAA6D,cAAJ,CAAmBsD,QAAQ,CAAC1F,YAA5B,EAA0C8C,CAA1C,EAA6C7C,UAA7C,EAAyDuH,sBAAzD,CAAP;AACA;;AAED,UAAInF,EAAE,GAAaS,CAAnB;AAEA,UAAIxH,MAAM,GAAyB,KAAKmI,sBAAL,CAA4BpB,EAA5B,EAAgCU,CAAhC,CAAnC;;AACA,UAAIzH,MAAM,IAAI,IAAd,EAAoB;AACnB,YAAImM,MAAM,GAA8C,KAAKC,kBAAL,CAAwBvH,GAAxB,EAA6BkC,EAA7B,EAAiCmF,sBAAjC,EAAyDzE,CAAzD,EAA4D9C,UAA5D,EAAwE0F,YAAxE,CAAxD;AACArK,QAAAA,MAAM,GAAGmM,MAAM,CAAC,CAAD,CAAf;AACAD,QAAAA,sBAAsB,GAAGC,MAAM,CAAC,CAAD,CAA/B;AACA;;AAED,UAAInM,MAAM,KAAK2B,cAAA,CAAA+G,YAAA,CAAaC,KAA5B,EAAmC;AAClC,eAAO/D,SAAP;AACA;;AAEDxB,MAAAA,MAAM,CAAC,CAACuB,UAAD,IAAe,CAAC3E,MAAM,CAACiJ,OAAP,CAAeI,oBAAhC,CAAN;AACA,aAAO,IAAIpG,gBAAA,CAAA6D,cAAJ,CAAmBsD,QAAQ,CAAC1F,YAA5B,EAA0C1E,MAA1C,EAAkD2E,UAAlD,EAA8DuH,sBAA9D,CAAP;AACA;AAED;;;;;;;;;;;;AAhwB8B;AAAA;AAAA,2CA2wBY1E,CA3wBZ,EA2wByBC,CA3wBzB,EA2wBkC;AAC/D,aAAOD,CAAC,CAAC6E,SAAF,CAAY5E,CAAZ,CAAP;AACA;AAED;;;;;;;;;;;;;;;;AA/wB8B;AAAA;AAAA,uCA+xBQ5C,GA/xBR,EA+xB2B2C,CA/xB3B,EA+xBwC0E,sBA/xBxC,EA+xB+FzE,CA/xB/F,EA+xB0G9C,UA/xB1G,EA+xB+H0F,YA/xB/H,EA+xBmK;AAChM,UAAIiC,cAAc,GAAgB9E,CAAC,CAACyB,OAAF,CAAUsD,OAAV,EAAlC;AACA,UAAIC,eAAJ;AACA,UAAIC,KAAK,GAAiB,IAAI/K,cAAA,CAAAkK,YAAJ,EAA1B;AACA,UAAIc,cAAJ;;AACA,SAAG;AACF,YAAIC,cAAc,GAAY,CAAChI,UAAD,IAAeuH,sBAAsB,IAAI,IAAvE;;AACA,YAAI,CAACS,cAAL,EAAqB;AACpBF,UAAAA,KAAK,CAACG,oBAAN,GAA6B,IAA7B;AACA;;AAED,YAAIC,iBAAiB,GAAiB,IAAInL,cAAA,CAAAkK,YAAJ,EAAtC;AAEA;;;;;;;;;;;AAUA,YAAIkB,iBAA0C,SAA9C;AAlBE;AAAA;AAAA;;AAAA;AAoBF,gCAAcR,cAAd,mIAA8B;AAAA,gBAArBnM,EAAqB;;AAC7B,gBAAIoD,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,cAAAA,OAAO,CAACC,GAAR,CAAY,aAAa,KAAK+G,YAAL,CAAkBtF,CAAlB,CAAb,GAAoC,MAApC,GAA6CtH,EAAC,CAAC+F,QAAF,EAAzD;AACA;;AAED,gBAAI/F,EAAC,CAACyF,KAAF,YAAmB/C,eAAA,CAAA2I,aAAvB,EAAsC;AACrCpI,cAAAA,MAAM,CAACjD,EAAC,CAAC6M,OAAF,CAAUhI,OAAX,CAAN;;AACA,kBAAIL,UAAU,IAAI,CAACxE,EAAC,CAACoL,uBAAjB,IAA4C9D,CAAC,KAAKrF,WAAA,CAAA0G,SAAA,CAAUC,GAAhE,EAAqE;AACpE,oBAAI+D,iBAAiB,IAAI,IAAzB,EAA+B;AAC9BA,kBAAAA,iBAAiB,GAAG,EAApB;AACA;;AAEDA,gBAAAA,iBAAiB,CAACG,IAAlB,CAAuB9M,EAAvB;AACA;;AAED;AACA;;AAED,gBAAI+M,CAAC,GAAW/M,EAAC,CAACyF,KAAF,CAAQuH,4BAAxB;;AACA,iBAAK,IAAIC,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGF,CAAtB,EAAyBE,EAAE,EAA3B,EAA+B;AAAgB;AAC9C,kBAAIC,KAAK,GAAelN,EAAC,CAACyF,KAAF,CAAQ0H,sBAAR,CAA+BF,EAA/B,CAAxB;;AACA,kBAAIpN,MAAM,GAAyB,KAAKuN,kBAAL,CAAwBpN,EAAxB,EAA2BkN,KAA3B,EAAkC5F,CAAlC,CAAnC;;AACA,kBAAIzH,MAAM,IAAI,IAAd,EAAoB;AACnB6M,gBAAAA,iBAAiB,CAAChB,GAAlB,CAAsB1L,EAAC,CAACqN,SAAF,CAAYxN,MAAZ,EAAoB,KAApB,CAAtB,EAAkDqK,YAAlD;AACA;AACD;AACD;AAED;;;;;;;;;;AAhDE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAyDF,YAAI,KAAKrG,uBAAL,IAAgC8I,iBAAiB,IAAI,IAArD,IAA6DrF,CAAC,KAAKvE,OAAA,CAAAuK,KAAA,CAAM1E,GAAzE,IAAgF8D,iBAAiB,CAACa,SAAlB,KAAgClM,KAAA,CAAAmJ,GAAA,CAAIC,kBAAxH,EAA4I;AAC3IiC,UAAAA,iBAAiB,CAACD,oBAAlB,GAAyCH,KAAK,CAACG,oBAA/C;AACAH,UAAAA,KAAK,GAAGI,iBAAR;AACA;AACA;AAED;;;;;AAGA,YAAIc,iBAAiB,GAAY,KAAjC;AACA,YAAIC,iBAAiB,GAAYnG,CAAC,KAAKvE,OAAA,CAAAuK,KAAA,CAAM1E,GAA7C;AACA,aAAK8E,OAAL,CAAahB,iBAAb,EAAgCJ,KAAhC,EAAuCkB,iBAAvC,EAA0DhB,cAA1D,EAA0EtC,YAA1E,EAAwFuD,iBAAxF;AACAlB,QAAAA,cAAc,GAAGD,KAAK,CAACpD,oBAAvB;;AAEA,YAAI5B,CAAC,KAAKrF,WAAA,CAAA0G,SAAA,CAAUC,GAApB,EAAyB;AACxB;;;;;;;;;;;;AAYA0D,UAAAA,KAAK,GAAG,KAAKqB,kCAAL,CAAwCrB,KAAxC,EAA+CpC,YAA/C,CAAR;AACA;AAED;;;;;;;;;;AAQA,YAAIyC,iBAAiB,IAAI,IAArB,KAA8B,CAACnI,UAAD,IAAe,CAAC/B,gBAAA,CAAAe,cAAA,CAAeoK,wBAAf,CAAwCtB,KAAxC,CAA9C,CAAJ,EAAmG;AAClGrJ,UAAAA,MAAM,CAAC0J,iBAAiB,CAACzM,MAAlB,GAA2B,CAA5B,CAAN;AADkG;AAAA;AAAA;;AAAA;AAElG,kCAAcyM,iBAAd,mIAAiC;AAAA,kBAAxB3M,CAAwB;AAChCsM,cAAAA,KAAK,CAACZ,GAAN,CAAU1L,CAAV,EAAakK,YAAb;AACA;AAJiG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKlG;;AAED,YAAI1F,UAAU,IAAI+H,cAAlB,EAAkC;AACjCD,UAAAA,KAAK,CAACuB,KAAN,GADiC,CAGjC;;AACA9B,UAAAA,sBAAsB,GAAGA,sBAAzB;AAEAA,UAAAA,sBAAsB,GAAG,KAAKhF,aAAL,CAAmBgF,sBAAnB,CAAzB;AACA,cAAI+B,kBAAkB,GAAW,KAAK7G,cAAL,CAAoB8E,sBAApB,CAAjC;;AACA,cAAIM,eAAe,IAAI,IAAvB,EAA6B;AAC5BA,YAAAA,eAAe,GAAG,IAAItK,aAAA,CAAAgM,WAAJ,EAAlB;AACA;;AAED,cAAIhC,sBAAsB,CAAClH,OAA3B,EAAoC;AACnCkH,YAAAA,sBAAsB,GAAGtH,SAAzB;AACA,WAFD,MAEO;AACNsH,YAAAA,sBAAsB,GAAGA,sBAAsB,CAAC7E,MAAhD;AACA;;AAEDmF,UAAAA,eAAe,CAACX,GAAhB,CAAoBoC,kBAApB;;AACA,cAAIA,kBAAkB,KAAKvL,mBAAA,CAAAyL,iBAAA,CAAkBC,oBAA7C,EAAmE;AAClE,iBAAK,IAAIxN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG0L,cAAc,CAACjM,MAAnC,EAA2CO,CAAC,EAA5C,EAAgD;AAC/C0L,cAAAA,cAAc,CAAC1L,CAAD,CAAd,GAAoB0L,cAAc,CAAC1L,CAAD,CAAd,CAAkByN,aAAlB,CAAgCJ,kBAAhC,EAAoD5D,YAApD,CAApB;AACA;AACD;AACD;AACD,OA/HD,QA+HS1F,UAAU,IAAI+H,cA/HvB;;AAiIA,UAAID,KAAK,CAACzH,OAAV,EAAmB;AAClB,aAAKyF,UAAL,CAAgBjD,CAAhB,EAAmBC,CAAnB,EAAsB9F,cAAA,CAAA+G,YAAA,CAAaC,KAAnC;AACA,eAAO,CAAChH,cAAA,CAAA+G,YAAA,CAAaC,KAAd,EAAqBuD,sBAArB,CAAP;AACA;;AAED,UAAIC,MAAM,GAAa,KAAKmC,UAAL,CAAgBzJ,GAAhB,EAAqB2C,CAArB,EAAwBC,CAAxB,EAA2B+E,eAA3B,EAA4CC,KAA5C,EAAmDpC,YAAnD,CAAvB;AACA,aAAO,CAAC8B,MAAD,EAASD,sBAAT,CAAP;AACA;AAED;;;;;;;;;;;;;;AA96B8B;AAAA;AAAA,uDA47BwBjD,OA57BxB,EA47B+CoB,YA57B/C,EA47BmF;AAChH,UAAIzH,gBAAA,CAAAe,cAAA,CAAe4K,0BAAf,CAA0CtF,OAA1C,CAAJ,EAAwD;AACvD,eAAOA,OAAP;AACA;;AAED,UAAIkD,MAAM,GAAiB,IAAIzK,cAAA,CAAAkK,YAAJ,EAA3B;AALgH;AAAA;AAAA;;AAAA;AAMhH,8BAAmB3C,OAAnB,mIAA4B;AAAA,cAAnBqC,MAAmB;;AAC3B,cAAI,EAAEA,MAAM,CAAC1F,KAAP,YAAwB/C,eAAA,CAAA2I,aAA1B,CAAJ,EAA8C;AAC7C;AACA;;AAEDW,UAAAA,MAAM,CAACN,GAAP,CAAWP,MAAX,EAAmBjB,YAAnB;AACA;AAZ+G;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAchH,aAAO8B,MAAP;AACA;AA38B6B;AAAA;AAAA,sCA+8B7BtH,GA/8B6B,EAg9B7B2J,aAh9B6B,EAi9B7B7J,UAj9B6B,EAi9BV;AACnB,UAAIoC,EAAE,GACLlC,GAAG,CAACE,eAAJ,GAAsBF,GAAG,CAAC+B,uBAAJ,CAA4B,KAAKrC,OAAL,CAAasC,UAAzC,EAAqDlC,UAArD,CAAtB,GACCA,UAAU,GAAGE,GAAG,CAACoC,MAAP,GACTpC,GAAG,CAACkC,EAHP;;AAKA,UAAIA,EAAE,IAAI,IAAV,EAAgB;AACf,YAAI,CAACpC,UAAL,EAAiB;AAChB,iBAAO,IAAI1B,gBAAA,CAAA6D,cAAJ,CAAmB0H,aAAnB,EAAkCzH,EAAlC,EAAsCpC,UAAtC,EAAkD6J,aAAlD,CAAP;AACA;;AAEDzH,QAAAA,EAAE,CAAC0H,mBAAH,CAAuB,KAAKjL,GAA5B;AACA;;AAED,UAAIiB,QAAQ,GAAWI,GAAG,CAACJ,QAA3B,CAdmB,CAenB;;AACA,UAAIiK,CAAC,GAAa7J,GAAG,CAACsE,aAAtB;AAEA,UAAIwF,eAAe,GAAW,CAA9B;AACA,UAAIzC,sBAAsB,GAAkCsC,aAA5D;AACA,UAAII,cAAc,GAAsBjK,UAAU,GAAGjC,mBAAA,CAAAyL,iBAAA,CAAkBU,UAArB,GAAkCnM,mBAAA,CAAAyL,iBAAA,CAAkBW,WAAtG,CApBmB,CAoBgG;;AACnH,UAAIzE,YAAY,GAA2B,IAAI1H,wBAAA,CAAA2H,sBAAJ,EAA3C;;AACA,UAAI3F,UAAJ,EAAgB;AACf,YAAI,CAAC,KAAKZ,yBAAV,EAAqC;AACpC,iBAAOmI,sBAAsB,IAAI,IAAjC,EAAuC;AACtC,gBAAIA,sBAAsB,CAAClH,OAA3B,EAAoC;AACnC2J,cAAAA,eAAe,GAAGjM,mBAAA,CAAAyL,iBAAA,CAAkBC,oBAApC;AACAlC,cAAAA,sBAAsB,GAAGtH,SAAzB;AACA,aAHD,MAIK;AACJ+J,cAAAA,eAAe,GAAG,KAAKvH,cAAL,CAAoB8E,sBAApB,CAAlB;AACA0C,cAAAA,cAAc,GAAGA,cAAc,CAACG,mBAAf,CAAmCJ,eAAnC,EAAoDtE,YAApD,CAAjB;AACA6B,cAAAA,sBAAsB,GAAGA,sBAAsB,CAAC7E,MAAhD;AACA;AACD;AACD;;AAED,eAAON,EAAE,IAAI,IAAN,IAAcA,EAAE,CAACzB,kBAAjB,IAAuC4G,sBAAsB,IAAI,IAAxE,EAA8E;AAC7E,cAAIrE,IAA0B,SAA9B;AACAqE,UAAAA,sBAAsB,GAAG,KAAKhF,aAAL,CAAmBgF,sBAAnB,CAAzB;;AACA,cAAIA,sBAAsB,CAAClH,OAA3B,EAAoC;AACnC6C,YAAAA,IAAI,GAAGd,EAAE,CAACI,gBAAH,CAAoBzE,mBAAA,CAAAyL,iBAAA,CAAkBC,oBAAtC,CAAP;AACAO,YAAAA,eAAe,GAAGjM,mBAAA,CAAAyL,iBAAA,CAAkBC,oBAApC;AACAlC,YAAAA,sBAAsB,GAAGtH,SAAzB;AACA,WAJD,MAKK;AACJ+J,YAAAA,eAAe,GAAG,KAAKvH,cAAL,CAAoB8E,sBAApB,CAAlB;AACArE,YAAAA,IAAI,GAAGd,EAAE,CAACI,gBAAH,CAAoBwH,eAApB,CAAP;AACAC,YAAAA,cAAc,GAAGA,cAAc,CAACG,mBAAf,CAAmCJ,eAAnC,EAAoDtE,YAApD,CAAjB;AACA6B,YAAAA,sBAAsB,GAAGA,sBAAsB,CAAC7E,MAAhD;AACA;;AAED,cAAIQ,IAAI,IAAI,IAAZ,EAAkB;AACjB;AACA;;AAEDd,UAAAA,EAAE,GAAGc,IAAL;AACA;AACD;;AAED,UAAId,EAAE,IAAI,IAAN,IAAc,CAACA,EAAE,CAACzB,kBAAtB,EAA0C;AACzC,eAAO,IAAIrC,gBAAA,CAAA6D,cAAJ,CAAmB0H,aAAnB,EAAkCzH,EAAlC,EAAsCpC,UAAtC,EAAkDuH,sBAAlD,CAAP;AACA;;AAED,UAAIjD,OAAO,GAAiB,IAAIvH,cAAA,CAAAkK,YAAJ,EAA5B;;AACA,aAAO,IAAP,EAAa;AACZ,YAAIiB,iBAAiB,GAAiB,IAAInL,cAAA,CAAAkK,YAAJ,EAAtC;AACA,YAAIsB,CAAC,GAAWwB,CAAC,CAACM,mBAAlB;;AACA,aAAK,IAAI5B,EAAE,GAAG,CAAd,EAAiBA,EAAE,GAAGF,CAAtB,EAAyBE,EAAE,EAA3B,EAA+B;AAC9B;AACA,cAAIpN,MAAM,GAAa0O,CAAC,CAACO,UAAF,CAAa7B,EAAb,EAAiBpN,MAAxC;AACA6M,UAAAA,iBAAiB,CAAChB,GAAlB,CAAsBpK,WAAA,CAAAyN,SAAA,CAAUC,MAAV,CAAiBnP,MAAjB,EAAyBoN,EAAE,GAAG,CAA9B,EAAiCwB,cAAjC,CAAtB;AACA;;AAED,YAAIjC,cAAc,GAAYT,sBAAsB,IAAI,IAAxD;;AACA,YAAI,CAACS,cAAL,EAAqB;AACpB1D,UAAAA,OAAO,CAAC2D,oBAAR,GAA+B,IAA/B;AACA;;AAED,YAAIe,iBAAiB,GAAY,IAAjC;AACA,aAAKE,OAAL,CAAahB,iBAAb,EAAgC5D,OAAhC,EAAyC0E,iBAAzC,EAA4DhB,cAA5D,EAA4EtC,YAA5E,EAA0F,KAA1F;AACA,YAAIqC,cAAc,GAAYzD,OAAO,CAACI,oBAAtC;;AAEA,YAAIxB,KAAc,SAAlB;;AACA,YAAIlD,UAAU,IAAI,CAAC,KAAKZ,yBAAxB,EAAmD;AAClDgD,UAAAA,EAAE,GAAG,KAAKqI,WAAL,CAAiBvK,GAAjB,EAAsBoE,OAAtB,EAA+BoB,YAA/B,CAAL;AACA;AACA,SAHD,MAIK,IAAItD,EAAE,IAAI,IAAV,EAAgB;AACpB,cAAI,CAAClC,GAAG,CAACE,eAAT,EAA0B;AACzB8C,YAAAA,KAAI,GAAG,KAAKuH,WAAL,CAAiBvK,GAAjB,EAAsBoE,OAAtB,EAA+BoB,YAA/B,CAAP;;AACA,gBAAI1F,UAAJ,EAAgB;AACf,kBAAI,CAACE,GAAG,CAACoC,MAAT,EAAiB;AAChBpC,gBAAAA,GAAG,CAACoC,MAAJ,GAAaY,KAAb;AACA,eAFD,MAEO;AACNA,gBAAAA,KAAI,GAAGhD,GAAG,CAACoC,MAAX;AACA;AACD,aAND,MAMO;AACN,kBAAI,CAACpC,GAAG,CAACkC,EAAT,EAAa;AACZlC,gBAAAA,GAAG,CAACkC,EAAJ,GAASc,KAAT;AACA,eAFD,MAEO;AACNA,gBAAAA,KAAI,GAAGhD,GAAG,CAACkC,EAAX;AACA;AACD;AACD,WAfD,MAgBK;AACJ;;;;;;AAMAkC,YAAAA,OAAO,GAAG,KAAKoG,qBAAL,CAA2BpG,OAA3B,EAAoCuF,aAApC,EAAmDnE,YAAnD,CAAV;AACAxC,YAAAA,KAAI,GAAG,KAAKuH,WAAL,CAAiBvK,GAAjB,EAAsBoE,OAAtB,EAA+BoB,YAA/B,CAAP;AACAxF,YAAAA,GAAG,CAACyK,uBAAJ,CAA4B,KAAK/K,OAAL,CAAasC,UAAzC,EAAqDlC,UAArD,EAAiEkD,KAAjE;AACA;AACD,SA5BI,MA6BA;AACJ,cAAIhD,GAAG,CAACE,eAAR,EAAyB;AACxBkE,YAAAA,OAAO,GAAG,KAAKoG,qBAAL,CAA2BpG,OAA3B,EAAoCuF,aAApC,EAAmDnE,YAAnD,CAAV;AACA;;AAEDxC,UAAAA,KAAI,GAAG,KAAKuH,WAAL,CAAiBvK,GAAjB,EAAsBoE,OAAtB,EAA+BoB,YAA/B,CAAP;AACAtD,UAAAA,EAAE,CAACwI,gBAAH,CAAoBZ,eAApB,EAAqC9G,KAArC;AACA;;AAEDd,QAAAA,EAAE,GAAGc,KAAL;;AAEA,YAAI,CAAClD,UAAD,IAAe,CAAC+H,cAApB,EAAoC;AACnC;AACA,SAjEW,CAmEZ;;;AACA7E,QAAAA,KAAI,CAAC4G,mBAAL,CAAyB,KAAKjL,GAA9B,EApEY,CAsEZ;;;AACA0I,QAAAA,sBAAsB,GAAGA,sBAAzB;AAEAjD,QAAAA,OAAO,CAAC+E,KAAR;AACA9B,QAAAA,sBAAsB,GAAG,KAAKhF,aAAL,CAAmBgF,sBAAnB,CAAzB;AACA,YAAI+B,kBAAkB,GAAW,KAAK7G,cAAL,CAAoB8E,sBAApB,CAAjC;;AAEA,YAAIA,sBAAsB,CAAClH,OAA3B,EAAoC;AACnCkH,UAAAA,sBAAsB,GAAGtH,SAAzB;AACA,SAFD,MAEO;AACNsH,UAAAA,sBAAsB,GAAGA,sBAAsB,CAAC7E,MAAhD;AACA;;AAED,YAAI4G,kBAAkB,KAAKvL,mBAAA,CAAAyL,iBAAA,CAAkBC,oBAA7C,EAAmE;AAClEQ,UAAAA,cAAc,GAAGA,cAAc,CAACG,mBAAf,CAAmCd,kBAAnC,EAAuD5D,YAAvD,CAAjB;AACA;;AAEDsE,QAAAA,eAAe,GAAGV,kBAAlB;AACA;;AAED,aAAO,IAAIhL,gBAAA,CAAA6D,cAAJ,CAAmB0H,aAAnB,EAAkCzH,EAAlC,EAAsCpC,UAAtC,EAAkDuH,sBAAlD,CAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA/mC8B;AAAA;AAAA,0CAoqCWjD,OApqCX,EAoqCkCuF,aApqClC,EAoqCoEnE,YApqCpE,EAoqCwG;AACrI,UAAImF,cAAc,GAAmC,IAAIC,GAAJ,EAArD;AACA,UAAIC,SAAS,GAAiB,IAAIhO,cAAA,CAAAkK,YAAJ,EAA9B;AAFqI;AAAA;AAAA;;AAAA;AAGrI,8BAAmB3C,OAAnB,mIAA4B;AAAA,cAAnBqC,MAAmB;;AAC3B;AACA,cAAIA,MAAM,CAACnG,GAAP,KAAe,CAAnB,EAAsB;AACrB;AACA;;AAED,cAAIwK,cAAc,GAAgCrE,MAAM,CAACsE,eAAP,CAAuBC,cAAvB,CAAsC,KAAKtL,OAA3C,EAAoDiK,aAApD,CAAlD;;AACA,cAAImB,cAAc,IAAI,IAAtB,EAA4B;AAC3B;AACA;AACA;;AAEDH,UAAAA,cAAc,CAACzE,GAAf,CAAmBO,MAAM,CAAC1F,KAAP,CAAa+B,WAAhC,EAA6C2D,MAAM,CAAC0B,OAApD;;AACA,cAAI2C,cAAc,KAAKrE,MAAM,CAACsE,eAA9B,EAA+C;AAC9CF,YAAAA,SAAS,CAAC7D,GAAV,CAAcP,MAAM,CAACkC,SAAP,CAAiBlC,MAAM,CAAC1F,KAAxB,EAA+B,KAA/B,EAAsC+J,cAAtC,CAAd,EAAqEtF,YAArE;AACA,WAFD,MAGK;AACJqF,YAAAA,SAAS,CAAC7D,GAAV,CAAcP,MAAd,EAAsBjB,YAAtB;AACA;AACD;AAtBoI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAwBrI,8BAAmBpB,OAAnB,mIAA4B;AAAA,cAAnBqC,QAAmB;;AAC3B,cAAIA,QAAM,CAACnG,GAAP,KAAe,CAAnB,EAAsB;AACrB;AACA;AACA;;AAED,cAAI,CAACmG,QAAM,CAACwE,4BAAZ,EAA0C;AACzC;;;;AAIA,gBAAI9C,OAAO,GAAkCwC,cAAc,CAACnK,GAAf,CAAmBiG,QAAM,CAAC1F,KAAP,CAAa+B,WAAhC,CAA7C;;AACA,gBAAIqF,OAAO,IAAI,IAAX,IAAmBA,OAAO,CAAC+C,MAAR,CAAezE,QAAM,CAAC0B,OAAtB,CAAvB,EAAuD;AACtD;AACA;AACA;AACD;;AAED0C,UAAAA,SAAS,CAAC7D,GAAV,CAAcP,QAAd,EAAsBjB,YAAtB;AACA;AA3CoI;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA6CrI,aAAOqF,SAAP;AACA;AAltC6B;AAAA;AAAA,uCAotCQM,MAptCR,EAotCoC3C,KAptCpC,EAotCuD4C,KAptCvD,EAotCoE;AACjG,UAAI5C,KAAK,CAAC6C,OAAN,CAAcD,KAAd,EAAqB,CAArB,EAAwB,KAAKzM,GAAL,CAAS2M,YAAjC,CAAJ,EAAoD;AACnD,eAAO9C,KAAK,CAACrN,MAAb;AACA;;AAED,aAAO4E,SAAP;AACA;AAED;;AA5tC8B;AAAA;AAAA,sCA8tC7B8F,CA9tC6B,EA+tC7BzB,OA/tC6B,EAguC7BmH,KAhuC6B,EAguChB;AACb,UAAI7G,eAAe,GAAuB,KAAK8G,+BAAL,CAAqCpH,OAArC,CAA1C;;AACA,UAAI,CAACM,eAAL,EAAsB;AACrB,cAAM,IAAI+G,KAAJ,CAAU,mHAAV,CAAN;AACA;;AAED,UAAI/M,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,uBAAuB0E,CAAnC;AACA;;AACD,UAAIoB,SAAS,GAAkC,KAAKC,oBAAL,CAA0BxC,eAA1B,EAA2CN,OAA3C,EAAoDmH,KAApD,CAA/C,CATa,CAUb;;AACA,UAAIlF,eAAJ;;AACA,UAAIY,SAAS,IAAI,IAAjB,EAAuB;AACtB;AACA;AACAZ,QAAAA,eAAe,GAAG,KAAKc,uBAAL,CAA6BzC,eAA7B,EAA8CuC,SAA9C,CAAlB;AACApB,QAAAA,CAAC,CAACzC,UAAF,GAAeiD,eAAf;AACA;;AACD,aAAOA,eAAP;AACA;AAnvC6B;AAAA;AAAA,yCAsvCpBqF,SAtvCoB,EAuvCpBtH,OAvvCoB,EAwvC7BmH,KAxvC6B,EAwvChB;AACb;;AAEA;;;;;;;;;;;AAWA,UAAItE,SAAS,GAAmD,IAAI0E,KAAJ,CAA2BJ,KAAK,GAAG,CAAnC,CAAhE;AACA,UAAIlD,CAAC,GAAWpB,SAAS,CAACzL,MAA1B;AAfa;AAAA;AAAA;;AAAA;AAgBb,8BAAc4I,OAAd,mIAAuB;AAAA,cAAd9I,CAAc;;AACtB,cAAIoQ,SAAS,CAAClL,GAAV,CAAclF,CAAC,CAACgF,GAAhB,CAAJ,EAA0B;AACzB2G,YAAAA,SAAS,CAAC3L,CAAC,CAACgF,GAAH,CAAT,GAAmBpC,iBAAA,CAAA0N,eAAA,CAAgBC,EAAhB,CAAmB5E,SAAS,CAAC3L,CAAC,CAACgF,GAAH,CAA5B,EAAqChF,CAAC,CAACyP,eAAvC,CAAnB;AACA;AACD;AApBY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsBb,UAAIe,SAAS,GAAW,CAAxB;;AACA,WAAK,IAAI/P,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGsM,CAApB,EAAuBtM,CAAC,EAAxB,EAA4B;AAC3B,YAAIkL,SAAS,CAAClL,CAAD,CAAT,IAAgB,IAApB,EAA0B;AACzBkL,UAAAA,SAAS,CAAClL,CAAD,CAAT,GAAemC,iBAAA,CAAA0N,eAAA,CAAgBG,IAA/B;AACA,SAFD,MAGK,IAAI9E,SAAS,CAAClL,CAAD,CAAT,KAAiBmC,iBAAA,CAAA0N,eAAA,CAAgBG,IAArC,EAA2C;AAC/CD,UAAAA,SAAS;AACT;AACD,OA9BY,CAgCb;;;AACA,UAAIxE,MAAM,GAAkCL,SAA5C,CAjCa,CAmCb;;AACA,UAAI6E,SAAS,KAAK,CAAlB,EAAqB;AACpBxE,QAAAA,MAAM,GAAGvH,SAAT;AACA;;AACD,UAAIrB,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,kCAAkCmG,MAAM,GAAG5K,QAAA,CAAAsP,MAAA,CAAO3K,QAAP,CAAgBiG,MAAhB,CAAH,GAA6B,WAArE,CAAZ;AACA;;AACD,aAAOA,MAAP;AACA;AAnyC6B;AAAA;AAAA,4CAqyCIoE,SAryCJ,EAqyCmCzE,SAryCnC,EAqyC+D;AAC5F,UAAIgF,KAAK,GAA8B,EAAvC;AACA,UAAIC,iBAAiB,GAAY,KAAjC;;AACA,WAAK,IAAInQ,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGkL,SAAS,CAACzL,MAA9B,EAAsCO,CAAC,EAAvC,EAA2C;AAC1C,YAAIoQ,IAAI,GAAoBlF,SAAS,CAAClL,CAAD,CAArC,CAD0C,CAG1C;;AACAwC,QAAAA,MAAM,CAAC4N,IAAI,IAAI,IAAT,CAAN,CAJ0C,CAM1C;AACA;AACA;AACA;AACA;;AACA,YAAIT,SAAS,IAAI,IAAb,IAAqBA,SAAS,CAAClL,GAAV,CAAczE,CAAd,CAArB,IAAyCoQ,IAAI,KAAKjO,iBAAA,CAAA0N,eAAA,CAAgBG,IAAtE,EAA4E;AAC3EE,UAAAA,KAAK,CAAC7D,IAAN,CAAW,IAAIhL,UAAA,CAAAgP,QAAA,CAASC,cAAb,CAA4BF,IAA5B,EAAkCpQ,CAAlC,CAAX;AACA,SAFD,MAGK,IAAIoQ,IAAI,KAAKjO,iBAAA,CAAA0N,eAAA,CAAgBG,IAA7B,EAAmC;AACvCG,UAAAA,iBAAiB,GAAG,IAApB;AACAD,UAAAA,KAAK,CAAC7D,IAAN,CAAW,IAAIhL,UAAA,CAAAgP,QAAA,CAASC,cAAb,CAA4BF,IAA5B,EAAkCpQ,CAAlC,CAAX;AACA;AACD;;AAED,UAAI,CAACmQ,iBAAL,EAAwB;AACvB,eAAOnM,SAAP;AACA,OAzB2F,CA2B9F;;;AACE,aAAOkM,KAAP;AACA;AAED;;;;;AAp0C8B;AAAA;AAAA,wCAy0CpB5F,eAz0CoB,EA00C7BxG,YA10C6B,EA20C7ByM,QA30C6B,EA20CZ;AACjB,UAAIC,WAAW,GAAW,IAAItP,QAAA,CAAAsJ,MAAJ,EAA1B;AADiB;AAAA;AAAA;;AAAA;AAEjB,8BAAiBF,eAAjB,mIAAkC;AAAA,cAAzBmG,IAAyB;;AACjC,cAAIA,IAAI,CAACL,IAAL,KAAcjO,iBAAA,CAAA0N,eAAA,CAAgBG,IAAlC,EAAwC;AACvCQ,YAAAA,WAAW,CAACrG,GAAZ,CAAgBsG,IAAI,CAAClM,GAArB;;AACA,gBAAI,CAACgM,QAAL,EAAe;AACd;AACA;;AAED;AACA;;AAED,cAAIG,eAAe,GAAY,KAAKC,uBAAL,CAA6BF,IAAI,CAACL,IAAlC,EAAwCtM,YAAxC,EAAsD2M,IAAI,CAAClM,GAA3D,CAA/B;;AACA,cAAI5B,kBAAkB,CAACuC,KAAnB,IAA4BvC,kBAAkB,CAACgE,SAAnD,EAA8D;AAC7DxB,YAAAA,OAAO,CAACC,GAAR,CAAY,eAAeqL,IAAf,GAAsB,GAAtB,GAA4BC,eAAxC;AACA;;AAED,cAAIA,eAAJ,EAAqB;AACpB,gBAAI/N,kBAAkB,CAACuC,KAAnB,IAA4BvC,kBAAkB,CAACgE,SAAnD,EAA8D;AAC7DxB,cAAAA,OAAO,CAACC,GAAR,CAAY,aAAaqL,IAAI,CAAClM,GAA9B;AACA;;AACDiM,YAAAA,WAAW,CAACrG,GAAZ,CAAgBsG,IAAI,CAAClM,GAArB;;AACA,gBAAI,CAACgM,QAAL,EAAe;AACd;AACA;AACD;AACD;AA1BgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA4BjB,aAAOC,WAAP;AACA;AAED;;;;;;;;;;;;;;;;;;;;;;;;;AA12C8B;AAAA;AAAA,4CAk4CaJ,IAl4Cb,EAk4CoCQ,eAl4CpC,EAk4CwErM,GAl4CxE,EAk4CmF;AAChH,aAAO6L,IAAI,CAACS,IAAL,CAAU,KAAKlN,OAAf,EAAwBiN,eAAxB,CAAP;AACA;AAED;;;;;;;AAt4C8B;AAAA;AAAA,4BA84C7BE,aA94C6B,EA+4CpBzI,OA/4CoB,EAg5C7B0E,iBAh5C6B,EAi5C7BhB,cAj5C6B,EAk5CnBtC,YAl5CmB,EAm5C7BuD,iBAn5C6B,EAm5CH;AAC1B,UAAIvD,YAAY,IAAI,IAApB,EAA0B;AACzBA,QAAAA,YAAY,GAAG1H,wBAAA,CAAA2H,sBAAA,CAAuBqH,QAAtC;AACA;;AAED,UAAIC,cAAc,GAAiBF,aAAnC;AACA,UAAIG,WAAW,GAA8B,IAAIvQ,gBAAA,CAAAwQ,cAAJ,CAA8BtP,0BAAA,CAAAuP,wBAAA,CAAyBC,QAAvD,CAA7C;;AACA,aAAOJ,cAAc,CAACK,IAAf,GAAsB,CAA7B,EAAgC;AAC/B,YAAIC,YAAY,GAAiB,IAAIxQ,cAAA,CAAAkK,YAAJ,EAAjC;AAD+B;AAAA;AAAA;;AAAA;AAE/B,iCAAmBgG,cAAnB,wIAAmC;AAAA,gBAA1BtG,MAA0B;AAClC,iBAAK6G,WAAL,CAAiB7G,MAAjB,EAAyBrC,OAAzB,EAAkCiJ,YAAlC,EAAgDL,WAAhD,EAA6DlE,iBAA7D,EAAgFhB,cAAhF,EAAgGtC,YAAhG,EAA8G,CAA9G,EAAiHuD,iBAAjH;AACA;AAJ8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAM/BgE,QAAAA,cAAc,GAAGM,YAAjB;AACA;AACD;AAl6C6B;AAAA;AAAA,gCAq6CpB5G,MAr6CoB,EAs6CpBrC,OAt6CoB,EAu6CnBiJ,YAv6CmB,EAw6CpBL,WAx6CoB,EAy6C7BlE,iBAz6C6B,EA06C7ByE,eA16C6B,EA26CpB/H,YA36CoB,EA46C7BgI,KA56C6B,EA66C7BzE,iBA76C6B,EA66CH;AAC1B,UAAIrK,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,aAAasF,MAAM,CAACpF,QAAP,CAAgB,KAAK3B,OAArB,EAA8B,IAA9B,CAAb,GAAmD,GAA/D;AACA;;AAED,UAAI+G,MAAM,CAAC1F,KAAP,YAAwB/C,eAAA,CAAA2I,aAA5B,EAA2C;AAC1C;AACA,YAAI,CAACF,MAAM,CAAC0B,OAAP,CAAehI,OAApB,EAA6B;AAC5B,cAAIsN,QAAQ,GAAYhH,MAAM,CAAC0B,OAAP,CAAesF,QAAvC;AACA,cAAIC,YAAY,GAAWjH,MAAM,CAAC0B,OAAP,CAAeiF,IAAf,IAAuBK,QAAQ,GAAG,CAAH,GAAO,CAAtC,CAA3B;;AACA,eAAK,IAAI1R,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG2R,YAApB,EAAkC3R,CAAC,EAAnC,EAAuC;AACtC,gBAAI4R,UAAU,GAAsBlH,MAAM,CAAC0B,OAAP,CAAeyF,SAAf,CAAyB7R,CAAzB,CAApC,CADsC,CAC2B;;AACjE,gBAAI8R,WAAW,GAAa,KAAKlP,GAAL,CAASmP,MAAT,CAAgBrH,MAAM,CAAC0B,OAAP,CAAe5F,cAAf,CAA8BxG,CAA9B,CAAhB,CAA5B;AACA,gBAAIT,CAAC,GAAcsB,WAAA,CAAAyN,SAAA,CAAUC,MAAV,CAAiBuD,WAAjB,EAA8BpH,MAAM,CAACnG,GAArC,EAA0CqN,UAA1C,EAAsDlH,MAAM,CAACsE,eAA7D,CAAnB,CAHsC,CAItC;AACA;AACA;;AACAzP,YAAAA,CAAC,CAACyS,iBAAF,GAAsBtH,MAAM,CAACsH,iBAA7B;AACAzS,YAAAA,CAAC,CAAC2P,4BAAF,GAAiCxE,MAAM,CAACwE,4BAAxC;AACA1M,YAAAA,MAAM,CAACiP,KAAK,GAAG/O,iBAAT,CAAN;AACA,iBAAK6O,WAAL,CAAiBhS,CAAjB,EAAoB8I,OAApB,EAA6BiJ,YAA7B,EAA2CL,WAA3C,EAAwDlE,iBAAxD,EAA2EyE,eAA3E,EAA4F/H,YAA5F,EAA0GgI,KAAK,GAAG,CAAlH,EAAqHzE,iBAArH;AACA;;AAED,cAAI,CAAC0E,QAAD,IAAa,CAACF,eAAlB,EAAmC;AAClC;AACA;;AAED9G,UAAAA,MAAM,GAAGA,MAAM,CAACkC,SAAP,CAAiBlC,MAAM,CAAC1F,KAAxB,EAA+B,KAA/B,EAAsClD,mBAAA,CAAAyL,iBAAA,CAAkBW,WAAxD,CAAT;AACA,SArBD,MAsBK,IAAI,CAACsD,eAAL,EAAsB;AAC1BnJ,UAAAA,OAAO,CAAC4C,GAAR,CAAYP,MAAZ,EAAoBjB,YAApB;AACA;AACA,SAHI,MAIA;AACJ;AACA,cAAI9G,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,YAAAA,OAAO,CAACC,GAAR,CAAY,sBACX,KAAK6M,WAAL,CAAiBvH,MAAM,CAAC1F,KAAP,CAAakN,SAA9B,CADD;AAEA;;AAED,cAAIxH,MAAM,CAAC0B,OAAP,KAAmBtK,mBAAA,CAAAyL,iBAAA,CAAkBU,UAAzC,EAAqD;AACpD;AACAvD,YAAAA,MAAM,GAAGA,MAAM,CAACkC,SAAP,CAAiBlC,MAAM,CAAC1F,KAAxB,EAA+B,KAA/B,EAAsClD,mBAAA,CAAAyL,iBAAA,CAAkBW,WAAxD,CAAT;AACA,WAHD,MAIK,IAAI,CAACxD,MAAM,CAACC,uBAAR,IAAmC7I,mBAAA,CAAAyL,iBAAA,CAAkB4E,YAAlB,CAA+BzH,MAAM,CAAC0B,OAAtC,CAAvC,EAAuF;AAC3F;AACA/D,YAAAA,OAAO,CAAC4C,GAAR,CAAYP,MAAZ,EAAoBjB,YAApB;AACA;AACD;AACD;;AAED,UAAIqE,CAAC,GAAapD,MAAM,CAAC1F,KAAzB,CAnD0B,CAoD1B;;AACA,UAAI,CAAC8I,CAAC,CAACsE,yBAAP,EAAkC;AACjC/J,QAAAA,OAAO,CAAC4C,GAAR,CAAYP,MAAZ,EAAoBjB,YAApB,EADiC,CAEjC;AACA;;AACA,YAAI9G,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,UAAAA,OAAO,CAACC,GAAR,CAAY,kBAAkBiD,OAA9B;AACA;AACD;;AAED,WAAK,IAAIrI,EAAC,GAAG,CAAb,EAAgBA,EAAC,GAAG8N,CAAC,CAACvB,4BAAtB,EAAoDvM,EAAC,EAArD,EAAyD;AACxD;AACA;AACA;AACA,YAAIA,EAAC,KAAK,CAAN,IACA8N,CAAC,CAACuE,SAAF,KAAgBrR,cAAA,CAAAsR,YAAA,CAAaC,eAD7B,IAECzE,CAAwB,CAAC0E,sBAF1B,IAGA,CAAC9H,MAAM,CAAC0B,OAAP,CAAesF,QAHpB,EAG8B;AAE7B,cAAIe,kBAAkB,GAAG3E,CAAzB,CAF6B,CAI7B;AACA;AACA;AACA;;AACA,cAAI4E,QAAQ,GAAY,IAAxB;;AACA,eAAK,IAAIC,CAAC,GAAW,CAArB,EAAwBA,CAAC,GAAGjI,MAAM,CAAC0B,OAAP,CAAeiF,IAA3C,EAAiDsB,CAAC,EAAlD,EAAsD;AACrD,gBAAI,CAACF,kBAAkB,CAACG,wBAAnB,CAA4CnO,GAA5C,CAAgDiG,MAAM,CAAC0B,OAAP,CAAe5F,cAAf,CAA8BmM,CAA9B,CAAhD,CAAL,EAAwF;AACvFD,cAAAA,QAAQ,GAAG,KAAX;AACA;AACA;AACD;;AAED,cAAIA,QAAJ,EAAc;AACb;AACA;AACD;;AAED,YAAI7L,CAAC,GAAeiH,CAAC,CAACpB,sBAAF,CAAyB1M,EAAzB,CAApB;AACA,YAAI6S,kBAAkB,GACrB,EAAEhM,CAAC,YAAYpG,kBAAA,CAAAqS,gBAAf,KAAoC/F,iBADrC;;AAEA,YAAIxN,GAAC,GAA0B,KAAKwT,gBAAL,CAAsBrI,MAAtB,EAA8B7D,CAA9B,EAAiCgM,kBAAjC,EAAqDpB,KAAK,KAAK,CAA/D,EAAkEhI,YAAlE,EAAgFuD,iBAAhF,CAA/B;;AACA,YAAIzN,GAAC,IAAI,IAAT,EAAe;AACd,cAAIsH,CAAC,YAAY3E,gBAAA,CAAA8Q,cAAjB,EAAiC;AAChC,gBAAI1B,YAAY,IAAI,IAAhB,IAAwB,CAACvE,iBAA7B,EAAgD;AAC/CuE,cAAAA,YAAY,CAACrG,GAAb,CAAiB1L,GAAjB,EAAoBkK,YAApB;AACA;AACA;AACD;;AAED,cAAIwJ,QAAQ,GAAWxB,KAAvB;;AACA,cAAI/G,MAAM,CAAC1F,KAAP,YAAwB/C,eAAA,CAAA2I,aAA5B,EAA2C;AAC1C;AACA;AACA;AACA;AACA;AAEA,gBAAI,KAAK3G,GAAL,IAAY,IAAZ,IAAoB,KAAKA,GAAL,CAASE,eAAjC,EAAkD;AACjD,kBAAI+O,yBAAyB,GAAYrM,CAAuB,CAACqM,yBAAjE;;AACA,kBAAIA,yBAAyB,KAAK,KAAKjP,GAAL,CAASsE,aAAT,CAAuB2J,SAAzD,EAAoE;AACnE3S,gBAAAA,GAAC,CAAC2P,4BAAF,GAAiC,IAAjC;AACA;AACD;;AAED3P,YAAAA,GAAC,CAACyS,iBAAF,GAAsBzS,GAAC,CAACyS,iBAAF,GAAsB,CAA5C;;AAEA,gBAAI,CAACf,WAAW,CAAChG,GAAZ,CAAgB1L,GAAhB,CAAL,EAAyB;AACxB;AACA;AACA;;AAEDiD,YAAAA,MAAM,CAACyQ,QAAQ,GAAGvQ,iBAAZ,CAAN;AACAuQ,YAAAA,QAAQ;;AACR,gBAAItQ,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,cAAAA,OAAO,CAACC,GAAR,CAAY,0BAA0B7F,GAAtC;AACA;AACD,WA1BD,MA2BK,IAAIsH,CAAC,YAAY3E,gBAAA,CAAA8Q,cAAjB,EAAiC;AACrC,gBAAI,KAAK1P,mBAAL,IAA4BuD,CAAC,CAACsM,iBAA9B,KAAoD,CAAC,KAAK5P,uBAAN,IAAiC,CAACzB,mBAAA,CAAAyL,iBAAA,CAAkB4E,YAAlB,CAA+BzH,MAAM,CAAC0B,OAAtC,CAAtF,CAAJ,EAA2I;AAC1I5J,cAAAA,MAAM,CAACjD,GAAC,CAAC6M,OAAF,KAAc1B,MAAM,CAAC0B,OAAtB,CAAN;;AACA,kBAAI6G,QAAQ,KAAK,CAAjB,EAAoB;AACnB;AACA;AACAA,gBAAAA,QAAQ;;AACR,oBAAI,CAAC,KAAK1P,uBAAN,IAAiCzB,mBAAA,CAAAyL,iBAAA,CAAkB4E,YAAlB,CAA+BzH,MAAM,CAAC0B,OAAtC,CAArC,EAAqF;AACpF;AACA7M,kBAAAA,GAAC,CAACyS,iBAAF,GAAsBzS,GAAC,CAACyS,iBAAF,GAAsB,CAA5C;AACA;AACD;AACD,aAXD,MAYK;AACJ;AACA,kBAAIiB,QAAQ,IAAI,CAAhB,EAAmB;AAClBA,gBAAAA,QAAQ;AACR;AACD;AACD,WAnBI,MAoBA;AACJ,gBAAI,CAACpM,CAAC,CAACuM,SAAH,IAAgB,CAACnC,WAAW,CAAChG,GAAZ,CAAgB1L,GAAhB,CAArB,EAAyC;AACxC;AACA;AACA;AACD;;AAED,eAAKgS,WAAL,CAAiBhS,GAAjB,EAAoB8I,OAApB,EAA6BiJ,YAA7B,EAA2CL,WAA3C,EAAwD4B,kBAAxD,EAA4ErB,eAA5E,EAA6F/H,YAA7F,EAA2GwJ,QAA3G,EAAqHjG,iBAArH;AACA;AACD;AACD;AA7kD6B;AAAA;AAAA,gCAglDXtH,KAhlDW,EAglDE;AAC/B,UAAI,KAAK/B,OAAL,IAAgB,IAAhB,IAAwB+B,KAAK,IAAI,CAArC,EAAwC;AACvC,eAAO,KAAK/B,OAAL,CAAakC,SAAb,CAAuBH,KAAvB,CAAP;AACA;;AACD,aAAO,WAAWA,KAAX,GAAmB,GAA1B;AACA;AArlD6B;AAAA;AAAA,qCAulDMgF,MAvlDN,EAulDkC7D,CAvlDlC,EAulDiDkG,iBAvlDjD,EAulD6EsG,SAvlD7E,EAulDiG5J,YAvlDjG,EAulDuIuD,iBAvlDvI,EAulDiK;AAC9L,cAAQnG,CAAC,CAACyM,iBAAV;AACA,aAAA;AAAA;AAAA;AACC,iBAAO,KAAKC,cAAL,CAAoB7I,MAApB,EAA4B7D,CAA5B,EAAiD4C,YAAjD,CAAP;;AAED,aAAA;AAAA;AAAA;AACC,iBAAO,KAAK+J,oBAAL,CAA0B9I,MAA1B,EAAkC7D,CAAlC,EAAsEkG,iBAAtE,EAAyFsG,SAAzF,CAAP;;AAED,aAAA;AAAA;AAAA;AACC,iBAAO,KAAKI,cAAL,CAAoB/I,MAApB,EAA4B7D,CAA5B,EAAsDkG,iBAAtD,EAAyEsG,SAAzE,CAAP;;AAED,aAAA;AAAA;AAAA;AACC,iBAAO,KAAKK,gBAAL,CAAsBhJ,MAAtB,EAA8B7D,CAA9B,CAAP;;AAED,aAAA;AAAA;AAAA;AACC,iBAAO6D,MAAM,CAACkC,SAAP,CAAiB/F,CAAC,CAACzH,MAAnB,EAA2B,KAA3B,CAAP;;AAED,aAAA;AAAA;AAAA;AACA,aAAA;AAAA;AAAA;AACA,aAAA;AAAA;AAAA;AACC;AACA;AACA,cAAI4N,iBAAJ,EAAuB;AACtB,gBAAInG,CAAC,CAACyI,OAAF,CAAUhN,OAAA,CAAAuK,KAAA,CAAM1E,GAAhB,EAAqB,CAArB,EAAwB,CAAxB,CAAJ,EAAgC;AAC/B,qBAAOuC,MAAM,CAACkC,SAAP,CAAiB/F,CAAC,CAACzH,MAAnB,EAA2B,KAA3B,CAAP;AACA;AACD;;AAED,iBAAO4E,SAAP;;AAED;AACC,iBAAOA,SAAP;AA9BD;AAgCA;AAxnD6B;AAAA;AAAA,qCA2nDM0G,MA3nDN,EA2nDkC7D,CA3nDlC,EA2nDqD;AAClF,UAAIlE,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,iBAAiByB,CAAC,CAACqL,SAAnB,GAA+B,GAA/B,GAAqCrL,CAAC,CAAC8M,WAAnD;AACA;;AACD,aAAOjJ,MAAM,CAACkC,SAAP,CAAiB/F,CAAC,CAACzH,MAAnB,EAA2B,KAA3B,CAAP;AACA;AAhoD6B;AAAA;AAAA,yCAooDpBsL,MApoDoB,EAqoDpBkJ,EAroDoB,EAsoD7B7G,iBAtoD6B,EAuoD7BsG,SAvoD6B,EAuoDX;AAClB,UAAI1Q,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,6BAA6B2H,iBAA7B,GAAiD,IAAjD,GACX6G,EAAE,CAAC3N,UADQ,GACK,MADL,GAEX,sBAFD;;AAGA,YAAI,KAAKtC,OAAL,IAAgB,IAApB,EAA0B;AACzBwB,UAAAA,OAAO,CAACC,GAAR,CAAY,iCACX,KAAKzB,OAAL,CAAakQ,sBAAb,EADD;AAEA;AACD;;AAED,UAAItU,CAAJ;;AACA,UAAIwN,iBAAiB,IAAIsG,SAAzB,EAAoC;AACnC,YAAIS,SAAS,GAAoB3R,iBAAA,CAAA0N,eAAA,CAAgBkE,GAAhB,CAAoBrJ,MAAM,CAACsE,eAA3B,EAA4C4E,EAAE,CAACI,SAA/C,CAAjC;AACAzU,QAAAA,CAAC,GAAGmL,MAAM,CAACkC,SAAP,CAAiBgH,EAAE,CAACxU,MAApB,EAA4B,KAA5B,EAAmC0U,SAAnC,CAAJ;AACA,OAHD,MAIK;AACJvU,QAAAA,CAAC,GAAGmL,MAAM,CAACkC,SAAP,CAAiBgH,EAAE,CAACxU,MAApB,EAA4B,KAA5B,CAAJ;AACA;;AAED,UAAIuD,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,iCAAiC7F,CAA7C;AACA;;AACD,aAAOA,CAAP;AACA;AA/pD6B;AAAA;AAAA,mCAmqDpBmL,MAnqDoB,EAoqDpBkJ,EApqDoB,EAqqD7B7G,iBArqD6B,EAsqD7BsG,SAtqD6B,EAsqDX;AAClB,UAAI1Q,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,6BAA6B2H,iBAA7B,GAAiD,IAAjD,GACX6G,EAAE,CAAC1B,SADQ,GACI,GADJ,GACU0B,EAAE,CAACK,SADb,GAEX,kBAFW,GAEUL,EAAE,CAACM,cAFzB;;AAGA,YAAI,KAAKvQ,OAAL,IAAgB,IAApB,EAA0B;AACzBwB,UAAAA,OAAO,CAACC,GAAR,CAAY,iCACX,KAAKzB,OAAL,CAAakQ,sBAAb,EADD;AAEA;AACD;;AAED,UAAItU,CAAJ;;AACA,UAAIwN,iBAAiB,KACnB,CAAC6G,EAAE,CAACM,cAAJ,IAAuBN,EAAE,CAACM,cAAH,IAAqBb,SADzB,CAArB,EAC2D;AAC1D,YAAIS,SAAS,GAAoB3R,iBAAA,CAAA0N,eAAA,CAAgBkE,GAAhB,CAAoBrJ,MAAM,CAACsE,eAA3B,EAA4C4E,EAAE,CAACI,SAA/C,CAAjC;AACAzU,QAAAA,CAAC,GAAGmL,MAAM,CAACkC,SAAP,CAAiBgH,EAAE,CAACxU,MAApB,EAA4B,KAA5B,EAAmC0U,SAAnC,CAAJ;AACA,OAJD,MAKK;AACJvU,QAAAA,CAAC,GAAGmL,MAAM,CAACkC,SAAP,CAAiBgH,EAAE,CAACxU,MAApB,EAA4B,KAA5B,CAAJ;AACA;;AAED,UAAIuD,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,iCAAiC7F,CAA7C;AACA;;AACD,aAAOA,CAAP;AACA;AA/rD6B;AAAA;AAAA,mCAksDImL,MAlsDJ,EAksDgC7D,CAlsDhC,EAksD6D4C,YAlsD7D,EAksDiG;AAC9H,UAAI9G,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,eAAe,KAAK6M,WAAL,CAAiBpL,CAAC,CAACzH,MAAF,CAAS8S,SAA1B,CAAf,GACX,QADW,GACAxH,MAAM,CAAC0B,OADnB;AAEA;;AAED,UAAI0F,WAAW,GAAajL,CAAC,CAACsN,WAA9B;AACA,UAAIvC,UAAJ;;AAEA,UAAI,KAAKtO,mBAAL,IAA4BuD,CAAC,CAACsM,iBAA9B,KAAoD,CAAC,KAAK5P,uBAAN,IAAiC,CAACzB,mBAAA,CAAAyL,iBAAA,CAAkB4E,YAAlB,CAA+BzH,MAAM,CAAC0B,OAAtC,CAAtF,CAAJ,EAA2I;AAC1IwF,QAAAA,UAAU,GAAGlH,MAAM,CAAC0B,OAApB;AACA,OAFD,MAGK,IAAI3C,YAAY,IAAI,IAApB,EAA0B;AAC9BmI,QAAAA,UAAU,GAAGnI,YAAY,CAAC2K,QAAb,CAAsB1J,MAAM,CAAC0B,OAA7B,EAAsC0F,WAAW,CAAC/K,WAAlD,CAAb;AACA,OAFI,MAGA;AACJ6K,QAAAA,UAAU,GAAGlH,MAAM,CAAC0B,OAAP,CAAegI,QAAf,CAAwBtC,WAAW,CAAC/K,WAApC,CAAb;AACA;;AAED,aAAO2D,MAAM,CAACkC,SAAP,CAAiB/F,CAAC,CAACzH,MAAnB,EAA2B,KAA3B,EAAkCwS,UAAlC,CAAP;AACA;AAttD6B;AAAA;AAAA,iCAuuDAyC,SAvuDA,EAuuDyB5K,YAvuDzB,EAuuD6D;AAC1F,UAAI4K,SAAS,CAACvH,SAAV,KAAwBlM,KAAA,CAAAmJ,GAAA,CAAIC,kBAA5B,IAAkDqK,SAAS,CAAChD,IAAV,IAAkB,CAAxE,EAA2E;AAC1E,eAAOrN,SAAP;AACA;;AAED,UAAIqE,OAAO,GAAgBgM,SAAS,CAAC1I,OAAV,EAA3B;AACAtD,MAAAA,OAAO,CAACiM,IAAR,CAAa3R,kBAAkB,CAAC4R,yBAAhC;AAEA,UAAIC,KAAK,GAAY,CAACH,SAAS,CAAC5L,oBAAhC;AACA,UAAIW,IAAI,GAAW,IAAIlI,QAAA,CAAAsJ,MAAJ,EAAnB;AACA,UAAIiK,MAAM,GAAWpM,OAAO,CAAC,CAAD,CAAP,CAAW9D,GAAhC;AACA6E,MAAAA,IAAI,CAACe,GAAL,CAASsK,MAAT;AAEA;;;;;;;;AASA;AACA;AACA;;AACA,UAAIC,YAAY,GAAWrM,OAAO,CAAC,CAAD,CAAP,CAAWrD,KAAX,CAAiB2P,kBAA5C;AAzB0F;AAAA;AAAA;;AAAA;AA0B1F,+BAAmBtM,OAAnB,wIAA4B;AAAA,cAAnBqC,QAAmB;AAC3B,cAAI3D,YAAW,GAAW2D,QAAM,CAAC1F,KAAP,CAAa2P,kBAAvC;;AACA,cAAI5N,YAAW,KAAK2N,YAApB,EAAkC;AACjC,gBAAIhK,QAAM,CAACnG,GAAP,KAAekQ,MAAnB,EAA2B;AAC1B,qBAAOzQ,SAAP;AACA;;AAED0Q,YAAAA,YAAY,GAAG3N,YAAf;AACA;AACD;AAnCyF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAqC1F,UAAI6N,eAAJ;;AACA,UAAIJ,KAAJ,EAAW;AACVE,QAAAA,YAAY,GAAGrM,OAAO,CAAC,CAAD,CAAP,CAAWrD,KAAX,CAAiB2P,kBAAhC,CADU,CAGV;;AACAC,QAAAA,eAAe,GAAG,IAAI1T,QAAA,CAAAsJ,MAAJ,EAAlB;AACA,YAAIC,MAAM,GAAWgK,MAArB;AALU;AAAA;AAAA;;AAAA;AAMV,iCAAmBpM,OAAnB,wIAA4B;AAAA,gBAAnBqC,MAAmB;;AAC3B,gBAAIA,MAAM,CAAC1F,KAAP,CAAa2P,kBAAb,KAAoCD,YAAxC,EAAsD;AACrD;AACA;;AAED,gBAAInQ,GAAG,GAAWmG,MAAM,CAACnG,GAAzB;AACAqQ,YAAAA,eAAe,CAACzK,GAAhB,CAAoB5F,GAApB;AACAkG,YAAAA,MAAM,GAAGlG,GAAT;AACA,WAdS,CAgBV;;AAhBU;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAiBVmQ,QAAAA,YAAY,GAAGrM,OAAO,CAAC,CAAD,CAAP,CAAWrD,KAAX,CAAiB2P,kBAAhC;AACA,YAAIE,UAAU,GAAWJ,MAAzB;AAlBU;AAAA;AAAA;;AAAA;AAmBV,iCAAmBpM,OAAnB,wIAA4B;AAAA,gBAAnBqC,QAAmB;AAC3B,gBAAI3D,WAAW,GAAW2D,QAAM,CAAC1F,KAAP,CAAa2P,kBAAvC;AACA,gBAAIpQ,KAAG,GAAWmG,QAAM,CAACnG,GAAzB;;AACA,gBAAIwC,WAAW,KAAK2N,YAApB,EAAkC;AACjC,kBAAIG,UAAU,KAAKpK,MAAnB,EAA2B;AAC1B+J,gBAAAA,KAAK,GAAG,KAAR;AACA;AACA;;AAEDE,cAAAA,YAAY,GAAG3N,WAAf;AACA8N,cAAAA,UAAU,GAAGJ,MAAb;AACA,aARD,MASK,IAAIlQ,KAAG,KAAKsQ,UAAZ,EAAwB;AAC5B,kBAAItQ,KAAG,KAAKqQ,eAAe,CAAC7L,UAAhB,CAA2B8L,UAAU,GAAG,CAAxC,CAAZ,EAAwD;AACvDL,gBAAAA,KAAK,GAAG,KAAR;AACA;AACA;;AAEDK,cAAAA,UAAU,GAAGtQ,KAAb;AACA;AACD;AAvCS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAwCV;;AAEDmQ,MAAAA,YAAY,GAAGrM,OAAO,CAAC,CAAD,CAAP,CAAWrD,KAAX,CAAiB2P,kBAAhC;AACA,UAAIG,sBAAsB,GAAW,CAArC;AACA,UAAIC,2BAA2B,GAAW,CAA1C;AACA,UAAIC,kBAAkB,GAAsB3M,OAAO,CAAC,CAAD,CAAP,CAAW+D,OAAvD;;AACA,WAAK,IAAIpM,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGqI,OAAO,CAAC5I,MAA5B,EAAoCO,CAAC,EAArC,EAAyC;AACxC,YAAI0K,QAAM,GAAcrC,OAAO,CAACrI,CAAD,CAA/B;;AACA,YAAI0K,QAAM,CAACnG,GAAP,KAAekQ,MAAnB,EAA2B;AAC1B;AACA;;AAED,YAAI/J,QAAM,CAAC1F,KAAP,CAAa2P,kBAAb,KAAoCD,YAAxC,EAAsD;AACrD;AACA;;AAEDK,QAAAA,2BAA2B,GAAG/U,CAA9B;AACAgV,QAAAA,kBAAkB,GAAGvL,YAAY,CAACwL,IAAb,CAAkBD,kBAAlB,EAAsC3M,OAAO,CAACrI,CAAD,CAAP,CAAWoM,OAAjD,CAArB;AACA;;AAED,WAAK,IAAIpM,GAAC,GAAG+U,2BAA2B,GAAG,CAA3C,EAA8C/U,GAAC,GAAGqI,OAAO,CAAC5I,MAA1D,EAAkEO,GAAC,EAAnE,EAAuE;AACtE,YAAI0K,QAAM,GAAcrC,OAAO,CAACrI,GAAD,CAA/B;AACA,YAAIgF,KAAK,GAAa0F,QAAM,CAAC1F,KAA7B;AACAoE,QAAAA,IAAI,CAACe,GAAL,CAASO,QAAM,CAACnG,GAAhB;;AACA,YAAIS,KAAK,CAAC2P,kBAAN,KAA6BD,YAAjC,EAA+C;AAC9CA,UAAAA,YAAY,GAAG1P,KAAK,CAAC2P,kBAArB;AACAG,UAAAA,sBAAsB,GAAG9U,GAAzB;AACA+U,UAAAA,2BAA2B,GAAG/U,GAA9B;AACAgV,UAAAA,kBAAkB,GAAGtK,QAAM,CAAC0B,OAA5B;;AACA,eAAK,IAAIuG,CAAC,GAAGmC,sBAAsB,GAAG,CAAtC,EAAyCnC,CAAC,GAAGtK,OAAO,CAAC5I,MAArD,EAA6DkT,CAAC,EAA9D,EAAkE;AACjE,gBAAIuC,OAAO,GAAc7M,OAAO,CAACsK,CAAD,CAAhC;;AACA,gBAAIuC,OAAO,CAAC3Q,GAAR,KAAgBkQ,MAApB,EAA4B;AAC3B;AACA;;AAED,gBAAIS,OAAO,CAAClQ,KAAR,CAAc2P,kBAAd,KAAqCD,YAAzC,EAAuD;AACtD;AACA;;AAEDK,YAAAA,2BAA2B,GAAGpC,CAA9B;AACAqC,YAAAA,kBAAkB,GAAGvL,YAAY,CAACwL,IAAb,CAAkBD,kBAAlB,EAAsCE,OAAO,CAAC9I,OAA9C,CAArB;AACA;;AAEDpM,UAAAA,GAAC,GAAG+U,2BAAJ;AACA;AACA;;AAED,YAAII,mBAAmB,GAAsBzK,QAAM,CAAC0B,OAApD;AACA,YAAIyI,WAAU,GAAWnK,QAAM,CAACnG,GAAhC;AACA,YAAI6Q,+BAA+B,GAAWpV,GAA9C;;AACA,aAAK,IAAI2S,EAAC,GAAGyC,+BAA+B,GAAG,CAA/C,EAAkDzC,EAAC,GAAGtK,OAAO,CAAC5I,MAA9D,EAAsEkT,EAAC,EAAvE,EAA2E;AAC1E,cAAIuC,QAAO,GAAc7M,OAAO,CAACsK,EAAD,CAAhC;;AACA,cAAIuC,QAAO,CAAC3Q,GAAR,KAAgBsQ,WAApB,EAAgC;AAC/B;AACA;;AAED,cAAIK,QAAO,CAAClQ,KAAR,CAAc2P,kBAAd,KAAqCD,YAAzC,EAAuD;AACtD;AACA;;AAEDU,UAAAA,+BAA+B,GAAGzC,EAAlC;AACAwC,UAAAA,mBAAmB,GAAG1L,YAAY,CAACwL,IAAb,CAAkBE,mBAAlB,EAAuCD,QAAO,CAAC9I,OAA/C,CAAtB;AACA;;AAEDpM,QAAAA,GAAC,GAAGoV,+BAAJ;AAEA,YAAIC,KAAK,GAAsB5L,YAAY,CAACwL,IAAb,CAAkBD,kBAAlB,EAAsCG,mBAAtC,CAA/B;;AACA,YAAI,CAACH,kBAAkB,CAAC7F,MAAnB,CAA0BkG,KAA1B,CAAL,EAAuC;AACtC,iBAAOrR,SAAP;AACA,SAjDqE,CAmDtE;;;AACAwQ,QAAAA,KAAK,GAAGA,KAAK,IAAIQ,kBAAkB,CAAC7F,MAAnB,CAA0BgG,mBAA1B,CAAjB;AACA;;AAED,aAAO,IAAIhU,cAAA,CAAAmU,YAAJ,CAAiBlM,IAAjB,EAAuBoL,KAAvB,CAAP;AACA;AAj4D6B;AAAA;AAAA,oDAm4DYnM,OAn4DZ,EAm4DiC;AAC9D,UAAIM,eAAe,GAAuBN,OAAO,CAACM,eAAlD;;AACA,UAAIA,eAAe,IAAI,IAAnB,IAA2BN,OAAO,CAACyE,SAAR,KAAsBlM,KAAA,CAAAmJ,GAAA,CAAIC,kBAAzD,EAA6E;AAC5ErB,QAAAA,eAAe,GAAG,IAAIzH,QAAA,CAAAsJ,MAAJ,EAAlB;AACA7B,QAAAA,eAAe,CAACwB,GAAhB,CAAoB9B,OAAO,CAACyE,SAA5B;AACA;;AAED,aAAOnE,eAAP;AACA;AA34D6B;AAAA;AAAA,iCA84DV9B,CA94DU,EA84DD;AAC5B,UAAIA,CAAC,KAAKvE,OAAA,CAAAuK,KAAA,CAAM1E,GAAhB,EAAqB;AACpB,eAAO,KAAP;AACA;;AAED,UAAIvC,UAAU,GAAe,KAAKjC,OAAL,IAAgB,IAAhB,GAAuB,KAAKA,OAAL,CAAaiC,UAApC,GAAiDrD,gBAAA,CAAAgT,cAAA,CAAeC,gBAA7F;AACA,UAAIC,WAAW,GAAW7P,UAAU,CAAC4B,cAAX,CAA0BX,CAA1B,CAA1B;;AACA,UAAI4O,WAAW,KAAKC,MAAM,CAAC7O,CAAD,CAA1B,EAA+B;AAC9B,eAAO4O,WAAP;AACA;;AAED,aAAOA,WAAW,GAAG,GAAd,GAAoB5O,CAApB,GAAwB,GAA/B;AACA;AA15D6B;AAAA;AAAA,qCA45DNjD,KA55DM,EA45DY;AACzC,aAAO,KAAKuI,YAAL,CAAkBvI,KAAK,CAACU,EAAN,CAAS,CAAT,CAAlB,CAAP;AACA;AA95D6B;AAAA;AAAA,uCAg6DKqR,IAh6DL,EAg6D+B;AAC5DxQ,MAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ;AACA,UAAIwQ,cAAc,GAAGD,IAAI,CAACC,cAA1B;;AACA,UAAI,CAACA,cAAL,EAAqB;AACpB;AACA;;AAL2D;AAAA;AAAA;;AAAA;AAO5D,+BAAcA,cAAd,wIAA8B;AAAA,cAArBrW,CAAqB;AAC7B,cAAIkN,KAAK,GAAW,UAApB;;AACA,cAAIlN,CAAC,CAACyF,KAAF,CAAQuH,4BAAR,GAAuC,CAA3C,EAA8C;AAC7C,gBAAI1F,CAAC,GAAetH,CAAC,CAACyF,KAAF,CAAQ0H,sBAAR,CAA+B,CAA/B,CAApB;;AACA,gBAAI7F,CAAC,YAAY5F,gBAAA,CAAA4U,cAAjB,EAAiC;AAChCpJ,cAAAA,KAAK,GAAG,UAAU,KAAKN,YAAL,CAAkBtF,CAAC,CAACiP,MAApB,CAAlB;AACA,aAFD,MAGK,IAAIjP,CAAC,YAAYzE,eAAA,CAAA2T,aAAjB,EAAgC;AACpC,kBAAIC,GAAG,GAAYnP,CAAC,YAAYnF,kBAAA,CAAAuU,gBAAhC;AACAxJ,cAAAA,KAAK,GAAG,CAACuJ,GAAG,GAAG,GAAH,GAAS,EAAb,IAAmB,MAAnB,GAA4BnP,CAAC,CAACsD,GAAF,CAAM7E,QAAN,EAApC;AACA;AACD;;AACDH,UAAAA,OAAO,CAACC,GAAR,CAAY7F,CAAC,CAAC+F,QAAF,CAAW,KAAK3B,OAAhB,EAAyB,IAAzB,IAAiC,GAAjC,GAAuC8I,KAAnD;AACA;AApB2D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqB5D;AAr7D6B;AAAA;AAAA,gCAy7DpB7I,KAz7DoB,EA07DpBE,YA17DoB,EA27DpBuE,OA37DoB,EA47D7B3B,UA57D6B,EA47DX;AAClB,aAAO,IAAI/E,sBAAA,CAAAuU,oBAAJ,CAAyB,KAAKvS,OAA9B,EAAuCC,KAAvC,EACNA,KAAK,CAACa,GAAN,CAAUiC,UAAV,CADM,EAEN9C,KAAK,CAACuS,EAAN,CAAS,CAAT,CAFM,EAGN9N,OAHM,EAGGvE,YAHH,CAAP;AAIA;AAj8D6B;AAAA;AAAA,iCAm8DEuE,OAn8DF,EAm8D8B;AAC3D,UAAI9D,GAAG,GAAW3D,KAAA,CAAAmJ,GAAA,CAAIC,kBAAtB;AAD2D;AAAA;AAAA;;AAAA;AAE3D,+BAAc3B,OAAd,wIAAuB;AAAA,cAAd9I,CAAc;;AACtB,cAAIgF,GAAG,KAAK3D,KAAA,CAAAmJ,GAAA,CAAIC,kBAAhB,EAAoC;AACnCzF,YAAAA,GAAG,GAAGhF,CAAC,CAACgF,GAAR,CADmC,CACtB;AACb,WAFD,MAGK,IAAIhF,CAAC,CAACgF,GAAF,KAAUA,GAAd,EAAmB;AACvB,mBAAO3D,KAAA,CAAAmJ,GAAA,CAAIC,kBAAX;AACA;AACD;AAT0D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAU3D,aAAOzF,GAAP;AACA;AA98D6B;AAAA;AAAA,6CAg9Dc8D,OAh9Dd,EAg9D4C9D,GAh9D5C,EAg9DuD;AAAA;AAAA;AAAA;;AAAA;AACpF,+BAAc8D,OAAd,wIAAuB;AAAA,cAAd9I,CAAc;;AACtB,cAAIA,CAAC,CAACgF,GAAF,KAAUA,GAAd,EAAmB;AAClB,gBAAIhF,CAAC,CAACyF,KAAF,YAAmB/C,eAAA,CAAA2I,aAAvB,EAAsC;AACrC,qBAAO,IAAP;AACA;AACD;AACD;AAPmF;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQpF,aAAO,KAAP;AACA;AAz9D6B;AAAA;AAAA,+BA69DpB3G,GA79DoB,EA89DpBmS,SA99DoB,EA+9D7BvP,CA/9D6B,EAg+D7BwP,kBAh+D6B,EAi+DpBC,SAj+DoB,EAk+D7B7M,YAl+D6B,EAk+DO;AACpCjH,MAAAA,MAAM,CAAC6T,kBAAkB,IAAI,IAAtB,IAA8BA,kBAAkB,CAACjS,OAAjD,IAA4DH,GAAG,CAACS,kBAAjE,CAAN;AAEA,UAAI6R,IAAI,GAAaH,SAArB;AACA,UAAII,EAAE,GAAa,KAAKhI,WAAL,CAAiBvK,GAAjB,EAAsBqS,SAAtB,EAAiC7M,YAAjC,CAAnB;;AAEA,UAAI4M,kBAAkB,IAAI,IAA1B,EAAgC;AAAA;AAAA;AAAA;;AAAA;AAC/B,iCAAoBA,kBAAkB,CAAC1K,OAAnB,EAApB,wIAAkD;AAAA,gBAAzCS,OAAyC;;AACjD,gBAAIA,OAAO,KAAKtK,mBAAA,CAAAyL,iBAAA,CAAkBC,oBAAlC,EAAwD;AACvD,kBAAI+I,IAAI,CAAClO,OAAL,CAAa2D,oBAAjB,EAAuC;AACtC;AACA;AACD;;AAEDuK,YAAAA,IAAI,CAAC1I,mBAAL,CAAyB,KAAKjL,GAA9B;AACA2T,YAAAA,IAAI,CAACE,gBAAL,CAAsB5P,CAAtB;AACA,gBAAII,IAAI,GAAyBsP,IAAI,CAAChQ,gBAAL,CAAsB6F,OAAtB,CAAjC;;AACA,gBAAInF,IAAI,IAAI,IAAZ,EAAkB;AACjBsP,cAAAA,IAAI,GAAGtP,IAAP;AACA;AACA;;AAEDA,YAAAA,IAAI,GAAG,KAAKyP,kBAAL,CAAwBzS,GAAxB,EAA6BsS,IAAI,CAAClO,OAAlC,EAA2C+D,OAA3C,EAAoD3C,YAApD,CAAP;AACAjH,YAAAA,MAAM,CAAC4J,OAAO,KAAKtK,mBAAA,CAAAyL,iBAAA,CAAkBC,oBAA9B,IAAsDvG,IAAI,CAACoB,OAAL,CAAa2D,oBAApE,CAAN;AACAuK,YAAAA,IAAI,CAAC5H,gBAAL,CAAsBvC,OAAtB,EAA+BnF,IAA/B;AACAsP,YAAAA,IAAI,GAAGtP,IAAP;AACA;AApB8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAqB/B;;AAED,UAAItE,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,UAAUmR,IAAV,GAAiB,MAAjB,GAA0BC,EAA1B,GAA+B,QAA/B,GAA0C,KAAKrK,YAAL,CAAkBtF,CAAlB,CAAtD;AACA;;AACD,WAAKgD,UAAL,CAAgB0M,IAAhB,EAAsB1P,CAAtB,EAAyB2P,EAAzB;;AACA,UAAI7T,kBAAkB,CAACuC,KAAvB,EAA8B;AAC7BC,QAAAA,OAAO,CAACC,GAAR,CAAY,WAAWnB,GAAG,CAACqB,QAAJ,CAAa,KAAK3B,OAAL,IAAgB,IAAhB,GAAuB,KAAKA,OAAL,CAAaiC,UAApC,GAAiDrD,gBAAA,CAAAgT,cAAA,CAAeC,gBAA7E,EAA+F,KAAK7R,OAAL,IAAgB,IAAhB,GAAuB,KAAKA,OAAL,CAAakC,SAApC,GAAgD7B,SAA/I,CAAvB;AACA;;AACD,aAAOwS,EAAP;AACA;AAvgE6B;AAAA;AAAA,+BAygEC1I,CAzgED,EAygEcjH,CAzgEd,EAygEmC8P,CAzgEnC,EAygE8C;AAC3E,UAAI7I,CAAC,IAAI,IAAT,EAAe;AACdA,QAAAA,CAAC,CAAC8I,SAAF,CAAY/P,CAAZ,EAAe8P,CAAf;AACA;AACD;AAED;;AA/gE8B;AAAA;AAAA,uCAihEQ1S,GAjhER,EAihE2BoE,OAjhE3B,EAihEkDwO,aAjhElD,EAihEyEpN,YAjhEzE,EAihE6G;AAC1I,UAAIoN,aAAa,KAAK/U,mBAAA,CAAAyL,iBAAA,CAAkBC,oBAAxC,EAA8D;AAC7D,YAAIsJ,cAAc,GAAiB,IAAIhW,cAAA,CAAAkK,YAAJ,EAAnC;AAD6D;AAAA;AAAA;;AAAA;AAE7D,iCAAmB3C,OAAnB,wIAA4B;AAAA,gBAAnBqC,MAAmB;AAC3BoM,YAAAA,cAAc,CAAC7L,GAAf,CAAmBP,MAAM,CAAC+C,aAAP,CAAqBoJ,aAArB,EAAoCpN,YAApC,CAAnB;AACA;AAJ4D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAM7D,eAAO,KAAK+E,WAAL,CAAiBvK,GAAjB,EAAsB6S,cAAtB,EAAsCrN,YAAtC,CAAP;AACA,OAPD,MAQK;AACJjH,QAAAA,MAAM,CAAC,CAAC6F,OAAO,CAAC2D,oBAAV,EAAgC,uCAAhC,CAAN;AACA3D,QAAAA,OAAO,GAAGA,OAAO,CAAC0O,KAAR,CAAc,IAAd,CAAV;AACA1O,QAAAA,OAAO,CAAC2D,oBAAR,GAA+B,IAA/B;AACA,eAAO,KAAKwC,WAAL,CAAiBvK,GAAjB,EAAsBoE,OAAtB,EAA+BoB,YAA/B,CAAP;AACA;AACD;AAED;;AAliE8B;AAAA;AAAA,gCAoiECxF,GApiED,EAoiEoBoE,OApiEpB,EAoiE2CoB,YApiE3C,EAoiE+E;AAC5G,UAAIuN,SAAS,GAAY,KAAK7T,yBAAL,IAAkC,CAACkF,OAAO,CAAC2D,oBAApE;;AACA,UAAIgL,SAAJ,EAAe;AACd,YAAI,CAAC3O,OAAO,CAAC4O,UAAb,EAAyB;AACxB5O,UAAAA,OAAO,CAAC6O,eAAR,CAAwB,IAAxB;AACA;;AAED,YAAIC,QAAQ,GAAa,KAAKC,cAAL,CAAoBnT,GAApB,EAAyBoE,OAAzB,CAAzB;AACA,YAAIgP,QAAQ,GAAyBpT,GAAG,CAAC8N,MAAJ,CAAWtN,GAAX,CAAe0S,QAAf,CAArC;;AACA,YAAIE,QAAQ,IAAI,IAAhB,EAAsB;AACrB,iBAAOA,QAAP;AACA;AACD;;AAED,UAAI,CAAChP,OAAO,CAAC4O,UAAb,EAAyB;AACxB,YAAI5O,OAAO,CAACC,YAAR,IAAwB,IAA5B,EAAkC;AACjCD,UAAAA,OAAO,CAACC,YAAR,GAAuB,KAAKgP,YAAL,CAAkBjP,OAAlB,EAA2BoB,YAA3B,CAAvB;AACA;AACD;;AAED,UAAI8N,QAAQ,GAAa,KAAKH,cAAL,CAAoBnT,GAApB,EAAyBoE,OAAO,CAAC0O,KAAR,CAAc,IAAd,CAAzB,CAAzB,CApB4G,CAqB5G;;AACA,UAAIS,aAAa,GAAkB,KAAK5U,GAAL,CAAS6U,gBAAT,CAA0BxT,GAAG,CAACJ,QAA9B,CAAnC;AACA,UAAIoG,YAAY,GAAW,KAAKyN,YAAL,CAAkBrP,OAAlB,CAA3B;;AACA,UAAI4B,YAAY,KAAKrJ,KAAA,CAAAmJ,GAAA,CAAIC,kBAAzB,EAA6C;AAC5CuN,QAAAA,QAAQ,CAACI,eAAT,GAA2B,IAAIpX,iBAAA,CAAAqX,eAAJ,CAAoB3N,YAApB,CAA3B;AACA,OAFD,MAEO,IAAI5B,OAAO,CAACM,eAAR,IAA2B,IAA/B,EAAqC;AAC3C,YAAIA,eAAe,GAAGN,OAAO,CAACM,eAA9B;;AACA,YAAIA,eAAJ,EAAqB;AACpB4O,UAAAA,QAAQ,CAACI,eAAT,GAA2B,IAAIpX,iBAAA,CAAAqX,eAAJ,CAAoBjP,eAAe,CAACI,UAAhB,CAA2B,CAA3B,CAApB,CAA3B;AACA;AACD;;AAED,UAAIwO,QAAQ,CAACnQ,aAAT,IAA0BiB,OAAO,CAAC6B,kBAAtC,EAA0D;AACzD,aAAK2N,iBAAL,CAAuBN,QAAvB,EAAiClP,OAAjC,EAA0CmP,aAAa,CAACpJ,mBAAxD;AACA;;AAED,UAAI,CAAC4I,SAAL,EAAgB;AACf,eAAOO,QAAP;AACA;;AAED,UAAIO,KAAK,GAAa7T,GAAG,CAAC8T,QAAJ,CAAaR,QAAb,CAAtB;;AACA,UAAI5U,kBAAkB,CAACuC,KAAnB,IAA4B4S,KAAK,KAAKP,QAA1C,EAAoD;AACnDpS,QAAAA,OAAO,CAACC,GAAR,CAAY,2BAA2BmS,QAAvC;AACA;;AACD,aAAOO,KAAP;AACA;AAllE6B;AAAA;AAAA,mCAqlEI7T,GArlEJ,EAqlEuBoE,OArlEvB,EAqlE4C;AACzE,aAAO,IAAIhH,UAAA,CAAAgP,QAAJ,CAAahI,OAAb,CAAP;AACA;AAvlE6B;AAAA;AAAA,gDAylEiBpE,GAzlEjB,EAylE2B0E,eAzlE3B,EAylEyEK,aAzlEzE,EAylEwGtC,UAzlExG,EAylE4HyC,SAzlE5H,EAylE6I;AAC1K,UAAIxG,kBAAkB,CAACuC,KAAnB,IAA4BvC,kBAAkB,CAACqV,WAAnD,EAAgE;AAC/D,YAAIvQ,QAAQ,GAAalG,UAAA,CAAAmG,QAAA,CAASC,EAAT,CAAYjB,UAAZ,EAAwByC,SAAxB,CAAzB;AACAhE,QAAAA,OAAO,CAACC,GAAR,CAAY,0CAA0CnB,GAAG,CAACJ,QAA9C,GAAyD,GAAzD,GAA+DmF,aAAa,CAAC7C,EAAd,CAAiBkC,OAAhF,GACX,UADW,GACE,KAAK1E,OAAL,CAAaiE,WAAb,CAAyBC,OAAzB,CAAiCJ,QAAjC,CADd;AAEA;;AACD,UAAI,KAAK9D,OAAL,IAAgB,IAApB,EAA0B;AACzB,YAAIsU,QAAQ,GAAG,KAAKtU,OAAL,CAAauU,wBAAb,EAAf;;AACA,YAAID,QAAQ,CAAChP,2BAAb,EAA0C;AACzCgP,UAAAA,QAAQ,CAAChP,2BAAT,CAAqC,KAAKtF,OAA1C,EAAmDM,GAAnD,EAAwDyC,UAAxD,EAAoEyC,SAApE,EAA+ER,eAA/E,EAAgGK,aAAhG;AACA;AACD;AACD;AArmE6B;AAAA;AAAA,6CAumEc/E,GAvmEd,EAumEwBqD,UAvmExB,EAumEqD6Q,WAvmErD,EAumEkFzR,UAvmElF,EAumEsGyC,SAvmEtG,EAumEuH;AACpJ,UAAIxG,kBAAkB,CAACuC,KAAnB,IAA4BvC,kBAAkB,CAACqV,WAAnD,EAAgE;AAC/D,YAAIvQ,QAAQ,GAAalG,UAAA,CAAAmG,QAAA,CAASC,EAAT,CAAYjB,UAAZ,EAAwByC,SAAxB,CAAzB;AACAhE,QAAAA,OAAO,CAACC,GAAR,CAAY,uCAAuCnB,GAAG,CAACJ,QAA3C,GAAsD,GAAtD,GAA4DsU,WAAW,CAAChS,EAAZ,CAAekC,OAA3E,GACX,UADW,GACE,KAAK1E,OAAL,CAAaiE,WAAb,CAAyBC,OAAzB,CAAiCJ,QAAjC,CADd;AAEA;;AACD,UAAI,KAAK9D,OAAL,IAAgB,IAApB,EAA0B;AACzB,YAAIsU,QAAQ,GAAG,KAAKtU,OAAL,CAAauU,wBAAb,EAAf;;AACA,YAAID,QAAQ,CAAC7N,wBAAb,EAAuC;AACtC6N,UAAAA,QAAQ,CAAC7N,wBAAT,CAAkC,KAAKzG,OAAvC,EAAgDM,GAAhD,EAAqDyC,UAArD,EAAiEyC,SAAjE,EAA4E7B,UAA5E,EAAwF6Q,WAAxF;AACA;AACD;AACD;AAED;;AArnE8B;AAAA;AAAA,oCAunEpBlU,GAvnEoB,EAwnE7B6F,CAxnE6B,EAwnEf;AACdpD,IAAAA,UAznE6B,EA0nE7ByC,SA1nE6B,EA2nE7BqL,KA3nE6B,EA4nEpB7E,SA5nEoB,EA6nEpBtH,OA7nEoB,EA6nEC;AAE9B,UAAI1F,kBAAkB,CAACuC,KAAnB,IAA4BvC,kBAAkB,CAACqV,WAAnD,EAAgE;AAC/D,YAAIvQ,QAAQ,GAAalG,UAAA,CAAAmG,QAAA,CAASC,EAAT,CAAYjB,UAAZ,EAAwByC,SAAxB,CAAzB;AACAhE,QAAAA,OAAO,CAACC,GAAR,CAAY,qBACXuK,SADW,GACC,GADD,GACOtH,OADP,GAEX,UAFW,GAEE,KAAK1E,OAAL,CAAaiE,WAAb,CAAyBC,OAAzB,CAAiCJ,QAAjC,CAFd;AAGA;;AACD,UAAI,KAAK9D,OAAL,IAAgB,IAApB,EAA0B;AACzB,YAAIsU,QAAQ,GAAG,KAAKtU,OAAL,CAAauU,wBAAb,EAAf;;AACA,YAAID,QAAQ,CAAC1O,eAAb,EAA8B;AAC7B0O,UAAAA,QAAQ,CAAC1O,eAAT,CAAyB,KAAK5F,OAA9B,EAAuCM,GAAvC,EAA4CyC,UAA5C,EAAwDyC,SAAxD,EAAmEqL,KAAnE,EAA0E7E,SAA1E,EAAqFtH,OAArF;AACA;AACD;AACD;AA3oE6B;AAAA;AAAA,mCA6oEL+D,OA7oEK,EA6oEe;AAC5C,UAAIA,OAAO,CAAChI,OAAZ,EAAqB;AACpB,eAAOtC,mBAAA,CAAAyL,iBAAA,CAAkBC,oBAAzB;AACA;;AAED,UAAIxI,KAAK,GAAa,KAAKpC,GAAL,CAASmP,MAAT,CAAgB3F,OAAO,CAACgM,aAAxB,CAAtB;AACA,UAAI/J,UAAU,GAAmBrJ,KAAK,CAACqJ,UAAN,CAAiB,CAAjB,CAAjC;AACA,aAAOA,UAAU,CAAC8F,WAAX,CAAuBpN,WAA9B;AACA;AArpE6B;AAAA;AAAA,kCAupENqF,OAvpEM,EAupEoB;AACjD,UAAI,CAAC,KAAK9I,mBAAV,EAA+B;AAC9B,eAAO8I,OAAP;AACA;;AAED,aAAO,CAACA,OAAO,CAAChI,OAAhB,EAAyB;AACxB,YAAIY,KAAK,GAAa,KAAKpC,GAAL,CAASmP,MAAT,CAAgB3F,OAAO,CAACgM,aAAxB,CAAtB;AACA5V,QAAAA,MAAM,CAACwC,KAAK,CAACoJ,mBAAN,KAA8B,CAA9B,IAAmCpJ,KAAK,CAACqJ,UAAN,CAAiB,CAAjB,EAAoBiF,iBAApB,KAAqC;AAAA;AAAzE,SAAN;AACA,YAAIjF,UAAU,GAAmBrJ,KAAK,CAACqJ,UAAN,CAAiB,CAAjB,CAAjC;;AACA,YAAI,CAACA,UAAU,CAACgK,QAAhB,EAA0B;AACzB;AACA,SANuB,CAQxB;AACA;;;AACAjM,QAAAA,OAAO,GAAGA,OAAO,CAAC3F,MAAlB;AACA;;AAED,aAAO2F,OAAP;AACA;AAED;;;;AA5qE8B;AAAA;AAAA,wBA+qEpB;AACT,aAAO,KAAKzI,OAAZ;AACA;AAjrE6B;AAAA;AAAA,EAAS5C,cAAA,CAAA+G,YAAT,CAA/B;;AACenF,kBAAA,CAAAuC,KAAA,GAAiB,KAAjB;AACAvC,kBAAA,CAAAgE,SAAA,GAAqB,KAArB;AACAhE,kBAAA,CAAAqV,WAAA,GAAuB,KAAvB;;AAqtDCrV,kBAAA,CAAA4R,yBAAA,GACd,UAAC+D,EAAD,EAAgBC,EAAhB,EAAyC;AACxC,MAAIC,IAAI,GAAWF,EAAE,CAACtT,KAAH,CAAS2P,kBAAT,GAA8B4D,EAAE,CAACvT,KAAH,CAAS2P,kBAA1D;;AACA,MAAI6D,IAAI,KAAK,CAAb,EAAgB;AACf,WAAOA,IAAP;AACA;;AAEDA,EAAAA,IAAI,GAAGF,EAAE,CAAC/T,GAAH,GAASgU,EAAE,CAAChU,GAAnB;;AACA,MAAIiU,IAAI,KAAK,CAAb,EAAgB;AACf,WAAOA,IAAP;AACA;;AAED,SAAO,CAAP;AACA,CAba;;AAltDftZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,CAAA,ED8zDE9V,kBAAkB,CAAC+V,SC9zDrB,ED8zDgC,gBC9zDhC,ED8zDkD,KAAK,CC9zDvD,CAAA;;AAqDAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,CAAA,ED4wDE9V,kBAAkB,CAAC+V,SC5wDrB,ED4wDgC,mBC5wDhC,ED4wDqD,IC5wDrD,CAAA;;AAIAxZ,UAAA,CAAA,CAA0BgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA1B,CAAA,ED2wDE9V,kBAAkB,CAAC+V,SC3wDrB,ED2wDgC,mBC3wDhC,ED2wDqD,IC3wDrD,CAAA;;AAKAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAkX,QACD,CAAA,EDywDEhW,kBAAkB,CAAC+V,SCzwDrB,EDywDgC,OCzwDhC,EDywDyC,ICzwDzC,CAAA;;AAMAxZ,UAAA,CAAA,CACEgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,CAAA,EDswDE9V,kBAAkB,CAAC+V,SCtwDrB,EDswDgC,iBCtwDhC,EDswDmD,ICtwDnD,CAAA;;AAsEAxZ,UAAA,CAAA,CACEgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,EAEEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAFF,EAGEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAHF,CAAA,EDqsDE9V,kBAAkB,CAAC+V,SCrsDrB,EDqsDgC,eCrsDhC,EDqsDiD,ICrsDjD,CAAA;;AA0DAxZ,UAAA,CAAA,CACEgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,EAEEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAFF,EAGEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAHF,CAAA,EDgpDE9V,kBAAkB,CAAC+V,SChpDrB,EDgpDgC,SChpDhC,EDgpD2C,IChpD3C,CAAA;;AAgRAxZ,UAAA,CAAA,CACEgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,EAEEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAFF,EAGEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAHF,CAAA,EDq4CE9V,kBAAkB,CAAC+V,SCr4CrB,EDq4CgC,SCr4ChC,EDq4C2C,ICr4C3C,CAAA;;AAoLAxZ,UAAA,CAAA,CAA6BgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA7B,EAA8EvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA9E,CAAA,EDotCE9V,kBAAkB,CAAC+V,SCptCrB,EDotCgC,mBCptChC,EDotCqD,ICptCrD,CAAA;;AA6HAxZ,UAAA,CAAA,CAAkCgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAlC,CAAA,ED0lCE9V,kBAAkB,CAAC+V,SC1lCrB,ED0lCgC,wBC1lChC,ED0lC0D,IC1lC1D,CAAA;;AAoBAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,EAA8BvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA9B,EAAiDvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAjD,CAAA,ED0kCE9V,kBAAkB,CAAC+V,SC1kCrB,ED0kCgC,oBC1kChC,ED0kCsD,IC1kCtD,CAAA;;AA6JAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,EAA8CvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA9C,CAAA,EDi7BE9V,kBAAkB,CAAC+V,SCj7BrB,EDi7BgC,oCCj7BhC,EDi7BsE,ICj7BtE,CAAA;;AAkBAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,CAAA,EDk6BE9V,kBAAkB,CAAC+V,SCl6BrB,EDk6BgC,mBCl6BhC,EDk6BqD,ICl6BrD,CAAA;;AAsNAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,EAAiCvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAjC,CAAA,EDgtBE9V,kBAAkB,CAAC+V,SChtBrB,EDgtBgC,uBChtBhC,EDgtByD,IChtBzD,CAAA;;AAgDAxZ,UAAA,CAAA,CAA8BgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA9B,EAA0DvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA1D,CAAA,EDmqBE9V,kBAAkB,CAAC+V,SCnqBrB,EDmqBgC,oBCnqBhC,EDmqBsD,ICnqBtD,CAAA;;AAiCAxZ,UAAA,CAAA,CACEgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,EAEEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAFF,CAAA,EDsoBE9V,kBAAkB,CAAC+V,SCtoBrB,EDsoBgC,sBCtoBhC,EDsoBwD,ICtoBxD,CAAA;;AAmFAxZ,UAAA,CAAA,CACEgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,CAAA,EDsjBE9V,kBAAkB,CAAC+V,SCtjBrB,EDsjBgC,qBCtjBhC,EDsjBuD,ICtjBvD,CAAA;;AA0DAxZ,UAAA,CAAA,CAAmCgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAnC,CAAA,ED+fE9V,kBAAkB,CAAC+V,SC/frB,ED+fgC,yBC/fhC,ED+f2D,IC/f3D,CAAA;;AAWAxZ,UAAA,CAAA,CAEEgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAFF,EAKEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAmX,QAAA,CALF,CAAA,EDwfEjW,kBAAkB,CAAC+V,SCxfrB,EDwfgC,SCxfhC,EDwf2C,ICxf3C,CAAA;;AAuBAxZ,UAAA,CAAA,CACEgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,EAEEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAFF,EAGEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAmX,QAAA,CAHF,EAIE1Y,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAJF,EAOEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAPF,CAAA,EDweE9V,kBAAkB,CAAC+V,SCxerB,EDwegC,aCxehC,EDwe+C,ICxe/C,CAAA;;AA4KAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,CAAA,ED+TE9V,kBAAkB,CAAC+V,SC/TrB,ED+TgC,aC/ThC,ED+T+C,IC/T/C,CAAA;;AAOAxZ,UAAA,CAAA,CAA4BgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA5B,EAAwDvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAxD,CAAA,ED2TE9V,kBAAkB,CAAC+V,SC3TrB,ED2TgC,kBC3ThC,ED2ToD,IC3TpD,CAAA;;AAoCAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,EAA4BvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA5B,EAAwDvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAxD,CAAA,ED2RE9V,kBAAkB,CAAC+V,SC3RrB,ED2RgC,kBC3RhC,ED2RoD,IC3RpD,CAAA;;AAQAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAmX,QACD,EACE1Y,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,EAEEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAFF,CAAA,EDwRE9V,kBAAkB,CAAC+V,SCxRrB,EDwRgC,sBCxRhC,EDwRwD,ICxRxD,CAAA;;AA+BAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAmX,QACD,EACE1Y,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,EAEEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAFF,CAAA,ED8PE9V,kBAAkB,CAAC+V,SC9PrB,ED8PgC,gBC9PhC,ED8PkD,IC9PlD,CAAA;;AAgCAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,EAA0BvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA1B,EAAsDvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAtD,EAAkFvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAmX,QAAA,CAAlF,CAAA,EDkOEjW,kBAAkB,CAAC+V,SClOrB,EDkOgC,gBClOhC,EDkOkD,IClOlD,CAAA;;AAqCAxZ,UAAA,CAAA,CAAsBgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAtB,CAAA,EDgME9V,kBAAkB,CAAC+V,SChMrB,EDgMgC,cChMhC,EDgMgD,IChMhD,CAAA;;AAuKAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,CAAA,ED4BE9V,kBAAkB,CAAC+V,SC5BrB,ED4BgC,cC5BhC,ED4BgD,IC5BhD,CAAA;;AAkBAxZ,UAAA,CAAA,CAA2BgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA3B,CAAA,EDaE9V,kBAAkB,CAAC+V,SCbrB,EDagC,oBCbhC,EDasD,ICbtD,CAAA;;AAwBAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,EACEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,EAEEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAFF,EAGEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAHF,CAAA,EDLE9V,kBAAkB,CAAC+V,SCKrB,EDLgC,aCKhC,EDL+C,ICK/C,CAAA;;AAWAxZ,UAAA,CAAA,CAAwBgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAxB,CAAA,EDbE9V,kBAAkB,CAAC+V,SCarB,EDbgC,cCahC,EDbgD,ICahD,CAAA;;AAaAxZ,UAAA,CAAA,CAAoCgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAApC,CAAA,EDvBE9V,kBAAkB,CAAC+V,SCuBrB,EDvBgC,0BCuBhC,EDvB4D,ICuB5D,CAAA;;AAYAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,EACEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,EAEEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAFF,EAKEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CALF,CAAA,ED7BE9V,kBAAkB,CAAC+V,SC6BrB,ED7BgC,YC6BhC,ED7B8C,IC6B9C,CAAA;;AA6CAxZ,UAAA,CAAA,CAAsBgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAmX,QAAA,CAAtB,EAAwD1Y,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAmX,QAAA,CAAxD,CAAA,EDvEEjW,kBAAkB,CAAC+V,SCuErB,EDvEgC,YCuEhC,EDvE8C,ICuE9C,CAAA;;AAQAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,EAA8BvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA9B,EAAiDvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAjD,CAAA,ED3EE9V,kBAAkB,CAAC+V,SC2ErB,ED3EgC,oBC2EhC,ED3EsD,IC2EtD,CAAA;;AAmBAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,EAAuBvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAvB,EAA0CvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA1C,CAAA,ED1FE9V,kBAAkB,CAAC+V,SC0FrB,ED1FgC,aC0FhC,ED1F+C,IC0F/C,CAAA;;AAiDAxZ,UAAA,CAAA,CADCuC,YAAA,CAAAgX,OACD,EAA0BvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA1B,EAA6CvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA7C,CAAA,EDvIE9V,kBAAkB,CAAC+V,SCuIrB,EDvIgC,gBCuIhC,EDvIkD,ICuIlD,CAAA;;AAIAxZ,UAAA,CAAA,CAAuCgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAAvC,EAA+FvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA/F,CAAA,EDxIE9V,kBAAkB,CAAC+V,SCwIrB,EDxIgC,6BCwIhC,EDxI+D,ICwI/D,CAAA;;AAcAxZ,UAAA,CAAA,CAAoCgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAApC,EAA2EvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAA3E,CAAA,EDnJE9V,kBAAkB,CAAC+V,SCmJrB,EDnJgC,0BCmJhC,EDnJ4D,ICmJ5D,CAAA;;AAeAxZ,UAAA,CAAA,CACEgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CADF,EAMEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CANF,EAOEvY,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CAPF,CAAA,ED7JE9V,kBAAkB,CAAC+V,SC6JrB,ED7JgC,iBC6JhC,ED7JmD,IC6JnD,CAAA;;AAtnEY/V,kBAAkB,GAAAzD,UAAA,CAAA,CAqDjBgB,OAAA,CAAA,CAAA,EAAAuB,YAAA,CAAAgX,OAAA,CArDiB,CAAA,EAAlB9V,kBAAkB,CAAlB;AAAAtC,OAAA,CAAAsC,kBAAA,GAAAA,kBAAA","file":"ParserATNSimulator.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:31.1989835-07:00\nconst AcceptStateInfo_1 = require(\"../dfa/AcceptStateInfo\");\nconst ActionTransition_1 = require(\"./ActionTransition\");\nconst Array2DHashSet_1 = require(\"../misc/Array2DHashSet\");\nconst Arrays_1 = require(\"../misc/Arrays\");\nconst ATN_1 = require(\"./ATN\");\nconst ATNConfig_1 = require(\"./ATNConfig\");\nconst ATNConfigSet_1 = require(\"./ATNConfigSet\");\nconst ATNSimulator_1 = require(\"./ATNSimulator\");\nconst ATNStateType_1 = require(\"./ATNStateType\");\nconst AtomTransition_1 = require(\"./AtomTransition\");\nconst BitSet_1 = require(\"../misc/BitSet\");\nconst ConflictInfo_1 = require(\"./ConflictInfo\");\nconst DecisionState_1 = require(\"./DecisionState\");\nconst DFAState_1 = require(\"../dfa/DFAState\");\nconst IntegerList_1 = require(\"../misc/IntegerList\");\nconst Interval_1 = require(\"../misc/Interval\");\nconst IntStream_1 = require(\"../IntStream\");\nconst Decorators_1 = require(\"../Decorators\");\nconst NotSetTransition_1 = require(\"./NotSetTransition\");\nconst NoViableAltException_1 = require(\"../NoViableAltException\");\nconst ObjectEqualityComparator_1 = require(\"../misc/ObjectEqualityComparator\");\nconst ParserRuleContext_1 = require(\"../ParserRuleContext\");\nconst PredictionContext_1 = require(\"./PredictionContext\");\nconst PredictionContextCache_1 = require(\"./PredictionContextCache\");\nconst PredictionMode_1 = require(\"./PredictionMode\");\nconst RuleStopState_1 = require(\"./RuleStopState\");\nconst RuleTransition_1 = require(\"./RuleTransition\");\nconst SemanticContext_1 = require(\"./SemanticContext\");\nconst SetTransition_1 = require(\"./SetTransition\");\nconst SimulatorState_1 = require(\"./SimulatorState\");\nconst Token_1 = require(\"../Token\");\nconst VocabularyImpl_1 = require(\"../VocabularyImpl\");\nconst assert = require(\"assert\");\nconst MAX_SHORT_VALUE = 0xFFFF;\nconst MIN_INTEGER_VALUE = -((1 << 31) >>> 0);\n/**\n * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.\n *\n * The basic complexity of the adaptive strategy makes it harder to understand.\n * We begin with ATN simulation to build paths in a DFA. Subsequent prediction\n * requests go through the DFA first. If they reach a state without an edge for\n * the current symbol, the algorithm fails over to the ATN simulation to\n * complete the DFA path for the current input (until it finds a conflict state\n * or uniquely predicting state).\n *\n * All of that is done without using the outer context because we want to create\n * a DFA that is not dependent upon the rule invocation stack when we do a\n * prediction. One DFA works in all contexts. We avoid using context not\n * necessarily because it's slower, although it can be, but because of the DFA\n * caching problem. The closure routine only considers the rule invocation stack\n * created during prediction beginning in the decision rule. For example, if\n * prediction occurs without invoking another rule's ATN, there are no context\n * stacks in the configurations. When lack of context leads to a conflict, we\n * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing\n * strategy (versus full LL(*)).\n *\n * When SLL yields a configuration set with conflict, we rewind the input and\n * retry the ATN simulation, this time using full outer context without adding\n * to the DFA. Configuration context stacks will be the full invocation stacks\n * from the start rule. If we get a conflict using full context, then we can\n * definitively say we have a true ambiguity for that input sequence. If we\n * don't get a conflict, it implies that the decision is sensitive to the outer\n * context. (It is not context-sensitive in the sense of context-sensitive\n * grammars.)\n *\n * The next time we reach this DFA state with an SLL conflict, through DFA\n * simulation, we will again retry the ATN simulation using full context mode.\n * This is slow because we can't save the results and have to \"interpret\" the\n * ATN each time we get that input.\n *\n * **CACHING FULL CONTEXT PREDICTIONS**\n *\n * We could cache results from full context to predicted alternative easily and\n * that saves a lot of time but doesn't work in presence of predicates. The set\n * of visible predicates from the ATN start state changes depending on the\n * context, because closure can fall off the end of a rule. I tried to cache\n * tuples (stack context, semantic context, predicted alt) but it was slower\n * than interpreting and much more complicated. Also required a huge amount of\n * memory. The goal is not to create the world's fastest parser anyway. I'd like\n * to keep this algorithm simple. By launching multiple threads, we can improve\n * the speed of parsing across a large number of files.\n *\n * There is no strict ordering between the amount of input used by SLL vs LL,\n * which makes it really hard to build a cache for full context. Let's say that\n * we have input A B C that leads to an SLL conflict with full context X. That\n * implies that using X we might only use A B but we could also use A B C D to\n * resolve conflict. Input A B C D could predict alternative 1 in one position\n * in the input and A B C E could predict alternative 2 in another position in\n * input. The conflicting SLL configurations could still be non-unique in the\n * full context prediction, which would lead us to requiring more input than the\n * original A B C.\tTo make a\tprediction cache work, we have to track\tthe exact\n * input\tused during the previous prediction. That amounts to a cache that maps\n * X to a specific DFA for that context.\n *\n * Something should be done for left-recursive expression predictions. They are\n * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry\n * with full LL thing Sam does.\n *\n * **AVOIDING FULL CONTEXT PREDICTION**\n *\n * We avoid doing full context retry when the outer context is empty, we did not\n * dip into the outer context by falling off the end of the decision state rule,\n * or when we force SLL mode.\n *\n * As an example of the not dip into outer context case, consider as super\n * constructor calls versus function calls. One grammar might look like\n * this:\n *\n * ```antlr\n * ctorBody\n *   : '{' superCall? stat* '}'\n *   ;\n * ```\n *\n * Or, you might see something like\n *\n * ```antlr\n * stat\n *   : superCall ';'\n *   | expression ';'\n *   | ...\n *   ;\n * ```\n *\n * In both cases I believe that no closure operations will dip into the outer\n * context. In the first case ctorBody in the worst case will stop at the '}'.\n * In the 2nd case it should stop at the ';'. Both cases should stay within the\n * entry rule and not dip into the outer context.\n *\n * **PREDICATES**\n *\n * Predicates are always evaluated if present in either SLL or LL both. SLL and\n * LL simulation deals with predicates differently. SLL collects predicates as\n * it performs closure operations like ANTLR v3 did. It delays predicate\n * evaluation until it reaches and accept state. This allows us to cache the SLL\n * ATN simulation whereas, if we had evaluated predicates on-the-fly during\n * closure, the DFA state configuration sets would be different and we couldn't\n * build up a suitable DFA.\n *\n * When building a DFA accept state during ATN simulation, we evaluate any\n * predicates and return the sole semantically valid alternative. If there is\n * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,\n * we throw an exception. Alternatives without predicates act like they have\n * true predicates. The simple way to think about it is to strip away all\n * alternatives with false predicates and choose the minimum alternative that\n * remains.\n *\n * When we start in the DFA and reach an accept state that's predicated, we test\n * those and return the minimum semantically viable alternative. If no\n * alternatives are viable, we throw an exception.\n *\n * During full LL ATN simulation, closure always evaluates predicates and\n * on-the-fly. This is crucial to reducing the configuration set size during\n * closure. It hits a landmine when parsing with the Java grammar, for example,\n * without this on-the-fly evaluation.\n *\n * **SHARING DFA**\n *\n * All instances of the same parser share the same decision DFAs through a\n * static field. Each instance gets its own ATN simulator but they share the\n * same {@link ATN#decisionToDFA} field. They also share a\n * {@link PredictionContextCache} object that makes sure that all\n * {@link PredictionContext} objects are shared among the DFA states. This makes\n * a big size difference.\n *\n * **THREAD SAFETY**\n *\n * The {@link ParserATNSimulator} locks on the {@link ATN#decisionToDFA} field when\n * it adds a new DFA object to that array. {@link #addDFAEdge}\n * locks on the DFA for the current decision when setting the\n * {@link DFAState#edges} field. {@link #addDFAState} locks on\n * the DFA for the current decision when looking up a DFA state to see if it\n * already exists. We must make sure that all requests to add DFA states that\n * are equivalent result in the same shared DFA object. This is because lots of\n * threads will be trying to update the DFA at once. The\n * {@link #addDFAState} method also locks inside the DFA lock\n * but this time on the shared context cache when it rebuilds the\n * configurations' {@link PredictionContext} objects using cached\n * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is\n * safe as long as we can guarantee that all threads referencing\n * `s.edge[t]` get the same physical target {@link DFAState}, or\n * `undefined`. Once into the DFA, the DFA simulation does not reference the\n * {@link DFA#states} map. It follows the {@link DFAState#edges} field to new\n * targets. The DFA simulator will either find {@link DFAState#edges} to be\n * `undefined`, to be non-`undefined` and `dfa.edges[t]` undefined, or\n * `dfa.edges[t]` to be non-undefined. The\n * {@link #addDFAEdge} method could be racing to set the field\n * but in either case the DFA simulator works; if `undefined`, and requests ATN\n * simulation. It could also race trying to get `dfa.edges[t]`, but either\n * way it will work because it's not doing a test and set operation.\n *\n * **Starting with SLL then failing to combined SLL/LL (Two-Stage\n * Parsing)**\n *\n * Sam pointed out that if SLL does not give a syntax error, then there is no\n * point in doing full LL, which is slower. We only have to try LL if we get a\n * syntax error. For maximum speed, Sam starts the parser set to pure SLL\n * mode with the {@link BailErrorStrategy}:\n *\n * ```\n * parser.interpreter.{@link #setPredictionMode setPredictionMode}`(`{@link PredictionMode#SLL}`)`;\n * parser.{@link Parser#setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());\n * ```\n *\n * If it does not get a syntax error, then we're done. If it does get a syntax\n * error, we need to retry with the combined SLL/LL strategy.\n *\n * The reason this works is as follows. If there are no SLL conflicts, then the\n * grammar is SLL (at least for that input set). If there is an SLL conflict,\n * the full LL analysis must yield a set of viable alternatives which is a\n * subset of the alternatives reported by SLL. If the LL set is a singleton,\n * then the grammar is LL but not SLL. If the LL set is the same size as the SLL\n * set, the decision is SLL. If the LL set has size &gt; 1, then that decision\n * is truly ambiguous on the current input. If the LL set is smaller, then the\n * SLL conflict resolution might choose an alternative that the full LL would\n * rule out as a possibility based upon better context information. If that's\n * the case, then the SLL parse will definitely get an error because the full LL\n * analysis says it's not viable. If SLL conflict resolution chooses an\n * alternative within the LL set, them both SLL and LL would choose the same\n * alternative because they both choose the minimum of multiple conflicting\n * alternatives.\n *\n * Let's say we have a set of SLL conflicting alternatives `{1, 2, 3}` and\n * a smaller LL set called *s*. If *s* is `{2, 3}`, then SLL\n * parsing will get an error because SLL will pursue alternative 1. If\n * *s* is `{1, 2}` or `{1, 3}` then both SLL and LL will\n * choose the same alternative because alternative one is the minimum of either\n * set. If *s* is `{2}` or `{3}` then SLL will get a syntax\n * error. If *s* is `{1}` then SLL will succeed.\n *\n * Of course, if the input is invalid, then we will get an error for sure in\n * both SLL and LL parsing. Erroneous input will therefore require 2 passes over\n * the input.\n */\nlet ParserATNSimulator = class ParserATNSimulator extends ATNSimulator_1.ATNSimulator {\n    constructor(atn, parser) {\n        super(atn);\n        this.predictionMode = PredictionMode_1.PredictionMode.LL;\n        this.force_global_context = false;\n        this.always_try_local_context = true;\n        /**\n         * Determines whether the DFA is used for full-context predictions. When\n         * `true`, the DFA stores transition information for both full-context\n         * and SLL parsing; otherwise, the DFA only stores SLL transition\n         * information.\n         *\n         * For some grammars, enabling the full-context DFA can result in a\n         * substantial performance improvement. However, this improvement typically\n         * comes at the expense of memory used for storing the cached DFA states,\n         * configuration sets, and prediction contexts.\n         *\n         * The default value is `false`.\n         */\n        this.enable_global_context_dfa = false;\n        this.optimize_unique_closure = true;\n        this.optimize_ll1 = true;\n        this.optimize_tail_calls = true;\n        this.tail_call_preserves_sll = true;\n        this.treat_sllk1_conflict_as_ambiguity = false;\n        /**\n         * When `true`, ambiguous alternatives are reported when they are\n         * encountered within {@link #execATN}. When `false`, these messages\n         * are suppressed. The default is `false`.\n         *\n         * When messages about ambiguous alternatives are not required, setting this\n         * to `false` enables additional internal optimizations which may lose\n         * this information.\n         */\n        this.reportAmbiguities = false;\n        /** By default we do full context-sensitive LL(*) parsing not\n         *  Strong LL(*) parsing. If we fail with Strong LL(*) we\n         *  try full LL(*). That means we rewind and use context information\n         *  when closure operations fall off the end of the rule that\n         *  holds the decision were evaluating.\n         */\n        this.userWantsCtxSensitive = true;\n        this._parser = parser;\n    }\n    getPredictionMode() {\n        return this.predictionMode;\n    }\n    setPredictionMode(predictionMode) {\n        this.predictionMode = predictionMode;\n    }\n    reset() {\n        // intentionally empty\n    }\n    adaptivePredict(input, decision, outerContext, useContext) {\n        if (useContext === undefined) {\n            useContext = false;\n        }\n        let dfa = this.atn.decisionToDFA[decision];\n        assert(dfa != null);\n        if (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {\n            let ll_1 = input.LA(1);\n            if (ll_1 >= 0 && ll_1 <= 0xFFFF) {\n                let key = ((decision << 16) >>> 0) + ll_1;\n                let alt = this.atn.LL1Table.get(key);\n                if (alt != null) {\n                    return alt;\n                }\n            }\n        }\n        this.dfa = dfa;\n        if (this.force_global_context) {\n            useContext = true;\n        }\n        else if (!this.always_try_local_context) {\n            useContext = useContext || dfa.isContextSensitive;\n        }\n        this.userWantsCtxSensitive = useContext || (this.predictionMode !== PredictionMode_1.PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll);\n        if (outerContext == null) {\n            outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();\n        }\n        let state;\n        if (!dfa.isEmpty) {\n            state = this.getStartState(dfa, input, outerContext, useContext);\n        }\n        if (state == null) {\n            if (outerContext == null) {\n                outerContext = ParserRuleContext_1.ParserRuleContext.emptyContext();\n            }\n            if (ParserATNSimulator.debug) {\n                console.log(\"ATN decision \" + dfa.decision +\n                    \" exec LA(1)==\" + this.getLookaheadName(input) +\n                    \", outerContext=\" + outerContext.toString(this._parser));\n            }\n            state = this.computeStartState(dfa, outerContext, useContext);\n        }\n        let m = input.mark();\n        let index = input.index;\n        try {\n            let alt = this.execDFA(dfa, input, index, state);\n            if (ParserATNSimulator.debug) {\n                console.log(\"DFA after predictATN: \" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\n            }\n            return alt;\n        }\n        finally {\n            this.dfa = undefined;\n            input.seek(index);\n            input.release(m);\n        }\n    }\n    getStartState(dfa, input, outerContext, useContext) {\n        if (!useContext) {\n            if (dfa.isPrecedenceDfa) {\n                // the start state for a precedence DFA depends on the current\n                // parser precedence, and is provided by a DFA method.\n                let state = dfa.getPrecedenceStartState(this._parser.precedence, false);\n                if (state == null) {\n                    return undefined;\n                }\n                return new SimulatorState_1.SimulatorState(outerContext, state, false, outerContext);\n            }\n            else {\n                if (dfa.s0 == null) {\n                    return undefined;\n                }\n                return new SimulatorState_1.SimulatorState(outerContext, dfa.s0, false, outerContext);\n            }\n        }\n        if (!this.enable_global_context_dfa) {\n            return undefined;\n        }\n        let remainingContext = outerContext;\n        assert(outerContext != null);\n        let s0;\n        if (dfa.isPrecedenceDfa) {\n            s0 = dfa.getPrecedenceStartState(this._parser.precedence, true);\n        }\n        else {\n            s0 = dfa.s0full;\n        }\n        while (remainingContext != null && s0 != null && s0.isContextSensitive) {\n            remainingContext = this.skipTailCalls(remainingContext);\n            s0 = s0.getContextTarget(this.getReturnState(remainingContext));\n            if (remainingContext.isEmpty) {\n                assert(s0 == null || !s0.isContextSensitive);\n            }\n            else {\n                remainingContext = remainingContext.parent;\n            }\n        }\n        if (s0 == null) {\n            return undefined;\n        }\n        return new SimulatorState_1.SimulatorState(outerContext, s0, useContext, remainingContext);\n    }\n    execDFA(dfa, input, startIndex, state) {\n        let outerContext = state.outerContext;\n        if (ParserATNSimulator.dfa_debug) {\n            console.log(\"DFA decision \" + dfa.decision +\n                \" exec LA(1)==\" + this.getLookaheadName(input) +\n                \", outerContext=\" + outerContext.toString(this._parser));\n        }\n        if (ParserATNSimulator.dfa_debug) {\n            console.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\n        }\n        let s = state.s0;\n        let t = input.LA(1);\n        let remainingOuterContext = state.remainingOuterContext;\n        while (true) {\n            if (ParserATNSimulator.dfa_debug) {\n                console.log(\"DFA state \" + s.stateNumber + \" LA(1)==\" + this.getLookaheadName(input));\n            }\n            if (state.useContext) {\n                while (s.isContextSymbol(t)) {\n                    let next;\n                    if (remainingOuterContext != null) {\n                        remainingOuterContext = this.skipTailCalls(remainingOuterContext);\n                        next = s.getContextTarget(this.getReturnState(remainingOuterContext));\n                    }\n                    if (next == null) {\n                        // fail over to ATN\n                        let initialState = new SimulatorState_1.SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);\n                        return this.execATN(dfa, input, startIndex, initialState);\n                    }\n                    assert(remainingOuterContext != null);\n                    remainingOuterContext = remainingOuterContext.parent;\n                    s = next;\n                }\n            }\n            if (this.isAcceptState(s, state.useContext)) {\n                if (s.predicates != null) {\n                    if (ParserATNSimulator.dfa_debug) {\n                        console.log(\"accept \" + s);\n                    }\n                }\n                else {\n                    if (ParserATNSimulator.dfa_debug) {\n                        console.log(\"accept; predict \" + s.prediction + \" in state \" + s.stateNumber);\n                    }\n                }\n                // keep going unless we're at EOF or state only has one alt number\n                // mentioned in configs; check if something else could match\n                // TODO: don't we always stop? only lexer would keep going\n                // TODO: v3 dfa don't do this.\n                break;\n            }\n            // t is not updated if one of these states is reached\n            assert(!this.isAcceptState(s, state.useContext));\n            // if no edge, pop over to ATN interpreter, update DFA and return\n            let target = this.getExistingTargetState(s, t);\n            if (target == null) {\n                if (ParserATNSimulator.dfa_debug && t >= 0) {\n                    console.log(\"no edge for \" + this._parser.vocabulary.getDisplayName(t));\n                }\n                let alt;\n                if (ParserATNSimulator.dfa_debug) {\n                    let interval = Interval_1.Interval.of(startIndex, this._parser.inputStream.index);\n                    console.log(\"ATN exec upon \" +\n                        this._parser.inputStream.getText(interval) +\n                        \" at DFA state \" + s.stateNumber);\n                }\n                let initialState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\n                alt = this.execATN(dfa, input, startIndex, initialState);\n                if (ParserATNSimulator.dfa_debug) {\n                    console.log(\"back from DFA update, alt=\" + alt + \", dfa=\\n\" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\n                    //dump(dfa);\n                }\n                // action already executed\n                if (ParserATNSimulator.dfa_debug) {\n                    console.log(\"DFA decision \" + dfa.decision +\n                        \" predicts \" + alt);\n                }\n                return alt; // we've updated DFA, exec'd action, and have our deepest answer\n            }\n            else if (target === ATNSimulator_1.ATNSimulator.ERROR) {\n                let errorState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\n                return this.handleNoViableAlt(input, startIndex, errorState);\n            }\n            s = target;\n            if (!this.isAcceptState(s, state.useContext) && t !== IntStream_1.IntStream.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n        //\t\tif ( acceptState==null ) {\n        //\t\t\tif ( debug ) System.out.println(\"!!! no viable alt in dfa\");\n        //\t\t\treturn -1;\n        //\t\t}\n        if (!state.useContext && s.configs.conflictInfo != null) {\n            if (dfa.atnStartState instanceof DecisionState_1.DecisionState) {\n                if (!this.userWantsCtxSensitive ||\n                    (!s.configs.dipsIntoOuterContext && s.configs.isExactConflict) ||\n                    (this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex)) {\n                    // we don't report the ambiguity again\n                    //if ( !this.acceptState.configset.hasSemanticContext ) {\n                    // \tthis.reportAmbiguity(dfa, acceptState, startIndex, input.index, acceptState.configset.conflictingAlts, acceptState.configset);\n                    //}\n                }\n                else {\n                    assert(!state.useContext);\n                    // Before attempting full context prediction, check to see if there are\n                    // disambiguating or validating predicates to evaluate which allow an\n                    // immediate decision\n                    let conflictingAlts;\n                    let predicates = s.predicates;\n                    if (predicates != null) {\n                        let conflictIndex = input.index;\n                        if (conflictIndex !== startIndex) {\n                            input.seek(startIndex);\n                        }\n                        conflictingAlts = this.evalSemanticContext(predicates, outerContext, true);\n                        if (conflictingAlts.cardinality() === 1) {\n                            return conflictingAlts.nextSetBit(0);\n                        }\n                        if (conflictIndex !== startIndex) {\n                            // restore the index so reporting the fallback to full\n                            // context occurs with the index at the correct spot\n                            input.seek(conflictIndex);\n                        }\n                    }\n                    if (this.reportAmbiguities) {\n                        let conflictState = new SimulatorState_1.SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\n                        this.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);\n                    }\n                    input.seek(startIndex);\n                    return this.adaptivePredict(input, dfa.decision, outerContext, true);\n                }\n            }\n        }\n        // Before jumping to prediction, check to see if there are\n        // disambiguating or validating predicates to evaluate\n        let predicates = s.predicates;\n        if (predicates != null) {\n            let stopIndex = input.index;\n            if (startIndex !== stopIndex) {\n                input.seek(startIndex);\n            }\n            let alts = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION);\n            switch (alts.cardinality()) {\n                case 0:\n                    throw this.noViableAlt(input, outerContext, s.configs, startIndex);\n                case 1:\n                    return alts.nextSetBit(0);\n                default:\n                    // report ambiguity after predicate evaluation to make sure the correct\n                    // set of ambig alts is reported.\n                    if (startIndex !== stopIndex) {\n                        input.seek(stopIndex);\n                    }\n                    this.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);\n                    return alts.nextSetBit(0);\n            }\n        }\n        if (ParserATNSimulator.dfa_debug) {\n            console.log(\"DFA decision \" + dfa.decision +\n                \" predicts \" + s.prediction);\n        }\n        return s.prediction;\n    }\n    /**\n     * Determines if a particular DFA state should be treated as an accept state\n     * for the current prediction mode. In addition to the `useContext`\n     * parameter, the {@link #getPredictionMode()} method provides the\n     * prediction mode controlling the prediction algorithm as a whole.\n     *\n     * The default implementation simply returns the value of\n     * `DFAState.isAcceptState` except for conflict states when\n     * `useContext` is `true` and {@link #getPredictionMode()} is\n     * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}. In that case, only\n     * conflict states where {@link ATNConfigSet#isExactConflict} is\n     * `true` are considered accept states.\n     *\n     * @param state The DFA state to check.\n     * @param useContext `true` if the prediction algorithm is currently\n     * considering the full parser context; otherwise, `false` if the\n     * algorithm is currently performing a local context prediction.\n     *\n     * @returns `true` if the specified `state` is an accept state;\n     * otherwise, `false`.\n     */\n    isAcceptState(state, useContext) {\n        if (!state.isAcceptState) {\n            return false;\n        }\n        if (state.configs.conflictingAlts == null) {\n            // unambiguous\n            return true;\n        }\n        // More picky when we need exact conflicts\n        if (useContext && this.predictionMode === PredictionMode_1.PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n            return state.configs.isExactConflict;\n        }\n        return true;\n    }\n    /** Performs ATN simulation to compute a predicted alternative based\n     *  upon the remaining input, but also updates the DFA cache to avoid\n     *  having to traverse the ATN again for the same input sequence.\n     *\n     * There are some key conditions we're looking for after computing a new\n     * set of ATN configs (proposed DFA state):\n     *\n     * * if the set is empty, there is no viable alternative for current symbol\n     * * does the state uniquely predict an alternative?\n     * * does the state have a conflict that would prevent us from\n     *   putting it on the work list?\n     * * if in non-greedy decision is there a config at a rule stop state?\n     *\n     * We also have some key operations to do:\n     *\n     * * add an edge from previous DFA state to potentially new DFA state, D,\n     *   upon current symbol but only if adding to work list, which means in all\n     *   cases except no viable alternative (and possibly non-greedy decisions?)\n     * * collecting predicates and adding semantic context to DFA accept states\n     * * adding rule context to context-sensitive DFA accept states\n     * * consuming an input symbol\n     * * reporting a conflict\n     * * reporting an ambiguity\n     * * reporting a context sensitivity\n     * * reporting insufficient predicates\n     *\n     * We should isolate those operations, which are side-effecting, to the\n     * main work loop. We can isolate lots of code into other functions, but\n     * they should be side effect free. They can return package that\n     * indicates whether we should report something, whether we need to add a\n     * DFA edge, whether we need to augment accept state with semantic\n     * context or rule invocation context. Actually, it seems like we always\n     * add predicates if they exist, so that can simply be done in the main\n     * loop for any accept state creation or modification request.\n     *\n     * cover these cases:\n     *   dead end\n     *   single alt\n     *   single alt + preds\n     *   conflict\n     *   conflict + preds\n     *\n     * TODO: greedy + those\n     */\n    execATN(dfa, input, startIndex, initialState) {\n        if (ParserATNSimulator.debug) {\n            console.log(\"execATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input));\n        }\n        let outerContext = initialState.outerContext;\n        let useContext = initialState.useContext;\n        let t = input.LA(1);\n        let previous = initialState;\n        let contextCache = new PredictionContextCache_1.PredictionContextCache();\n        while (true) { // while more work\n            let nextState = this.computeReachSet(dfa, previous, t, contextCache);\n            if (nextState == null) {\n                this.setDFAEdge(previous.s0, input.LA(1), ATNSimulator_1.ATNSimulator.ERROR);\n                return this.handleNoViableAlt(input, startIndex, previous);\n            }\n            let D = nextState.s0;\n            // predicted alt => accept state\n            assert(D.isAcceptState || D.prediction === ATN_1.ATN.INVALID_ALT_NUMBER);\n            // conflicted => accept state\n            assert(D.isAcceptState || D.configs.conflictInfo == null);\n            if (this.isAcceptState(D, useContext)) {\n                let conflictingAlts = D.configs.conflictingAlts;\n                let predictedAlt = conflictingAlts == null ? D.prediction : ATN_1.ATN.INVALID_ALT_NUMBER;\n                if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n                    if (this.optimize_ll1\n                        && input.index === startIndex\n                        && !dfa.isPrecedenceDfa\n                        && nextState.outerContext === nextState.remainingOuterContext\n                        && dfa.decision >= 0\n                        && !D.configs.hasSemanticContext) {\n                        if (t >= 0 && t <= MAX_SHORT_VALUE) {\n                            let key = ((dfa.decision << 16) >>> 0) + t;\n                            this.atn.LL1Table.set(key, predictedAlt);\n                        }\n                    }\n                    if (useContext && this.always_try_local_context) {\n                        this.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);\n                    }\n                }\n                predictedAlt = D.prediction;\n                //\t\t\t\tint k = input.index - startIndex + 1; // how much input we used\n                //\t\t\t\tSystem.out.println(\"used k=\"+k);\n                let attemptFullContext = conflictingAlts != null && this.userWantsCtxSensitive;\n                if (attemptFullContext) {\n                    // Only exact conflicts are known to be ambiguous when local\n                    // prediction does not step out of the decision rule.\n                    attemptFullContext = !useContext\n                        && (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict)\n                        && (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);\n                }\n                if (D.configs.hasSemanticContext) {\n                    let predPredictions = D.predicates;\n                    if (predPredictions != null) {\n                        let conflictIndex = input.index;\n                        if (conflictIndex !== startIndex) {\n                            input.seek(startIndex);\n                        }\n                        // use complete evaluation here if we'll want to retry with full context if still ambiguous\n                        conflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);\n                        switch (conflictingAlts.cardinality()) {\n                            case 0:\n                                throw this.noViableAlt(input, outerContext, D.configs, startIndex);\n                            case 1:\n                                return conflictingAlts.nextSetBit(0);\n                            default:\n                                break;\n                        }\n                        if (conflictIndex !== startIndex) {\n                            // restore the index so reporting the fallback to full\n                            // context occurs with the index at the correct spot\n                            input.seek(conflictIndex);\n                        }\n                    }\n                }\n                if (!attemptFullContext) {\n                    if (conflictingAlts != null) {\n                        if (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {\n                            this.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);\n                        }\n                        predictedAlt = conflictingAlts.nextSetBit(0);\n                    }\n                    return predictedAlt;\n                }\n                else {\n                    assert(!useContext);\n                    assert(this.isAcceptState(D, false));\n                    if (ParserATNSimulator.debug) {\n                        console.log(\"RETRY with outerContext=\" + outerContext);\n                    }\n                    let fullContextState = this.computeStartState(dfa, outerContext, true);\n                    if (this.reportAmbiguities) {\n                        this.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);\n                    }\n                    input.seek(startIndex);\n                    return this.execATN(dfa, input, startIndex, fullContextState);\n                }\n            }\n            previous = nextState;\n            if (t !== IntStream_1.IntStream.EOF) {\n                input.consume();\n                t = input.LA(1);\n            }\n        }\n    }\n    /**\n     * This method is used to improve the localization of error messages by\n     * choosing an alternative rather than throwing a\n     * {@link NoViableAltException} in particular prediction scenarios where the\n     * {@link #ERROR} state was reached during ATN simulation.\n     *\n     * The default implementation of this method uses the following\n     * algorithm to identify an ATN configuration which successfully parsed the\n     * decision entry rule. Choosing such an alternative ensures that the\n     * {@link ParserRuleContext} returned by the calling rule will be complete\n     * and valid, and the syntax error will be reported later at a more\n     * localized location.\n     *\n     * * If no configuration in `configs` reached the end of the\n     *   decision rule, return {@link ATN#INVALID_ALT_NUMBER}.\n     * * If all configurations in `configs` which reached the end of the\n     *   decision rule predict the same alternative, return that alternative.\n     * * If the configurations in `configs` which reached the end of the\n     *   decision rule predict multiple alternatives (call this *S*),\n     *   choose an alternative in the following order.\n     *\n     *     1. Filter the configurations in `configs` to only those\n     *        configurations which remain viable after evaluating semantic predicates.\n     *        If the set of these filtered configurations which also reached the end of\n     *        the decision rule is not empty, return the minimum alternative\n     *        represented in this set.\n     *     1. Otherwise, choose the minimum alternative in *S*.\n     *\n     * In some scenarios, the algorithm described above could predict an\n     * alternative which will result in a {@link FailedPredicateException} in\n     * parser. Specifically, this could occur if the *only* configuration\n     * capable of successfully parsing to the end of the decision rule is\n     * blocked by a semantic predicate. By choosing this alternative within\n     * {@link #adaptivePredict} instead of throwing a\n     * {@link NoViableAltException}, the resulting\n     * {@link FailedPredicateException} in the parser will identify the specific\n     * predicate which is preventing the parser from successfully parsing the\n     * decision rule, which helps developers identify and correct logic errors\n     * in semantic predicates.\n     *\n     * @param input The input {@link TokenStream}\n     * @param startIndex The start index for the current prediction, which is\n     * the input index where any semantic context in `configs` should be\n     * evaluated\n     * @param previous The ATN simulation state immediately before the\n     * {@link #ERROR} state was reached\n     *\n     * @returns The value to return from {@link #adaptivePredict}, or\n     * {@link ATN#INVALID_ALT_NUMBER} if a suitable alternative was not\n     * identified and {@link #adaptivePredict} should report an error instead.\n     */\n    handleNoViableAlt(input, startIndex, previous) {\n        if (previous.s0 != null) {\n            let alts = new BitSet_1.BitSet();\n            let maxAlt = 0;\n            for (let config of previous.s0.configs) {\n                if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {\n                    alts.set(config.alt);\n                    maxAlt = Math.max(maxAlt, config.alt);\n                }\n            }\n            switch (alts.cardinality()) {\n                case 0:\n                    break;\n                case 1:\n                    return alts.nextSetBit(0);\n                default:\n                    if (!previous.s0.configs.hasSemanticContext) {\n                        // configs doesn't contain any predicates, so the predicate\n                        // filtering code below would be pointless\n                        return alts.nextSetBit(0);\n                    }\n                    /*\n                     * Try to find a configuration set that not only dipped into the outer\n                     * context, but also isn't eliminated by a predicate.\n                     */\n                    let filteredConfigs = new ATNConfigSet_1.ATNConfigSet();\n                    for (let config of previous.s0.configs) {\n                        if (config.reachesIntoOuterContext || config.state instanceof RuleStopState_1.RuleStopState) {\n                            filteredConfigs.add(config);\n                        }\n                    }\n                    /* The following code blocks are adapted from predicateDFAState with\n                     * the following key changes.\n                     *\n                     *  1. The code operates on an ATNConfigSet rather than a DFAState.\n                     *  2. Predicates are collected for all alternatives represented in\n                     *     filteredConfigs, rather than restricting the evaluation to\n                     *     conflicting and/or unique configurations.\n                     */\n                    let altToPred = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);\n                    if (altToPred != null) {\n                        let predicates = this.getPredicatePredictions(alts, altToPred);\n                        if (predicates != null) {\n                            let stopIndex = input.index;\n                            try {\n                                input.seek(startIndex);\n                                let filteredAlts = this.evalSemanticContext(predicates, previous.outerContext, false);\n                                if (!filteredAlts.isEmpty) {\n                                    return filteredAlts.nextSetBit(0);\n                                }\n                            }\n                            finally {\n                                input.seek(stopIndex);\n                            }\n                        }\n                    }\n                    return alts.nextSetBit(0);\n            }\n        }\n        throw this.noViableAlt(input, previous.outerContext, previous.s0.configs, startIndex);\n    }\n    computeReachSet(dfa, previous, t, contextCache) {\n        let useContext = previous.useContext;\n        let remainingGlobalContext = previous.remainingOuterContext;\n        let s = previous.s0;\n        if (useContext) {\n            while (s.isContextSymbol(t)) {\n                let next;\n                if (remainingGlobalContext != null) {\n                    remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n                    next = s.getContextTarget(this.getReturnState(remainingGlobalContext));\n                }\n                if (next == null) {\n                    break;\n                }\n                assert(remainingGlobalContext != null);\n                remainingGlobalContext = remainingGlobalContext.parent;\n                s = next;\n            }\n        }\n        assert(!this.isAcceptState(s, useContext));\n        if (this.isAcceptState(s, useContext)) {\n            return new SimulatorState_1.SimulatorState(previous.outerContext, s, useContext, remainingGlobalContext);\n        }\n        let s0 = s;\n        let target = this.getExistingTargetState(s0, t);\n        if (target == null) {\n            let result = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);\n            target = result[0];\n            remainingGlobalContext = result[1];\n        }\n        if (target === ATNSimulator_1.ATNSimulator.ERROR) {\n            return undefined;\n        }\n        assert(!useContext || !target.configs.dipsIntoOuterContext);\n        return new SimulatorState_1.SimulatorState(previous.outerContext, target, useContext, remainingGlobalContext);\n    }\n    /**\n     * Get an existing target state for an edge in the DFA. If the target state\n     * for the edge has not yet been computed or is otherwise not available,\n     * this method returns `undefined`.\n     *\n     * @param s The current DFA state\n     * @param t The next input symbol\n     * @returns The existing target DFA state for the given input symbol\n     * `t`, or `undefined` if the target state for this edge is not\n     * already cached\n     */\n    getExistingTargetState(s, t) {\n        return s.getTarget(t);\n    }\n    /**\n     * Compute a target state for an edge in the DFA, and attempt to add the\n     * computed state and corresponding edge to the DFA.\n     *\n     * @param dfa\n     * @param s The current DFA state\n     * @param remainingGlobalContext\n     * @param t The next input symbol\n     * @param useContext\n     * @param contextCache\n     *\n     * @returns The computed target DFA state for the given input symbol\n     * `t`. If `t` does not lead to a valid DFA state, this method\n     * returns {@link #ERROR}.\n     */\n    computeTargetState(dfa, s, remainingGlobalContext, t, useContext, contextCache) {\n        let closureConfigs = s.configs.toArray();\n        let contextElements;\n        let reach = new ATNConfigSet_1.ATNConfigSet();\n        let stepIntoGlobal;\n        do {\n            let hasMoreContext = !useContext || remainingGlobalContext != null;\n            if (!hasMoreContext) {\n                reach.isOutermostConfigSet = true;\n            }\n            let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();\n            /* Configurations already in a rule stop state indicate reaching the end\n             * of the decision rule (local context) or end of the start rule (full\n             * context). Once reached, these configurations are never updated by a\n             * closure operation, so they are handled separately for the performance\n             * advantage of having a smaller intermediate set when calling closure.\n             *\n             * For full-context reach operations, separate handling is required to\n             * ensure that the alternative matching the longest overall sequence is\n             * chosen when multiple such configurations can match the input.\n             */\n            let skippedStopStates;\n            for (let c of closureConfigs) {\n                if (ParserATNSimulator.debug) {\n                    console.log(\"testing \" + this.getTokenName(t) + \" at \" + c.toString());\n                }\n                if (c.state instanceof RuleStopState_1.RuleStopState) {\n                    assert(c.context.isEmpty);\n                    if (useContext && !c.reachesIntoOuterContext || t === IntStream_1.IntStream.EOF) {\n                        if (skippedStopStates == null) {\n                            skippedStopStates = [];\n                        }\n                        skippedStopStates.push(c);\n                    }\n                    continue;\n                }\n                let n = c.state.numberOfOptimizedTransitions;\n                for (let ti = 0; ti < n; ti++) { // for each optimized transition\n                    let trans = c.state.getOptimizedTransition(ti);\n                    let target = this.getReachableTarget(c, trans, t);\n                    if (target != null) {\n                        reachIntermediate.add(c.transform(target, false), contextCache);\n                    }\n                }\n            }\n            /* This block optimizes the reach operation for intermediate sets which\n             * trivially indicate a termination state for the overall\n             * adaptivePredict operation.\n             *\n             * The conditions assume that intermediate\n             * contains all configurations relevant to the reach set, but this\n             * condition is not true when one or more configurations have been\n             * withheld in skippedStopStates, or when the current symbol is EOF.\n             */\n            if (this.optimize_unique_closure && skippedStopStates == null && t !== Token_1.Token.EOF && reachIntermediate.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n                reachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;\n                reach = reachIntermediate;\n                break;\n            }\n            /* If the reach set could not be trivially determined, perform a closure\n             * operation on the intermediate set to compute its initial value.\n             */\n            let collectPredicates = false;\n            let treatEofAsEpsilon = t === Token_1.Token.EOF;\n            this.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);\n            stepIntoGlobal = reach.dipsIntoOuterContext;\n            if (t === IntStream_1.IntStream.EOF) {\n                /* After consuming EOF no additional input is possible, so we are\n                 * only interested in configurations which reached the end of the\n                 * decision rule (local context) or end of the start rule (full\n                 * context). Update reach to contain only these configurations. This\n                 * handles both explicit EOF transitions in the grammar and implicit\n                 * EOF transitions following the end of the decision or start rule.\n                 *\n                 * This is handled before the configurations in skippedStopStates,\n                 * because any configurations potentially added from that list are\n                 * already guaranteed to meet this condition whether or not it's\n                 * required.\n                 */\n                reach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);\n            }\n            /* If skippedStopStates is not undefined, then it contains at least one\n             * configuration. For full-context reach operations, these\n             * configurations reached the end of the start rule, in which case we\n             * only add them back to reach if no configuration during the current\n             * closure operation reached such a state. This ensures adaptivePredict\n             * chooses an alternative matching the longest overall sequence when\n             * multiple alternatives are viable.\n             */\n            if (skippedStopStates != null && (!useContext || !PredictionMode_1.PredictionMode.hasConfigInRuleStopState(reach))) {\n                assert(skippedStopStates.length > 0);\n                for (let c of skippedStopStates) {\n                    reach.add(c, contextCache);\n                }\n            }\n            if (useContext && stepIntoGlobal) {\n                reach.clear();\n                // We know remainingGlobalContext is not undefined at this point (why?)\n                remainingGlobalContext = remainingGlobalContext;\n                remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n                let nextContextElement = this.getReturnState(remainingGlobalContext);\n                if (contextElements == null) {\n                    contextElements = new IntegerList_1.IntegerList();\n                }\n                if (remainingGlobalContext.isEmpty) {\n                    remainingGlobalContext = undefined;\n                }\n                else {\n                    remainingGlobalContext = remainingGlobalContext.parent;\n                }\n                contextElements.add(nextContextElement);\n                if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n                    for (let i = 0; i < closureConfigs.length; i++) {\n                        closureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);\n                    }\n                }\n            }\n        } while (useContext && stepIntoGlobal);\n        if (reach.isEmpty) {\n            this.setDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);\n            return [ATNSimulator_1.ATNSimulator.ERROR, remainingGlobalContext];\n        }\n        let result = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);\n        return [result, remainingGlobalContext];\n    }\n    /**\n     * Return a configuration set containing only the configurations from\n     * `configs` which are in a {@link RuleStopState}. If all\n     * configurations in `configs` are already in a rule stop state, this\n     * method simply returns `configs`.\n     *\n     * @param configs the configuration set to update\n     * @param contextCache the {@link PredictionContext} cache\n     *\n     * @returns `configs` if all configurations in `configs` are in a\n     * rule stop state, otherwise return a new configuration set containing only\n     * the configurations from `configs` which are in a rule stop state\n     */\n    removeAllConfigsNotInRuleStopState(configs, contextCache) {\n        if (PredictionMode_1.PredictionMode.allConfigsInRuleStopStates(configs)) {\n            return configs;\n        }\n        let result = new ATNConfigSet_1.ATNConfigSet();\n        for (let config of configs) {\n            if (!(config.state instanceof RuleStopState_1.RuleStopState)) {\n                continue;\n            }\n            result.add(config, contextCache);\n        }\n        return result;\n    }\n    computeStartState(dfa, globalContext, useContext) {\n        let s0 = dfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) :\n            useContext ? dfa.s0full :\n                dfa.s0;\n        if (s0 != null) {\n            if (!useContext) {\n                return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, globalContext);\n            }\n            s0.setContextSensitive(this.atn);\n        }\n        let decision = dfa.decision;\n        // @NotNull\n        let p = dfa.atnStartState;\n        let previousContext = 0;\n        let remainingGlobalContext = globalContext;\n        let initialContext = useContext ? PredictionContext_1.PredictionContext.EMPTY_FULL : PredictionContext_1.PredictionContext.EMPTY_LOCAL; // always at least the implicit call to start rule\n        let contextCache = new PredictionContextCache_1.PredictionContextCache();\n        if (useContext) {\n            if (!this.enable_global_context_dfa) {\n                while (remainingGlobalContext != null) {\n                    if (remainingGlobalContext.isEmpty) {\n                        previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;\n                        remainingGlobalContext = undefined;\n                    }\n                    else {\n                        previousContext = this.getReturnState(remainingGlobalContext);\n                        initialContext = initialContext.appendSingleContext(previousContext, contextCache);\n                        remainingGlobalContext = remainingGlobalContext.parent;\n                    }\n                }\n            }\n            while (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {\n                let next;\n                remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n                if (remainingGlobalContext.isEmpty) {\n                    next = s0.getContextTarget(PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY);\n                    previousContext = PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;\n                    remainingGlobalContext = undefined;\n                }\n                else {\n                    previousContext = this.getReturnState(remainingGlobalContext);\n                    next = s0.getContextTarget(previousContext);\n                    initialContext = initialContext.appendSingleContext(previousContext, contextCache);\n                    remainingGlobalContext = remainingGlobalContext.parent;\n                }\n                if (next == null) {\n                    break;\n                }\n                s0 = next;\n            }\n        }\n        if (s0 != null && !s0.isContextSensitive) {\n            return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);\n        }\n        let configs = new ATNConfigSet_1.ATNConfigSet();\n        while (true) {\n            let reachIntermediate = new ATNConfigSet_1.ATNConfigSet();\n            let n = p.numberOfTransitions;\n            for (let ti = 0; ti < n; ti++) {\n                // for each transition\n                let target = p.transition(ti).target;\n                reachIntermediate.add(ATNConfig_1.ATNConfig.create(target, ti + 1, initialContext));\n            }\n            let hasMoreContext = remainingGlobalContext != null;\n            if (!hasMoreContext) {\n                configs.isOutermostConfigSet = true;\n            }\n            let collectPredicates = true;\n            this.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);\n            let stepIntoGlobal = configs.dipsIntoOuterContext;\n            let next;\n            if (useContext && !this.enable_global_context_dfa) {\n                s0 = this.addDFAState(dfa, configs, contextCache);\n                break;\n            }\n            else if (s0 == null) {\n                if (!dfa.isPrecedenceDfa) {\n                    next = this.addDFAState(dfa, configs, contextCache);\n                    if (useContext) {\n                        if (!dfa.s0full) {\n                            dfa.s0full = next;\n                        }\n                        else {\n                            next = dfa.s0full;\n                        }\n                    }\n                    else {\n                        if (!dfa.s0) {\n                            dfa.s0 = next;\n                        }\n                        else {\n                            next = dfa.s0;\n                        }\n                    }\n                }\n                else {\n                    /* If this is a precedence DFA, we use applyPrecedenceFilter\n                     * to convert the computed start state to a precedence start\n                     * state. We then use DFA.setPrecedenceStartState to set the\n                     * appropriate start state for the precedence level rather\n                     * than simply setting DFA.s0.\n                     */\n                    configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);\n                    next = this.addDFAState(dfa, configs, contextCache);\n                    dfa.setPrecedenceStartState(this._parser.precedence, useContext, next);\n                }\n            }\n            else {\n                if (dfa.isPrecedenceDfa) {\n                    configs = this.applyPrecedenceFilter(configs, globalContext, contextCache);\n                }\n                next = this.addDFAState(dfa, configs, contextCache);\n                s0.setContextTarget(previousContext, next);\n            }\n            s0 = next;\n            if (!useContext || !stepIntoGlobal) {\n                break;\n            }\n            // TODO: make sure it distinguishes empty stack states\n            next.setContextSensitive(this.atn);\n            // We know remainingGlobalContext is not undefined at this point (why?)\n            remainingGlobalContext = remainingGlobalContext;\n            configs.clear();\n            remainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n            let nextContextElement = this.getReturnState(remainingGlobalContext);\n            if (remainingGlobalContext.isEmpty) {\n                remainingGlobalContext = undefined;\n            }\n            else {\n                remainingGlobalContext = remainingGlobalContext.parent;\n            }\n            if (nextContextElement !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n                initialContext = initialContext.appendSingleContext(nextContextElement, contextCache);\n            }\n            previousContext = nextContextElement;\n        }\n        return new SimulatorState_1.SimulatorState(globalContext, s0, useContext, remainingGlobalContext);\n    }\n    /**\n     * This method transforms the start state computed by\n     * {@link #computeStartState} to the special start state used by a\n     * precedence DFA for a particular precedence value. The transformation\n     * process applies the following changes to the start state's configuration\n     * set.\n     *\n     * 1. Evaluate the precedence predicates for each configuration using\n     *    {@link SemanticContext#evalPrecedence}.\n     * 1. When {@link ATNConfig#isPrecedenceFilterSuppressed} is `false`,\n     *    remove all configurations which predict an alternative greater than 1,\n     *    for which another configuration that predicts alternative 1 is in the\n     *    same ATN state with the same prediction context. This transformation is\n     *    valid for the following reasons:\n     *\n     *     * The closure block cannot contain any epsilon transitions which bypass\n     *       the body of the closure, so all states reachable via alternative 1 are\n     *       part of the precedence alternatives of the transformed left-recursive\n     *       rule.\n     *     * The \"primary\" portion of a left recursive rule cannot contain an\n     *       epsilon transition, so the only way an alternative other than 1 can exist\n     *       in a state that is also reachable via alternative 1 is by nesting calls\n     *       to the left-recursive rule, with the outer calls not being at the\n     *       preferred precedence level. The\n     *       {@link ATNConfig#isPrecedenceFilterSuppressed} property marks ATN\n     *       configurations which do not meet this condition, and therefore are not\n     *       eligible for elimination during the filtering process.\n     *\n     * The prediction context must be considered by this filter to address\n     * situations like the following.\n     *\n     * ```antlr\n     * grammar TA;\n     * prog: statement* EOF;\n     * statement: letterA | statement letterA 'b' ;\n     * letterA: 'a';\n     * ```\n     *\n     * If the above grammar, the ATN state immediately before the token\n     * reference `'a'` in `letterA` is reachable from the left edge\n     * of both the primary and closure blocks of the left-recursive rule\n     * `statement`. The prediction context associated with each of these\n     * configurations distinguishes between them, and prevents the alternative\n     * which stepped out to `prog` (and then back in to `statement`\n     * from being eliminated by the filter.\n     *\n     * @param configs The configuration set computed by\n     * {@link #computeStartState} as the start state for the DFA.\n     * @returns The transformed configuration set representing the start state\n     * for a precedence DFA at a particular precedence level (determined by\n     * calling {@link Parser#getPrecedence}).\n     */\n    applyPrecedenceFilter(configs, globalContext, contextCache) {\n        let statesFromAlt1 = new Map();\n        let configSet = new ATNConfigSet_1.ATNConfigSet();\n        for (let config of configs) {\n            // handle alt 1 first\n            if (config.alt !== 1) {\n                continue;\n            }\n            let updatedContext = config.semanticContext.evalPrecedence(this._parser, globalContext);\n            if (updatedContext == null) {\n                // the configuration was eliminated\n                continue;\n            }\n            statesFromAlt1.set(config.state.stateNumber, config.context);\n            if (updatedContext !== config.semanticContext) {\n                configSet.add(config.transform(config.state, false, updatedContext), contextCache);\n            }\n            else {\n                configSet.add(config, contextCache);\n            }\n        }\n        for (let config of configs) {\n            if (config.alt === 1) {\n                // already handled\n                continue;\n            }\n            if (!config.isPrecedenceFilterSuppressed) {\n                /* In the future, this elimination step could be updated to also\n                 * filter the prediction context for alternatives predicting alt>1\n                 * (basically a graph subtraction algorithm).\n                 */\n                let context = statesFromAlt1.get(config.state.stateNumber);\n                if (context != null && context.equals(config.context)) {\n                    // eliminated\n                    continue;\n                }\n            }\n            configSet.add(config, contextCache);\n        }\n        return configSet;\n    }\n    getReachableTarget(source, trans, ttype) {\n        if (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n            return trans.target;\n        }\n        return undefined;\n    }\n    /** collect and set D's semantic context */\n    predicateDFAState(D, configs, nalts) {\n        let conflictingAlts = this.getConflictingAltsFromConfigSet(configs);\n        if (!conflictingAlts) {\n            throw new Error(\"This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.\");\n        }\n        if (ParserATNSimulator.debug) {\n            console.log(\"predicateDFAState \" + D);\n        }\n        let altToPred = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);\n        // altToPred[uniqueAlt] is now our validating predicate (if any)\n        let predPredictions;\n        if (altToPred != null) {\n            // we have a validating predicate; test it\n            // Update DFA so reach becomes accept state with predicate\n            predPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);\n            D.predicates = predPredictions;\n        }\n        return predPredictions;\n    }\n    getPredsForAmbigAlts(ambigAlts, configs, nalts) {\n        // REACH=[1|1|[]|0:0, 1|2|[]|0:1]\n        /* altToPred starts as an array of all undefined contexts. The entry at index i\n         * corresponds to alternative i. altToPred[i] may have one of three values:\n         *   1. undefined: no ATNConfig c is found such that c.alt===i\n         *   2. SemanticContext.NONE: At least one ATNConfig c exists such that\n         *      c.alt===i and c.semanticContext===SemanticContext.NONE. In other words,\n         *      alt i has at least one unpredicated config.\n         *   3. Non-NONE Semantic Context: There exists at least one, and for all\n         *      ATNConfig c such that c.alt===i, c.semanticContext!==SemanticContext.NONE.\n         *\n         * From this, it is clear that NONE||anything==NONE.\n         */\n        let altToPred = new Array(nalts + 1);\n        let n = altToPred.length;\n        for (let c of configs) {\n            if (ambigAlts.get(c.alt)) {\n                altToPred[c.alt] = SemanticContext_1.SemanticContext.or(altToPred[c.alt], c.semanticContext);\n            }\n        }\n        let nPredAlts = 0;\n        for (let i = 0; i < n; i++) {\n            if (altToPred[i] == null) {\n                altToPred[i] = SemanticContext_1.SemanticContext.NONE;\n            }\n            else if (altToPred[i] !== SemanticContext_1.SemanticContext.NONE) {\n                nPredAlts++;\n            }\n        }\n        // At this point we know `altToPred` doesn't contain any undefined entries\n        let result = altToPred;\n        // nonambig alts are undefined in result\n        if (nPredAlts === 0) {\n            result = undefined;\n        }\n        if (ParserATNSimulator.debug) {\n            console.log(\"getPredsForAmbigAlts result \" + (result ? Arrays_1.Arrays.toString(result) : \"undefined\"));\n        }\n        return result;\n    }\n    getPredicatePredictions(ambigAlts, altToPred) {\n        let pairs = [];\n        let containsPredicate = false;\n        for (let i = 1; i < altToPred.length; i++) {\n            let pred = altToPred[i];\n            // unpredicated is indicated by SemanticContext.NONE\n            assert(pred != null);\n            // find first unpredicated but ambig alternative, if any.\n            // Only ambiguous alternatives will have SemanticContext.NONE.\n            // Any unambig alts or ambig naked alts after first ambig naked are ignored\n            // (undefined, i) means alt i is the default prediction\n            // if no (undefined, i), then no default prediction.\n            if (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext_1.SemanticContext.NONE) {\n                pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));\n            }\n            else if (pred !== SemanticContext_1.SemanticContext.NONE) {\n                containsPredicate = true;\n                pairs.push(new DFAState_1.DFAState.PredPrediction(pred, i));\n            }\n        }\n        if (!containsPredicate) {\n            return undefined;\n        }\n        //\t\tSystem.out.println(Arrays.toString(altToPred)+\"->\"+pairs);\n        return pairs;\n    }\n    /** Look through a list of predicate/alt pairs, returning alts for the\n     *  pairs that win. An `undefined` predicate indicates an alt containing an\n     *  unpredicated config which behaves as \"always true.\"\n     */\n    evalSemanticContext(predPredictions, outerContext, complete) {\n        let predictions = new BitSet_1.BitSet();\n        for (let pair of predPredictions) {\n            if (pair.pred === SemanticContext_1.SemanticContext.NONE) {\n                predictions.set(pair.alt);\n                if (!complete) {\n                    break;\n                }\n                continue;\n            }\n            let evaluatedResult = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);\n            if (ParserATNSimulator.debug || ParserATNSimulator.dfa_debug) {\n                console.log(\"eval pred \" + pair + \"=\" + evaluatedResult);\n            }\n            if (evaluatedResult) {\n                if (ParserATNSimulator.debug || ParserATNSimulator.dfa_debug) {\n                    console.log(\"PREDICT \" + pair.alt);\n                }\n                predictions.set(pair.alt);\n                if (!complete) {\n                    break;\n                }\n            }\n        }\n        return predictions;\n    }\n    /**\n     * Evaluate a semantic context within a specific parser context.\n     *\n     * This method might not be called for every semantic context evaluated\n     * during the prediction process. In particular, we currently do not\n     * evaluate the following but it may change in the future:\n     *\n     * * Precedence predicates (represented by\n     *   {@link SemanticContext.PrecedencePredicate}) are not currently evaluated\n     *   through this method.\n     * * Operator predicates (represented by {@link SemanticContext.AND} and\n     *   {@link SemanticContext.OR}) are evaluated as a single semantic\n     *   context, rather than evaluating the operands individually.\n     *   Implementations which require evaluation results from individual\n     *   predicates should override this method to explicitly handle evaluation of\n     *   the operands within operator predicates.\n     *\n     * @param pred The semantic context to evaluate\n     * @param parserCallStack The parser context in which to evaluate the\n     * semantic context\n     * @param alt The alternative which is guarded by `pred`\n     *\n     * @since 4.3\n     */\n    evalSemanticContextImpl(pred, parserCallStack, alt) {\n        return pred.eval(this._parser, parserCallStack);\n    }\n    /* TODO: If we are doing predicates, there is no point in pursuing\n         closure operations if we reach a DFA state that uniquely predicts\n         alternative. We will not be caching that DFA state and it is a\n         waste to pursue the closure. Might have to advance when we do\n         ambig detection thought :(\n          */\n    closure(sourceConfigs, configs, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon) {\n        if (contextCache == null) {\n            contextCache = PredictionContextCache_1.PredictionContextCache.UNCACHED;\n        }\n        let currentConfigs = sourceConfigs;\n        let closureBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n        while (currentConfigs.size > 0) {\n            let intermediate = new ATNConfigSet_1.ATNConfigSet();\n            for (let config of currentConfigs) {\n                this.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);\n            }\n            currentConfigs = intermediate;\n        }\n    }\n    closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth, treatEofAsEpsilon) {\n        if (ParserATNSimulator.debug) {\n            console.log(\"closure(\" + config.toString(this._parser, true) + \")\");\n        }\n        if (config.state instanceof RuleStopState_1.RuleStopState) {\n            // We hit rule end. If we have context info, use it\n            if (!config.context.isEmpty) {\n                let hasEmpty = config.context.hasEmpty;\n                let nonEmptySize = config.context.size - (hasEmpty ? 1 : 0);\n                for (let i = 0; i < nonEmptySize; i++) {\n                    let newContext = config.context.getParent(i); // \"pop\" return state\n                    let returnState = this.atn.states[config.context.getReturnState(i)];\n                    let c = ATNConfig_1.ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);\n                    // While we have context to pop back from, we may have\n                    // gotten that context AFTER having fallen off a rule.\n                    // Make sure we track that we are now out of context.\n                    c.outerContextDepth = config.outerContextDepth;\n                    c.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;\n                    assert(depth > MIN_INTEGER_VALUE);\n                    this.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);\n                }\n                if (!hasEmpty || !hasMoreContexts) {\n                    return;\n                }\n                config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);\n            }\n            else if (!hasMoreContexts) {\n                configs.add(config, contextCache);\n                return;\n            }\n            else {\n                // else if we have no context info, just chase follow links (if greedy)\n                if (ParserATNSimulator.debug) {\n                    console.log(\"FALLING off rule \" +\n                        this.getRuleName(config.state.ruleIndex));\n                }\n                if (config.context === PredictionContext_1.PredictionContext.EMPTY_FULL) {\n                    // no need to keep full context overhead when we step out\n                    config = config.transform(config.state, false, PredictionContext_1.PredictionContext.EMPTY_LOCAL);\n                }\n                else if (!config.reachesIntoOuterContext && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {\n                    // add stop state when leaving decision rule for the first time\n                    configs.add(config, contextCache);\n                }\n            }\n        }\n        let p = config.state;\n        // optimization\n        if (!p.onlyHasEpsilonTransitions) {\n            configs.add(config, contextCache);\n            // make sure to not return here, because EOF transitions can act as\n            // both epsilon transitions and non-epsilon transitions.\n            if (ParserATNSimulator.debug) {\n                console.log(\"added config \" + configs);\n            }\n        }\n        for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {\n            // This block implements first-edge elimination of ambiguous LR\n            // alternatives as part of dynamic disambiguation during prediction.\n            // See antlr/antlr4#1398.\n            if (i === 0\n                && p.stateType === ATNStateType_1.ATNStateType.STAR_LOOP_ENTRY\n                && p.precedenceRuleDecision\n                && !config.context.hasEmpty) {\n                let precedenceDecision = p;\n                // When suppress is true, it means the outgoing edge i==0 is\n                // ambiguous with the outgoing edge i==1, and thus the closure\n                // operation can dynamically disambiguate by suppressing this\n                // edge during the closure operation.\n                let suppress = true;\n                for (let j = 0; j < config.context.size; j++) {\n                    if (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {\n                        suppress = false;\n                        break;\n                    }\n                }\n                if (suppress) {\n                    continue;\n                }\n            }\n            let t = p.getOptimizedTransition(i);\n            let continueCollecting = !(t instanceof ActionTransition_1.ActionTransition) && collectPredicates;\n            let c = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);\n            if (c != null) {\n                if (t instanceof RuleTransition_1.RuleTransition) {\n                    if (intermediate != null && !collectPredicates) {\n                        intermediate.add(c, contextCache);\n                        continue;\n                    }\n                }\n                let newDepth = depth;\n                if (config.state instanceof RuleStopState_1.RuleStopState) {\n                    // target fell off end of rule; mark resulting c as having dipped into outer context\n                    // We can't get here if incoming config was rule stop and we had context\n                    // track how far we dip into outer context.  Might\n                    // come in handy and we avoid evaluating context dependent\n                    // preds if this is > 0.\n                    if (this.dfa != null && this.dfa.isPrecedenceDfa) {\n                        let outermostPrecedenceReturn = t.outermostPrecedenceReturn;\n                        if (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {\n                            c.isPrecedenceFilterSuppressed = true;\n                        }\n                    }\n                    c.outerContextDepth = c.outerContextDepth + 1;\n                    if (!closureBusy.add(c)) {\n                        // avoid infinite recursion for right-recursive rules\n                        continue;\n                    }\n                    assert(newDepth > MIN_INTEGER_VALUE);\n                    newDepth--;\n                    if (ParserATNSimulator.debug) {\n                        console.log(\"dips into outer ctx: \" + c);\n                    }\n                }\n                else if (t instanceof RuleTransition_1.RuleTransition) {\n                    if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {\n                        assert(c.context === config.context);\n                        if (newDepth === 0) {\n                            // the pop/push of a tail call would keep the depth\n                            // constant, except we latch if it goes negative\n                            newDepth--;\n                            if (!this.tail_call_preserves_sll && PredictionContext_1.PredictionContext.isEmptyLocal(config.context)) {\n                                // make sure the SLL config \"dips into the outer context\" or prediction may not fall back to LL on conflict\n                                c.outerContextDepth = c.outerContextDepth + 1;\n                            }\n                        }\n                    }\n                    else {\n                        // latch when newDepth goes negative - once we step out of the entry context we can't return\n                        if (newDepth >= 0) {\n                            newDepth++;\n                        }\n                    }\n                }\n                else {\n                    if (!t.isEpsilon && !closureBusy.add(c)) {\n                        // avoid infinite recursion for EOF* and EOF+\n                        continue;\n                    }\n                }\n                this.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);\n            }\n        }\n    }\n    getRuleName(index) {\n        if (this._parser != null && index >= 0) {\n            return this._parser.ruleNames[index];\n        }\n        return \"<rule \" + index + \">\";\n    }\n    getEpsilonTarget(config, t, collectPredicates, inContext, contextCache, treatEofAsEpsilon) {\n        switch (t.serializationType) {\n            case 3 /* RULE */:\n                return this.ruleTransition(config, t, contextCache);\n            case 10 /* PRECEDENCE */:\n                return this.precedenceTransition(config, t, collectPredicates, inContext);\n            case 4 /* PREDICATE */:\n                return this.predTransition(config, t, collectPredicates, inContext);\n            case 6 /* ACTION */:\n                return this.actionTransition(config, t);\n            case 1 /* EPSILON */:\n                return config.transform(t.target, false);\n            case 5 /* ATOM */:\n            case 2 /* RANGE */:\n            case 7 /* SET */:\n                // EOF transitions act like epsilon transitions after the first EOF\n                // transition is traversed\n                if (treatEofAsEpsilon) {\n                    if (t.matches(Token_1.Token.EOF, 0, 1)) {\n                        return config.transform(t.target, false);\n                    }\n                }\n                return undefined;\n            default:\n                return undefined;\n        }\n    }\n    actionTransition(config, t) {\n        if (ParserATNSimulator.debug) {\n            console.log(\"ACTION edge \" + t.ruleIndex + \":\" + t.actionIndex);\n        }\n        return config.transform(t.target, false);\n    }\n    precedenceTransition(config, pt, collectPredicates, inContext) {\n        if (ParserATNSimulator.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n                pt.precedence + \">=_p\" +\n                \", ctx dependent=true\");\n            if (this._parser != null) {\n                console.log(\"context surrounding pred is \" +\n                    this._parser.getRuleInvocationStack());\n            }\n        }\n        let c;\n        if (collectPredicates && inContext) {\n            let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);\n            c = config.transform(pt.target, false, newSemCtx);\n        }\n        else {\n            c = config.transform(pt.target, false);\n        }\n        if (ParserATNSimulator.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n    predTransition(config, pt, collectPredicates, inContext) {\n        if (ParserATNSimulator.debug) {\n            console.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n                pt.ruleIndex + \":\" + pt.predIndex +\n                \", ctx dependent=\" + pt.isCtxDependent);\n            if (this._parser != null) {\n                console.log(\"context surrounding pred is \" +\n                    this._parser.getRuleInvocationStack());\n            }\n        }\n        let c;\n        if (collectPredicates &&\n            (!pt.isCtxDependent || (pt.isCtxDependent && inContext))) {\n            let newSemCtx = SemanticContext_1.SemanticContext.and(config.semanticContext, pt.predicate);\n            c = config.transform(pt.target, false, newSemCtx);\n        }\n        else {\n            c = config.transform(pt.target, false);\n        }\n        if (ParserATNSimulator.debug) {\n            console.log(\"config from pred transition=\" + c);\n        }\n        return c;\n    }\n    ruleTransition(config, t, contextCache) {\n        if (ParserATNSimulator.debug) {\n            console.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) +\n                \", ctx=\" + config.context);\n        }\n        let returnState = t.followState;\n        let newContext;\n        if (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext_1.PredictionContext.isEmptyLocal(config.context))) {\n            newContext = config.context;\n        }\n        else if (contextCache != null) {\n            newContext = contextCache.getChild(config.context, returnState.stateNumber);\n        }\n        else {\n            newContext = config.context.getChild(returnState.stateNumber);\n        }\n        return config.transform(t.target, false, newContext);\n    }\n    isConflicted(configset, contextCache) {\n        if (configset.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER || configset.size <= 1) {\n            return undefined;\n        }\n        let configs = configset.toArray();\n        configs.sort(ParserATNSimulator.STATE_ALT_SORT_COMPARATOR);\n        let exact = !configset.dipsIntoOuterContext;\n        let alts = new BitSet_1.BitSet();\n        let minAlt = configs[0].alt;\n        alts.set(minAlt);\n        /* Quick checks come first (single pass, no context joining):\n         *  1. Make sure first config in the sorted list predicts the minimum\n         *     represented alternative.\n         *  2. Make sure every represented state has at least one configuration\n         *     which predicts the minimum represented alternative.\n         *  3. (exact only) make sure every represented state has at least one\n         *     configuration which predicts each represented alternative.\n         */\n        // quick check 1 & 2 => if we assume #1 holds and check #2 against the\n        // minAlt from the first state, #2 will fail if the assumption was\n        // incorrect\n        let currentState = configs[0].state.nonStopStateNumber;\n        for (let config of configs) {\n            let stateNumber = config.state.nonStopStateNumber;\n            if (stateNumber !== currentState) {\n                if (config.alt !== minAlt) {\n                    return undefined;\n                }\n                currentState = stateNumber;\n            }\n        }\n        let representedAlts;\n        if (exact) {\n            currentState = configs[0].state.nonStopStateNumber;\n            // get the represented alternatives of the first state\n            representedAlts = new BitSet_1.BitSet();\n            let maxAlt = minAlt;\n            for (let config of configs) {\n                if (config.state.nonStopStateNumber !== currentState) {\n                    break;\n                }\n                let alt = config.alt;\n                representedAlts.set(alt);\n                maxAlt = alt;\n            }\n            // quick check #3:\n            currentState = configs[0].state.nonStopStateNumber;\n            let currentAlt = minAlt;\n            for (let config of configs) {\n                let stateNumber = config.state.nonStopStateNumber;\n                let alt = config.alt;\n                if (stateNumber !== currentState) {\n                    if (currentAlt !== maxAlt) {\n                        exact = false;\n                        break;\n                    }\n                    currentState = stateNumber;\n                    currentAlt = minAlt;\n                }\n                else if (alt !== currentAlt) {\n                    if (alt !== representedAlts.nextSetBit(currentAlt + 1)) {\n                        exact = false;\n                        break;\n                    }\n                    currentAlt = alt;\n                }\n            }\n        }\n        currentState = configs[0].state.nonStopStateNumber;\n        let firstIndexCurrentState = 0;\n        let lastIndexCurrentStateMinAlt = 0;\n        let joinedCheckContext = configs[0].context;\n        for (let i = 1; i < configs.length; i++) {\n            let config = configs[i];\n            if (config.alt !== minAlt) {\n                break;\n            }\n            if (config.state.nonStopStateNumber !== currentState) {\n                break;\n            }\n            lastIndexCurrentStateMinAlt = i;\n            joinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);\n        }\n        for (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {\n            let config = configs[i];\n            let state = config.state;\n            alts.set(config.alt);\n            if (state.nonStopStateNumber !== currentState) {\n                currentState = state.nonStopStateNumber;\n                firstIndexCurrentState = i;\n                lastIndexCurrentStateMinAlt = i;\n                joinedCheckContext = config.context;\n                for (let j = firstIndexCurrentState + 1; j < configs.length; j++) {\n                    let config2 = configs[j];\n                    if (config2.alt !== minAlt) {\n                        break;\n                    }\n                    if (config2.state.nonStopStateNumber !== currentState) {\n                        break;\n                    }\n                    lastIndexCurrentStateMinAlt = j;\n                    joinedCheckContext = contextCache.join(joinedCheckContext, config2.context);\n                }\n                i = lastIndexCurrentStateMinAlt;\n                continue;\n            }\n            let joinedCheckContext2 = config.context;\n            let currentAlt = config.alt;\n            let lastIndexCurrentStateCurrentAlt = i;\n            for (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {\n                let config2 = configs[j];\n                if (config2.alt !== currentAlt) {\n                    break;\n                }\n                if (config2.state.nonStopStateNumber !== currentState) {\n                    break;\n                }\n                lastIndexCurrentStateCurrentAlt = j;\n                joinedCheckContext2 = contextCache.join(joinedCheckContext2, config2.context);\n            }\n            i = lastIndexCurrentStateCurrentAlt;\n            let check = contextCache.join(joinedCheckContext, joinedCheckContext2);\n            if (!joinedCheckContext.equals(check)) {\n                return undefined;\n            }\n            // update exact if necessary\n            exact = exact && joinedCheckContext.equals(joinedCheckContext2);\n        }\n        return new ConflictInfo_1.ConflictInfo(alts, exact);\n    }\n    getConflictingAltsFromConfigSet(configs) {\n        let conflictingAlts = configs.conflictingAlts;\n        if (conflictingAlts == null && configs.uniqueAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n            conflictingAlts = new BitSet_1.BitSet();\n            conflictingAlts.set(configs.uniqueAlt);\n        }\n        return conflictingAlts;\n    }\n    getTokenName(t) {\n        if (t === Token_1.Token.EOF) {\n            return \"EOF\";\n        }\n        let vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY;\n        let displayName = vocabulary.getDisplayName(t);\n        if (displayName === String(t)) {\n            return displayName;\n        }\n        return displayName + \"<\" + t + \">\";\n    }\n    getLookaheadName(input) {\n        return this.getTokenName(input.LA(1));\n    }\n    dumpDeadEndConfigs(nvae) {\n        console.log(\"dead end configs: \");\n        let deadEndConfigs = nvae.deadEndConfigs;\n        if (!deadEndConfigs) {\n            return;\n        }\n        for (let c of deadEndConfigs) {\n            let trans = \"no edges\";\n            if (c.state.numberOfOptimizedTransitions > 0) {\n                let t = c.state.getOptimizedTransition(0);\n                if (t instanceof AtomTransition_1.AtomTransition) {\n                    trans = \"Atom \" + this.getTokenName(t._label);\n                }\n                else if (t instanceof SetTransition_1.SetTransition) {\n                    let not = t instanceof NotSetTransition_1.NotSetTransition;\n                    trans = (not ? \"~\" : \"\") + \"Set \" + t.set.toString();\n                }\n            }\n            console.log(c.toString(this._parser, true) + \":\" + trans);\n        }\n    }\n    noViableAlt(input, outerContext, configs, startIndex) {\n        return new NoViableAltException_1.NoViableAltException(this._parser, input, input.get(startIndex), input.LT(1), configs, outerContext);\n    }\n    getUniqueAlt(configs) {\n        let alt = ATN_1.ATN.INVALID_ALT_NUMBER;\n        for (let c of configs) {\n            if (alt === ATN_1.ATN.INVALID_ALT_NUMBER) {\n                alt = c.alt; // found first alt\n            }\n            else if (c.alt !== alt) {\n                return ATN_1.ATN.INVALID_ALT_NUMBER;\n            }\n        }\n        return alt;\n    }\n    configWithAltAtStopState(configs, alt) {\n        for (let c of configs) {\n            if (c.alt === alt) {\n                if (c.state instanceof RuleStopState_1.RuleStopState) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    addDFAEdge(dfa, fromState, t, contextTransitions, toConfigs, contextCache) {\n        assert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);\n        let from = fromState;\n        let to = this.addDFAState(dfa, toConfigs, contextCache);\n        if (contextTransitions != null) {\n            for (let context of contextTransitions.toArray()) {\n                if (context === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n                    if (from.configs.isOutermostConfigSet) {\n                        continue;\n                    }\n                }\n                from.setContextSensitive(this.atn);\n                from.setContextSymbol(t);\n                let next = from.getContextTarget(context);\n                if (next != null) {\n                    from = next;\n                    continue;\n                }\n                next = this.addDFAContextState(dfa, from.configs, context, contextCache);\n                assert(context !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);\n                from.setContextTarget(context, next);\n                from = next;\n            }\n        }\n        if (ParserATNSimulator.debug) {\n            console.log(\"EDGE \" + from + \" -> \" + to + \" upon \" + this.getTokenName(t));\n        }\n        this.setDFAEdge(from, t, to);\n        if (ParserATNSimulator.debug) {\n            console.log(\"DFA=\\n\" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl_1.VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : undefined));\n        }\n        return to;\n    }\n    setDFAEdge(p, t, q) {\n        if (p != null) {\n            p.setTarget(t, q);\n        }\n    }\n    /** See comment on LexerInterpreter.addDFAState. */\n    addDFAContextState(dfa, configs, returnContext, contextCache) {\n        if (returnContext !== PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n            let contextConfigs = new ATNConfigSet_1.ATNConfigSet();\n            for (let config of configs) {\n                contextConfigs.add(config.appendContext(returnContext, contextCache));\n            }\n            return this.addDFAState(dfa, contextConfigs, contextCache);\n        }\n        else {\n            assert(!configs.isOutermostConfigSet, \"Shouldn't be adding a duplicate edge.\");\n            configs = configs.clone(true);\n            configs.isOutermostConfigSet = true;\n            return this.addDFAState(dfa, configs, contextCache);\n        }\n    }\n    /** See comment on LexerInterpreter.addDFAState. */\n    addDFAState(dfa, configs, contextCache) {\n        let enableDfa = this.enable_global_context_dfa || !configs.isOutermostConfigSet;\n        if (enableDfa) {\n            if (!configs.isReadOnly) {\n                configs.optimizeConfigs(this);\n            }\n            let proposed = this.createDFAState(dfa, configs);\n            let existing = dfa.states.get(proposed);\n            if (existing != null) {\n                return existing;\n            }\n        }\n        if (!configs.isReadOnly) {\n            if (configs.conflictInfo == null) {\n                configs.conflictInfo = this.isConflicted(configs, contextCache);\n            }\n        }\n        let newState = this.createDFAState(dfa, configs.clone(true));\n        // getDecisionState won't return undefined when we request a known valid decision\n        let decisionState = this.atn.getDecisionState(dfa.decision);\n        let predictedAlt = this.getUniqueAlt(configs);\n        if (predictedAlt !== ATN_1.ATN.INVALID_ALT_NUMBER) {\n            newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(predictedAlt);\n        }\n        else if (configs.conflictingAlts != null) {\n            let conflictingAlts = configs.conflictingAlts;\n            if (conflictingAlts) {\n                newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(conflictingAlts.nextSetBit(0));\n            }\n        }\n        if (newState.isAcceptState && configs.hasSemanticContext) {\n            this.predicateDFAState(newState, configs, decisionState.numberOfTransitions);\n        }\n        if (!enableDfa) {\n            return newState;\n        }\n        let added = dfa.addState(newState);\n        if (ParserATNSimulator.debug && added === newState) {\n            console.log(\"adding new DFA state: \" + newState);\n        }\n        return added;\n    }\n    createDFAState(dfa, configs) {\n        return new DFAState_1.DFAState(configs);\n    }\n    reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, stopIndex) {\n        if (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {\n            let interval = Interval_1.Interval.of(startIndex, stopIndex);\n            console.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + conflictState.s0.configs +\n                \", input=\" + this._parser.inputStream.getText(interval));\n        }\n        if (this._parser != null) {\n            let listener = this._parser.getErrorListenerDispatch();\n            if (listener.reportAttemptingFullContext) {\n                listener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);\n            }\n        }\n    }\n    reportContextSensitivity(dfa, prediction, acceptState, startIndex, stopIndex) {\n        if (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {\n            let interval = Interval_1.Interval.of(startIndex, stopIndex);\n            console.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + acceptState.s0.configs +\n                \", input=\" + this._parser.inputStream.getText(interval));\n        }\n        if (this._parser != null) {\n            let listener = this._parser.getErrorListenerDispatch();\n            if (listener.reportContextSensitivity) {\n                listener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);\n            }\n        }\n    }\n    /** If context sensitive parsing, we know it's ambiguity not conflict */\n    reportAmbiguity(dfa, D, // the DFA state from execATN(): void that had SLL conflicts\n    startIndex, stopIndex, exact, ambigAlts, configs) {\n        if (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {\n            let interval = Interval_1.Interval.of(startIndex, stopIndex);\n            console.log(\"reportAmbiguity \" +\n                ambigAlts + \":\" + configs +\n                \", input=\" + this._parser.inputStream.getText(interval));\n        }\n        if (this._parser != null) {\n            let listener = this._parser.getErrorListenerDispatch();\n            if (listener.reportAmbiguity) {\n                listener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n            }\n        }\n    }\n    getReturnState(context) {\n        if (context.isEmpty) {\n            return PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY;\n        }\n        let state = this.atn.states[context.invokingState];\n        let transition = state.transition(0);\n        return transition.followState.stateNumber;\n    }\n    skipTailCalls(context) {\n        if (!this.optimize_tail_calls) {\n            return context;\n        }\n        while (!context.isEmpty) {\n            let state = this.atn.states[context.invokingState];\n            assert(state.numberOfTransitions === 1 && state.transition(0).serializationType === 3 /* RULE */);\n            let transition = state.transition(0);\n            if (!transition.tailCall) {\n                break;\n            }\n            // This method requires that the root ancestor of the ParserRuleContext be empty. If we make it to this\n            // line, we know the current node is not empty, which means it does have a parent.\n            context = context.parent;\n        }\n        return context;\n    }\n    /**\n     * @since 4.3\n     */\n    get parser() {\n        return this._parser;\n    }\n};\nParserATNSimulator.debug = false;\nParserATNSimulator.dfa_debug = false;\nParserATNSimulator.retry_debug = false;\nParserATNSimulator.STATE_ALT_SORT_COMPARATOR = (o1, o2) => {\n    let diff = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;\n    if (diff !== 0) {\n        return diff;\n    }\n    diff = o1.alt - o2.alt;\n    if (diff !== 0) {\n        return diff;\n    }\n    return 0;\n};\n__decorate([\n    Decorators_1.NotNull\n], ParserATNSimulator.prototype, \"predictionMode\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], ParserATNSimulator.prototype, \"getPredictionMode\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"setPredictionMode\", null);\n__decorate([\n    Decorators_1.Override\n], ParserATNSimulator.prototype, \"reset\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"adaptivePredict\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"getStartState\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"execDFA\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"execATN\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"handleNoViableAlt\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"getExistingTargetState\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"computeTargetState\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"removeAllConfigsNotInRuleStopState\", null);\n__decorate([\n    Decorators_1.NotNull\n], ParserATNSimulator.prototype, \"computeStartState\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"applyPrecedenceFilter\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"getReachableTarget\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"getPredsForAmbigAlts\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"evalSemanticContext\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"evalSemanticContextImpl\", null);\n__decorate([\n    __param(1, Decorators_1.NotNull),\n    __param(4, Decorators_1.Nullable)\n], ParserATNSimulator.prototype, \"closure\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.Nullable),\n    __param(3, Decorators_1.NotNull),\n    __param(6, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"closureImpl\", null);\n__decorate([\n    Decorators_1.NotNull\n], ParserATNSimulator.prototype, \"getRuleName\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"getEpsilonTarget\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"actionTransition\", null);\n__decorate([\n    Decorators_1.Nullable,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"precedenceTransition\", null);\n__decorate([\n    Decorators_1.Nullable,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"predTransition\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.Nullable)\n], ParserATNSimulator.prototype, \"ruleTransition\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"isConflicted\", null);\n__decorate([\n    Decorators_1.NotNull\n], ParserATNSimulator.prototype, \"getTokenName\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"dumpDeadEndConfigs\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"noViableAlt\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"getUniqueAlt\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"configWithAltAtStopState\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(4, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"addDFAEdge\", null);\n__decorate([\n    __param(0, Decorators_1.Nullable), __param(2, Decorators_1.Nullable)\n], ParserATNSimulator.prototype, \"setDFAEdge\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"addDFAContextState\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"addDFAState\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"createDFAState\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"reportAttemptingFullContext\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"reportContextSensitivity\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(5, Decorators_1.NotNull),\n    __param(6, Decorators_1.NotNull)\n], ParserATNSimulator.prototype, \"reportAmbiguity\", null);\nParserATNSimulator = __decorate([\n    __param(0, Decorators_1.NotNull)\n], ParserATNSimulator);\nexports.ParserATNSimulator = ParserATNSimulator;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:31.1989835-07:00\n\nimport { AcceptStateInfo } from \"../dfa/AcceptStateInfo\";\nimport { ActionTransition } from \"./ActionTransition\";\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\nimport { Arrays } from \"../misc/Arrays\";\nimport { ATN } from \"./ATN\";\nimport { ATNConfig } from \"./ATNConfig\";\nimport { ATNConfigSet } from \"./ATNConfigSet\";\nimport { ATNSimulator } from \"./ATNSimulator\";\nimport { ATNState } from \"./ATNState\";\nimport { ATNStateType } from \"./ATNStateType\";\nimport { AtomTransition } from \"./AtomTransition\";\nimport { BitSet } from \"../misc/BitSet\";\nimport { ConflictInfo } from \"./ConflictInfo\";\nimport { DecisionState } from \"./DecisionState\";\nimport { DFA } from \"../dfa/DFA\";\nimport { DFAState } from \"../dfa/DFAState\";\nimport { EpsilonTransition } from \"./EpsilonTransition\";\nimport { IntegerList } from \"../misc/IntegerList\";\nimport { Interval } from \"../misc/Interval\";\nimport { IntStream } from \"../IntStream\";\nimport { NotNull, Nullable, Override } from \"../Decorators\";\nimport { NotSetTransition } from \"./NotSetTransition\";\nimport { NoViableAltException } from \"../NoViableAltException\";\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\nimport { Parser } from \"../Parser\";\nimport { ParserRuleContext } from \"../ParserRuleContext\";\nimport { PrecedencePredicateTransition } from \"./PrecedencePredicateTransition\";\nimport { PredicateTransition } from \"./PredicateTransition\";\nimport { PredictionContext } from \"./PredictionContext\";\nimport { PredictionContextCache } from \"./PredictionContextCache\";\nimport { PredictionMode } from \"./PredictionMode\";\nimport { RuleContext } from \"../RuleContext\";\nimport { RuleStopState } from \"./RuleStopState\";\nimport { RuleTransition } from \"./RuleTransition\";\nimport { SemanticContext } from \"./SemanticContext\";\nimport { SetTransition } from \"./SetTransition\";\nimport { SimulatorState } from \"./SimulatorState\";\nimport { StarLoopEntryState } from \"./StarLoopEntryState\";\nimport { Token } from \"../Token\";\nimport { TokenStream } from \"../TokenStream\";\nimport { Transition } from \"./Transition\";\nimport { TransitionType } from \"./TransitionType\";\nimport { Vocabulary } from \"../Vocabulary\";\nimport { VocabularyImpl } from \"../VocabularyImpl\";\n\nimport * as assert from \"assert\";\n\nconst MAX_SHORT_VALUE = 0xFFFF;\nconst MIN_INTEGER_VALUE = -((1 << 31) >>> 0);\n\n/**\n * The embodiment of the adaptive LL(*), ALL(*), parsing strategy.\n *\n * The basic complexity of the adaptive strategy makes it harder to understand.\n * We begin with ATN simulation to build paths in a DFA. Subsequent prediction\n * requests go through the DFA first. If they reach a state without an edge for\n * the current symbol, the algorithm fails over to the ATN simulation to\n * complete the DFA path for the current input (until it finds a conflict state\n * or uniquely predicting state).\n *\n * All of that is done without using the outer context because we want to create\n * a DFA that is not dependent upon the rule invocation stack when we do a\n * prediction. One DFA works in all contexts. We avoid using context not\n * necessarily because it's slower, although it can be, but because of the DFA\n * caching problem. The closure routine only considers the rule invocation stack\n * created during prediction beginning in the decision rule. For example, if\n * prediction occurs without invoking another rule's ATN, there are no context\n * stacks in the configurations. When lack of context leads to a conflict, we\n * don't know if it's an ambiguity or a weakness in the strong LL(*) parsing\n * strategy (versus full LL(*)).\n *\n * When SLL yields a configuration set with conflict, we rewind the input and\n * retry the ATN simulation, this time using full outer context without adding\n * to the DFA. Configuration context stacks will be the full invocation stacks\n * from the start rule. If we get a conflict using full context, then we can\n * definitively say we have a true ambiguity for that input sequence. If we\n * don't get a conflict, it implies that the decision is sensitive to the outer\n * context. (It is not context-sensitive in the sense of context-sensitive\n * grammars.)\n *\n * The next time we reach this DFA state with an SLL conflict, through DFA\n * simulation, we will again retry the ATN simulation using full context mode.\n * This is slow because we can't save the results and have to \"interpret\" the\n * ATN each time we get that input.\n *\n * **CACHING FULL CONTEXT PREDICTIONS**\n *\n * We could cache results from full context to predicted alternative easily and\n * that saves a lot of time but doesn't work in presence of predicates. The set\n * of visible predicates from the ATN start state changes depending on the\n * context, because closure can fall off the end of a rule. I tried to cache\n * tuples (stack context, semantic context, predicted alt) but it was slower\n * than interpreting and much more complicated. Also required a huge amount of\n * memory. The goal is not to create the world's fastest parser anyway. I'd like\n * to keep this algorithm simple. By launching multiple threads, we can improve\n * the speed of parsing across a large number of files.\n *\n * There is no strict ordering between the amount of input used by SLL vs LL,\n * which makes it really hard to build a cache for full context. Let's say that\n * we have input A B C that leads to an SLL conflict with full context X. That\n * implies that using X we might only use A B but we could also use A B C D to\n * resolve conflict. Input A B C D could predict alternative 1 in one position\n * in the input and A B C E could predict alternative 2 in another position in\n * input. The conflicting SLL configurations could still be non-unique in the\n * full context prediction, which would lead us to requiring more input than the\n * original A B C.\tTo make a\tprediction cache work, we have to track\tthe exact\n * input\tused during the previous prediction. That amounts to a cache that maps\n * X to a specific DFA for that context.\n *\n * Something should be done for left-recursive expression predictions. They are\n * likely LL(1) + pred eval. Easier to do the whole SLL unless error and retry\n * with full LL thing Sam does.\n *\n * **AVOIDING FULL CONTEXT PREDICTION**\n *\n * We avoid doing full context retry when the outer context is empty, we did not\n * dip into the outer context by falling off the end of the decision state rule,\n * or when we force SLL mode.\n *\n * As an example of the not dip into outer context case, consider as super\n * constructor calls versus function calls. One grammar might look like\n * this:\n *\n * ```antlr\n * ctorBody\n *   : '{' superCall? stat* '}'\n *   ;\n * ```\n *\n * Or, you might see something like\n *\n * ```antlr\n * stat\n *   : superCall ';'\n *   | expression ';'\n *   | ...\n *   ;\n * ```\n *\n * In both cases I believe that no closure operations will dip into the outer\n * context. In the first case ctorBody in the worst case will stop at the '}'.\n * In the 2nd case it should stop at the ';'. Both cases should stay within the\n * entry rule and not dip into the outer context.\n *\n * **PREDICATES**\n *\n * Predicates are always evaluated if present in either SLL or LL both. SLL and\n * LL simulation deals with predicates differently. SLL collects predicates as\n * it performs closure operations like ANTLR v3 did. It delays predicate\n * evaluation until it reaches and accept state. This allows us to cache the SLL\n * ATN simulation whereas, if we had evaluated predicates on-the-fly during\n * closure, the DFA state configuration sets would be different and we couldn't\n * build up a suitable DFA.\n *\n * When building a DFA accept state during ATN simulation, we evaluate any\n * predicates and return the sole semantically valid alternative. If there is\n * more than 1 alternative, we report an ambiguity. If there are 0 alternatives,\n * we throw an exception. Alternatives without predicates act like they have\n * true predicates. The simple way to think about it is to strip away all\n * alternatives with false predicates and choose the minimum alternative that\n * remains.\n *\n * When we start in the DFA and reach an accept state that's predicated, we test\n * those and return the minimum semantically viable alternative. If no\n * alternatives are viable, we throw an exception.\n *\n * During full LL ATN simulation, closure always evaluates predicates and\n * on-the-fly. This is crucial to reducing the configuration set size during\n * closure. It hits a landmine when parsing with the Java grammar, for example,\n * without this on-the-fly evaluation.\n *\n * **SHARING DFA**\n *\n * All instances of the same parser share the same decision DFAs through a\n * static field. Each instance gets its own ATN simulator but they share the\n * same {@link ATN#decisionToDFA} field. They also share a\n * {@link PredictionContextCache} object that makes sure that all\n * {@link PredictionContext} objects are shared among the DFA states. This makes\n * a big size difference.\n *\n * **THREAD SAFETY**\n *\n * The {@link ParserATNSimulator} locks on the {@link ATN#decisionToDFA} field when\n * it adds a new DFA object to that array. {@link #addDFAEdge}\n * locks on the DFA for the current decision when setting the\n * {@link DFAState#edges} field. {@link #addDFAState} locks on\n * the DFA for the current decision when looking up a DFA state to see if it\n * already exists. We must make sure that all requests to add DFA states that\n * are equivalent result in the same shared DFA object. This is because lots of\n * threads will be trying to update the DFA at once. The\n * {@link #addDFAState} method also locks inside the DFA lock\n * but this time on the shared context cache when it rebuilds the\n * configurations' {@link PredictionContext} objects using cached\n * subgraphs/nodes. No other locking occurs, even during DFA simulation. This is\n * safe as long as we can guarantee that all threads referencing\n * `s.edge[t]` get the same physical target {@link DFAState}, or\n * `undefined`. Once into the DFA, the DFA simulation does not reference the\n * {@link DFA#states} map. It follows the {@link DFAState#edges} field to new\n * targets. The DFA simulator will either find {@link DFAState#edges} to be\n * `undefined`, to be non-`undefined` and `dfa.edges[t]` undefined, or\n * `dfa.edges[t]` to be non-undefined. The\n * {@link #addDFAEdge} method could be racing to set the field\n * but in either case the DFA simulator works; if `undefined`, and requests ATN\n * simulation. It could also race trying to get `dfa.edges[t]`, but either\n * way it will work because it's not doing a test and set operation.\n *\n * **Starting with SLL then failing to combined SLL/LL (Two-Stage\n * Parsing)**\n *\n * Sam pointed out that if SLL does not give a syntax error, then there is no\n * point in doing full LL, which is slower. We only have to try LL if we get a\n * syntax error. For maximum speed, Sam starts the parser set to pure SLL\n * mode with the {@link BailErrorStrategy}:\n *\n * ```\n * parser.interpreter.{@link #setPredictionMode setPredictionMode}`(`{@link PredictionMode#SLL}`)`;\n * parser.{@link Parser#setErrorHandler setErrorHandler}(new {@link BailErrorStrategy}());\n * ```\n *\n * If it does not get a syntax error, then we're done. If it does get a syntax\n * error, we need to retry with the combined SLL/LL strategy.\n *\n * The reason this works is as follows. If there are no SLL conflicts, then the\n * grammar is SLL (at least for that input set). If there is an SLL conflict,\n * the full LL analysis must yield a set of viable alternatives which is a\n * subset of the alternatives reported by SLL. If the LL set is a singleton,\n * then the grammar is LL but not SLL. If the LL set is the same size as the SLL\n * set, the decision is SLL. If the LL set has size &gt; 1, then that decision\n * is truly ambiguous on the current input. If the LL set is smaller, then the\n * SLL conflict resolution might choose an alternative that the full LL would\n * rule out as a possibility based upon better context information. If that's\n * the case, then the SLL parse will definitely get an error because the full LL\n * analysis says it's not viable. If SLL conflict resolution chooses an\n * alternative within the LL set, them both SLL and LL would choose the same\n * alternative because they both choose the minimum of multiple conflicting\n * alternatives.\n *\n * Let's say we have a set of SLL conflicting alternatives `{1, 2, 3}` and\n * a smaller LL set called *s*. If *s* is `{2, 3}`, then SLL\n * parsing will get an error because SLL will pursue alternative 1. If\n * *s* is `{1, 2}` or `{1, 3}` then both SLL and LL will\n * choose the same alternative because alternative one is the minimum of either\n * set. If *s* is `{2}` or `{3}` then SLL will get a syntax\n * error. If *s* is `{1}` then SLL will succeed.\n *\n * Of course, if the input is invalid, then we will get an error for sure in\n * both SLL and LL parsing. Erroneous input will therefore require 2 passes over\n * the input.\n */\nexport class ParserATNSimulator extends ATNSimulator {\n\tpublic static debug: boolean = false;\n\tpublic static dfa_debug: boolean = false;\n\tpublic static retry_debug: boolean = false;\n\n\t@NotNull\n\tprivate predictionMode: PredictionMode = PredictionMode.LL;\n\tpublic force_global_context: boolean = false;\n\tpublic always_try_local_context: boolean = true;\n\n\t/**\n\t * Determines whether the DFA is used for full-context predictions. When\n\t * `true`, the DFA stores transition information for both full-context\n\t * and SLL parsing; otherwise, the DFA only stores SLL transition\n\t * information.\n\t *\n\t * For some grammars, enabling the full-context DFA can result in a\n\t * substantial performance improvement. However, this improvement typically\n\t * comes at the expense of memory used for storing the cached DFA states,\n\t * configuration sets, and prediction contexts.\n\t *\n\t * The default value is `false`.\n\t */\n\tpublic enable_global_context_dfa: boolean = false;\n\tpublic optimize_unique_closure: boolean = true;\n\tpublic optimize_ll1: boolean = true;\n\tpublic optimize_tail_calls: boolean = true;\n\tpublic tail_call_preserves_sll: boolean = true;\n\tpublic treat_sllk1_conflict_as_ambiguity: boolean = false;\n\n\tprotected _parser: Parser;\n\n\t/**\n\t * When `true`, ambiguous alternatives are reported when they are\n\t * encountered within {@link #execATN}. When `false`, these messages\n\t * are suppressed. The default is `false`.\n\t *\n\t * When messages about ambiguous alternatives are not required, setting this\n\t * to `false` enables additional internal optimizations which may lose\n\t * this information.\n\t */\n\tpublic reportAmbiguities: boolean = false;\n\n\t/** By default we do full context-sensitive LL(*) parsing not\n\t *  Strong LL(*) parsing. If we fail with Strong LL(*) we\n\t *  try full LL(*). That means we rewind and use context information\n\t *  when closure operations fall off the end of the rule that\n\t *  holds the decision were evaluating.\n\t */\n\tprotected userWantsCtxSensitive: boolean = true;\n\n\tprivate dfa?: DFA;\n\n\tconstructor(@NotNull atn: ATN, parser: Parser) {\n\t\tsuper(atn);\n\t\tthis._parser = parser;\n\t}\n\n\t@NotNull\n\tpublic getPredictionMode(): PredictionMode {\n\t\treturn this.predictionMode;\n\t}\n\n\tpublic setPredictionMode(@NotNull predictionMode: PredictionMode): void {\n\t\tthis.predictionMode = predictionMode;\n\t}\n\n\t@Override\n\tpublic reset(): void {\n\t\t// intentionally empty\n\t}\n\n\tpublic adaptivePredict(/*@NotNull*/ input: TokenStream, decision: number, outerContext: ParserRuleContext | undefined): number;\n\tpublic adaptivePredict(/*@NotNull*/ input: TokenStream, decision: number, outerContext: ParserRuleContext | undefined, useContext: boolean): number;\n\tpublic adaptivePredict(\n\t\t@NotNull input: TokenStream,\n\t\tdecision: number,\n\t\touterContext: ParserRuleContext | undefined,\n\t\tuseContext?: boolean): number {\n\t\tif (useContext === undefined) {\n\t\t\tuseContext = false;\n\t\t}\n\n\t\tlet dfa: DFA = this.atn.decisionToDFA[decision];\n\t\tassert(dfa != null);\n\t\tif (this.optimize_ll1 && !dfa.isPrecedenceDfa && !dfa.isEmpty) {\n\t\t\tlet ll_1: number = input.LA(1);\n\t\t\tif (ll_1 >= 0 && ll_1 <= 0xFFFF) {\n\t\t\t\tlet key: number = ((decision << 16) >>> 0) + ll_1;\n\t\t\t\tlet alt: number | undefined = this.atn.LL1Table.get(key);\n\t\t\t\tif (alt != null) {\n\t\t\t\t\treturn alt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.dfa = dfa;\n\n\t\tif (this.force_global_context) {\n\t\t\tuseContext = true;\n\t\t}\n\t\telse if (!this.always_try_local_context) {\n\t\t\tuseContext = useContext || dfa.isContextSensitive;\n\t\t}\n\n\t\tthis.userWantsCtxSensitive = useContext || (this.predictionMode !== PredictionMode.SLL && outerContext != null && !this.atn.decisionToState[decision].sll);\n\t\tif (outerContext == null) {\n\t\t\touterContext = ParserRuleContext.emptyContext();\n\t\t}\n\n\t\tlet state: SimulatorState | undefined;\n\t\tif (!dfa.isEmpty) {\n\t\t\tstate = this.getStartState(dfa, input, outerContext, useContext);\n\t\t}\n\n\t\tif (state == null) {\n\t\t\tif (outerContext == null) {\n\t\t\t\touterContext = ParserRuleContext.emptyContext();\n\t\t\t}\n\t\t\tif (ParserATNSimulator.debug) {\n\t\t\t\tconsole.log(\"ATN decision \" + dfa.decision +\n\t\t\t\t\t\" exec LA(1)==\" + this.getLookaheadName(input) +\n\t\t\t\t\t\", outerContext=\" + outerContext.toString(this._parser));\n\t\t\t}\n\n\t\t\tstate = this.computeStartState(dfa, outerContext, useContext);\n\t\t}\n\n\t\tlet m: number = input.mark();\n\t\tlet index: number = input.index;\n\t\ttry {\n\t\t\tlet alt: number = this.execDFA(dfa, input, index, state);\n\t\t\tif (ParserATNSimulator.debug) {\n\t\t\t\tconsole.log(\"DFA after predictATN: \" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\n\t\t\t}\n\t\t\treturn alt;\n\t\t}\n\t\tfinally {\n\t\t\tthis.dfa = undefined;\n\t\t\tinput.seek(index);\n\t\t\tinput.release(m);\n\t\t}\n\t}\n\n\tprotected getStartState(\n\t\t@NotNull dfa: DFA,\n\t\t@NotNull input: TokenStream,\n\t\t@NotNull outerContext: ParserRuleContext,\n\t\tuseContext: boolean): SimulatorState | undefined {\n\n\t\tif (!useContext) {\n\t\t\tif (dfa.isPrecedenceDfa) {\n\t\t\t\t// the start state for a precedence DFA depends on the current\n\t\t\t\t// parser precedence, and is provided by a DFA method.\n\t\t\t\tlet state: DFAState | undefined = dfa.getPrecedenceStartState(this._parser.precedence, false);\n\t\t\t\tif (state == null) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\treturn new SimulatorState(outerContext, state, false, outerContext);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dfa.s0 == null) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\treturn new SimulatorState(outerContext, dfa.s0, false, outerContext);\n\t\t\t}\n\t\t}\n\n\t\tif (!this.enable_global_context_dfa) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet remainingContext: ParserRuleContext | undefined = outerContext;\n\t\tassert(outerContext != null);\n\t\tlet s0: DFAState | undefined;\n\t\tif (dfa.isPrecedenceDfa) {\n\t\t\ts0 = dfa.getPrecedenceStartState(this._parser.precedence, true);\n\t\t}\n\t\telse {\n\t\t\ts0 = dfa.s0full;\n\t\t}\n\n\t\twhile (remainingContext != null && s0 != null && s0.isContextSensitive) {\n\t\t\tremainingContext = this.skipTailCalls(remainingContext);\n\t\t\ts0 = s0.getContextTarget(this.getReturnState(remainingContext));\n\t\t\tif (remainingContext.isEmpty) {\n\t\t\t\tassert(s0 == null || !s0.isContextSensitive);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tremainingContext = remainingContext.parent;\n\t\t\t}\n\t\t}\n\n\t\tif (s0 == null) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\treturn new SimulatorState(outerContext, s0, useContext, remainingContext);\n\t}\n\n\tprotected execDFA(\n\t\t@NotNull dfa: DFA,\n\t\t@NotNull input: TokenStream, startIndex: number,\n\t\t@NotNull state: SimulatorState): number {\n\t\tlet outerContext: ParserRuleContext = state.outerContext;\n\t\tif (ParserATNSimulator.dfa_debug) {\n\t\t\tconsole.log(\"DFA decision \" + dfa.decision +\n\t\t\t\t\" exec LA(1)==\" + this.getLookaheadName(input) +\n\t\t\t\t\", outerContext=\" + outerContext.toString(this._parser));\n\t\t}\n\t\tif (ParserATNSimulator.dfa_debug) {\n\t\t\tconsole.log(dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\n\t\t}\n\t\tlet s: DFAState = state.s0;\n\n\t\tlet t: number = input.LA(1);\n\t\tlet remainingOuterContext: ParserRuleContext | undefined = state.remainingOuterContext;\n\n\t\twhile (true) {\n\t\t\tif (ParserATNSimulator.dfa_debug) {\n\t\t\t\tconsole.log(\"DFA state \" + s.stateNumber + \" LA(1)==\" + this.getLookaheadName(input));\n\t\t\t}\n\t\t\tif (state.useContext) {\n\t\t\t\twhile (s.isContextSymbol(t)) {\n\t\t\t\t\tlet next: DFAState | undefined;\n\t\t\t\t\tif (remainingOuterContext != null) {\n\t\t\t\t\t\tremainingOuterContext = this.skipTailCalls(remainingOuterContext);\n\t\t\t\t\t\tnext = s.getContextTarget(this.getReturnState(remainingOuterContext));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (next == null) {\n\t\t\t\t\t\t// fail over to ATN\n\t\t\t\t\t\tlet initialState: SimulatorState = new SimulatorState(state.outerContext, s, state.useContext, remainingOuterContext);\n\t\t\t\t\t\treturn this.execATN(dfa, input, startIndex, initialState);\n\t\t\t\t\t}\n\n\t\t\t\t\tassert(remainingOuterContext != null);\n\t\t\t\t\tremainingOuterContext = (remainingOuterContext as ParserRuleContext).parent;\n\t\t\t\t\ts = next;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.isAcceptState(s, state.useContext)) {\n\t\t\t\tif (s.predicates != null) {\n\t\t\t\t\tif (ParserATNSimulator.dfa_debug) {\n\t\t\t\t\t\tconsole.log(\"accept \" + s);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (ParserATNSimulator.dfa_debug) {\n\t\t\t\t\t\tconsole.log(\"accept; predict \" + s.prediction + \" in state \" + s.stateNumber);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// keep going unless we're at EOF or state only has one alt number\n\t\t\t\t// mentioned in configs; check if something else could match\n\t\t\t\t// TODO: don't we always stop? only lexer would keep going\n\t\t\t\t// TODO: v3 dfa don't do this.\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// t is not updated if one of these states is reached\n\t\t\tassert(!this.isAcceptState(s, state.useContext));\n\n\t\t\t// if no edge, pop over to ATN interpreter, update DFA and return\n\t\t\tlet target: DFAState | undefined = this.getExistingTargetState(s, t);\n\t\t\tif (target == null) {\n\t\t\t\tif (ParserATNSimulator.dfa_debug && t >= 0) {\n\t\t\t\t\tconsole.log(\"no edge for \" + this._parser.vocabulary.getDisplayName(t));\n\t\t\t\t}\n\t\t\t\tlet alt: number;\n\t\t\t\tif (ParserATNSimulator.dfa_debug) {\n\t\t\t\t\tlet interval: Interval = Interval.of(startIndex, this._parser.inputStream.index);\n\t\t\t\t\tconsole.log(\"ATN exec upon \" +\n\t\t\t\t\t\tthis._parser.inputStream.getText(interval) +\n\t\t\t\t\t\t\" at DFA state \" + s.stateNumber);\n\t\t\t\t}\n\n\t\t\t\tlet initialState: SimulatorState = new SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\n\t\t\t\talt = this.execATN(dfa, input, startIndex, initialState);\n\t\t\t\tif (ParserATNSimulator.dfa_debug) {\n\t\t\t\t\tconsole.log(\"back from DFA update, alt=\" + alt + \", dfa=\\n\" + dfa.toString(this._parser.vocabulary, this._parser.ruleNames));\n\t\t\t\t\t//dump(dfa);\n\t\t\t\t}\n\t\t\t\t// action already executed\n\t\t\t\tif (ParserATNSimulator.dfa_debug) {\n\t\t\t\t\tconsole.log(\"DFA decision \" + dfa.decision +\n\t\t\t\t\t\t\" predicts \" + alt);\n\t\t\t\t}\n\t\t\t\treturn alt; // we've updated DFA, exec'd action, and have our deepest answer\n\t\t\t}\n\t\t\telse if (target === ATNSimulator.ERROR) {\n\t\t\t\tlet errorState: SimulatorState = new SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\n\t\t\t\treturn this.handleNoViableAlt(input, startIndex, errorState);\n\t\t\t}\n\t\t\ts = target;\n\t\t\tif (!this.isAcceptState(s, state.useContext) && t !== IntStream.EOF) {\n\t\t\t\tinput.consume();\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\t\t}\n//\t\tif ( acceptState==null ) {\n//\t\t\tif ( debug ) System.out.println(\"!!! no viable alt in dfa\");\n//\t\t\treturn -1;\n//\t\t}\n\n\t\tif (!state.useContext && s.configs.conflictInfo != null) {\n\t\t\tif (dfa.atnStartState instanceof DecisionState) {\n\t\t\t\tif (!this.userWantsCtxSensitive ||\n\t\t\t\t\t(!s.configs.dipsIntoOuterContext && s.configs.isExactConflict) ||\n\t\t\t\t\t(this.treat_sllk1_conflict_as_ambiguity && input.index === startIndex)) {\n\t\t\t\t\t// we don't report the ambiguity again\n\t\t\t\t\t//if ( !this.acceptState.configset.hasSemanticContext ) {\n\t\t\t\t\t// \tthis.reportAmbiguity(dfa, acceptState, startIndex, input.index, acceptState.configset.conflictingAlts, acceptState.configset);\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(!state.useContext);\n\n\t\t\t\t\t// Before attempting full context prediction, check to see if there are\n\t\t\t\t\t// disambiguating or validating predicates to evaluate which allow an\n\t\t\t\t\t// immediate decision\n\t\t\t\t\tlet conflictingAlts: BitSet | undefined;\n\t\t\t\t\tlet predicates: DFAState.PredPrediction[] | undefined = s.predicates;\n\t\t\t\t\tif (predicates != null) {\n\t\t\t\t\t\tlet conflictIndex: number = input.index;\n\t\t\t\t\t\tif (conflictIndex !== startIndex) {\n\t\t\t\t\t\t\tinput.seek(startIndex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconflictingAlts = this.evalSemanticContext(predicates, outerContext, true);\n\t\t\t\t\t\tif (conflictingAlts.cardinality() === 1) {\n\t\t\t\t\t\t\treturn conflictingAlts.nextSetBit(0);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (conflictIndex !== startIndex) {\n\t\t\t\t\t\t\t// restore the index so reporting the fallback to full\n\t\t\t\t\t\t\t// context occurs with the index at the correct spot\n\t\t\t\t\t\t\tinput.seek(conflictIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (this.reportAmbiguities) {\n\t\t\t\t\t\tlet conflictState: SimulatorState = new SimulatorState(outerContext, s, state.useContext, remainingOuterContext);\n\t\t\t\t\t\tthis.reportAttemptingFullContext(dfa, conflictingAlts, conflictState, startIndex, input.index);\n\t\t\t\t\t}\n\n\t\t\t\t\tinput.seek(startIndex);\n\t\t\t\t\treturn this.adaptivePredict(input, dfa.decision, outerContext, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Before jumping to prediction, check to see if there are\n\t\t// disambiguating or validating predicates to evaluate\n\t\tlet predicates: DFAState.PredPrediction[] | undefined = s.predicates;\n\t\tif (predicates != null) {\n\t\t\tlet stopIndex: number = input.index;\n\t\t\tif (startIndex !== stopIndex) {\n\t\t\t\tinput.seek(startIndex);\n\t\t\t}\n\n\t\t\tlet alts: BitSet = this.evalSemanticContext(predicates, outerContext, this.reportAmbiguities && this.predictionMode === PredictionMode.LL_EXACT_AMBIG_DETECTION);\n\t\t\tswitch (alts.cardinality()) {\n\t\t\tcase 0:\n\t\t\t\tthrow this.noViableAlt(input, outerContext, s.configs, startIndex);\n\n\t\t\tcase 1:\n\t\t\t\treturn alts.nextSetBit(0);\n\n\t\t\tdefault:\n\t\t\t\t// report ambiguity after predicate evaluation to make sure the correct\n\t\t\t\t// set of ambig alts is reported.\n\t\t\t\tif (startIndex !== stopIndex) {\n\t\t\t\t\tinput.seek(stopIndex);\n\t\t\t\t}\n\n\t\t\t\tthis.reportAmbiguity(dfa, s, startIndex, stopIndex, s.configs.isExactConflict, alts, s.configs);\n\t\t\t\treturn alts.nextSetBit(0);\n\t\t\t}\n\t\t}\n\n\t\tif (ParserATNSimulator.dfa_debug) {\n\t\t\tconsole.log(\"DFA decision \" + dfa.decision +\n\t\t\t\t\" predicts \" + s.prediction);\n\t\t}\n\t\treturn s.prediction;\n\t}\n\n\t/**\n\t * Determines if a particular DFA state should be treated as an accept state\n\t * for the current prediction mode. In addition to the `useContext`\n\t * parameter, the {@link #getPredictionMode()} method provides the\n\t * prediction mode controlling the prediction algorithm as a whole.\n\t *\n\t * The default implementation simply returns the value of\n\t * `DFAState.isAcceptState` except for conflict states when\n\t * `useContext` is `true` and {@link #getPredictionMode()} is\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}. In that case, only\n\t * conflict states where {@link ATNConfigSet#isExactConflict} is\n\t * `true` are considered accept states.\n\t *\n\t * @param state The DFA state to check.\n\t * @param useContext `true` if the prediction algorithm is currently\n\t * considering the full parser context; otherwise, `false` if the\n\t * algorithm is currently performing a local context prediction.\n\t *\n\t * @returns `true` if the specified `state` is an accept state;\n\t * otherwise, `false`.\n\t */\n\tprotected isAcceptState(state: DFAState, useContext: boolean): boolean {\n\t\tif (!state.isAcceptState) {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (state.configs.conflictingAlts == null) {\n\t\t\t// unambiguous\n\t\t\treturn true;\n\t\t}\n\n\t\t// More picky when we need exact conflicts\n\t\tif (useContext && this.predictionMode === PredictionMode.LL_EXACT_AMBIG_DETECTION) {\n\t\t\treturn state.configs.isExactConflict;\n\t\t}\n\n\t\treturn true;\n\t}\n\n\t/** Performs ATN simulation to compute a predicted alternative based\n\t *  upon the remaining input, but also updates the DFA cache to avoid\n\t *  having to traverse the ATN again for the same input sequence.\n\t *\n\t * There are some key conditions we're looking for after computing a new\n\t * set of ATN configs (proposed DFA state):\n\t *\n\t * * if the set is empty, there is no viable alternative for current symbol\n\t * * does the state uniquely predict an alternative?\n\t * * does the state have a conflict that would prevent us from\n\t *   putting it on the work list?\n\t * * if in non-greedy decision is there a config at a rule stop state?\n\t *\n\t * We also have some key operations to do:\n\t *\n\t * * add an edge from previous DFA state to potentially new DFA state, D,\n\t *   upon current symbol but only if adding to work list, which means in all\n\t *   cases except no viable alternative (and possibly non-greedy decisions?)\n\t * * collecting predicates and adding semantic context to DFA accept states\n\t * * adding rule context to context-sensitive DFA accept states\n\t * * consuming an input symbol\n\t * * reporting a conflict\n\t * * reporting an ambiguity\n\t * * reporting a context sensitivity\n\t * * reporting insufficient predicates\n\t *\n\t * We should isolate those operations, which are side-effecting, to the\n\t * main work loop. We can isolate lots of code into other functions, but\n\t * they should be side effect free. They can return package that\n\t * indicates whether we should report something, whether we need to add a\n\t * DFA edge, whether we need to augment accept state with semantic\n\t * context or rule invocation context. Actually, it seems like we always\n\t * add predicates if they exist, so that can simply be done in the main\n\t * loop for any accept state creation or modification request.\n\t *\n\t * cover these cases:\n\t *   dead end\n\t *   single alt\n\t *   single alt + preds\n\t *   conflict\n\t *   conflict + preds\n\t *\n\t * TODO: greedy + those\n\t */\n\tprotected execATN(\n\t\t@NotNull dfa: DFA,\n\t\t@NotNull input: TokenStream, startIndex: number,\n\t\t@NotNull initialState: SimulatorState): number {\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"execATN decision \" + dfa.decision + \" exec LA(1)==\" + this.getLookaheadName(input));\n\t\t}\n\n\t\tlet outerContext: ParserRuleContext = initialState.outerContext;\n\t\tlet useContext: boolean = initialState.useContext;\n\n\t\tlet t: number = input.LA(1);\n\n\t\tlet previous: SimulatorState = initialState;\n\n\t\tlet contextCache: PredictionContextCache = new PredictionContextCache();\n\t\twhile (true) { // while more work\n\t\t\tlet nextState: SimulatorState | undefined = this.computeReachSet(dfa, previous, t, contextCache);\n\t\t\tif (nextState == null) {\n\t\t\t\tthis.setDFAEdge(previous.s0, input.LA(1), ATNSimulator.ERROR);\n\t\t\t\treturn this.handleNoViableAlt(input, startIndex, previous);\n\t\t\t}\n\n\t\t\tlet D: DFAState = nextState.s0;\n\n\t\t\t// predicted alt => accept state\n\t\t\tassert(D.isAcceptState || D.prediction === ATN.INVALID_ALT_NUMBER);\n\t\t\t// conflicted => accept state\n\t\t\tassert(D.isAcceptState || D.configs.conflictInfo == null);\n\n\t\t\tif (this.isAcceptState(D, useContext)) {\n\t\t\t\tlet conflictingAlts: BitSet | undefined = D.configs.conflictingAlts;\n\t\t\t\tlet predictedAlt: number = conflictingAlts == null ? D.prediction : ATN.INVALID_ALT_NUMBER;\n\t\t\t\tif (predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n\t\t\t\t\tif (this.optimize_ll1\n\t\t\t\t\t\t&& input.index === startIndex\n\t\t\t\t\t\t&& !dfa.isPrecedenceDfa\n\t\t\t\t\t\t&& nextState.outerContext === nextState.remainingOuterContext\n\t\t\t\t\t\t&& dfa.decision >= 0\n\t\t\t\t\t\t&& !D.configs.hasSemanticContext) {\n\t\t\t\t\t\tif (t >= 0 && t <= MAX_SHORT_VALUE) {\n\t\t\t\t\t\t\tlet key: number = ((dfa.decision << 16) >>> 0) + t;\n\t\t\t\t\t\t\tthis.atn.LL1Table.set(key, predictedAlt);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (useContext && this.always_try_local_context) {\n\t\t\t\t\t\tthis.reportContextSensitivity(dfa, predictedAlt, nextState, startIndex, input.index);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tpredictedAlt = D.prediction;\n//\t\t\t\tint k = input.index - startIndex + 1; // how much input we used\n//\t\t\t\tSystem.out.println(\"used k=\"+k);\n\t\t\t\tlet attemptFullContext: boolean = conflictingAlts != null && this.userWantsCtxSensitive;\n\t\t\t\tif (attemptFullContext) {\n\t\t\t\t\t// Only exact conflicts are known to be ambiguous when local\n\t\t\t\t\t// prediction does not step out of the decision rule.\n\t\t\t\t\tattemptFullContext = !useContext\n\t\t\t\t\t\t&& (D.configs.dipsIntoOuterContext || !D.configs.isExactConflict)\n\t\t\t\t\t\t&& (!this.treat_sllk1_conflict_as_ambiguity || input.index !== startIndex);\n\t\t\t\t}\n\n\t\t\t\tif (D.configs.hasSemanticContext) {\n\t\t\t\t\tlet predPredictions: DFAState.PredPrediction[] | undefined = D.predicates;\n\t\t\t\t\tif (predPredictions != null) {\n\t\t\t\t\t\tlet conflictIndex: number = input.index;\n\t\t\t\t\t\tif (conflictIndex !== startIndex) {\n\t\t\t\t\t\t\tinput.seek(startIndex);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// use complete evaluation here if we'll want to retry with full context if still ambiguous\n\t\t\t\t\t\tconflictingAlts = this.evalSemanticContext(predPredictions, outerContext, attemptFullContext || this.reportAmbiguities);\n\t\t\t\t\t\tswitch (conflictingAlts.cardinality()) {\n\t\t\t\t\t\tcase 0:\n\t\t\t\t\t\t\tthrow this.noViableAlt(input, outerContext, D.configs, startIndex);\n\n\t\t\t\t\t\tcase 1:\n\t\t\t\t\t\t\treturn conflictingAlts.nextSetBit(0);\n\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (conflictIndex !== startIndex) {\n\t\t\t\t\t\t\t// restore the index so reporting the fallback to full\n\t\t\t\t\t\t\t// context occurs with the index at the correct spot\n\t\t\t\t\t\t\tinput.seek(conflictIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (!attemptFullContext) {\n\t\t\t\t\tif (conflictingAlts != null) {\n\t\t\t\t\t\tif (this.reportAmbiguities && conflictingAlts.cardinality() > 1) {\n\t\t\t\t\t\t\tthis.reportAmbiguity(dfa, D, startIndex, input.index, D.configs.isExactConflict, conflictingAlts, D.configs);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpredictedAlt = conflictingAlts.nextSetBit(0);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn predictedAlt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tassert(!useContext);\n\t\t\t\t\tassert(this.isAcceptState(D, false));\n\n\t\t\t\t\tif (ParserATNSimulator.debug) {\n\t\t\t\t\t\tconsole.log(\"RETRY with outerContext=\" + outerContext);\n\t\t\t\t\t}\n\t\t\t\t\tlet fullContextState: SimulatorState = this.computeStartState(dfa, outerContext, true);\n\t\t\t\t\tif (this.reportAmbiguities) {\n\t\t\t\t\t\tthis.reportAttemptingFullContext(dfa, conflictingAlts, nextState, startIndex, input.index);\n\t\t\t\t\t}\n\n\t\t\t\t\tinput.seek(startIndex);\n\t\t\t\t\treturn this.execATN(dfa, input, startIndex, fullContextState);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprevious = nextState;\n\n\t\t\tif (t !== IntStream.EOF) {\n\t\t\t\tinput.consume();\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * This method is used to improve the localization of error messages by\n\t * choosing an alternative rather than throwing a\n\t * {@link NoViableAltException} in particular prediction scenarios where the\n\t * {@link #ERROR} state was reached during ATN simulation.\n\t *\n\t * The default implementation of this method uses the following\n\t * algorithm to identify an ATN configuration which successfully parsed the\n\t * decision entry rule. Choosing such an alternative ensures that the\n\t * {@link ParserRuleContext} returned by the calling rule will be complete\n\t * and valid, and the syntax error will be reported later at a more\n\t * localized location.\n\t *\n\t * * If no configuration in `configs` reached the end of the\n\t *   decision rule, return {@link ATN#INVALID_ALT_NUMBER}.\n\t * * If all configurations in `configs` which reached the end of the\n\t *   decision rule predict the same alternative, return that alternative.\n\t * * If the configurations in `configs` which reached the end of the\n\t *   decision rule predict multiple alternatives (call this *S*),\n\t *   choose an alternative in the following order.\n\t *\n\t *     1. Filter the configurations in `configs` to only those\n\t *        configurations which remain viable after evaluating semantic predicates.\n\t *        If the set of these filtered configurations which also reached the end of\n\t *        the decision rule is not empty, return the minimum alternative\n\t *        represented in this set.\n\t *     1. Otherwise, choose the minimum alternative in *S*.\n\t *\n\t * In some scenarios, the algorithm described above could predict an\n\t * alternative which will result in a {@link FailedPredicateException} in\n\t * parser. Specifically, this could occur if the *only* configuration\n\t * capable of successfully parsing to the end of the decision rule is\n\t * blocked by a semantic predicate. By choosing this alternative within\n\t * {@link #adaptivePredict} instead of throwing a\n\t * {@link NoViableAltException}, the resulting\n\t * {@link FailedPredicateException} in the parser will identify the specific\n\t * predicate which is preventing the parser from successfully parsing the\n\t * decision rule, which helps developers identify and correct logic errors\n\t * in semantic predicates.\n\t *\n\t * @param input The input {@link TokenStream}\n\t * @param startIndex The start index for the current prediction, which is\n\t * the input index where any semantic context in `configs` should be\n\t * evaluated\n\t * @param previous The ATN simulation state immediately before the\n\t * {@link #ERROR} state was reached\n\t *\n\t * @returns The value to return from {@link #adaptivePredict}, or\n\t * {@link ATN#INVALID_ALT_NUMBER} if a suitable alternative was not\n\t * identified and {@link #adaptivePredict} should report an error instead.\n\t */\n\tprotected handleNoViableAlt(@NotNull input: TokenStream, startIndex: number, @NotNull previous: SimulatorState): number {\n\t\tif (previous.s0 != null) {\n\t\t\tlet alts: BitSet = new BitSet();\n\t\t\tlet maxAlt: number = 0;\n\t\t\tfor (let config of previous.s0.configs) {\n\t\t\t\tif (config.reachesIntoOuterContext || config.state instanceof RuleStopState) {\n\t\t\t\t\talts.set(config.alt);\n\t\t\t\t\tmaxAlt = Math.max(maxAlt, config.alt);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tswitch (alts.cardinality()) {\n\t\t\tcase 0:\n\t\t\t\tbreak;\n\n\t\t\tcase 1:\n\t\t\t\treturn alts.nextSetBit(0);\n\n\t\t\tdefault:\n\t\t\t\tif (!previous.s0.configs.hasSemanticContext) {\n\t\t\t\t\t// configs doesn't contain any predicates, so the predicate\n\t\t\t\t\t// filtering code below would be pointless\n\t\t\t\t\treturn alts.nextSetBit(0);\n\t\t\t\t}\n\n\t\t\t\t/*\n\t\t\t\t * Try to find a configuration set that not only dipped into the outer\n\t\t\t\t * context, but also isn't eliminated by a predicate.\n\t\t\t\t */\n\t\t\t\tlet filteredConfigs: ATNConfigSet = new ATNConfigSet();\n\t\t\t\tfor (let config of previous.s0.configs) {\n\t\t\t\t\tif (config.reachesIntoOuterContext || config.state instanceof RuleStopState) {\n\t\t\t\t\t\tfilteredConfigs.add(config);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t/* The following code blocks are adapted from predicateDFAState with\n\t\t\t\t * the following key changes.\n\t\t\t\t *\n\t\t\t\t *  1. The code operates on an ATNConfigSet rather than a DFAState.\n\t\t\t\t *  2. Predicates are collected for all alternatives represented in\n\t\t\t\t *     filteredConfigs, rather than restricting the evaluation to\n\t\t\t\t *     conflicting and/or unique configurations.\n\t\t\t\t */\n\t\t\t\tlet altToPred: SemanticContext[] | undefined = this.getPredsForAmbigAlts(alts, filteredConfigs, maxAlt);\n\t\t\t\tif (altToPred != null) {\n\t\t\t\t\tlet predicates: DFAState.PredPrediction[] | undefined = this.getPredicatePredictions(alts, altToPred);\n\t\t\t\t\tif (predicates != null) {\n\t\t\t\t\t\tlet stopIndex: number = input.index;\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tinput.seek(startIndex);\n\t\t\t\t\t\t\tlet filteredAlts: BitSet = this.evalSemanticContext(predicates, previous.outerContext, false);\n\t\t\t\t\t\t\tif (!filteredAlts.isEmpty) {\n\t\t\t\t\t\t\t\treturn filteredAlts.nextSetBit(0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfinally {\n\t\t\t\t\t\t\tinput.seek(stopIndex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn alts.nextSetBit(0);\n\t\t\t}\n\t\t}\n\n\t\tthrow this.noViableAlt(input, previous.outerContext, previous.s0.configs, startIndex);\n\t}\n\n\tprotected computeReachSet(dfa: DFA, previous: SimulatorState, t: number, contextCache: PredictionContextCache): SimulatorState | undefined {\n\t\tlet useContext: boolean = previous.useContext;\n\t\tlet remainingGlobalContext: ParserRuleContext | undefined = previous.remainingOuterContext;\n\n\t\tlet s: DFAState = previous.s0;\n\t\tif (useContext) {\n\t\t\twhile (s.isContextSymbol(t)) {\n\t\t\t\tlet next: DFAState | undefined;\n\t\t\t\tif (remainingGlobalContext != null) {\n\t\t\t\t\tremainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n\t\t\t\t\tnext = s.getContextTarget(this.getReturnState(remainingGlobalContext));\n\t\t\t\t}\n\n\t\t\t\tif (next == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tassert(remainingGlobalContext != null);\n\t\t\t\tremainingGlobalContext = (remainingGlobalContext as ParserRuleContext).parent;\n\t\t\t\ts = next;\n\t\t\t}\n\t\t}\n\n\t\tassert(!this.isAcceptState(s, useContext));\n\t\tif (this.isAcceptState(s, useContext)) {\n\t\t\treturn new SimulatorState(previous.outerContext, s, useContext, remainingGlobalContext);\n\t\t}\n\n\t\tlet s0: DFAState = s;\n\n\t\tlet target: DFAState | undefined = this.getExistingTargetState(s0, t);\n\t\tif (target == null) {\n\t\t\tlet result: [DFAState, ParserRuleContext | undefined] = this.computeTargetState(dfa, s0, remainingGlobalContext, t, useContext, contextCache);\n\t\t\ttarget = result[0];\n\t\t\tremainingGlobalContext = result[1];\n\t\t}\n\n\t\tif (target === ATNSimulator.ERROR) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tassert(!useContext || !target.configs.dipsIntoOuterContext);\n\t\treturn new SimulatorState(previous.outerContext, target, useContext, remainingGlobalContext);\n\t}\n\n\t/**\n\t * Get an existing target state for an edge in the DFA. If the target state\n\t * for the edge has not yet been computed or is otherwise not available,\n\t * this method returns `undefined`.\n\t *\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t * @returns The existing target DFA state for the given input symbol\n\t * `t`, or `undefined` if the target state for this edge is not\n\t * already cached\n\t */\n\tprotected getExistingTargetState(@NotNull s: DFAState, t: number): DFAState | undefined {\n\t\treturn s.getTarget(t);\n\t}\n\n\t/**\n\t * Compute a target state for an edge in the DFA, and attempt to add the\n\t * computed state and corresponding edge to the DFA.\n\t *\n\t * @param dfa\n\t * @param s The current DFA state\n\t * @param remainingGlobalContext\n\t * @param t The next input symbol\n\t * @param useContext\n\t * @param contextCache\n\t *\n\t * @returns The computed target DFA state for the given input symbol\n\t * `t`. If `t` does not lead to a valid DFA state, this method\n\t * returns {@link #ERROR}.\n\t */\n\t@NotNull\n\tprotected computeTargetState(@NotNull dfa: DFA, @NotNull s: DFAState, remainingGlobalContext: ParserRuleContext | undefined, t: number, useContext: boolean, contextCache: PredictionContextCache): [DFAState, ParserRuleContext | undefined] {\n\t\tlet closureConfigs: ATNConfig[] = s.configs.toArray();\n\t\tlet contextElements: IntegerList | undefined;\n\t\tlet reach: ATNConfigSet = new ATNConfigSet();\n\t\tlet stepIntoGlobal: boolean;\n\t\tdo {\n\t\t\tlet hasMoreContext: boolean = !useContext || remainingGlobalContext != null;\n\t\t\tif (!hasMoreContext) {\n\t\t\t\treach.isOutermostConfigSet = true;\n\t\t\t}\n\n\t\t\tlet reachIntermediate: ATNConfigSet = new ATNConfigSet();\n\n\t\t\t/* Configurations already in a rule stop state indicate reaching the end\n\t\t\t * of the decision rule (local context) or end of the start rule (full\n\t\t\t * context). Once reached, these configurations are never updated by a\n\t\t\t * closure operation, so they are handled separately for the performance\n\t\t\t * advantage of having a smaller intermediate set when calling closure.\n\t\t\t *\n\t\t\t * For full-context reach operations, separate handling is required to\n\t\t\t * ensure that the alternative matching the longest overall sequence is\n\t\t\t * chosen when multiple such configurations can match the input.\n\t\t\t */\n\t\t\tlet skippedStopStates: ATNConfig[] | undefined;\n\n\t\t\tfor (let c of closureConfigs) {\n\t\t\t\tif (ParserATNSimulator.debug) {\n\t\t\t\t\tconsole.log(\"testing \" + this.getTokenName(t) + \" at \" + c.toString());\n\t\t\t\t}\n\n\t\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\t\tassert(c.context.isEmpty);\n\t\t\t\t\tif (useContext && !c.reachesIntoOuterContext || t === IntStream.EOF) {\n\t\t\t\t\t\tif (skippedStopStates == null) {\n\t\t\t\t\t\t\tskippedStopStates = [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tskippedStopStates.push(c);\n\t\t\t\t\t}\n\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet n: number = c.state.numberOfOptimizedTransitions;\n\t\t\t\tfor (let ti = 0; ti < n; ti++) {               // for each optimized transition\n\t\t\t\t\tlet trans: Transition = c.state.getOptimizedTransition(ti);\n\t\t\t\t\tlet target: ATNState | undefined = this.getReachableTarget(c, trans, t);\n\t\t\t\t\tif (target != null) {\n\t\t\t\t\t\treachIntermediate.add(c.transform(target, false), contextCache);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t/* This block optimizes the reach operation for intermediate sets which\n\t\t\t * trivially indicate a termination state for the overall\n\t\t\t * adaptivePredict operation.\n\t\t\t *\n\t\t\t * The conditions assume that intermediate\n\t\t\t * contains all configurations relevant to the reach set, but this\n\t\t\t * condition is not true when one or more configurations have been\n\t\t\t * withheld in skippedStopStates, or when the current symbol is EOF.\n\t\t\t */\n\t\t\tif (this.optimize_unique_closure && skippedStopStates == null && t !== Token.EOF && reachIntermediate.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n\t\t\t\treachIntermediate.isOutermostConfigSet = reach.isOutermostConfigSet;\n\t\t\t\treach = reachIntermediate;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* If the reach set could not be trivially determined, perform a closure\n\t\t\t * operation on the intermediate set to compute its initial value.\n\t\t\t */\n\t\t\tlet collectPredicates: boolean = false;\n\t\t\tlet treatEofAsEpsilon: boolean = t === Token.EOF;\n\t\t\tthis.closure(reachIntermediate, reach, collectPredicates, hasMoreContext, contextCache, treatEofAsEpsilon);\n\t\t\tstepIntoGlobal = reach.dipsIntoOuterContext;\n\n\t\t\tif (t === IntStream.EOF) {\n\t\t\t\t/* After consuming EOF no additional input is possible, so we are\n\t\t\t\t * only interested in configurations which reached the end of the\n\t\t\t\t * decision rule (local context) or end of the start rule (full\n\t\t\t\t * context). Update reach to contain only these configurations. This\n\t\t\t\t * handles both explicit EOF transitions in the grammar and implicit\n\t\t\t\t * EOF transitions following the end of the decision or start rule.\n\t\t\t\t *\n\t\t\t\t * This is handled before the configurations in skippedStopStates,\n\t\t\t\t * because any configurations potentially added from that list are\n\t\t\t\t * already guaranteed to meet this condition whether or not it's\n\t\t\t\t * required.\n\t\t\t\t */\n\t\t\t\treach = this.removeAllConfigsNotInRuleStopState(reach, contextCache);\n\t\t\t}\n\n\t\t\t/* If skippedStopStates is not undefined, then it contains at least one\n\t\t\t * configuration. For full-context reach operations, these\n\t\t\t * configurations reached the end of the start rule, in which case we\n\t\t\t * only add them back to reach if no configuration during the current\n\t\t\t * closure operation reached such a state. This ensures adaptivePredict\n\t\t\t * chooses an alternative matching the longest overall sequence when\n\t\t\t * multiple alternatives are viable.\n\t\t\t */\n\t\t\tif (skippedStopStates != null && (!useContext || !PredictionMode.hasConfigInRuleStopState(reach))) {\n\t\t\t\tassert(skippedStopStates.length > 0);\n\t\t\t\tfor (let c of skippedStopStates) {\n\t\t\t\t\treach.add(c, contextCache);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (useContext && stepIntoGlobal) {\n\t\t\t\treach.clear();\n\n\t\t\t\t// We know remainingGlobalContext is not undefined at this point (why?)\n\t\t\t\tremainingGlobalContext = remainingGlobalContext as ParserRuleContext;\n\n\t\t\t\tremainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n\t\t\t\tlet nextContextElement: number = this.getReturnState(remainingGlobalContext);\n\t\t\t\tif (contextElements == null) {\n\t\t\t\t\tcontextElements = new IntegerList();\n\t\t\t\t}\n\n\t\t\t\tif (remainingGlobalContext.isEmpty) {\n\t\t\t\t\tremainingGlobalContext = undefined;\n\t\t\t\t} else {\n\t\t\t\t\tremainingGlobalContext = remainingGlobalContext.parent;\n\t\t\t\t}\n\n\t\t\t\tcontextElements.add(nextContextElement);\n\t\t\t\tif (nextContextElement !== PredictionContext.EMPTY_FULL_STATE_KEY) {\n\t\t\t\t\tfor (let i = 0; i < closureConfigs.length; i++) {\n\t\t\t\t\t\tclosureConfigs[i] = closureConfigs[i].appendContext(nextContextElement, contextCache);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} while (useContext && stepIntoGlobal);\n\n\t\tif (reach.isEmpty) {\n\t\t\tthis.setDFAEdge(s, t, ATNSimulator.ERROR);\n\t\t\treturn [ATNSimulator.ERROR, remainingGlobalContext];\n\t\t}\n\n\t\tlet result: DFAState = this.addDFAEdge(dfa, s, t, contextElements, reach, contextCache);\n\t\treturn [result, remainingGlobalContext];\n\t}\n\n\t/**\n\t * Return a configuration set containing only the configurations from\n\t * `configs` which are in a {@link RuleStopState}. If all\n\t * configurations in `configs` are already in a rule stop state, this\n\t * method simply returns `configs`.\n\t *\n\t * @param configs the configuration set to update\n\t * @param contextCache the {@link PredictionContext} cache\n\t *\n\t * @returns `configs` if all configurations in `configs` are in a\n\t * rule stop state, otherwise return a new configuration set containing only\n\t * the configurations from `configs` which are in a rule stop state\n\t */\n\t@NotNull\n\tprotected removeAllConfigsNotInRuleStopState(@NotNull configs: ATNConfigSet, contextCache: PredictionContextCache): ATNConfigSet {\n\t\tif (PredictionMode.allConfigsInRuleStopStates(configs)) {\n\t\t\treturn configs;\n\t\t}\n\n\t\tlet result: ATNConfigSet = new ATNConfigSet();\n\t\tfor (let config of configs) {\n\t\t\tif (!(config.state instanceof RuleStopState)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tresult.add(config, contextCache);\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t@NotNull\n\tprotected computeStartState(\n\t\tdfa: DFA,\n\t\tglobalContext: ParserRuleContext,\n\t\tuseContext: boolean): SimulatorState {\n\t\tlet s0: DFAState | undefined =\n\t\t\tdfa.isPrecedenceDfa ? dfa.getPrecedenceStartState(this._parser.precedence, useContext) :\n\t\t\t\tuseContext ? dfa.s0full :\n\t\t\t\t\tdfa.s0;\n\n\t\tif (s0 != null) {\n\t\t\tif (!useContext) {\n\t\t\t\treturn new SimulatorState(globalContext, s0, useContext, globalContext);\n\t\t\t}\n\n\t\t\ts0.setContextSensitive(this.atn);\n\t\t}\n\n\t\tlet decision: number = dfa.decision;\n\t\t// @NotNull\n\t\tlet p: ATNState = dfa.atnStartState;\n\n\t\tlet previousContext: number = 0;\n\t\tlet remainingGlobalContext: ParserRuleContext | undefined = globalContext;\n\t\tlet initialContext: PredictionContext = useContext ? PredictionContext.EMPTY_FULL : PredictionContext.EMPTY_LOCAL; // always at least the implicit call to start rule\n\t\tlet contextCache: PredictionContextCache = new PredictionContextCache();\n\t\tif (useContext) {\n\t\t\tif (!this.enable_global_context_dfa) {\n\t\t\t\twhile (remainingGlobalContext != null) {\n\t\t\t\t\tif (remainingGlobalContext.isEmpty) {\n\t\t\t\t\t\tpreviousContext = PredictionContext.EMPTY_FULL_STATE_KEY;\n\t\t\t\t\t\tremainingGlobalContext = undefined;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tpreviousContext = this.getReturnState(remainingGlobalContext);\n\t\t\t\t\t\tinitialContext = initialContext.appendSingleContext(previousContext, contextCache);\n\t\t\t\t\t\tremainingGlobalContext = remainingGlobalContext.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\twhile (s0 != null && s0.isContextSensitive && remainingGlobalContext != null) {\n\t\t\t\tlet next: DFAState | undefined;\n\t\t\t\tremainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n\t\t\t\tif (remainingGlobalContext.isEmpty) {\n\t\t\t\t\tnext = s0.getContextTarget(PredictionContext.EMPTY_FULL_STATE_KEY);\n\t\t\t\t\tpreviousContext = PredictionContext.EMPTY_FULL_STATE_KEY;\n\t\t\t\t\tremainingGlobalContext = undefined;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tpreviousContext = this.getReturnState(remainingGlobalContext);\n\t\t\t\t\tnext = s0.getContextTarget(previousContext);\n\t\t\t\t\tinitialContext = initialContext.appendSingleContext(previousContext, contextCache);\n\t\t\t\t\tremainingGlobalContext = remainingGlobalContext.parent;\n\t\t\t\t}\n\n\t\t\t\tif (next == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ts0 = next;\n\t\t\t}\n\t\t}\n\n\t\tif (s0 != null && !s0.isContextSensitive) {\n\t\t\treturn new SimulatorState(globalContext, s0, useContext, remainingGlobalContext);\n\t\t}\n\n\t\tlet configs: ATNConfigSet = new ATNConfigSet();\n\t\twhile (true) {\n\t\t\tlet reachIntermediate: ATNConfigSet = new ATNConfigSet();\n\t\t\tlet n: number = p.numberOfTransitions;\n\t\t\tfor (let ti = 0; ti < n; ti++) {\n\t\t\t\t// for each transition\n\t\t\t\tlet target: ATNState = p.transition(ti).target;\n\t\t\t\treachIntermediate.add(ATNConfig.create(target, ti + 1, initialContext));\n\t\t\t}\n\n\t\t\tlet hasMoreContext: boolean = remainingGlobalContext != null;\n\t\t\tif (!hasMoreContext) {\n\t\t\t\tconfigs.isOutermostConfigSet = true;\n\t\t\t}\n\n\t\t\tlet collectPredicates: boolean = true;\n\t\t\tthis.closure(reachIntermediate, configs, collectPredicates, hasMoreContext, contextCache, false);\n\t\t\tlet stepIntoGlobal: boolean = configs.dipsIntoOuterContext;\n\n\t\t\tlet next: DFAState;\n\t\t\tif (useContext && !this.enable_global_context_dfa) {\n\t\t\t\ts0 = this.addDFAState(dfa, configs, contextCache);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (s0 == null) {\n\t\t\t\tif (!dfa.isPrecedenceDfa) {\n\t\t\t\t\tnext = this.addDFAState(dfa, configs, contextCache);\n\t\t\t\t\tif (useContext) {\n\t\t\t\t\t\tif (!dfa.s0full) {\n\t\t\t\t\t\t\tdfa.s0full = next;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnext = dfa.s0full;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (!dfa.s0) {\n\t\t\t\t\t\t\tdfa.s0 = next;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tnext = dfa.s0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t/* If this is a precedence DFA, we use applyPrecedenceFilter\n\t\t\t\t\t * to convert the computed start state to a precedence start\n\t\t\t\t\t * state. We then use DFA.setPrecedenceStartState to set the\n\t\t\t\t\t * appropriate start state for the precedence level rather\n\t\t\t\t\t * than simply setting DFA.s0.\n\t\t\t\t\t */\n\t\t\t\t\tconfigs = this.applyPrecedenceFilter(configs, globalContext, contextCache);\n\t\t\t\t\tnext = this.addDFAState(dfa, configs, contextCache);\n\t\t\t\t\tdfa.setPrecedenceStartState(this._parser.precedence, useContext, next);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (dfa.isPrecedenceDfa) {\n\t\t\t\t\tconfigs = this.applyPrecedenceFilter(configs, globalContext, contextCache);\n\t\t\t\t}\n\n\t\t\t\tnext = this.addDFAState(dfa, configs, contextCache);\n\t\t\t\ts0.setContextTarget(previousContext, next);\n\t\t\t}\n\n\t\t\ts0 = next;\n\n\t\t\tif (!useContext || !stepIntoGlobal) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// TODO: make sure it distinguishes empty stack states\n\t\t\tnext.setContextSensitive(this.atn);\n\n\t\t\t// We know remainingGlobalContext is not undefined at this point (why?)\n\t\t\tremainingGlobalContext = remainingGlobalContext as ParserRuleContext;\n\n\t\t\tconfigs.clear();\n\t\t\tremainingGlobalContext = this.skipTailCalls(remainingGlobalContext);\n\t\t\tlet nextContextElement: number = this.getReturnState(remainingGlobalContext);\n\n\t\t\tif (remainingGlobalContext.isEmpty) {\n\t\t\t\tremainingGlobalContext = undefined;\n\t\t\t} else {\n\t\t\t\tremainingGlobalContext = remainingGlobalContext.parent;\n\t\t\t}\n\n\t\t\tif (nextContextElement !== PredictionContext.EMPTY_FULL_STATE_KEY) {\n\t\t\t\tinitialContext = initialContext.appendSingleContext(nextContextElement, contextCache);\n\t\t\t}\n\n\t\t\tpreviousContext = nextContextElement;\n\t\t}\n\n\t\treturn new SimulatorState(globalContext, s0, useContext, remainingGlobalContext);\n\t}\n\n\t/**\n\t * This method transforms the start state computed by\n\t * {@link #computeStartState} to the special start state used by a\n\t * precedence DFA for a particular precedence value. The transformation\n\t * process applies the following changes to the start state's configuration\n\t * set.\n\t *\n\t * 1. Evaluate the precedence predicates for each configuration using\n\t *    {@link SemanticContext#evalPrecedence}.\n\t * 1. When {@link ATNConfig#isPrecedenceFilterSuppressed} is `false`,\n\t *    remove all configurations which predict an alternative greater than 1,\n\t *    for which another configuration that predicts alternative 1 is in the\n\t *    same ATN state with the same prediction context. This transformation is\n\t *    valid for the following reasons:\n\t *\n\t *     * The closure block cannot contain any epsilon transitions which bypass\n\t *       the body of the closure, so all states reachable via alternative 1 are\n\t *       part of the precedence alternatives of the transformed left-recursive\n\t *       rule.\n\t *     * The \"primary\" portion of a left recursive rule cannot contain an\n\t *       epsilon transition, so the only way an alternative other than 1 can exist\n\t *       in a state that is also reachable via alternative 1 is by nesting calls\n\t *       to the left-recursive rule, with the outer calls not being at the\n\t *       preferred precedence level. The\n\t *       {@link ATNConfig#isPrecedenceFilterSuppressed} property marks ATN\n\t *       configurations which do not meet this condition, and therefore are not\n\t *       eligible for elimination during the filtering process.\n\t *\n\t * The prediction context must be considered by this filter to address\n\t * situations like the following.\n\t *\n\t * ```antlr\n\t * grammar TA;\n\t * prog: statement* EOF;\n\t * statement: letterA | statement letterA 'b' ;\n\t * letterA: 'a';\n\t * ```\n\t *\n\t * If the above grammar, the ATN state immediately before the token\n\t * reference `'a'` in `letterA` is reachable from the left edge\n\t * of both the primary and closure blocks of the left-recursive rule\n\t * `statement`. The prediction context associated with each of these\n\t * configurations distinguishes between them, and prevents the alternative\n\t * which stepped out to `prog` (and then back in to `statement`\n\t * from being eliminated by the filter.\n\t *\n\t * @param configs The configuration set computed by\n\t * {@link #computeStartState} as the start state for the DFA.\n\t * @returns The transformed configuration set representing the start state\n\t * for a precedence DFA at a particular precedence level (determined by\n\t * calling {@link Parser#getPrecedence}).\n\t */\n\t@NotNull\n\tprotected applyPrecedenceFilter(@NotNull configs: ATNConfigSet, globalContext: ParserRuleContext, contextCache: PredictionContextCache): ATNConfigSet {\n\t\tlet statesFromAlt1: Map<number, PredictionContext> = new Map<number, PredictionContext>();\n\t\tlet configSet: ATNConfigSet = new ATNConfigSet();\n\t\tfor (let config of configs) {\n\t\t\t// handle alt 1 first\n\t\t\tif (config.alt !== 1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet updatedContext: SemanticContext | undefined = config.semanticContext.evalPrecedence(this._parser, globalContext);\n\t\t\tif (updatedContext == null) {\n\t\t\t\t// the configuration was eliminated\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstatesFromAlt1.set(config.state.stateNumber, config.context);\n\t\t\tif (updatedContext !== config.semanticContext) {\n\t\t\t\tconfigSet.add(config.transform(config.state, false, updatedContext), contextCache);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconfigSet.add(config, contextCache);\n\t\t\t}\n\t\t}\n\n\t\tfor (let config of configs) {\n\t\t\tif (config.alt === 1) {\n\t\t\t\t// already handled\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (!config.isPrecedenceFilterSuppressed) {\n\t\t\t\t/* In the future, this elimination step could be updated to also\n\t\t\t\t * filter the prediction context for alternatives predicting alt>1\n\t\t\t\t * (basically a graph subtraction algorithm).\n\t\t\t\t */\n\t\t\t\tlet context: PredictionContext | undefined = statesFromAlt1.get(config.state.stateNumber);\n\t\t\t\tif (context != null && context.equals(config.context)) {\n\t\t\t\t\t// eliminated\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconfigSet.add(config, contextCache);\n\t\t}\n\n\t\treturn configSet;\n\t}\n\n\tprotected getReachableTarget(@NotNull source: ATNConfig, @NotNull trans: Transition, ttype: number): ATNState | undefined {\n\t\tif (trans.matches(ttype, 0, this.atn.maxTokenType)) {\n\t\t\treturn trans.target;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t/** collect and set D's semantic context */\n\tprotected predicateDFAState(\n\t\tD: DFAState,\n\t\tconfigs: ATNConfigSet,\n\t\tnalts: number): DFAState.PredPrediction[] | undefined {\n\t\tlet conflictingAlts: BitSet | undefined = this.getConflictingAltsFromConfigSet(configs);\n\t\tif (!conflictingAlts) {\n\t\t\tthrow new Error(\"This unhandled scenario is intended to be unreachable, but I'm currently not sure of why we know that's the case.\");\n\t\t}\n\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"predicateDFAState \" + D);\n\t\t}\n\t\tlet altToPred: SemanticContext[] | undefined = this.getPredsForAmbigAlts(conflictingAlts, configs, nalts);\n\t\t// altToPred[uniqueAlt] is now our validating predicate (if any)\n\t\tlet predPredictions: DFAState.PredPrediction[] | undefined;\n\t\tif (altToPred != null) {\n\t\t\t// we have a validating predicate; test it\n\t\t\t// Update DFA so reach becomes accept state with predicate\n\t\t\tpredPredictions = this.getPredicatePredictions(conflictingAlts, altToPred);\n\t\t\tD.predicates = predPredictions;\n\t\t}\n\t\treturn predPredictions;\n\t}\n\n\tprotected getPredsForAmbigAlts(\n\t\t@NotNull ambigAlts: BitSet,\n\t\t@NotNull configs: ATNConfigSet,\n\t\tnalts: number): SemanticContext[] | undefined {\n\t\t// REACH=[1|1|[]|0:0, 1|2|[]|0:1]\n\n\t\t/* altToPred starts as an array of all undefined contexts. The entry at index i\n\t\t * corresponds to alternative i. altToPred[i] may have one of three values:\n\t\t *   1. undefined: no ATNConfig c is found such that c.alt===i\n\t\t *   2. SemanticContext.NONE: At least one ATNConfig c exists such that\n\t\t *      c.alt===i and c.semanticContext===SemanticContext.NONE. In other words,\n\t\t *      alt i has at least one unpredicated config.\n\t\t *   3. Non-NONE Semantic Context: There exists at least one, and for all\n\t\t *      ATNConfig c such that c.alt===i, c.semanticContext!==SemanticContext.NONE.\n\t\t *\n\t\t * From this, it is clear that NONE||anything==NONE.\n\t\t */\n\t\tlet altToPred: Array<SemanticContext | undefined> | undefined = new Array<SemanticContext>(nalts + 1);\n\t\tlet n: number = altToPred.length;\n\t\tfor (let c of configs) {\n\t\t\tif (ambigAlts.get(c.alt)) {\n\t\t\t\taltToPred[c.alt] = SemanticContext.or(altToPred[c.alt], c.semanticContext);\n\t\t\t}\n\t\t}\n\n\t\tlet nPredAlts: number = 0;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tif (altToPred[i] == null) {\n\t\t\t\taltToPred[i] = SemanticContext.NONE;\n\t\t\t}\n\t\t\telse if (altToPred[i] !== SemanticContext.NONE) {\n\t\t\t\tnPredAlts++;\n\t\t\t}\n\t\t}\n\n\t\t// At this point we know `altToPred` doesn't contain any undefined entries\n\t\tlet result: SemanticContext[] | undefined = altToPred as SemanticContext[];\n\n\t\t// nonambig alts are undefined in result\n\t\tif (nPredAlts === 0) {\n\t\t\tresult = undefined;\n\t\t}\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"getPredsForAmbigAlts result \" + (result ? Arrays.toString(result) : \"undefined\"));\n\t\t}\n\t\treturn result;\n\t}\n\n\tprotected getPredicatePredictions(ambigAlts: BitSet | undefined, altToPred: SemanticContext[]): DFAState.PredPrediction[] | undefined {\n\t\tlet pairs: DFAState.PredPrediction[] = [];\n\t\tlet containsPredicate: boolean = false;\n\t\tfor (let i = 1; i < altToPred.length; i++) {\n\t\t\tlet pred: SemanticContext = altToPred[i];\n\n\t\t\t// unpredicated is indicated by SemanticContext.NONE\n\t\t\tassert(pred != null);\n\n\t\t\t// find first unpredicated but ambig alternative, if any.\n\t\t\t// Only ambiguous alternatives will have SemanticContext.NONE.\n\t\t\t// Any unambig alts or ambig naked alts after first ambig naked are ignored\n\t\t\t// (undefined, i) means alt i is the default prediction\n\t\t\t// if no (undefined, i), then no default prediction.\n\t\t\tif (ambigAlts != null && ambigAlts.get(i) && pred === SemanticContext.NONE) {\n\t\t\t\tpairs.push(new DFAState.PredPrediction(pred, i));\n\t\t\t}\n\t\t\telse if (pred !== SemanticContext.NONE) {\n\t\t\t\tcontainsPredicate = true;\n\t\t\t\tpairs.push(new DFAState.PredPrediction(pred, i));\n\t\t\t}\n\t\t}\n\n\t\tif (!containsPredicate) {\n\t\t\treturn undefined;\n\t\t}\n\n//\t\tSystem.out.println(Arrays.toString(altToPred)+\"->\"+pairs);\n\t\treturn pairs;\n\t}\n\n\t/** Look through a list of predicate/alt pairs, returning alts for the\n\t *  pairs that win. An `undefined` predicate indicates an alt containing an\n\t *  unpredicated config which behaves as \"always true.\"\n\t */\n\tprotected evalSemanticContext(\n\t\t@NotNull predPredictions: DFAState.PredPrediction[],\n\t\touterContext: ParserRuleContext,\n\t\tcomplete: boolean): BitSet {\n\t\tlet predictions: BitSet = new BitSet();\n\t\tfor (let pair of predPredictions) {\n\t\t\tif (pair.pred === SemanticContext.NONE) {\n\t\t\t\tpredictions.set(pair.alt);\n\t\t\t\tif (!complete) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet evaluatedResult: boolean = this.evalSemanticContextImpl(pair.pred, outerContext, pair.alt);\n\t\t\tif (ParserATNSimulator.debug || ParserATNSimulator.dfa_debug) {\n\t\t\t\tconsole.log(\"eval pred \" + pair + \"=\" + evaluatedResult);\n\t\t\t}\n\n\t\t\tif (evaluatedResult) {\n\t\t\t\tif (ParserATNSimulator.debug || ParserATNSimulator.dfa_debug) {\n\t\t\t\t\tconsole.log(\"PREDICT \" + pair.alt);\n\t\t\t\t}\n\t\t\t\tpredictions.set(pair.alt);\n\t\t\t\tif (!complete) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn predictions;\n\t}\n\n\t/**\n\t * Evaluate a semantic context within a specific parser context.\n\t *\n\t * This method might not be called for every semantic context evaluated\n\t * during the prediction process. In particular, we currently do not\n\t * evaluate the following but it may change in the future:\n\t *\n\t * * Precedence predicates (represented by\n\t *   {@link SemanticContext.PrecedencePredicate}) are not currently evaluated\n\t *   through this method.\n\t * * Operator predicates (represented by {@link SemanticContext.AND} and\n\t *   {@link SemanticContext.OR}) are evaluated as a single semantic\n\t *   context, rather than evaluating the operands individually.\n\t *   Implementations which require evaluation results from individual\n\t *   predicates should override this method to explicitly handle evaluation of\n\t *   the operands within operator predicates.\n\t *\n\t * @param pred The semantic context to evaluate\n\t * @param parserCallStack The parser context in which to evaluate the\n\t * semantic context\n\t * @param alt The alternative which is guarded by `pred`\n\t *\n\t * @since 4.3\n\t */\n\tprotected evalSemanticContextImpl(@NotNull pred: SemanticContext, parserCallStack: ParserRuleContext, alt: number): boolean {\n\t\treturn pred.eval(this._parser, parserCallStack);\n\t}\n\n\t/* TODO: If we are doing predicates, there is no point in pursuing\n\t\t closure operations if we reach a DFA state that uniquely predicts\n\t\t alternative. We will not be caching that DFA state and it is a\n\t\t waste to pursue the closure. Might have to advance when we do\n\t\t ambig detection thought :(\n\t\t  */\n\n\tprotected closure(\n\t\tsourceConfigs: ATNConfigSet,\n\t\t@NotNull configs: ATNConfigSet,\n\t\tcollectPredicates: boolean,\n\t\thasMoreContext: boolean,\n\t\t@Nullable contextCache: PredictionContextCache,\n\t\ttreatEofAsEpsilon: boolean): void {\n\t\tif (contextCache == null) {\n\t\t\tcontextCache = PredictionContextCache.UNCACHED;\n\t\t}\n\n\t\tlet currentConfigs: ATNConfigSet = sourceConfigs;\n\t\tlet closureBusy: Array2DHashSet<ATNConfig> = new Array2DHashSet<ATNConfig>(ObjectEqualityComparator.INSTANCE);\n\t\twhile (currentConfigs.size > 0) {\n\t\t\tlet intermediate: ATNConfigSet = new ATNConfigSet();\n\t\t\tfor (let config of currentConfigs) {\n\t\t\t\tthis.closureImpl(config, configs, intermediate, closureBusy, collectPredicates, hasMoreContext, contextCache, 0, treatEofAsEpsilon);\n\t\t\t}\n\n\t\t\tcurrentConfigs = intermediate;\n\t\t}\n\t}\n\n\tprotected closureImpl(\n\t\t@NotNull config: ATNConfig,\n\t\t@NotNull configs: ATNConfigSet,\n\t\t@Nullable intermediate: ATNConfigSet,\n\t\t@NotNull closureBusy: Array2DHashSet<ATNConfig>,\n\t\tcollectPredicates: boolean,\n\t\thasMoreContexts: boolean,\n\t\t@NotNull contextCache: PredictionContextCache,\n\t\tdepth: number,\n\t\ttreatEofAsEpsilon: boolean): void {\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"closure(\" + config.toString(this._parser, true) + \")\");\n\t\t}\n\n\t\tif (config.state instanceof RuleStopState) {\n\t\t\t// We hit rule end. If we have context info, use it\n\t\t\tif (!config.context.isEmpty) {\n\t\t\t\tlet hasEmpty: boolean = config.context.hasEmpty;\n\t\t\t\tlet nonEmptySize: number = config.context.size - (hasEmpty ? 1 : 0);\n\t\t\t\tfor (let i = 0; i < nonEmptySize; i++) {\n\t\t\t\t\tlet newContext: PredictionContext = config.context.getParent(i); // \"pop\" return state\n\t\t\t\t\tlet returnState: ATNState = this.atn.states[config.context.getReturnState(i)];\n\t\t\t\t\tlet c: ATNConfig = ATNConfig.create(returnState, config.alt, newContext, config.semanticContext);\n\t\t\t\t\t// While we have context to pop back from, we may have\n\t\t\t\t\t// gotten that context AFTER having fallen off a rule.\n\t\t\t\t\t// Make sure we track that we are now out of context.\n\t\t\t\t\tc.outerContextDepth = config.outerContextDepth;\n\t\t\t\t\tc.isPrecedenceFilterSuppressed = config.isPrecedenceFilterSuppressed;\n\t\t\t\t\tassert(depth > MIN_INTEGER_VALUE);\n\t\t\t\t\tthis.closureImpl(c, configs, intermediate, closureBusy, collectPredicates, hasMoreContexts, contextCache, depth - 1, treatEofAsEpsilon);\n\t\t\t\t}\n\n\t\t\t\tif (!hasEmpty || !hasMoreContexts) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconfig = config.transform(config.state, false, PredictionContext.EMPTY_LOCAL);\n\t\t\t}\n\t\t\telse if (!hasMoreContexts) {\n\t\t\t\tconfigs.add(config, contextCache);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// else if we have no context info, just chase follow links (if greedy)\n\t\t\t\tif (ParserATNSimulator.debug) {\n\t\t\t\t\tconsole.log(\"FALLING off rule \" +\n\t\t\t\t\t\tthis.getRuleName(config.state.ruleIndex));\n\t\t\t\t}\n\n\t\t\t\tif (config.context === PredictionContext.EMPTY_FULL) {\n\t\t\t\t\t// no need to keep full context overhead when we step out\n\t\t\t\t\tconfig = config.transform(config.state, false, PredictionContext.EMPTY_LOCAL);\n\t\t\t\t}\n\t\t\t\telse if (!config.reachesIntoOuterContext && PredictionContext.isEmptyLocal(config.context)) {\n\t\t\t\t\t// add stop state when leaving decision rule for the first time\n\t\t\t\t\tconfigs.add(config, contextCache);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet p: ATNState = config.state;\n\t\t// optimization\n\t\tif (!p.onlyHasEpsilonTransitions) {\n\t\t\tconfigs.add(config, contextCache);\n\t\t\t// make sure to not return here, because EOF transitions can act as\n\t\t\t// both epsilon transitions and non-epsilon transitions.\n\t\t\tif (ParserATNSimulator.debug) {\n\t\t\t\tconsole.log(\"added config \" + configs);\n\t\t\t}\n\t\t}\n\n\t\tfor (let i = 0; i < p.numberOfOptimizedTransitions; i++) {\n\t\t\t// This block implements first-edge elimination of ambiguous LR\n\t\t\t// alternatives as part of dynamic disambiguation during prediction.\n\t\t\t// See antlr/antlr4#1398.\n\t\t\tif (i === 0\n\t\t\t\t&& p.stateType === ATNStateType.STAR_LOOP_ENTRY\n\t\t\t\t&& (p as StarLoopEntryState).precedenceRuleDecision\n\t\t\t\t&& !config.context.hasEmpty) {\n\n\t\t\t\tlet precedenceDecision = p as StarLoopEntryState;\n\n\t\t\t\t// When suppress is true, it means the outgoing edge i==0 is\n\t\t\t\t// ambiguous with the outgoing edge i==1, and thus the closure\n\t\t\t\t// operation can dynamically disambiguate by suppressing this\n\t\t\t\t// edge during the closure operation.\n\t\t\t\tlet suppress: boolean = true;\n\t\t\t\tfor (let j: number = 0; j < config.context.size; j++) {\n\t\t\t\t\tif (!precedenceDecision.precedenceLoopbackStates.get(config.context.getReturnState(j))) {\n\t\t\t\t\t\tsuppress = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (suppress) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet t: Transition = p.getOptimizedTransition(i);\n\t\t\tlet continueCollecting: boolean =\n\t\t\t\t!(t instanceof ActionTransition) && collectPredicates;\n\t\t\tlet c: ATNConfig | undefined = this.getEpsilonTarget(config, t, continueCollecting, depth === 0, contextCache, treatEofAsEpsilon);\n\t\t\tif (c != null) {\n\t\t\t\tif (t instanceof RuleTransition) {\n\t\t\t\t\tif (intermediate != null && !collectPredicates) {\n\t\t\t\t\t\tintermediate.add(c, contextCache);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet newDepth: number = depth;\n\t\t\t\tif (config.state instanceof RuleStopState) {\n\t\t\t\t\t// target fell off end of rule; mark resulting c as having dipped into outer context\n\t\t\t\t\t// We can't get here if incoming config was rule stop and we had context\n\t\t\t\t\t// track how far we dip into outer context.  Might\n\t\t\t\t\t// come in handy and we avoid evaluating context dependent\n\t\t\t\t\t// preds if this is > 0.\n\n\t\t\t\t\tif (this.dfa != null && this.dfa.isPrecedenceDfa) {\n\t\t\t\t\t\tlet outermostPrecedenceReturn: number = (t as EpsilonTransition).outermostPrecedenceReturn;\n\t\t\t\t\t\tif (outermostPrecedenceReturn === this.dfa.atnStartState.ruleIndex) {\n\t\t\t\t\t\t\tc.isPrecedenceFilterSuppressed = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tc.outerContextDepth = c.outerContextDepth + 1;\n\n\t\t\t\t\tif (!closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for right-recursive rules\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tassert(newDepth > MIN_INTEGER_VALUE);\n\t\t\t\t\tnewDepth--;\n\t\t\t\t\tif (ParserATNSimulator.debug) {\n\t\t\t\t\t\tconsole.log(\"dips into outer ctx: \" + c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (t instanceof RuleTransition) {\n\t\t\t\t\tif (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext.isEmptyLocal(config.context))) {\n\t\t\t\t\t\tassert(c.context === config.context);\n\t\t\t\t\t\tif (newDepth === 0) {\n\t\t\t\t\t\t\t// the pop/push of a tail call would keep the depth\n\t\t\t\t\t\t\t// constant, except we latch if it goes negative\n\t\t\t\t\t\t\tnewDepth--;\n\t\t\t\t\t\t\tif (!this.tail_call_preserves_sll && PredictionContext.isEmptyLocal(config.context)) {\n\t\t\t\t\t\t\t\t// make sure the SLL config \"dips into the outer context\" or prediction may not fall back to LL on conflict\n\t\t\t\t\t\t\t\tc.outerContextDepth = c.outerContextDepth + 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// latch when newDepth goes negative - once we step out of the entry context we can't return\n\t\t\t\t\t\tif (newDepth >= 0) {\n\t\t\t\t\t\t\tnewDepth++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (!t.isEpsilon && !closureBusy.add(c)) {\n\t\t\t\t\t\t// avoid infinite recursion for EOF* and EOF+\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tthis.closureImpl(c, configs, intermediate, closureBusy, continueCollecting, hasMoreContexts, contextCache, newDepth, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\t}\n\n\t@NotNull\n\tpublic getRuleName(index: number): string {\n\t\tif (this._parser != null && index >= 0) {\n\t\t\treturn this._parser.ruleNames[index];\n\t\t}\n\t\treturn \"<rule \" + index + \">\";\n\t}\n\n\tprotected getEpsilonTarget(@NotNull config: ATNConfig, @NotNull t: Transition, collectPredicates: boolean, inContext: boolean, contextCache: PredictionContextCache, treatEofAsEpsilon: boolean): ATNConfig | undefined {\n\t\tswitch (t.serializationType) {\n\t\tcase TransitionType.RULE:\n\t\t\treturn this.ruleTransition(config, t as RuleTransition, contextCache);\n\n\t\tcase TransitionType.PRECEDENCE:\n\t\t\treturn this.precedenceTransition(config, t as PrecedencePredicateTransition, collectPredicates, inContext);\n\n\t\tcase TransitionType.PREDICATE:\n\t\t\treturn this.predTransition(config, t as PredicateTransition, collectPredicates, inContext);\n\n\t\tcase TransitionType.ACTION:\n\t\t\treturn this.actionTransition(config, t as ActionTransition);\n\n\t\tcase TransitionType.EPSILON:\n\t\t\treturn config.transform(t.target, false);\n\n\t\tcase TransitionType.ATOM:\n\t\tcase TransitionType.RANGE:\n\t\tcase TransitionType.SET:\n\t\t\t// EOF transitions act like epsilon transitions after the first EOF\n\t\t\t// transition is traversed\n\t\t\tif (treatEofAsEpsilon) {\n\t\t\t\tif (t.matches(Token.EOF, 0, 1)) {\n\t\t\t\t\treturn config.transform(t.target, false);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn undefined;\n\n\t\tdefault:\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t@NotNull\n\tprotected actionTransition(@NotNull config: ATNConfig, @NotNull t: ActionTransition): ATNConfig {\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"ACTION edge \" + t.ruleIndex + \":\" + t.actionIndex);\n\t\t}\n\t\treturn config.transform(t.target, false);\n\t}\n\n\t@Nullable\n\tprotected precedenceTransition(\n\t\t@NotNull config: ATNConfig,\n\t\t@NotNull pt: PrecedencePredicateTransition,\n\t\tcollectPredicates: boolean,\n\t\tinContext: boolean): ATNConfig {\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n\t\t\t\tpt.precedence + \">=_p\" +\n\t\t\t\t\", ctx dependent=true\");\n\t\t\tif (this._parser != null) {\n\t\t\t\tconsole.log(\"context surrounding pred is \" +\n\t\t\t\t\tthis._parser.getRuleInvocationStack());\n\t\t\t}\n\t\t}\n\n\t\tlet c: ATNConfig;\n\t\tif (collectPredicates && inContext) {\n\t\t\tlet newSemCtx: SemanticContext = SemanticContext.and(config.semanticContext, pt.predicate);\n\t\t\tc = config.transform(pt.target, false, newSemCtx);\n\t\t}\n\t\telse {\n\t\t\tc = config.transform(pt.target, false);\n\t\t}\n\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"config from pred transition=\" + c);\n\t\t}\n\t\treturn c;\n\t}\n\n\t@Nullable\n\tprotected predTransition(\n\t\t@NotNull config: ATNConfig,\n\t\t@NotNull pt: PredicateTransition,\n\t\tcollectPredicates: boolean,\n\t\tinContext: boolean): ATNConfig {\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"PRED (collectPredicates=\" + collectPredicates + \") \" +\n\t\t\t\tpt.ruleIndex + \":\" + pt.predIndex +\n\t\t\t\t\", ctx dependent=\" + pt.isCtxDependent);\n\t\t\tif (this._parser != null) {\n\t\t\t\tconsole.log(\"context surrounding pred is \" +\n\t\t\t\t\tthis._parser.getRuleInvocationStack());\n\t\t\t}\n\t\t}\n\n\t\tlet c: ATNConfig;\n\t\tif (collectPredicates &&\n\t\t\t(!pt.isCtxDependent || (pt.isCtxDependent && inContext))) {\n\t\t\tlet newSemCtx: SemanticContext = SemanticContext.and(config.semanticContext, pt.predicate);\n\t\t\tc = config.transform(pt.target, false, newSemCtx);\n\t\t}\n\t\telse {\n\t\t\tc = config.transform(pt.target, false);\n\t\t}\n\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"config from pred transition=\" + c);\n\t\t}\n\t\treturn c;\n\t}\n\n\t@NotNull\n\tprotected ruleTransition(@NotNull config: ATNConfig, @NotNull t: RuleTransition, @Nullable contextCache: PredictionContextCache): ATNConfig {\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"CALL rule \" + this.getRuleName(t.target.ruleIndex) +\n\t\t\t\t\", ctx=\" + config.context);\n\t\t}\n\n\t\tlet returnState: ATNState = t.followState;\n\t\tlet newContext: PredictionContext;\n\n\t\tif (this.optimize_tail_calls && t.optimizedTailCall && (!this.tail_call_preserves_sll || !PredictionContext.isEmptyLocal(config.context))) {\n\t\t\tnewContext = config.context;\n\t\t}\n\t\telse if (contextCache != null) {\n\t\t\tnewContext = contextCache.getChild(config.context, returnState.stateNumber);\n\t\t}\n\t\telse {\n\t\t\tnewContext = config.context.getChild(returnState.stateNumber);\n\t\t}\n\n\t\treturn config.transform(t.target, false, newContext);\n\t}\n\n\tprivate static STATE_ALT_SORT_COMPARATOR: (o1: ATNConfig, o2: ATNConfig) => number =\n\t\t(o1: ATNConfig, o2: ATNConfig): number => {\n\t\t\tlet diff: number = o1.state.nonStopStateNumber - o2.state.nonStopStateNumber;\n\t\t\tif (diff !== 0) {\n\t\t\t\treturn diff;\n\t\t\t}\n\n\t\t\tdiff = o1.alt - o2.alt;\n\t\t\tif (diff !== 0) {\n\t\t\t\treturn diff;\n\t\t\t}\n\n\t\t\treturn 0;\n\t\t}\n\n\tprivate isConflicted(@NotNull configset: ATNConfigSet, contextCache: PredictionContextCache): ConflictInfo | undefined {\n\t\tif (configset.uniqueAlt !== ATN.INVALID_ALT_NUMBER || configset.size <= 1) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet configs: ATNConfig[] = configset.toArray();\n\t\tconfigs.sort(ParserATNSimulator.STATE_ALT_SORT_COMPARATOR);\n\n\t\tlet exact: boolean = !configset.dipsIntoOuterContext;\n\t\tlet alts: BitSet = new BitSet();\n\t\tlet minAlt: number = configs[0].alt;\n\t\talts.set(minAlt);\n\n\t\t/* Quick checks come first (single pass, no context joining):\n\t\t *  1. Make sure first config in the sorted list predicts the minimum\n\t\t *     represented alternative.\n\t\t *  2. Make sure every represented state has at least one configuration\n\t\t *     which predicts the minimum represented alternative.\n\t\t *  3. (exact only) make sure every represented state has at least one\n\t\t *     configuration which predicts each represented alternative.\n\t\t */\n\n\t\t// quick check 1 & 2 => if we assume #1 holds and check #2 against the\n\t\t// minAlt from the first state, #2 will fail if the assumption was\n\t\t// incorrect\n\t\tlet currentState: number = configs[0].state.nonStopStateNumber;\n\t\tfor (let config of configs) {\n\t\t\tlet stateNumber: number = config.state.nonStopStateNumber;\n\t\t\tif (stateNumber !== currentState) {\n\t\t\t\tif (config.alt !== minAlt) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tcurrentState = stateNumber;\n\t\t\t}\n\t\t}\n\n\t\tlet representedAlts: BitSet;\n\t\tif (exact) {\n\t\t\tcurrentState = configs[0].state.nonStopStateNumber;\n\n\t\t\t// get the represented alternatives of the first state\n\t\t\trepresentedAlts = new BitSet();\n\t\t\tlet maxAlt: number = minAlt;\n\t\t\tfor (let config of configs) {\n\t\t\t\tif (config.state.nonStopStateNumber !== currentState) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlet alt: number = config.alt;\n\t\t\t\trepresentedAlts.set(alt);\n\t\t\t\tmaxAlt = alt;\n\t\t\t}\n\n\t\t\t// quick check #3:\n\t\t\tcurrentState = configs[0].state.nonStopStateNumber;\n\t\t\tlet currentAlt: number = minAlt;\n\t\t\tfor (let config of configs) {\n\t\t\t\tlet stateNumber: number = config.state.nonStopStateNumber;\n\t\t\t\tlet alt: number = config.alt;\n\t\t\t\tif (stateNumber !== currentState) {\n\t\t\t\t\tif (currentAlt !== maxAlt) {\n\t\t\t\t\t\texact = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentState = stateNumber;\n\t\t\t\t\tcurrentAlt = minAlt;\n\t\t\t\t}\n\t\t\t\telse if (alt !== currentAlt) {\n\t\t\t\t\tif (alt !== representedAlts.nextSetBit(currentAlt + 1)) {\n\t\t\t\t\t\texact = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrentAlt = alt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcurrentState = configs[0].state.nonStopStateNumber;\n\t\tlet firstIndexCurrentState: number = 0;\n\t\tlet lastIndexCurrentStateMinAlt: number = 0;\n\t\tlet joinedCheckContext: PredictionContext = configs[0].context;\n\t\tfor (let i = 1; i < configs.length; i++) {\n\t\t\tlet config: ATNConfig = configs[i];\n\t\t\tif (config.alt !== minAlt) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (config.state.nonStopStateNumber !== currentState) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tlastIndexCurrentStateMinAlt = i;\n\t\t\tjoinedCheckContext = contextCache.join(joinedCheckContext, configs[i].context);\n\t\t}\n\n\t\tfor (let i = lastIndexCurrentStateMinAlt + 1; i < configs.length; i++) {\n\t\t\tlet config: ATNConfig = configs[i];\n\t\t\tlet state: ATNState = config.state;\n\t\t\talts.set(config.alt);\n\t\t\tif (state.nonStopStateNumber !== currentState) {\n\t\t\t\tcurrentState = state.nonStopStateNumber;\n\t\t\t\tfirstIndexCurrentState = i;\n\t\t\t\tlastIndexCurrentStateMinAlt = i;\n\t\t\t\tjoinedCheckContext = config.context;\n\t\t\t\tfor (let j = firstIndexCurrentState + 1; j < configs.length; j++) {\n\t\t\t\t\tlet config2: ATNConfig = configs[j];\n\t\t\t\t\tif (config2.alt !== minAlt) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (config2.state.nonStopStateNumber !== currentState) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tlastIndexCurrentStateMinAlt = j;\n\t\t\t\t\tjoinedCheckContext = contextCache.join(joinedCheckContext, config2.context);\n\t\t\t\t}\n\n\t\t\t\ti = lastIndexCurrentStateMinAlt;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tlet joinedCheckContext2: PredictionContext = config.context;\n\t\t\tlet currentAlt: number = config.alt;\n\t\t\tlet lastIndexCurrentStateCurrentAlt: number = i;\n\t\t\tfor (let j = lastIndexCurrentStateCurrentAlt + 1; j < configs.length; j++) {\n\t\t\t\tlet config2: ATNConfig = configs[j];\n\t\t\t\tif (config2.alt !== currentAlt) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (config2.state.nonStopStateNumber !== currentState) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tlastIndexCurrentStateCurrentAlt = j;\n\t\t\t\tjoinedCheckContext2 = contextCache.join(joinedCheckContext2, config2.context);\n\t\t\t}\n\n\t\t\ti = lastIndexCurrentStateCurrentAlt;\n\n\t\t\tlet check: PredictionContext = contextCache.join(joinedCheckContext, joinedCheckContext2);\n\t\t\tif (!joinedCheckContext.equals(check)) {\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\t// update exact if necessary\n\t\t\texact = exact && joinedCheckContext.equals(joinedCheckContext2);\n\t\t}\n\n\t\treturn new ConflictInfo(alts, exact);\n\t}\n\n\tprotected getConflictingAltsFromConfigSet(configs: ATNConfigSet): BitSet | undefined {\n\t\tlet conflictingAlts: BitSet | undefined = configs.conflictingAlts;\n\t\tif (conflictingAlts == null && configs.uniqueAlt !== ATN.INVALID_ALT_NUMBER) {\n\t\t\tconflictingAlts = new BitSet();\n\t\t\tconflictingAlts.set(configs.uniqueAlt);\n\t\t}\n\n\t\treturn conflictingAlts;\n\t}\n\n\t@NotNull\n\tpublic getTokenName(t: number): string {\n\t\tif (t === Token.EOF) {\n\t\t\treturn \"EOF\";\n\t\t}\n\n\t\tlet vocabulary: Vocabulary = this._parser != null ? this._parser.vocabulary : VocabularyImpl.EMPTY_VOCABULARY;\n\t\tlet displayName: string = vocabulary.getDisplayName(t);\n\t\tif (displayName === String(t)) {\n\t\t\treturn displayName;\n\t\t}\n\n\t\treturn displayName + \"<\" + t + \">\";\n\t}\n\n\tpublic getLookaheadName(input: TokenStream): string {\n\t\treturn this.getTokenName(input.LA(1));\n\t}\n\n\tpublic dumpDeadEndConfigs(@NotNull nvae: NoViableAltException): void {\n\t\tconsole.log(\"dead end configs: \");\n\t\tlet deadEndConfigs = nvae.deadEndConfigs;\n\t\tif (!deadEndConfigs) {\n\t\t\treturn;\n\t\t}\n\n\t\tfor (let c of deadEndConfigs) {\n\t\t\tlet trans: string = \"no edges\";\n\t\t\tif (c.state.numberOfOptimizedTransitions > 0) {\n\t\t\t\tlet t: Transition = c.state.getOptimizedTransition(0);\n\t\t\t\tif (t instanceof AtomTransition) {\n\t\t\t\t\ttrans = \"Atom \" + this.getTokenName(t._label);\n\t\t\t\t}\n\t\t\t\telse if (t instanceof SetTransition) {\n\t\t\t\t\tlet not: boolean = t instanceof NotSetTransition;\n\t\t\t\t\ttrans = (not ? \"~\" : \"\") + \"Set \" + t.set.toString();\n\t\t\t\t}\n\t\t\t}\n\t\t\tconsole.log(c.toString(this._parser, true) + \":\" + trans);\n\t\t}\n\t}\n\n\t@NotNull\n\tprotected noViableAlt(\n\t\t@NotNull input: TokenStream,\n\t\t@NotNull outerContext: ParserRuleContext,\n\t\t@NotNull configs: ATNConfigSet,\n\t\tstartIndex: number): NoViableAltException {\n\t\treturn new NoViableAltException(this._parser, input,\n\t\t\tinput.get(startIndex),\n\t\t\tinput.LT(1),\n\t\t\tconfigs, outerContext);\n\t}\n\n\tprotected getUniqueAlt(@NotNull configs: Iterable<ATNConfig>): number {\n\t\tlet alt: number = ATN.INVALID_ALT_NUMBER;\n\t\tfor (let c of configs) {\n\t\t\tif (alt === ATN.INVALID_ALT_NUMBER) {\n\t\t\t\talt = c.alt; // found first alt\n\t\t\t}\n\t\t\telse if (c.alt !== alt) {\n\t\t\t\treturn ATN.INVALID_ALT_NUMBER;\n\t\t\t}\n\t\t}\n\t\treturn alt;\n\t}\n\n\tprotected configWithAltAtStopState(@NotNull configs: Iterable<ATNConfig>, alt: number): boolean {\n\t\tfor (let c of configs) {\n\t\t\tif (c.alt === alt) {\n\t\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t@NotNull\n\tprotected addDFAEdge(\n\t\t@NotNull dfa: DFA,\n\t\t@NotNull fromState: DFAState,\n\t\tt: number,\n\t\tcontextTransitions: IntegerList | undefined,\n\t\t@NotNull toConfigs: ATNConfigSet,\n\t\tcontextCache: PredictionContextCache): DFAState {\n\t\tassert(contextTransitions == null || contextTransitions.isEmpty || dfa.isContextSensitive);\n\n\t\tlet from: DFAState = fromState;\n\t\tlet to: DFAState = this.addDFAState(dfa, toConfigs, contextCache);\n\n\t\tif (contextTransitions != null) {\n\t\t\tfor (let context of contextTransitions.toArray()) {\n\t\t\t\tif (context === PredictionContext.EMPTY_FULL_STATE_KEY) {\n\t\t\t\t\tif (from.configs.isOutermostConfigSet) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfrom.setContextSensitive(this.atn);\n\t\t\t\tfrom.setContextSymbol(t);\n\t\t\t\tlet next: DFAState | undefined = from.getContextTarget(context);\n\t\t\t\tif (next != null) {\n\t\t\t\t\tfrom = next;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tnext = this.addDFAContextState(dfa, from.configs, context, contextCache);\n\t\t\t\tassert(context !== PredictionContext.EMPTY_FULL_STATE_KEY || next.configs.isOutermostConfigSet);\n\t\t\t\tfrom.setContextTarget(context, next);\n\t\t\t\tfrom = next;\n\t\t\t}\n\t\t}\n\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"EDGE \" + from + \" -> \" + to + \" upon \" + this.getTokenName(t));\n\t\t}\n\t\tthis.setDFAEdge(from, t, to);\n\t\tif (ParserATNSimulator.debug) {\n\t\t\tconsole.log(\"DFA=\\n\" + dfa.toString(this._parser != null ? this._parser.vocabulary : VocabularyImpl.EMPTY_VOCABULARY, this._parser != null ? this._parser.ruleNames : undefined));\n\t\t}\n\t\treturn to;\n\t}\n\n\tprotected setDFAEdge(@Nullable p: DFAState, t: number, @Nullable q: DFAState): void {\n\t\tif (p != null) {\n\t\t\tp.setTarget(t, q);\n\t\t}\n\t}\n\n\t/** See comment on LexerInterpreter.addDFAState. */\n\t@NotNull\n\tprotected addDFAContextState(@NotNull dfa: DFA, @NotNull configs: ATNConfigSet, returnContext: number, contextCache: PredictionContextCache): DFAState {\n\t\tif (returnContext !== PredictionContext.EMPTY_FULL_STATE_KEY) {\n\t\t\tlet contextConfigs: ATNConfigSet = new ATNConfigSet();\n\t\t\tfor (let config of configs) {\n\t\t\t\tcontextConfigs.add(config.appendContext(returnContext, contextCache));\n\t\t\t}\n\n\t\t\treturn this.addDFAState(dfa, contextConfigs, contextCache);\n\t\t}\n\t\telse {\n\t\t\tassert(!configs.isOutermostConfigSet, \"Shouldn't be adding a duplicate edge.\");\n\t\t\tconfigs = configs.clone(true);\n\t\t\tconfigs.isOutermostConfigSet = true;\n\t\t\treturn this.addDFAState(dfa, configs, contextCache);\n\t\t}\n\t}\n\n\t/** See comment on LexerInterpreter.addDFAState. */\n\t@NotNull\n\tprotected addDFAState(@NotNull dfa: DFA, @NotNull configs: ATNConfigSet, contextCache: PredictionContextCache): DFAState {\n\t\tlet enableDfa: boolean = this.enable_global_context_dfa || !configs.isOutermostConfigSet;\n\t\tif (enableDfa) {\n\t\t\tif (!configs.isReadOnly) {\n\t\t\t\tconfigs.optimizeConfigs(this);\n\t\t\t}\n\n\t\t\tlet proposed: DFAState = this.createDFAState(dfa, configs);\n\t\t\tlet existing: DFAState | undefined = dfa.states.get(proposed);\n\t\t\tif (existing != null) {\n\t\t\t\treturn existing;\n\t\t\t}\n\t\t}\n\n\t\tif (!configs.isReadOnly) {\n\t\t\tif (configs.conflictInfo == null) {\n\t\t\t\tconfigs.conflictInfo = this.isConflicted(configs, contextCache);\n\t\t\t}\n\t\t}\n\n\t\tlet newState: DFAState = this.createDFAState(dfa, configs.clone(true));\n\t\t// getDecisionState won't return undefined when we request a known valid decision\n\t\tlet decisionState: DecisionState = this.atn.getDecisionState(dfa.decision) as DecisionState;\n\t\tlet predictedAlt: number = this.getUniqueAlt(configs);\n\t\tif (predictedAlt !== ATN.INVALID_ALT_NUMBER) {\n\t\t\tnewState.acceptStateInfo = new AcceptStateInfo(predictedAlt);\n\t\t} else if (configs.conflictingAlts != null) {\n\t\t\tlet conflictingAlts = configs.conflictingAlts;\n\t\t\tif (conflictingAlts) {\n\t\t\t\tnewState.acceptStateInfo = new AcceptStateInfo(conflictingAlts.nextSetBit(0));\n\t\t\t}\n\t\t}\n\n\t\tif (newState.isAcceptState && configs.hasSemanticContext) {\n\t\t\tthis.predicateDFAState(newState, configs, decisionState.numberOfTransitions);\n\t\t}\n\n\t\tif (!enableDfa) {\n\t\t\treturn newState;\n\t\t}\n\n\t\tlet added: DFAState = dfa.addState(newState);\n\t\tif (ParserATNSimulator.debug && added === newState) {\n\t\t\tconsole.log(\"adding new DFA state: \" + newState);\n\t\t}\n\t\treturn added;\n\t}\n\n\t@NotNull\n\tprotected createDFAState(@NotNull dfa: DFA, @NotNull configs: ATNConfigSet): DFAState {\n\t\treturn new DFAState(configs);\n\t}\n\n\tprotected reportAttemptingFullContext(@NotNull dfa: DFA, conflictingAlts: BitSet | undefined, @NotNull conflictState: SimulatorState, startIndex: number, stopIndex: number): void {\n\t\tif (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {\n\t\t\tlet interval: Interval = Interval.of(startIndex, stopIndex);\n\t\t\tconsole.log(\"reportAttemptingFullContext decision=\" + dfa.decision + \":\" + conflictState.s0.configs +\n\t\t\t\t\", input=\" + this._parser.inputStream.getText(interval));\n\t\t}\n\t\tif (this._parser != null) {\n\t\t\tlet listener = this._parser.getErrorListenerDispatch();\n\t\t\tif (listener.reportAttemptingFullContext) {\n\t\t\t\tlistener.reportAttemptingFullContext(this._parser, dfa, startIndex, stopIndex, conflictingAlts, conflictState);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected reportContextSensitivity(@NotNull dfa: DFA, prediction: number, @NotNull acceptState: SimulatorState, startIndex: number, stopIndex: number): void {\n\t\tif (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {\n\t\t\tlet interval: Interval = Interval.of(startIndex, stopIndex);\n\t\t\tconsole.log(\"reportContextSensitivity decision=\" + dfa.decision + \":\" + acceptState.s0.configs +\n\t\t\t\t\", input=\" + this._parser.inputStream.getText(interval));\n\t\t}\n\t\tif (this._parser != null) {\n\t\t\tlet listener = this._parser.getErrorListenerDispatch();\n\t\t\tif (listener.reportContextSensitivity) {\n\t\t\t\tlistener.reportContextSensitivity(this._parser, dfa, startIndex, stopIndex, prediction, acceptState);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** If context sensitive parsing, we know it's ambiguity not conflict */\n\tprotected reportAmbiguity(\n\t\t@NotNull dfa: DFA,\n\t\tD: DFAState,  // the DFA state from execATN(): void that had SLL conflicts\n\t\tstartIndex: number,\n\t\tstopIndex: number,\n\t\texact: boolean,\n\t\t@NotNull ambigAlts: BitSet,\n\t\t@NotNull configs: ATNConfigSet) // configs that LL not SLL considered conflicting\n\t{\n\t\tif (ParserATNSimulator.debug || ParserATNSimulator.retry_debug) {\n\t\t\tlet interval: Interval = Interval.of(startIndex, stopIndex);\n\t\t\tconsole.log(\"reportAmbiguity \" +\n\t\t\t\tambigAlts + \":\" + configs +\n\t\t\t\t\", input=\" + this._parser.inputStream.getText(interval));\n\t\t}\n\t\tif (this._parser != null) {\n\t\t\tlet listener = this._parser.getErrorListenerDispatch();\n\t\t\tif (listener.reportAmbiguity) {\n\t\t\t\tlistener.reportAmbiguity(this._parser, dfa, startIndex, stopIndex, exact, ambigAlts, configs);\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected getReturnState(context: RuleContext): number {\n\t\tif (context.isEmpty) {\n\t\t\treturn PredictionContext.EMPTY_FULL_STATE_KEY;\n\t\t}\n\n\t\tlet state: ATNState = this.atn.states[context.invokingState];\n\t\tlet transition: RuleTransition = state.transition(0) as RuleTransition;\n\t\treturn transition.followState.stateNumber;\n\t}\n\n\tprotected skipTailCalls(context: ParserRuleContext): ParserRuleContext {\n\t\tif (!this.optimize_tail_calls) {\n\t\t\treturn context;\n\t\t}\n\n\t\twhile (!context.isEmpty) {\n\t\t\tlet state: ATNState = this.atn.states[context.invokingState];\n\t\t\tassert(state.numberOfTransitions === 1 && state.transition(0).serializationType === TransitionType.RULE);\n\t\t\tlet transition: RuleTransition = state.transition(0) as RuleTransition;\n\t\t\tif (!transition.tailCall) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// This method requires that the root ancestor of the ParserRuleContext be empty. If we make it to this\n\t\t\t// line, we know the current node is not empty, which means it does have a parent.\n\t\t\tcontext = context.parent as ParserRuleContext;\n\t\t}\n\n\t\treturn context;\n\t}\n\n\t/**\n\t * @since 4.3\n\t */\n\tget parser(): Parser {\n\t\treturn this._parser;\n\t}\n}\n"]}