{"version":3,"sources":["atn/ATNConfig.js","../src/atn/ATNConfig.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","Array2DHashMap_1","require","DecisionState_1","MurmurHash_1","Decorators_1","ObjectEqualityComparator_1","PredictionContext_1","SemanticContext_1","assert","SUPPRESS_PRECEDENCE_FILTER","ATNConfig","state","altOrConfig","context","_state","altAndOuterContextDepth","_context","transform","checkNonGreedy","arg2","transformImpl","semanticContext","lexerActionExecutor","PredictionContext","SemanticContext","passedThroughNonGreedy","checkNonGreedyDecision","NONE","ActionSemanticContextATNConfig","SemanticContextATNConfig","ActionATNConfig","contextCache","appendedContext","appendSingleContext","result","appendContext","subconfig","stateNumber","alt","equals","leftWorkList","rightWorkList","push","left","pop","right","size","isEmpty","hasEmpty","index","findReturnState","getReturnState","getParent","o","reachesIntoOuterContext","isPrecedenceFilterSuppressed","hasPassedThroughNonGreedyDecision","ObjectEqualityComparator","INSTANCE","hashCode","MurmurHash","initialize","update","finish","builder","visited","Array2DHashMap","IdentityEqualityComparator","workList","getOrAddContext","newNumber","putIfAbsent","put","current","toString","recog","showAlt","showContext","buf","contexts","toStrings","first","contextDesc","outerContextDepth","Math","min","undefined","source","DecisionState","nonGreedy","NotNull","prototype","Override","_semanticContext","passedThroughNonGreedyDecision","Error","_lexerActionExecutor"],"mappings":"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","file":"ATNConfig.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:25.2796692-07:00\nconst Array2DHashMap_1 = require(\"../misc/Array2DHashMap\");\nconst DecisionState_1 = require(\"./DecisionState\");\nconst MurmurHash_1 = require(\"../misc/MurmurHash\");\nconst Decorators_1 = require(\"../Decorators\");\nconst ObjectEqualityComparator_1 = require(\"../misc/ObjectEqualityComparator\");\nconst PredictionContext_1 = require(\"./PredictionContext\");\nconst SemanticContext_1 = require(\"./SemanticContext\");\nconst assert = require(\"assert\");\n/**\n * This field stores the bit mask for implementing the\n * {@link #isPrecedenceFilterSuppressed} property as a bit within the\n * existing {@link #altAndOuterContextDepth} field.\n */\nconst SUPPRESS_PRECEDENCE_FILTER = 0x80000000;\n/**\n * Represents a location with context in an ATN. The location is identified by the following values:\n *\n * * The current ATN state\n * * The predicted alternative\n * * The semantic context which must be true for this configuration to be enabled\n * * The syntactic context, which is represented as a graph-structured stack whose path(s) lead to the root of the rule\n *   invocations leading to this state\n *\n * In addition to these values, `ATNConfig` stores several properties about paths taken to get to the location which\n * were added over time to help with performance, correctness, and/or debugging.\n *\n * * `reachesIntoOuterContext`:: Used to ensure semantic predicates are not evaluated in the wrong context.\n * * `hasPassedThroughNonGreedyDecision`: Used for enabling first-match-wins instead of longest-match-wins after\n *   crossing a non-greedy decision.\n * * `lexerActionExecutor`: Used for tracking the lexer action(s) to execute should this instance be selected during\n *   lexing.\n * * `isPrecedenceFilterSuppressed`: A state variable for one of the dynamic disambiguation strategies employed by\n *   `ParserATNSimulator.applyPrecedenceFilter`.\n *\n * Due to the use of a graph-structured stack, a single `ATNConfig` is capable of representing many individual ATN\n * configurations which reached the same location in an ATN by following different paths.\n *\n * PERF: To conserve memory, `ATNConfig` is split into several different concrete types. `ATNConfig` itself stores the\n * minimum amount of information typically used to define an `ATNConfig` instance. Various derived types provide\n * additional storage space for cases where a non-default value is used for some of the object properties. The\n * `ATNConfig.create` and `ATNConfig.transform` methods automatically select the smallest concrete type capable of\n * representing the unique information for any given `ATNConfig`.\n */\nlet ATNConfig = class ATNConfig {\n    constructor(state, altOrConfig, context) {\n        if (typeof altOrConfig === \"number\") {\n            assert((altOrConfig & 0xFFFFFF) === altOrConfig);\n            this._state = state;\n            this.altAndOuterContextDepth = altOrConfig;\n            this._context = context;\n        }\n        else {\n            this._state = state;\n            this.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;\n            this._context = context;\n        }\n    }\n    static create(state, alt, context, semanticContext = SemanticContext_1.SemanticContext.NONE, lexerActionExecutor) {\n        if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {\n            if (lexerActionExecutor != null) {\n                return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);\n            }\n            else {\n                return new SemanticContextATNConfig(semanticContext, state, alt, context);\n            }\n        }\n        else if (lexerActionExecutor != null) {\n            return new ActionATNConfig(lexerActionExecutor, state, alt, context, false);\n        }\n        else {\n            return new ATNConfig(state, alt, context);\n        }\n    }\n    /** Gets the ATN state associated with this configuration */\n    get state() {\n        return this._state;\n    }\n    /** What alt (or lexer rule) is predicted by this configuration */\n    get alt() {\n        return this.altAndOuterContextDepth & 0x00FFFFFF;\n    }\n    get context() {\n        return this._context;\n    }\n    set context(context) {\n        this._context = context;\n    }\n    get reachesIntoOuterContext() {\n        return this.outerContextDepth !== 0;\n    }\n    /**\n     * We cannot execute predicates dependent upon local context unless\n     * we know for sure we are in the correct context. Because there is\n     * no way to do this efficiently, we simply cannot evaluate\n     * dependent predicates unless we are in the rule that initially\n     * invokes the ATN simulator.\n     *\n     * closure() tracks the depth of how far we dip into the outer context:\n     * depth &gt; 0.  Note that it may not be totally accurate depth since I\n     * don't ever decrement. TODO: make it a boolean then\n     */\n    get outerContextDepth() {\n        return (this.altAndOuterContextDepth >>> 24) & 0x7F;\n    }\n    set outerContextDepth(outerContextDepth) {\n        assert(outerContextDepth >= 0);\n        // saturate at 0x7F - everything but zero/positive is only used for debug information anyway\n        outerContextDepth = Math.min(outerContextDepth, 0x7F);\n        this.altAndOuterContextDepth = ((outerContextDepth << 24) | (this.altAndOuterContextDepth & ~0x7F000000) >>> 0);\n    }\n    get lexerActionExecutor() {\n        return undefined;\n    }\n    get semanticContext() {\n        return SemanticContext_1.SemanticContext.NONE;\n    }\n    get hasPassedThroughNonGreedyDecision() {\n        return false;\n    }\n    clone() {\n        return this.transform(this.state, false);\n    }\n    transform(/*@NotNull*/ state, checkNonGreedy, arg2) {\n        if (arg2 == null) {\n            return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);\n        }\n        else if (arg2 instanceof PredictionContext_1.PredictionContext) {\n            return this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);\n        }\n        else if (arg2 instanceof SemanticContext_1.SemanticContext) {\n            return this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);\n        }\n        else {\n            return this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);\n        }\n    }\n    transformImpl(state, context, semanticContext, checkNonGreedy, lexerActionExecutor) {\n        let passedThroughNonGreedy = checkNonGreedy && ATNConfig.checkNonGreedyDecision(this, state);\n        if (semanticContext !== SemanticContext_1.SemanticContext.NONE) {\n            if (lexerActionExecutor != null || passedThroughNonGreedy) {\n                return new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);\n            }\n            else {\n                return new SemanticContextATNConfig(semanticContext, state, this, context);\n            }\n        }\n        else if (lexerActionExecutor != null || passedThroughNonGreedy) {\n            return new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);\n        }\n        else {\n            return new ATNConfig(state, this, context);\n        }\n    }\n    static checkNonGreedyDecision(source, target) {\n        return source.hasPassedThroughNonGreedyDecision\n            || target instanceof DecisionState_1.DecisionState && target.nonGreedy;\n    }\n    appendContext(context, contextCache) {\n        if (typeof context === \"number\") {\n            let appendedContext = this.context.appendSingleContext(context, contextCache);\n            let result = this.transform(this.state, false, appendedContext);\n            return result;\n        }\n        else {\n            let appendedContext = this.context.appendContext(context, contextCache);\n            let result = this.transform(this.state, false, appendedContext);\n            return result;\n        }\n    }\n    /**\n     * Determines if this `ATNConfig` fully contains another `ATNConfig`.\n     *\n     * An ATN configuration represents a position (including context) in an ATN during parsing. Since `ATNConfig` stores\n     * the context as a graph, a single `ATNConfig` instance is capable of representing many ATN configurations which\n     * are all in the same \"location\" but have different contexts. These `ATNConfig` instances are again merged when\n     * they are added to an `ATNConfigSet`. This method supports `ATNConfigSet.contains` by evaluating whether a\n     * particular `ATNConfig` contains all of the ATN configurations represented by another `ATNConfig`.\n     *\n     * An `ATNConfig` _a_ contains another `ATNConfig` _b_ if all of the following conditions are met:\n     *\n     * * The configurations are in the same state (`state`)\n     * * The configurations predict the same alternative (`alt`)\n     * * The semantic context of _a_ implies the semantic context of _b_ (this method performs a weaker equality check)\n     * * Joining the prediction contexts of _a_ and _b_ results in the prediction context of _a_\n     *\n     * This method implements a conservative approximation of containment. As a result, when this method returns `true`\n     * it is known that parsing from `subconfig` can only recognize a subset of the inputs which can be recognized\n     * starting at the current `ATNConfig`. However, due to the imprecise evaluation of implication for the semantic\n     * contexts, no assumptions can be made about the relationship between the configurations when this method returns\n     * `false`.\n     *\n     * @param subconfig The sub configuration.\n     * @returns `true` if this configuration contains `subconfig`; otherwise, `false`.\n     */\n    contains(subconfig) {\n        if (this.state.stateNumber !== subconfig.state.stateNumber\n            || this.alt !== subconfig.alt\n            || !this.semanticContext.equals(subconfig.semanticContext)) {\n            return false;\n        }\n        let leftWorkList = [];\n        let rightWorkList = [];\n        leftWorkList.push(this.context);\n        rightWorkList.push(subconfig.context);\n        while (true) {\n            let left = leftWorkList.pop();\n            let right = rightWorkList.pop();\n            if (!left || !right) {\n                break;\n            }\n            if (left === right) {\n                return true;\n            }\n            if (left.size < right.size) {\n                return false;\n            }\n            if (right.isEmpty) {\n                return left.hasEmpty;\n            }\n            else {\n                for (let i = 0; i < right.size; i++) {\n                    let index = left.findReturnState(right.getReturnState(i));\n                    if (index < 0) {\n                        // assumes invokingStates has no duplicate entries\n                        return false;\n                    }\n                    leftWorkList.push(left.getParent(index));\n                    rightWorkList.push(right.getParent(i));\n                }\n            }\n        }\n        return false;\n    }\n    get isPrecedenceFilterSuppressed() {\n        return (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;\n    }\n    set isPrecedenceFilterSuppressed(value) {\n        if (value) {\n            this.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;\n        }\n        else {\n            this.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;\n        }\n    }\n    /** An ATN configuration is equal to another if both have\n     *  the same state, they predict the same alternative, and\n     *  syntactic/semantic contexts are the same.\n     */\n    equals(o) {\n        if (this === o) {\n            return true;\n        }\n        else if (!(o instanceof ATNConfig)) {\n            return false;\n        }\n        return this.state.stateNumber === o.state.stateNumber\n            && this.alt === o.alt\n            && this.reachesIntoOuterContext === o.reachesIntoOuterContext\n            && this.context.equals(o.context)\n            && this.semanticContext.equals(o.semanticContext)\n            && this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed\n            && this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision\n            && ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);\n    }\n    hashCode() {\n        let hashCode = MurmurHash_1.MurmurHash.initialize(7);\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.state.stateNumber);\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.alt);\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.context);\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.semanticContext);\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);\n        hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.lexerActionExecutor);\n        hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 7);\n        return hashCode;\n    }\n    /**\n     * Returns a graphical representation of the current `ATNConfig` in Graphviz format. The graph can be stored to a\n     * **.dot** file and then rendered to an image using Graphviz.\n     *\n     * @returns A Graphviz graph representing the current `ATNConfig`.\n     *\n     * @see http://www.graphviz.org/\n     */\n    toDotString() {\n        let builder = \"\";\n        builder += (\"digraph G {\\n\");\n        builder += (\"rankdir=LR;\\n\");\n        let visited = new Array2DHashMap_1.Array2DHashMap(PredictionContext_1.PredictionContext.IdentityEqualityComparator.INSTANCE);\n        let workList = [];\n        function getOrAddContext(context) {\n            let newNumber = visited.size;\n            let result = visited.putIfAbsent(context, newNumber);\n            if (result != null) {\n                // Already saw this context\n                return result;\n            }\n            workList.push(context);\n            return newNumber;\n        }\n        workList.push(this.context);\n        visited.put(this.context, 0);\n        while (true) {\n            let current = workList.pop();\n            if (!current) {\n                break;\n            }\n            for (let i = 0; i < current.size; i++) {\n                builder += (\"  s\") + (getOrAddContext(current));\n                builder += (\"->\");\n                builder += (\"s\") + (getOrAddContext(current.getParent(i)));\n                builder += (\"[label=\\\"\") + (current.getReturnState(i)) + (\"\\\"];\\n\");\n            }\n        }\n        builder += (\"}\\n\");\n        return builder.toString();\n    }\n    toString(recog, showAlt, showContext) {\n        // Must check showContext before showAlt to preserve original overload behavior\n        if (showContext == null) {\n            showContext = showAlt != null;\n        }\n        if (showAlt == null) {\n            showAlt = true;\n        }\n        let buf = \"\";\n        // if (this.state.ruleIndex >= 0) {\n        // \tif (recog != null) {\n        // \t\tbuf += (recog.ruleNames[this.state.ruleIndex] + \":\");\n        // \t} else {\n        // \t\tbuf += (this.state.ruleIndex + \":\");\n        // \t}\n        // }\n        let contexts;\n        if (showContext) {\n            contexts = this.context.toStrings(recog, this.state.stateNumber);\n        }\n        else {\n            contexts = [\"?\"];\n        }\n        let first = true;\n        for (let contextDesc of contexts) {\n            if (first) {\n                first = false;\n            }\n            else {\n                buf += (\", \");\n            }\n            buf += (\"(\");\n            buf += (this.state);\n            if (showAlt) {\n                buf += (\",\");\n                buf += (this.alt);\n            }\n            if (this.context) {\n                buf += (\",\");\n                buf += (contextDesc);\n            }\n            if (this.semanticContext !== SemanticContext_1.SemanticContext.NONE) {\n                buf += (\",\");\n                buf += (this.semanticContext);\n            }\n            if (this.reachesIntoOuterContext) {\n                buf += (\",up=\") + (this.outerContextDepth);\n            }\n            buf += (\")\");\n        }\n        return buf.toString();\n    }\n};\n__decorate([\n    Decorators_1.NotNull\n], ATNConfig.prototype, \"_state\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], ATNConfig.prototype, \"_context\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], ATNConfig.prototype, \"state\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], ATNConfig.prototype, \"context\", null);\n__decorate([\n    Decorators_1.NotNull\n], ATNConfig.prototype, \"semanticContext\", null);\n__decorate([\n    Decorators_1.Override\n], ATNConfig.prototype, \"clone\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)\n], ATNConfig.prototype, \"transformImpl\", null);\n__decorate([\n    Decorators_1.Override\n], ATNConfig.prototype, \"equals\", null);\n__decorate([\n    Decorators_1.Override\n], ATNConfig.prototype, \"hashCode\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(3, Decorators_1.NotNull)\n], ATNConfig, \"create\", null);\nATNConfig = __decorate([\n    __param(0, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)\n], ATNConfig);\nexports.ATNConfig = ATNConfig;\n/**\n * This class was derived from `ATNConfig` purely as a memory optimization. It allows for the creation of an `ATNConfig`\n * with a non-default semantic context.\n *\n * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete\n * types.\n */\nlet SemanticContextATNConfig = class SemanticContextATNConfig extends ATNConfig {\n    constructor(semanticContext, state, altOrConfig, context) {\n        if (typeof altOrConfig === \"number\") {\n            super(state, altOrConfig, context);\n        }\n        else {\n            super(state, altOrConfig, context);\n        }\n        this._semanticContext = semanticContext;\n    }\n    get semanticContext() {\n        return this._semanticContext;\n    }\n};\n__decorate([\n    Decorators_1.NotNull\n], SemanticContextATNConfig.prototype, \"_semanticContext\", void 0);\n__decorate([\n    Decorators_1.Override\n], SemanticContextATNConfig.prototype, \"semanticContext\", null);\nSemanticContextATNConfig = __decorate([\n    __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)\n], SemanticContextATNConfig);\n/**\n * This class was derived from `ATNConfig` purely as a memory optimization. It allows for the creation of an `ATNConfig`\n * with a lexer action.\n *\n * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete\n * types.\n */\nlet ActionATNConfig = class ActionATNConfig extends ATNConfig {\n    constructor(lexerActionExecutor, state, altOrConfig, context, passedThroughNonGreedyDecision) {\n        if (typeof altOrConfig === \"number\") {\n            super(state, altOrConfig, context);\n        }\n        else {\n            super(state, altOrConfig, context);\n            if (altOrConfig.semanticContext !== SemanticContext_1.SemanticContext.NONE) {\n                throw new Error(\"Not supported\");\n            }\n        }\n        this._lexerActionExecutor = lexerActionExecutor;\n        this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;\n    }\n    get lexerActionExecutor() {\n        return this._lexerActionExecutor;\n    }\n    get hasPassedThroughNonGreedyDecision() {\n        return this.passedThroughNonGreedyDecision;\n    }\n};\n__decorate([\n    Decorators_1.Override\n], ActionATNConfig.prototype, \"lexerActionExecutor\", null);\n__decorate([\n    Decorators_1.Override\n], ActionATNConfig.prototype, \"hasPassedThroughNonGreedyDecision\", null);\nActionATNConfig = __decorate([\n    __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)\n], ActionATNConfig);\n/**\n * This class was derived from `SemanticContextATNConfig` purely as a memory optimization. It allows for the creation of\n * an `ATNConfig` with both a lexer action and a non-default semantic context.\n *\n * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete\n * types.\n */\nlet ActionSemanticContextATNConfig = class ActionSemanticContextATNConfig extends SemanticContextATNConfig {\n    constructor(lexerActionExecutor, semanticContext, state, altOrConfig, context, passedThroughNonGreedyDecision) {\n        if (typeof altOrConfig === \"number\") {\n            super(semanticContext, state, altOrConfig, context);\n        }\n        else {\n            super(semanticContext, state, altOrConfig, context);\n        }\n        this._lexerActionExecutor = lexerActionExecutor;\n        this.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;\n    }\n    get lexerActionExecutor() {\n        return this._lexerActionExecutor;\n    }\n    get hasPassedThroughNonGreedyDecision() {\n        return this.passedThroughNonGreedyDecision;\n    }\n};\n__decorate([\n    Decorators_1.Override\n], ActionSemanticContextATNConfig.prototype, \"lexerActionExecutor\", null);\n__decorate([\n    Decorators_1.Override\n], ActionSemanticContextATNConfig.prototype, \"hasPassedThroughNonGreedyDecision\", null);\nActionSemanticContextATNConfig = __decorate([\n    __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)\n], ActionSemanticContextATNConfig);\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:25.2796692-07:00\n\nimport { Array2DHashMap } from \"../misc/Array2DHashMap\";\nimport { ATNState } from \"./ATNState\";\nimport { DecisionState } from \"./DecisionState\";\nimport { Equatable } from \"../misc/Stubs\";\nimport { LexerActionExecutor } from \"./LexerActionExecutor\";\nimport { MurmurHash } from \"../misc/MurmurHash\";\nimport { NotNull, Override } from \"../Decorators\";\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\nimport { PredictionContext } from \"./PredictionContext\";\nimport { PredictionContextCache } from \"./PredictionContextCache\";\nimport { Recognizer } from \"../Recognizer\";\nimport { SemanticContext } from \"./SemanticContext\";\n\nimport * as assert from \"assert\";\n\n/**\n * This field stores the bit mask for implementing the\n * {@link #isPrecedenceFilterSuppressed} property as a bit within the\n * existing {@link #altAndOuterContextDepth} field.\n */\nconst SUPPRESS_PRECEDENCE_FILTER: number = 0x80000000;\n\n/**\n * Represents a location with context in an ATN. The location is identified by the following values:\n *\n * * The current ATN state\n * * The predicted alternative\n * * The semantic context which must be true for this configuration to be enabled\n * * The syntactic context, which is represented as a graph-structured stack whose path(s) lead to the root of the rule\n *   invocations leading to this state\n *\n * In addition to these values, `ATNConfig` stores several properties about paths taken to get to the location which\n * were added over time to help with performance, correctness, and/or debugging.\n *\n * * `reachesIntoOuterContext`:: Used to ensure semantic predicates are not evaluated in the wrong context.\n * * `hasPassedThroughNonGreedyDecision`: Used for enabling first-match-wins instead of longest-match-wins after\n *   crossing a non-greedy decision.\n * * `lexerActionExecutor`: Used for tracking the lexer action(s) to execute should this instance be selected during\n *   lexing.\n * * `isPrecedenceFilterSuppressed`: A state variable for one of the dynamic disambiguation strategies employed by\n *   `ParserATNSimulator.applyPrecedenceFilter`.\n *\n * Due to the use of a graph-structured stack, a single `ATNConfig` is capable of representing many individual ATN\n * configurations which reached the same location in an ATN by following different paths.\n *\n * PERF: To conserve memory, `ATNConfig` is split into several different concrete types. `ATNConfig` itself stores the\n * minimum amount of information typically used to define an `ATNConfig` instance. Various derived types provide\n * additional storage space for cases where a non-default value is used for some of the object properties. The\n * `ATNConfig.create` and `ATNConfig.transform` methods automatically select the smallest concrete type capable of\n * representing the unique information for any given `ATNConfig`.\n */\nexport class ATNConfig implements Equatable {\n\t/** The ATN state associated with this configuration */\n\t@NotNull\n\tprivate _state: ATNState;\n\n\t/**\n\t * This is a bit-field currently containing the following values.\n\t *\n\t * * 0x00FFFFFF: Alternative\n\t * * 0x7F000000: Outer context depth\n\t * * 0x80000000: Suppress precedence filter\n\t */\n\tprivate altAndOuterContextDepth: number;\n\n\t/** The stack of invoking states leading to the rule/states associated\n\t *  with this config.  We track only those contexts pushed during\n\t *  execution of the ATN simulator.\n\t */\n\t@NotNull\n\tprivate _context: PredictionContext;\n\n\tconstructor(/*@NotNull*/ state: ATNState, alt: number, /*@NotNull*/ context: PredictionContext);\n\tconstructor(/*@NotNull*/ state: ATNState, /*@NotNull*/ c: ATNConfig, /*@NotNull*/ context: PredictionContext);\n\n\tconstructor(@NotNull state: ATNState, altOrConfig: number | ATNConfig, @NotNull context: PredictionContext) {\n\t\tif (typeof altOrConfig === \"number\") {\n\t\t\tassert((altOrConfig & 0xFFFFFF) === altOrConfig);\n\t\t\tthis._state = state;\n\t\t\tthis.altAndOuterContextDepth = altOrConfig;\n\t\t\tthis._context = context;\n\t\t} else {\n\t\t\tthis._state = state;\n\t\t\tthis.altAndOuterContextDepth = altOrConfig.altAndOuterContextDepth;\n\t\t\tthis._context = context;\n\t\t}\n\t}\n\n\tpublic static create(/*@NotNull*/ state: ATNState, alt: number, context: PredictionContext): ATNConfig;\n\n\tpublic static create(/*@NotNull*/ state: ATNState, alt: number, context: PredictionContext, /*@NotNull*/ semanticContext: SemanticContext): ATNConfig;\n\n\tpublic static create(/*@NotNull*/ state: ATNState, alt: number, context: PredictionContext, /*@*/ semanticContext: SemanticContext, lexerActionExecutor: LexerActionExecutor | undefined): ATNConfig;\n\n\tpublic static create(@NotNull state: ATNState, alt: number, context: PredictionContext, @NotNull semanticContext: SemanticContext = SemanticContext.NONE, lexerActionExecutor?: LexerActionExecutor): ATNConfig {\n\t\tif (semanticContext !== SemanticContext.NONE) {\n\t\t\tif (lexerActionExecutor != null) {\n\t\t\t\treturn new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, alt, context, false);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new SemanticContextATNConfig(semanticContext, state, alt, context);\n\t\t\t}\n\t\t}\n\t\telse if (lexerActionExecutor != null) {\n\t\t\treturn new ActionATNConfig(lexerActionExecutor, state, alt, context, false);\n\t\t}\n\t\telse {\n\t\t\treturn new ATNConfig(state, alt, context);\n\t\t}\n\t}\n\n\t/** Gets the ATN state associated with this configuration */\n\t@NotNull\n\tget state(): ATNState {\n\t\treturn this._state;\n\t}\n\n\t/** What alt (or lexer rule) is predicted by this configuration */\n\tget alt(): number {\n\t\treturn this.altAndOuterContextDepth & 0x00FFFFFF;\n\t}\n\n\t@NotNull\n\tget context(): PredictionContext {\n\t\treturn this._context;\n\t}\n\n\tset context(@NotNull context: PredictionContext) {\n\t\tthis._context = context;\n\t}\n\n\tget reachesIntoOuterContext(): boolean {\n\t\treturn this.outerContextDepth !== 0;\n\t}\n\n\t/**\n\t * We cannot execute predicates dependent upon local context unless\n\t * we know for sure we are in the correct context. Because there is\n\t * no way to do this efficiently, we simply cannot evaluate\n\t * dependent predicates unless we are in the rule that initially\n\t * invokes the ATN simulator.\n\t *\n\t * closure() tracks the depth of how far we dip into the outer context:\n\t * depth &gt; 0.  Note that it may not be totally accurate depth since I\n\t * don't ever decrement. TODO: make it a boolean then\n\t */\n\tget outerContextDepth(): number {\n\t\treturn (this.altAndOuterContextDepth >>> 24) & 0x7F;\n\t}\n\n\tset outerContextDepth(outerContextDepth: number) {\n\t\tassert(outerContextDepth >= 0);\n\t\t// saturate at 0x7F - everything but zero/positive is only used for debug information anyway\n\t\touterContextDepth = Math.min(outerContextDepth, 0x7F);\n\t\tthis.altAndOuterContextDepth = ((outerContextDepth << 24) | (this.altAndOuterContextDepth & ~0x7F000000) >>> 0);\n\t}\n\n\tget lexerActionExecutor(): LexerActionExecutor | undefined {\n\t\treturn undefined;\n\t}\n\n\t@NotNull\n\tget semanticContext(): SemanticContext {\n\t\treturn SemanticContext.NONE;\n\t}\n\n\tget hasPassedThroughNonGreedyDecision(): boolean {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic clone(): ATNConfig {\n\t\treturn this.transform(this.state, false);\n\t}\n\n\tpublic transform(/*@NotNull*/ state: ATNState, checkNonGreedy: boolean): ATNConfig;\n\tpublic transform(/*@NotNull*/ state: ATNState, checkNonGreedy: boolean, /*@NotNull*/ semanticContext: SemanticContext): ATNConfig;\n\tpublic transform(/*@NotNull*/ state: ATNState, checkNonGreedy: boolean, context: PredictionContext): ATNConfig;\n\tpublic transform(/*@NotNull*/ state: ATNState, checkNonGreedy: boolean, lexerActionExecutor: LexerActionExecutor): ATNConfig;\n\tpublic transform(/*@NotNull*/ state: ATNState, checkNonGreedy: boolean, arg2?: SemanticContext | PredictionContext | LexerActionExecutor): ATNConfig {\n\t\tif (arg2 == null) {\n\t\t\treturn this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);\n\t\t} else if (arg2 instanceof PredictionContext) {\n\t\t\treturn this.transformImpl(state, arg2, this.semanticContext, checkNonGreedy, this.lexerActionExecutor);\n\t\t} else if (arg2 instanceof SemanticContext) {\n\t\t\treturn this.transformImpl(state, this._context, arg2, checkNonGreedy, this.lexerActionExecutor);\n\t\t} else {\n\t\t\treturn this.transformImpl(state, this._context, this.semanticContext, checkNonGreedy, arg2);\n\t\t}\n\t}\n\n\tprivate transformImpl(@NotNull state: ATNState, context: PredictionContext, @NotNull semanticContext: SemanticContext, checkNonGreedy: boolean, lexerActionExecutor: LexerActionExecutor | undefined): ATNConfig {\n\t\tlet passedThroughNonGreedy: boolean = checkNonGreedy && ATNConfig.checkNonGreedyDecision(this, state);\n\t\tif (semanticContext !== SemanticContext.NONE) {\n\t\t\tif (lexerActionExecutor != null || passedThroughNonGreedy) {\n\t\t\t\treturn new ActionSemanticContextATNConfig(lexerActionExecutor, semanticContext, state, this, context, passedThroughNonGreedy);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn new SemanticContextATNConfig(semanticContext, state, this, context);\n\t\t\t}\n\t\t}\n\t\telse if (lexerActionExecutor != null || passedThroughNonGreedy) {\n\t\t\treturn new ActionATNConfig(lexerActionExecutor, state, this, context, passedThroughNonGreedy);\n\t\t}\n\t\telse {\n\t\t\treturn new ATNConfig(state, this, context);\n\t\t}\n\t}\n\n\tprivate static checkNonGreedyDecision(source: ATNConfig, target: ATNState): boolean {\n\t\treturn source.hasPassedThroughNonGreedyDecision\n\t\t\t|| target instanceof DecisionState && target.nonGreedy;\n\t}\n\n\tpublic appendContext(context: number, contextCache: PredictionContextCache): ATNConfig;\n\tpublic appendContext(context: PredictionContext, contextCache: PredictionContextCache): ATNConfig;\n\tpublic appendContext(context: number | PredictionContext, contextCache: PredictionContextCache): ATNConfig {\n\t\tif (typeof context === \"number\") {\n\t\t\tlet appendedContext: PredictionContext = this.context.appendSingleContext(context, contextCache);\n\t\t\tlet result: ATNConfig = this.transform(this.state, false, appendedContext);\n\t\t\treturn result;\n\t\t} else {\n\t\t\tlet appendedContext: PredictionContext = this.context.appendContext(context, contextCache);\n\t\t\tlet result: ATNConfig = this.transform(this.state, false, appendedContext);\n\t\t\treturn result;\n\t\t}\n\t}\n\n\t/**\n\t * Determines if this `ATNConfig` fully contains another `ATNConfig`.\n\t *\n\t * An ATN configuration represents a position (including context) in an ATN during parsing. Since `ATNConfig` stores\n\t * the context as a graph, a single `ATNConfig` instance is capable of representing many ATN configurations which\n\t * are all in the same \"location\" but have different contexts. These `ATNConfig` instances are again merged when\n\t * they are added to an `ATNConfigSet`. This method supports `ATNConfigSet.contains` by evaluating whether a\n\t * particular `ATNConfig` contains all of the ATN configurations represented by another `ATNConfig`.\n\t *\n\t * An `ATNConfig` _a_ contains another `ATNConfig` _b_ if all of the following conditions are met:\n\t *\n\t * * The configurations are in the same state (`state`)\n\t * * The configurations predict the same alternative (`alt`)\n\t * * The semantic context of _a_ implies the semantic context of _b_ (this method performs a weaker equality check)\n\t * * Joining the prediction contexts of _a_ and _b_ results in the prediction context of _a_\n\t *\n\t * This method implements a conservative approximation of containment. As a result, when this method returns `true`\n\t * it is known that parsing from `subconfig` can only recognize a subset of the inputs which can be recognized\n\t * starting at the current `ATNConfig`. However, due to the imprecise evaluation of implication for the semantic\n\t * contexts, no assumptions can be made about the relationship between the configurations when this method returns\n\t * `false`.\n\t *\n\t * @param subconfig The sub configuration.\n\t * @returns `true` if this configuration contains `subconfig`; otherwise, `false`.\n\t */\n\tpublic contains(subconfig: ATNConfig): boolean {\n\t\tif (this.state.stateNumber !== subconfig.state.stateNumber\n\t\t\t|| this.alt !== subconfig.alt\n\t\t\t|| !this.semanticContext.equals(subconfig.semanticContext)) {\n\t\t\treturn false;\n\t\t}\n\n\t\tlet leftWorkList: PredictionContext[] = [];\n\t\tlet rightWorkList: PredictionContext[] = [];\n\t\tleftWorkList.push(this.context);\n\t\trightWorkList.push(subconfig.context);\n\t\twhile (true) {\n\t\t\tlet left = leftWorkList.pop();\n\t\t\tlet right = rightWorkList.pop();\n\t\t\tif (!left || !right) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif (left === right) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\tif (left.size < right.size) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (right.isEmpty) {\n\t\t\t\treturn left.hasEmpty;\n\t\t\t} else {\n\t\t\t\tfor (let i = 0; i < right.size; i++) {\n\t\t\t\t\tlet index: number = left.findReturnState(right.getReturnState(i));\n\t\t\t\t\tif (index < 0) {\n\t\t\t\t\t\t// assumes invokingStates has no duplicate entries\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\n\t\t\t\t\tleftWorkList.push(left.getParent(index));\n\t\t\t\t\trightWorkList.push(right.getParent(i));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget isPrecedenceFilterSuppressed(): boolean {\n\t\treturn (this.altAndOuterContextDepth & SUPPRESS_PRECEDENCE_FILTER) !== 0;\n\t}\n\n\tset isPrecedenceFilterSuppressed(value: boolean) {\n\t\tif (value) {\n\t\t\tthis.altAndOuterContextDepth |= SUPPRESS_PRECEDENCE_FILTER;\n\t\t}\n\t\telse {\n\t\t\tthis.altAndOuterContextDepth &= ~SUPPRESS_PRECEDENCE_FILTER;\n\t\t}\n\t}\n\n\t/** An ATN configuration is equal to another if both have\n\t *  the same state, they predict the same alternative, and\n\t *  syntactic/semantic contexts are the same.\n\t */\n\t@Override\n\tpublic equals(o: any): boolean {\n\t\tif (this === o) {\n\t\t\treturn true;\n\t\t} else if (!(o instanceof ATNConfig)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.state.stateNumber === o.state.stateNumber\n\t\t\t&& this.alt === o.alt\n\t\t\t&& this.reachesIntoOuterContext === o.reachesIntoOuterContext\n\t\t\t&& this.context.equals(o.context)\n\t\t\t&& this.semanticContext.equals(o.semanticContext)\n\t\t\t&& this.isPrecedenceFilterSuppressed === o.isPrecedenceFilterSuppressed\n\t\t\t&& this.hasPassedThroughNonGreedyDecision === o.hasPassedThroughNonGreedyDecision\n\t\t\t&& ObjectEqualityComparator.INSTANCE.equals(this.lexerActionExecutor, o.lexerActionExecutor);\n\t}\n\n\t@Override\n\tpublic hashCode(): number {\n\t\tlet hashCode: number = MurmurHash.initialize(7);\n\t\thashCode = MurmurHash.update(hashCode, this.state.stateNumber);\n\t\thashCode = MurmurHash.update(hashCode, this.alt);\n\t\thashCode = MurmurHash.update(hashCode, this.reachesIntoOuterContext ? 1 : 0);\n\t\thashCode = MurmurHash.update(hashCode, this.context);\n\t\thashCode = MurmurHash.update(hashCode, this.semanticContext);\n\t\thashCode = MurmurHash.update(hashCode, this.hasPassedThroughNonGreedyDecision ? 1 : 0);\n\t\thashCode = MurmurHash.update(hashCode, this.lexerActionExecutor);\n\t\thashCode = MurmurHash.finish(hashCode, 7);\n\t\treturn hashCode;\n\t}\n\n\t/**\n\t * Returns a graphical representation of the current `ATNConfig` in Graphviz format. The graph can be stored to a\n\t * **.dot** file and then rendered to an image using Graphviz.\n\t *\n\t * @returns A Graphviz graph representing the current `ATNConfig`.\n\t *\n\t * @see http://www.graphviz.org/\n\t */\n\tpublic toDotString(): string {\n\t\tlet builder = \"\";\n\t\tbuilder += (\"digraph G {\\n\");\n\t\tbuilder += (\"rankdir=LR;\\n\");\n\n\t\tlet visited = new Array2DHashMap<PredictionContext, number>(PredictionContext.IdentityEqualityComparator.INSTANCE);\n\t\tlet workList: PredictionContext[] = [];\n\t\tfunction getOrAddContext(context: PredictionContext): number {\n\t\t\tlet newNumber = visited.size;\n\t\t\tlet result = visited.putIfAbsent(context, newNumber);\n\t\t\tif (result != null) {\n\t\t\t\t// Already saw this context\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\tworkList.push(context);\n\t\t\treturn newNumber;\n\t\t}\n\n\t\tworkList.push(this.context);\n\t\tvisited.put(this.context, 0);\n\t\twhile (true) {\n\t\t\tlet current = workList.pop();\n\t\t\tif (!current) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < current.size; i++) {\n\t\t\t\tbuilder += (\"  s\") + (getOrAddContext(current));\n\t\t\t\tbuilder += (\"->\");\n\t\t\t\tbuilder += (\"s\") + (getOrAddContext(current.getParent(i)));\n\t\t\t\tbuilder += (\"[label=\\\"\") + (current.getReturnState(i)) + (\"\\\"];\\n\");\n\t\t\t}\n\t\t}\n\n\t\tbuilder += (\"}\\n\");\n\t\treturn builder.toString();\n\t}\n\n\tpublic toString(): string;\n\tpublic toString(recog: Recognizer<any, any> | undefined, showAlt: boolean): string;\n\tpublic toString(recog: Recognizer<any, any> | undefined, showAlt: boolean, showContext: boolean): string;\n\tpublic toString(recog?: Recognizer<any, any>, showAlt?: boolean, showContext?: boolean): string {\n\t\t// Must check showContext before showAlt to preserve original overload behavior\n\t\tif (showContext == null) {\n\t\t\tshowContext = showAlt != null;\n\t\t}\n\n\t\tif (showAlt == null) {\n\t\t\tshowAlt = true;\n\t\t}\n\n\t\tlet buf = \"\";\n\t\t// if (this.state.ruleIndex >= 0) {\n\t\t// \tif (recog != null) {\n\t\t// \t\tbuf += (recog.ruleNames[this.state.ruleIndex] + \":\");\n\t\t// \t} else {\n\t\t// \t\tbuf += (this.state.ruleIndex + \":\");\n\t\t// \t}\n\t\t// }\n\t\tlet contexts: string[];\n\t\tif (showContext) {\n\t\t\tcontexts = this.context.toStrings(recog, this.state.stateNumber);\n\t\t}\n\t\telse {\n\t\t\tcontexts = [\"?\"];\n\t\t}\n\n\t\tlet first: boolean = true;\n\t\tfor (let contextDesc of contexts) {\n\t\t\tif (first) {\n\t\t\t\tfirst = false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuf += (\", \");\n\t\t\t}\n\n\t\t\tbuf += (\"(\");\n\t\t\tbuf += (this.state);\n\t\t\tif (showAlt) {\n\t\t\t\tbuf += (\",\");\n\t\t\t\tbuf += (this.alt);\n\t\t\t}\n\t\t\tif (this.context) {\n\t\t\t\tbuf += (\",\");\n\t\t\t\tbuf += (contextDesc);\n\t\t\t}\n\t\t\tif (this.semanticContext !== SemanticContext.NONE) {\n\t\t\t\tbuf += (\",\");\n\t\t\t\tbuf += (this.semanticContext);\n\t\t\t}\n\t\t\tif (this.reachesIntoOuterContext) {\n\t\t\t\tbuf += (\",up=\") + (this.outerContextDepth);\n\t\t\t}\n\t\t\tbuf += (\")\");\n\t\t}\n\t\treturn buf.toString();\n\t}\n}\n\n/**\n * This class was derived from `ATNConfig` purely as a memory optimization. It allows for the creation of an `ATNConfig`\n * with a non-default semantic context.\n *\n * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete\n * types.\n */\nclass SemanticContextATNConfig extends ATNConfig {\n\t@NotNull\n\tprivate _semanticContext: SemanticContext;\n\n\tconstructor(semanticContext: SemanticContext, /*@NotNull*/ state: ATNState, alt: number, context: PredictionContext);\n\tconstructor(semanticContext: SemanticContext, /*@NotNull*/ state: ATNState, /*@NotNull*/ c: ATNConfig, context: PredictionContext);\n\tconstructor(semanticContext: SemanticContext, @NotNull state: ATNState, @NotNull altOrConfig: number | ATNConfig, context: PredictionContext) {\n\t\tif (typeof altOrConfig === \"number\") {\n\t\t\tsuper(state, altOrConfig, context);\n\t\t} else {\n\t\t\tsuper(state, altOrConfig, context);\n\t\t}\n\n\t\tthis._semanticContext = semanticContext;\n\t}\n\n\t@Override\n\tget semanticContext(): SemanticContext {\n\t\treturn this._semanticContext;\n\t}\n\n}\n\n/**\n * This class was derived from `ATNConfig` purely as a memory optimization. It allows for the creation of an `ATNConfig`\n * with a lexer action.\n *\n * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete\n * types.\n */\nclass ActionATNConfig extends ATNConfig {\n\tprivate _lexerActionExecutor?: LexerActionExecutor;\n\tprivate passedThroughNonGreedyDecision: boolean;\n\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, /*@NotNull*/ state: ATNState, alt: number, context: PredictionContext, passedThroughNonGreedyDecision: boolean);\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, /*@NotNull*/ state: ATNState, /*@NotNull*/ c: ATNConfig, context: PredictionContext, passedThroughNonGreedyDecision: boolean);\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, @NotNull state: ATNState, @NotNull altOrConfig: number | ATNConfig, context: PredictionContext, passedThroughNonGreedyDecision: boolean) {\n\t\tif (typeof altOrConfig === \"number\") {\n\t\t\tsuper(state, altOrConfig, context);\n\t\t} else {\n\t\t\tsuper(state, altOrConfig, context);\n\t\t\tif (altOrConfig.semanticContext !== SemanticContext.NONE) {\n\t\t\t\tthrow new Error(\"Not supported\");\n\t\t\t}\n\t\t}\n\n\t\tthis._lexerActionExecutor = lexerActionExecutor;\n\t\tthis.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;\n\t}\n\n\t@Override\n\tget lexerActionExecutor(): LexerActionExecutor | undefined {\n\t\treturn this._lexerActionExecutor;\n\t}\n\n\t@Override\n\tget hasPassedThroughNonGreedyDecision(): boolean {\n\t\treturn this.passedThroughNonGreedyDecision;\n\t}\n}\n\n/**\n * This class was derived from `SemanticContextATNConfig` purely as a memory optimization. It allows for the creation of\n * an `ATNConfig` with both a lexer action and a non-default semantic context.\n *\n * See the `ATNConfig` documentation for more information about conserving memory through the use of several concrete\n * types.\n */\nclass ActionSemanticContextATNConfig extends SemanticContextATNConfig {\n\tprivate _lexerActionExecutor?: LexerActionExecutor;\n\tprivate passedThroughNonGreedyDecision: boolean;\n\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, /*@NotNull*/ semanticContext: SemanticContext, /*@NotNull*/ state: ATNState, alt: number, context: PredictionContext, passedThroughNonGreedyDecision: boolean);\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, /*@NotNull*/ semanticContext: SemanticContext, /*@NotNull*/ state: ATNState, /*@NotNull*/ c: ATNConfig, context: PredictionContext, passedThroughNonGreedyDecision: boolean);\n\tconstructor(lexerActionExecutor: LexerActionExecutor | undefined, @NotNull semanticContext: SemanticContext, @NotNull state: ATNState, altOrConfig: number | ATNConfig, context: PredictionContext, passedThroughNonGreedyDecision: boolean) {\n\t\tif (typeof altOrConfig === \"number\") {\n\t\t\tsuper(semanticContext, state, altOrConfig, context);\n\t\t} else {\n\t\t\tsuper(semanticContext, state, altOrConfig, context);\n\t\t}\n\n\t\tthis._lexerActionExecutor = lexerActionExecutor;\n\t\tthis.passedThroughNonGreedyDecision = passedThroughNonGreedyDecision;\n\t}\n\n\t@Override\n\tget lexerActionExecutor(): LexerActionExecutor | undefined {\n\t\treturn this._lexerActionExecutor;\n\t}\n\n\t@Override\n\tget hasPassedThroughNonGreedyDecision(): boolean {\n\t\treturn this.passedThroughNonGreedyDecision;\n\t}\n}\n"]}