{"version":3,"sources":["atn/SemanticContext.js","../src/atn/SemanticContext.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","Array2DHashSet_1","require","ArrayEqualityComparator_1","MurmurHash_1","Decorators_1","ObjectEqualityComparator_1","Utils","max","items","result","current","undefined","comparison","compareTo","min","SemanticContext","parser","parserCallStack","a","b","NONE","AND","opnds","OR","_NONE","Predicate","AND_HASHCODE","OR_HASHCODE","filterPrecedencePredicates","collection","context","PrecedencePredicate","push","splice","ruleIndex","predIndex","isCtxDependent","localctx","sempred","hashCode","MurmurHash","initialize","update","finish","obj","Override","prototype","precedence","precpred","o","Operator","operands","Array2DHashSet","ObjectEqualityComparator","INSTANCE","addAll","add","toArray","precedencePredicates","reduced","ArrayEqualityComparator","equals","opnd","eval","differs","evaluated","evalPrecedence","and","join","NotNull","or"],"mappings":"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","file":"SemanticContext.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:36.9521478-07:00\nconst Array2DHashSet_1 = require(\"../misc/Array2DHashSet\");\nconst ArrayEqualityComparator_1 = require(\"../misc/ArrayEqualityComparator\");\nconst MurmurHash_1 = require(\"../misc/MurmurHash\");\nconst Decorators_1 = require(\"../Decorators\");\nconst ObjectEqualityComparator_1 = require(\"../misc/ObjectEqualityComparator\");\nconst Utils = require(\"../misc/Utils\");\nfunction max(items) {\n    let result;\n    for (let current of items) {\n        if (result === undefined) {\n            result = current;\n            continue;\n        }\n        let comparison = result.compareTo(current);\n        if (comparison < 0) {\n            result = current;\n        }\n    }\n    return result;\n}\nfunction min(items) {\n    let result;\n    for (let current of items) {\n        if (result === undefined) {\n            result = current;\n            continue;\n        }\n        let comparison = result.compareTo(current);\n        if (comparison > 0) {\n            result = current;\n        }\n    }\n    return result;\n}\n/** A tree structure used to record the semantic context in which\n *  an ATN configuration is valid.  It's either a single predicate,\n *  a conjunction `p1&&p2`, or a sum of products `p1||p2`.\n *\n *  I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of\n *  {@link SemanticContext} within the scope of this outer class.\n */\nclass SemanticContext {\n    /**\n     * The default {@link SemanticContext}, which is semantically equivalent to\n     * a predicate of the form `{true}?`.\n     */\n    static get NONE() {\n        if (SemanticContext._NONE === undefined) {\n            SemanticContext._NONE = new SemanticContext.Predicate();\n        }\n        return SemanticContext._NONE;\n    }\n    /**\n     * Evaluate the precedence predicates for the context and reduce the result.\n     *\n     * @param parser The parser instance.\n     * @param parserCallStack\n     * @returns The simplified semantic context after precedence predicates are\n     * evaluated, which will be one of the following values.\n     *\n     * * {@link #NONE}: if the predicate simplifies to `true` after\n     *   precedence predicates are evaluated.\n     * * `undefined`: if the predicate simplifies to `false` after\n     *   precedence predicates are evaluated.\n     * * `this`: if the semantic context is not changed as a result of\n     *   precedence predicate evaluation.\n     * * A non-`undefined` {@link SemanticContext}: the new simplified\n     *   semantic context after precedence predicates are evaluated.\n     */\n    evalPrecedence(parser, parserCallStack) {\n        return this;\n    }\n    static and(a, b) {\n        if (!a || a === SemanticContext.NONE) {\n            return b;\n        }\n        if (b === SemanticContext.NONE) {\n            return a;\n        }\n        let result = new SemanticContext.AND(a, b);\n        if (result.opnds.length === 1) {\n            return result.opnds[0];\n        }\n        return result;\n    }\n    /**\n     *\n     *  @see ParserATNSimulator#getPredsForAmbigAlts\n     */\n    static or(a, b) {\n        if (!a) {\n            return b;\n        }\n        if (a === SemanticContext.NONE || b === SemanticContext.NONE) {\n            return SemanticContext.NONE;\n        }\n        let result = new SemanticContext.OR(a, b);\n        if (result.opnds.length === 1) {\n            return result.opnds[0];\n        }\n        return result;\n    }\n}\nexports.SemanticContext = SemanticContext;\n(function (SemanticContext) {\n    /**\n     * This random 30-bit prime represents the value of `AND.class.hashCode()`.\n     */\n    const AND_HASHCODE = 40363613;\n    /**\n     * This random 30-bit prime represents the value of `OR.class.hashCode()`.\n     */\n    const OR_HASHCODE = 486279973;\n    function filterPrecedencePredicates(collection) {\n        let result = [];\n        for (let i = 0; i < collection.length; i++) {\n            let context = collection[i];\n            if (context instanceof SemanticContext.PrecedencePredicate) {\n                result.push(context);\n                // Remove the item from 'collection' and move i back so we look at the same index again\n                collection.splice(i, 1);\n                i--;\n            }\n        }\n        return result;\n    }\n    class Predicate extends SemanticContext {\n        constructor(ruleIndex = -1, predIndex = -1, isCtxDependent = false) {\n            super();\n            this.ruleIndex = ruleIndex;\n            this.predIndex = predIndex;\n            this.isCtxDependent = isCtxDependent;\n        }\n        eval(parser, parserCallStack) {\n            let localctx = this.isCtxDependent ? parserCallStack : undefined;\n            return parser.sempred(localctx, this.ruleIndex, this.predIndex);\n        }\n        hashCode() {\n            let hashCode = MurmurHash_1.MurmurHash.initialize();\n            hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.ruleIndex);\n            hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.predIndex);\n            hashCode = MurmurHash_1.MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);\n            hashCode = MurmurHash_1.MurmurHash.finish(hashCode, 3);\n            return hashCode;\n        }\n        equals(obj) {\n            if (!(obj instanceof Predicate)) {\n                return false;\n            }\n            if (this === obj) {\n                return true;\n            }\n            return this.ruleIndex === obj.ruleIndex &&\n                this.predIndex === obj.predIndex &&\n                this.isCtxDependent === obj.isCtxDependent;\n        }\n        toString() {\n            return \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n        }\n    }\n    __decorate([\n        Decorators_1.Override\n    ], Predicate.prototype, \"eval\", null);\n    __decorate([\n        Decorators_1.Override\n    ], Predicate.prototype, \"hashCode\", null);\n    __decorate([\n        Decorators_1.Override\n    ], Predicate.prototype, \"equals\", null);\n    __decorate([\n        Decorators_1.Override\n    ], Predicate.prototype, \"toString\", null);\n    SemanticContext.Predicate = Predicate;\n    class PrecedencePredicate extends SemanticContext {\n        constructor(precedence) {\n            super();\n            this.precedence = precedence;\n        }\n        eval(parser, parserCallStack) {\n            return parser.precpred(parserCallStack, this.precedence);\n        }\n        evalPrecedence(parser, parserCallStack) {\n            if (parser.precpred(parserCallStack, this.precedence)) {\n                return SemanticContext.NONE;\n            }\n            else {\n                return undefined;\n            }\n        }\n        compareTo(o) {\n            return this.precedence - o.precedence;\n        }\n        hashCode() {\n            let hashCode = 1;\n            hashCode = 31 * hashCode + this.precedence;\n            return hashCode;\n        }\n        equals(obj) {\n            if (!(obj instanceof PrecedencePredicate)) {\n                return false;\n            }\n            if (this === obj) {\n                return true;\n            }\n            return this.precedence === obj.precedence;\n        }\n        toString() {\n            return \"{\" + this.precedence + \">=prec}?\";\n        }\n    }\n    __decorate([\n        Decorators_1.Override\n    ], PrecedencePredicate.prototype, \"eval\", null);\n    __decorate([\n        Decorators_1.Override\n    ], PrecedencePredicate.prototype, \"evalPrecedence\", null);\n    __decorate([\n        Decorators_1.Override\n    ], PrecedencePredicate.prototype, \"compareTo\", null);\n    __decorate([\n        Decorators_1.Override\n    ], PrecedencePredicate.prototype, \"hashCode\", null);\n    __decorate([\n        Decorators_1.Override\n    ], PrecedencePredicate.prototype, \"equals\", null);\n    __decorate([\n        Decorators_1.Override\n        // precedence >= _precedenceStack.peek()\n    ], PrecedencePredicate.prototype, \"toString\", null);\n    SemanticContext.PrecedencePredicate = PrecedencePredicate;\n    /**\n     * This is the base class for semantic context \"operators\", which operate on\n     * a collection of semantic context \"operands\".\n     *\n     * @since 4.3\n     */\n    class Operator extends SemanticContext {\n    }\n    SemanticContext.Operator = Operator;\n    /**\n     * A semantic context which is true whenever none of the contained contexts\n     * is false.\n     */\n    let AND = class AND extends Operator {\n        constructor(a, b) {\n            super();\n            let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n            if (a instanceof AND) {\n                operands.addAll(a.opnds);\n            }\n            else {\n                operands.add(a);\n            }\n            if (b instanceof AND) {\n                operands.addAll(b.opnds);\n            }\n            else {\n                operands.add(b);\n            }\n            this.opnds = operands.toArray();\n            let precedencePredicates = filterPrecedencePredicates(this.opnds);\n            // interested in the transition with the lowest precedence\n            let reduced = min(precedencePredicates);\n            if (reduced) {\n                this.opnds.push(reduced);\n            }\n        }\n        get operands() {\n            return this.opnds;\n        }\n        equals(obj) {\n            if (this === obj) {\n                return true;\n            }\n            if (!(obj instanceof AND)) {\n                return false;\n            }\n            return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);\n        }\n        hashCode() {\n            return MurmurHash_1.MurmurHash.hashCode(this.opnds, AND_HASHCODE);\n        }\n        /**\n         * {@inheritDoc}\n         *\n         * The evaluation of predicates by this context is short-circuiting, but\n         * unordered.\n         */\n        eval(parser, parserCallStack) {\n            for (let opnd of this.opnds) {\n                if (!opnd.eval(parser, parserCallStack)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        evalPrecedence(parser, parserCallStack) {\n            let differs = false;\n            let operands = [];\n            for (let context of this.opnds) {\n                let evaluated = context.evalPrecedence(parser, parserCallStack);\n                differs = differs || (evaluated !== context);\n                if (evaluated == null) {\n                    // The AND context is false if any element is false\n                    return undefined;\n                }\n                else if (evaluated !== SemanticContext.NONE) {\n                    // Reduce the result by skipping true elements\n                    operands.push(evaluated);\n                }\n            }\n            if (!differs) {\n                return this;\n            }\n            if (operands.length === 0) {\n                // all elements were true, so the AND context is true\n                return SemanticContext.NONE;\n            }\n            let result = operands[0];\n            for (let i = 1; i < operands.length; i++) {\n                result = SemanticContext.and(result, operands[i]);\n            }\n            return result;\n        }\n        toString() {\n            return Utils.join(this.opnds, \"&&\");\n        }\n    };\n    __decorate([\n        Decorators_1.Override\n    ], AND.prototype, \"operands\", null);\n    __decorate([\n        Decorators_1.Override\n    ], AND.prototype, \"equals\", null);\n    __decorate([\n        Decorators_1.Override\n    ], AND.prototype, \"hashCode\", null);\n    __decorate([\n        Decorators_1.Override\n    ], AND.prototype, \"eval\", null);\n    __decorate([\n        Decorators_1.Override\n    ], AND.prototype, \"evalPrecedence\", null);\n    __decorate([\n        Decorators_1.Override\n    ], AND.prototype, \"toString\", null);\n    AND = __decorate([\n        __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n    ], AND);\n    SemanticContext.AND = AND;\n    /**\n     * A semantic context which is true whenever at least one of the contained\n     * contexts is true.\n     */\n    let OR = class OR extends Operator {\n        constructor(a, b) {\n            super();\n            let operands = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n            if (a instanceof OR) {\n                operands.addAll(a.opnds);\n            }\n            else {\n                operands.add(a);\n            }\n            if (b instanceof OR) {\n                operands.addAll(b.opnds);\n            }\n            else {\n                operands.add(b);\n            }\n            this.opnds = operands.toArray();\n            let precedencePredicates = filterPrecedencePredicates(this.opnds);\n            // interested in the transition with the highest precedence\n            let reduced = max(precedencePredicates);\n            if (reduced) {\n                this.opnds.push(reduced);\n            }\n        }\n        get operands() {\n            return this.opnds;\n        }\n        equals(obj) {\n            if (this === obj) {\n                return true;\n            }\n            if (!(obj instanceof OR)) {\n                return false;\n            }\n            return ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);\n        }\n        hashCode() {\n            return MurmurHash_1.MurmurHash.hashCode(this.opnds, OR_HASHCODE);\n        }\n        /**\n         * {@inheritDoc}\n         *\n         * The evaluation of predicates by this context is short-circuiting, but\n         * unordered.\n         */\n        eval(parser, parserCallStack) {\n            for (let opnd of this.opnds) {\n                if (opnd.eval(parser, parserCallStack)) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        evalPrecedence(parser, parserCallStack) {\n            let differs = false;\n            let operands = [];\n            for (let context of this.opnds) {\n                let evaluated = context.evalPrecedence(parser, parserCallStack);\n                differs = differs || (evaluated !== context);\n                if (evaluated === SemanticContext.NONE) {\n                    // The OR context is true if any element is true\n                    return SemanticContext.NONE;\n                }\n                else if (evaluated) {\n                    // Reduce the result by skipping false elements\n                    operands.push(evaluated);\n                }\n            }\n            if (!differs) {\n                return this;\n            }\n            if (operands.length === 0) {\n                // all elements were false, so the OR context is false\n                return undefined;\n            }\n            let result = operands[0];\n            for (let i = 1; i < operands.length; i++) {\n                result = SemanticContext.or(result, operands[i]);\n            }\n            return result;\n        }\n        toString() {\n            return Utils.join(this.opnds, \"||\");\n        }\n    };\n    __decorate([\n        Decorators_1.Override\n    ], OR.prototype, \"operands\", null);\n    __decorate([\n        Decorators_1.Override\n    ], OR.prototype, \"equals\", null);\n    __decorate([\n        Decorators_1.Override\n    ], OR.prototype, \"hashCode\", null);\n    __decorate([\n        Decorators_1.Override\n    ], OR.prototype, \"eval\", null);\n    __decorate([\n        Decorators_1.Override\n    ], OR.prototype, \"evalPrecedence\", null);\n    __decorate([\n        Decorators_1.Override\n    ], OR.prototype, \"toString\", null);\n    OR = __decorate([\n        __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n    ], OR);\n    SemanticContext.OR = OR;\n})(SemanticContext = exports.SemanticContext || (exports.SemanticContext = {}));\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:36.9521478-07:00\n\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\nimport { ArrayEqualityComparator } from \"../misc/ArrayEqualityComparator\";\nimport { Comparable } from \"../misc/Stubs\";\nimport { Equatable } from \"../misc/Stubs\";\nimport { MurmurHash } from \"../misc/MurmurHash\";\nimport { NotNull, Override } from \"../Decorators\";\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\nimport { Recognizer } from \"../Recognizer\";\nimport { RuleContext } from \"../RuleContext\";\nimport * as Utils from \"../misc/Utils\";\n\nfunction max<T extends Comparable<T>>(items: Iterable<T>): T | undefined {\n\tlet result: T | undefined;\n\tfor (let current of items) {\n\t\tif (result === undefined) {\n\t\t\tresult = current;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet comparison = result.compareTo(current);\n\t\tif (comparison < 0) {\n\t\t\tresult = current;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nfunction min<T extends Comparable<T>>(items: Iterable<T>): T | undefined {\n\tlet result: T | undefined;\n\tfor (let current of items) {\n\t\tif (result === undefined) {\n\t\t\tresult = current;\n\t\t\tcontinue;\n\t\t}\n\n\t\tlet comparison = result.compareTo(current);\n\t\tif (comparison > 0) {\n\t\t\tresult = current;\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/** A tree structure used to record the semantic context in which\n *  an ATN configuration is valid.  It's either a single predicate,\n *  a conjunction `p1&&p2`, or a sum of products `p1||p2`.\n *\n *  I have scoped the {@link AND}, {@link OR}, and {@link Predicate} subclasses of\n *  {@link SemanticContext} within the scope of this outer class.\n */\nexport abstract class SemanticContext implements Equatable {\n\tprivate static _NONE: SemanticContext;\n\n\t/**\n\t * The default {@link SemanticContext}, which is semantically equivalent to\n\t * a predicate of the form `{true}?`.\n\t */\n\tstatic get NONE(): SemanticContext {\n\t\tif (SemanticContext._NONE === undefined) {\n\t\t\tSemanticContext._NONE = new SemanticContext.Predicate();\n\t\t}\n\n\t\treturn SemanticContext._NONE;\n\t}\n\n\t/**\n\t * For context independent predicates, we evaluate them without a local\n\t * context (i.e., unedfined context). That way, we can evaluate them without\n\t * having to create proper rule-specific context during prediction (as\n\t * opposed to the parser, which creates them naturally). In a practical\n\t * sense, this avoids a cast exception from RuleContext to myruleContext.\n\t *\n\t * For context dependent predicates, we must pass in a local context so that\n\t * references such as $arg evaluate properly as _localctx.arg. We only\n\t * capture context dependent predicates in the context in which we begin\n\t * prediction, so we passed in the outer context here in case of context\n\t * dependent predicate evaluation.\n\t */\n\tpublic abstract eval<T>(parser: Recognizer<T, any>, parserCallStack: RuleContext): boolean;\n\n\t/**\n\t * Evaluate the precedence predicates for the context and reduce the result.\n\t *\n\t * @param parser The parser instance.\n\t * @param parserCallStack\n\t * @returns The simplified semantic context after precedence predicates are\n\t * evaluated, which will be one of the following values.\n\t *\n\t * * {@link #NONE}: if the predicate simplifies to `true` after\n\t *   precedence predicates are evaluated.\n\t * * `undefined`: if the predicate simplifies to `false` after\n\t *   precedence predicates are evaluated.\n\t * * `this`: if the semantic context is not changed as a result of\n\t *   precedence predicate evaluation.\n\t * * A non-`undefined` {@link SemanticContext}: the new simplified\n\t *   semantic context after precedence predicates are evaluated.\n\t */\n\tpublic evalPrecedence(parser: Recognizer<any, any>, parserCallStack: RuleContext): SemanticContext | undefined {\n\t\treturn this;\n\t}\n\n\tpublic abstract hashCode(): number;\n\n\tpublic abstract equals(obj: any): boolean;\n\n\tpublic static and(a: SemanticContext | undefined, b: SemanticContext): SemanticContext {\n\t\tif (!a || a === SemanticContext.NONE) {\n\t\t\treturn b;\n\t\t}\n\t\tif (b === SemanticContext.NONE) {\n\t\t\treturn a;\n\t\t}\n\t\tlet result: SemanticContext.AND = new SemanticContext.AND(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t *\n\t *  @see ParserATNSimulator#getPredsForAmbigAlts\n\t */\n\tpublic static or(a: SemanticContext | undefined, b: SemanticContext): SemanticContext {\n\t\tif (!a) {\n\t\t\treturn b;\n\t\t}\n\n\t\tif (a === SemanticContext.NONE || b === SemanticContext.NONE) {\n\t\t\treturn SemanticContext.NONE;\n\t\t}\n\t\tlet result: SemanticContext.OR = new SemanticContext.OR(a, b);\n\t\tif (result.opnds.length === 1) {\n\t\t\treturn result.opnds[0];\n\t\t}\n\n\t\treturn result;\n\t}\n}\n\nexport namespace SemanticContext {\n\t/**\n\t * This random 30-bit prime represents the value of `AND.class.hashCode()`.\n\t */\n\tconst AND_HASHCODE = 40363613;\n\t/**\n\t * This random 30-bit prime represents the value of `OR.class.hashCode()`.\n\t */\n\tconst OR_HASHCODE = 486279973;\n\n\tfunction filterPrecedencePredicates(collection: SemanticContext[]): SemanticContext.PrecedencePredicate[] {\n\t\tlet result: SemanticContext.PrecedencePredicate[] = [];\n\t\tfor (let i = 0; i < collection.length; i++) {\n\t\t\tlet context: SemanticContext = collection[i];\n\t\t\tif (context instanceof SemanticContext.PrecedencePredicate) {\n\t\t\t\tresult.push(context);\n\n\t\t\t\t// Remove the item from 'collection' and move i back so we look at the same index again\n\t\t\t\tcollection.splice(i, 1);\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\texport class Predicate extends SemanticContext {\n\t\tpublic ruleIndex: number;\n\t\tpublic predIndex: number;\n\t\tpublic isCtxDependent: boolean;   // e.g., $i ref in pred\n\n\t\tconstructor();\n\t\tconstructor(ruleIndex: number, predIndex: number, isCtxDependent: boolean);\n\n\t\tconstructor(ruleIndex: number = -1, predIndex: number = -1, isCtxDependent: boolean = false) {\n\t\t\tsuper();\n\t\t\tthis.ruleIndex = ruleIndex;\n\t\t\tthis.predIndex = predIndex;\n\t\t\tthis.isCtxDependent = isCtxDependent;\n\t\t}\n\n\t\t@Override\n\t\tpublic eval<T>(parser: Recognizer<T, any>, parserCallStack: RuleContext): boolean {\n\t\t\tlet localctx: RuleContext | undefined = this.isCtxDependent ? parserCallStack : undefined;\n\t\t\treturn parser.sempred(localctx, this.ruleIndex, this.predIndex);\n\t\t}\n\n\t\t@Override\n\t\tpublic hashCode(): number {\n\t\t\tlet hashCode: number = MurmurHash.initialize();\n\t\t\thashCode = MurmurHash.update(hashCode, this.ruleIndex);\n\t\t\thashCode = MurmurHash.update(hashCode, this.predIndex);\n\t\t\thashCode = MurmurHash.update(hashCode, this.isCtxDependent ? 1 : 0);\n\t\t\thashCode = MurmurHash.finish(hashCode, 3);\n\t\t\treturn hashCode;\n\t\t}\n\n\t\t@Override\n\t\tpublic equals(obj: any): boolean {\n\t\t\tif (!(obj instanceof Predicate)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (this === obj) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn this.ruleIndex === obj.ruleIndex &&\n\t\t\t\tthis.predIndex === obj.predIndex &&\n\t\t\t\tthis.isCtxDependent === obj.isCtxDependent;\n\t\t}\n\n\t\t@Override\n\t\tpublic toString(): string {\n\t\t\treturn \"{\" + this.ruleIndex + \":\" + this.predIndex + \"}?\";\n\t\t}\n\t}\n\n\texport class PrecedencePredicate extends SemanticContext implements Comparable<PrecedencePredicate> {\n\t\tpublic precedence: number;\n\n\t\tconstructor(precedence: number) {\n\t\t\tsuper();\n\t\t\tthis.precedence = precedence;\n\t\t}\n\n\t\t@Override\n\t\tpublic eval<T>(parser: Recognizer<T, any>, parserCallStack: RuleContext): boolean {\n\t\t\treturn parser.precpred(parserCallStack, this.precedence);\n\t\t}\n\n\t\t@Override\n\t\tpublic evalPrecedence(parser: Recognizer<any, any>, parserCallStack: RuleContext): SemanticContext | undefined {\n\t\t\tif (parser.precpred(parserCallStack, this.precedence)) {\n\t\t\t\treturn SemanticContext.NONE;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn undefined;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic compareTo(o: PrecedencePredicate): number {\n\t\t\treturn this.precedence - o.precedence;\n\t\t}\n\n\t\t@Override\n\t\tpublic hashCode(): number {\n\t\t\tlet hashCode: number = 1;\n\t\t\thashCode = 31 * hashCode + this.precedence;\n\t\t\treturn hashCode;\n\t\t}\n\n\t\t@Override\n\t\tpublic equals(obj: any): boolean {\n\t\t\tif (!(obj instanceof PrecedencePredicate)) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (this === obj) {\n\t\t\t\treturn true;\n\t\t\t}\n\n\t\t\treturn this.precedence === obj.precedence;\n\t\t}\n\n\t\t@Override\n\t\t// precedence >= _precedenceStack.peek()\n\t\tpublic toString(): string {\n\t\t\treturn \"{\" + this.precedence + \">=prec}?\";\n\t\t}\n\t}\n\n\t/**\n\t * This is the base class for semantic context \"operators\", which operate on\n\t * a collection of semantic context \"operands\".\n\t *\n\t * @since 4.3\n\t */\n\texport abstract class Operator extends SemanticContext {\n\t\t/**\n\t\t * Gets the operands for the semantic context operator.\n\t\t *\n\t\t * @returns a collection of {@link SemanticContext} operands for the\n\t\t * operator.\n\t\t *\n\t\t * @since 4.3\n\t\t */\n\t\t// @NotNull\n\t\tpublic abstract readonly operands: Iterable<SemanticContext>;\n\t}\n\n\t/**\n\t * A semantic context which is true whenever none of the contained contexts\n\t * is false.\n\t */\n\texport class AND extends Operator {\n\t\tpublic opnds: SemanticContext[];\n\n\t\tconstructor(@NotNull a: SemanticContext, @NotNull b: SemanticContext) {\n\t\t\tsuper();\n\n\t\t\tlet operands: Array2DHashSet<SemanticContext> = new Array2DHashSet<SemanticContext>(ObjectEqualityComparator.INSTANCE);\n\t\t\tif (a instanceof AND) {\n\t\t\t\toperands.addAll(a.opnds);\n\t\t\t} else {\n\t\t\t\toperands.add(a);\n\t\t\t}\n\n\t\t\tif (b instanceof AND) {\n\t\t\t\toperands.addAll(b.opnds);\n\t\t\t} else {\n\t\t\t\toperands.add(b);\n\t\t\t}\n\n\t\t\tthis.opnds = operands.toArray();\n\t\t\tlet precedencePredicates: PrecedencePredicate[] = filterPrecedencePredicates(this.opnds);\n\n\t\t\t// interested in the transition with the lowest precedence\n\t\t\tlet reduced = min(precedencePredicates);\n\t\t\tif (reduced) {\n\t\t\t\tthis.opnds.push(reduced);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tget operands(): Iterable<SemanticContext> {\n\t\t\treturn this.opnds;\n\t\t}\n\n\t\t@Override\n\t\tpublic equals(obj: any): boolean {\n\t\t\tif (this === obj) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!(obj instanceof AND)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);\n\t\t}\n\n\t\t@Override\n\t\tpublic hashCode(): number {\n\t\t\treturn MurmurHash.hashCode(this.opnds, AND_HASHCODE);\n\t\t}\n\n\t\t/**\n\t\t * {@inheritDoc}\n\t\t *\n\t\t * The evaluation of predicates by this context is short-circuiting, but\n\t\t * unordered.\n\t\t */\n\t\t@Override\n\t\tpublic eval<T>(parser: Recognizer<T, any>, parserCallStack: RuleContext): boolean {\n\t\t\tfor (let opnd of this.opnds) {\n\t\t\t\tif (!opnd.eval(parser, parserCallStack)) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn true;\n\t\t}\n\n\t\t@Override\n\t\tpublic evalPrecedence(parser: Recognizer<any, any>, parserCallStack: RuleContext): SemanticContext | undefined {\n\t\t\tlet differs: boolean = false;\n\t\t\tlet operands: SemanticContext[] = [];\n\t\t\tfor (let context of this.opnds) {\n\t\t\t\tlet evaluated: SemanticContext | undefined = context.evalPrecedence(parser, parserCallStack);\n\t\t\t\tdiffers = differs || (evaluated !== context);\n\t\t\t\tif (evaluated == null) {\n\t\t\t\t\t// The AND context is false if any element is false\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\telse if (evaluated !== SemanticContext.NONE) {\n\t\t\t\t\t// Reduce the result by skipping true elements\n\t\t\t\t\toperands.push(evaluated);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!differs) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (operands.length === 0) {\n\t\t\t\t// all elements were true, so the AND context is true\n\t\t\t\treturn SemanticContext.NONE;\n\t\t\t}\n\n\t\t\tlet result: SemanticContext = operands[0];\n\t\t\tfor (let i = 1; i < operands.length; i++) {\n\t\t\t\tresult = SemanticContext.and(result, operands[i]);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic toString(): string {\n\t\t\treturn Utils.join(this.opnds, \"&&\");\n\t\t}\n\t}\n\n\t/**\n\t * A semantic context which is true whenever at least one of the contained\n\t * contexts is true.\n\t */\n\texport class OR extends Operator {\n\t\tpublic opnds: SemanticContext[];\n\n\t\tconstructor(@NotNull a: SemanticContext, @NotNull b: SemanticContext) {\n\t\t\tsuper();\n\n\t\t\tlet operands: Array2DHashSet<SemanticContext> = new Array2DHashSet<SemanticContext>(ObjectEqualityComparator.INSTANCE);\n\t\t\tif (a instanceof OR) {\n\t\t\t\toperands.addAll(a.opnds);\n\t\t\t} else {\n\t\t\t\toperands.add(a);\n\t\t\t}\n\n\t\t\tif (b instanceof OR) {\n\t\t\t\toperands.addAll(b.opnds);\n\t\t\t} else {\n\t\t\t\toperands.add(b);\n\t\t\t}\n\n\t\t\tthis.opnds = operands.toArray();\n\t\t\tlet precedencePredicates: PrecedencePredicate[] = filterPrecedencePredicates(this.opnds);\n\n\t\t\t// interested in the transition with the highest precedence\n\t\t\tlet reduced = max(precedencePredicates);\n\t\t\tif (reduced) {\n\t\t\t\tthis.opnds.push(reduced);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tget operands(): Iterable<SemanticContext> {\n\t\t\treturn this.opnds;\n\t\t}\n\n\t\t@Override\n\t\tpublic equals(obj: any): boolean {\n\t\t\tif (this === obj) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif (!(obj instanceof OR)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn ArrayEqualityComparator.INSTANCE.equals(this.opnds, obj.opnds);\n\t\t}\n\n\t\t@Override\n\t\tpublic hashCode(): number {\n\t\t\treturn MurmurHash.hashCode(this.opnds, OR_HASHCODE);\n\t\t}\n\n\t\t/**\n\t\t * {@inheritDoc}\n\t\t *\n\t\t * The evaluation of predicates by this context is short-circuiting, but\n\t\t * unordered.\n\t\t */\n\t\t@Override\n\t\tpublic eval<T>(parser: Recognizer<T, any>, parserCallStack: RuleContext): boolean {\n\t\t\tfor (let opnd of this.opnds) {\n\t\t\t\tif (opnd.eval(parser, parserCallStack)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\t@Override\n\t\tpublic evalPrecedence(parser: Recognizer<any, any>, parserCallStack: RuleContext): SemanticContext | undefined {\n\t\t\tlet differs: boolean = false;\n\t\t\tlet operands: SemanticContext[] = [];\n\t\t\tfor (let context of this.opnds) {\n\t\t\t\tlet evaluated: SemanticContext | undefined = context.evalPrecedence(parser, parserCallStack);\n\t\t\t\tdiffers = differs || (evaluated !== context);\n\t\t\t\tif (evaluated === SemanticContext.NONE) {\n\t\t\t\t\t// The OR context is true if any element is true\n\t\t\t\t\treturn SemanticContext.NONE;\n\t\t\t\t} else if (evaluated) {\n\t\t\t\t\t// Reduce the result by skipping false elements\n\t\t\t\t\toperands.push(evaluated);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!differs) {\n\t\t\t\treturn this;\n\t\t\t}\n\n\t\t\tif (operands.length === 0) {\n\t\t\t\t// all elements were false, so the OR context is false\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tlet result: SemanticContext = operands[0];\n\t\t\tfor (let i = 1; i < operands.length; i++) {\n\t\t\t\tresult = SemanticContext.or(result, operands[i]);\n\t\t\t}\n\n\t\t\treturn result;\n\t\t}\n\n\t\t@Override\n\t\tpublic toString(): string {\n\t\t\treturn Utils.join(this.opnds, \"||\");\n\t\t}\n\t}\n}\n"]}