{"version":3,"sources":["atn/LL1Analyzer.js","../src/atn/LL1Analyzer.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","AbstractPredicateTransition_1","require","Array2DHashSet_1","ATNConfig_1","BitSet_1","IntervalSet_1","Decorators_1","NotSetTransition_1","ObjectEqualityComparator_1","PredictionContext_1","RuleStopState_1","RuleTransition_1","Token_1","WildcardTransition_1","LL1Analyzer","atn","s","undefined","look","Array","numberOfTransitions","alt","current","IntervalSet","lookBusy","Array2DHashSet","ObjectEqualityComparator","INSTANCE","seeThruPreds","_LOOK","transition","PredictionContext","EMPTY_LOCAL","BitSet","size","contains","HIT_PRED","ctx","stopState","Error","ruleToStopState","ruleIndex","addEOF","calledRuleStack","ATNConfig","create","add","isEmptyLocal","Token","EPSILON","isEmpty","EOF","RuleStopState","removed","get","clear","getReturnState","EMPTY_FULL_STATE_KEY","returnState","states","getParent","set","n","t","RuleTransition","newContext","getChild","followState","stateNumber","AbstractPredicateTransition","isEpsilon","WildcardTransition","addAll","of","MIN_USER_TOKEN_TYPE","maxTokenType","label","NotSetTransition","complement","INVALID_TYPE","NotNull","prototype"],"mappings":"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","file":"LL1Analyzer.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:30.4445360-07:00\nconst AbstractPredicateTransition_1 = require(\"./AbstractPredicateTransition\");\nconst Array2DHashSet_1 = require(\"../misc/Array2DHashSet\");\nconst ATNConfig_1 = require(\"./ATNConfig\");\nconst BitSet_1 = require(\"../misc/BitSet\");\nconst IntervalSet_1 = require(\"../misc/IntervalSet\");\nconst Decorators_1 = require(\"../Decorators\");\nconst NotSetTransition_1 = require(\"./NotSetTransition\");\nconst ObjectEqualityComparator_1 = require(\"../misc/ObjectEqualityComparator\");\nconst PredictionContext_1 = require(\"./PredictionContext\");\nconst RuleStopState_1 = require(\"./RuleStopState\");\nconst RuleTransition_1 = require(\"./RuleTransition\");\nconst Token_1 = require(\"../Token\");\nconst WildcardTransition_1 = require(\"./WildcardTransition\");\nlet LL1Analyzer = class LL1Analyzer {\n    constructor(atn) { this.atn = atn; }\n    /**\n     * Calculates the SLL(1) expected lookahead set for each outgoing transition\n     * of an {@link ATNState}. The returned array has one element for each\n     * outgoing transition in `s`. If the closure from transition\n     * *i* leads to a semantic predicate before matching a symbol, the\n     * element at index *i* of the result will be `undefined`.\n     *\n     * @param s the ATN state\n     * @returns the expected symbols for each outgoing transition of `s`.\n     */\n    getDecisionLookahead(s) {\n        //\t\tSystem.out.println(\"LOOK(\"+s.stateNumber+\")\");\n        if (s == null) {\n            return undefined;\n        }\n        let look = new Array(s.numberOfTransitions);\n        for (let alt = 0; alt < s.numberOfTransitions; alt++) {\n            let current = new IntervalSet_1.IntervalSet();\n            look[alt] = current;\n            let lookBusy = new Array2DHashSet_1.Array2DHashSet(ObjectEqualityComparator_1.ObjectEqualityComparator.INSTANCE);\n            let seeThruPreds = false; // fail to get lookahead upon pred\n            this._LOOK(s.transition(alt).target, undefined, PredictionContext_1.PredictionContext.EMPTY_LOCAL, current, lookBusy, new BitSet_1.BitSet(), seeThruPreds, false);\n            // Wipe out lookahead for this alternative if we found nothing\n            // or we had a predicate when we !seeThruPreds\n            if (current.size === 0 || current.contains(LL1Analyzer.HIT_PRED)) {\n                current = undefined;\n                look[alt] = current;\n            }\n        }\n        return look;\n    }\n    LOOK(s, ctx, stopState) {\n        if (stopState === undefined) {\n            if (s.atn == null) {\n                throw new Error(\"Illegal state\");\n            }\n            stopState = s.atn.ruleToStopState[s.ruleIndex];\n        }\n        else if (stopState === null) {\n            // This is an explicit request to pass undefined as the stopState to _LOOK. Used to distinguish an overload\n            // from the method which simply omits the stopState parameter.\n            stopState = undefined;\n        }\n        let r = new IntervalSet_1.IntervalSet();\n        let seeThruPreds = true; // ignore preds; get all lookahead\n        let addEOF = true;\n        this._LOOK(s, stopState, ctx, r, new Array2DHashSet_1.Array2DHashSet(), new BitSet_1.BitSet(), seeThruPreds, addEOF);\n        return r;\n    }\n    /**\n     * Compute set of tokens that can follow `s` in the ATN in the\n     * specified `ctx`.\n     * <p/>\n     * If `ctx` is {@link PredictionContext#EMPTY_LOCAL} and\n     * `stopState` or the end of the rule containing `s` is reached,\n     * {@link Token#EPSILON} is added to the result set. If `ctx` is not\n     * {@link PredictionContext#EMPTY_LOCAL} and `addEOF` is `true`\n     * and `stopState` or the end of the outermost rule is reached,\n     * {@link Token#EOF} is added to the result set.\n     *\n     * @param s the ATN state.\n     * @param stopState the ATN state to stop at. This can be a\n     * {@link BlockEndState} to detect epsilon paths through a closure.\n     * @param ctx The outer context, or {@link PredictionContext#EMPTY_LOCAL} if\n     * the outer context should not be used.\n     * @param look The result lookahead set.\n     * @param lookBusy A set used for preventing epsilon closures in the ATN\n     * from causing a stack overflow. Outside code should pass\n     * `new HashSet<ATNConfig>` for this argument.\n     * @param calledRuleStack A set used for preventing left recursion in the\n     * ATN from causing a stack overflow. Outside code should pass\n     * `new BitSet()` for this argument.\n     * @param seeThruPreds `true` to true semantic predicates as\n     * implicitly `true` and \"see through them\", otherwise `false`\n     * to treat semantic predicates as opaque and add {@link #HIT_PRED} to the\n     * result if one is encountered.\n     * @param addEOF Add {@link Token#EOF} to the result if the end of the\n     * outermost context is reached. This parameter has no effect if `ctx`\n     * is {@link PredictionContext#EMPTY_LOCAL}.\n     */\n    _LOOK(s, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF) {\n        //\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n        let c = ATNConfig_1.ATNConfig.create(s, 0, ctx);\n        if (!lookBusy.add(c)) {\n            return;\n        }\n        if (s === stopState) {\n            if (PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {\n                look.add(Token_1.Token.EPSILON);\n                return;\n            }\n            else if (ctx.isEmpty) {\n                if (addEOF) {\n                    look.add(Token_1.Token.EOF);\n                }\n                return;\n            }\n        }\n        if (s instanceof RuleStopState_1.RuleStopState) {\n            if (ctx.isEmpty && !PredictionContext_1.PredictionContext.isEmptyLocal(ctx)) {\n                if (addEOF) {\n                    look.add(Token_1.Token.EOF);\n                }\n                return;\n            }\n            let removed = calledRuleStack.get(s.ruleIndex);\n            try {\n                calledRuleStack.clear(s.ruleIndex);\n                for (let i = 0; i < ctx.size; i++) {\n                    if (ctx.getReturnState(i) === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n                        continue;\n                    }\n                    let returnState = this.atn.states[ctx.getReturnState(i)];\n                    //\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n                    this._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                }\n            }\n            finally {\n                if (removed) {\n                    calledRuleStack.set(s.ruleIndex);\n                }\n            }\n        }\n        let n = s.numberOfTransitions;\n        for (let i = 0; i < n; i++) {\n            let t = s.transition(i);\n            if (t instanceof RuleTransition_1.RuleTransition) {\n                if (calledRuleStack.get(t.ruleIndex)) {\n                    continue;\n                }\n                let newContext = ctx.getChild(t.followState.stateNumber);\n                try {\n                    calledRuleStack.set(t.ruleIndex);\n                    this._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                }\n                finally {\n                    calledRuleStack.clear(t.ruleIndex);\n                }\n            }\n            else if (t instanceof AbstractPredicateTransition_1.AbstractPredicateTransition) {\n                if (seeThruPreds) {\n                    this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n                }\n                else {\n                    look.add(LL1Analyzer.HIT_PRED);\n                }\n            }\n            else if (t.isEpsilon) {\n                this._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n            }\n            else if (t instanceof WildcardTransition_1.WildcardTransition) {\n                look.addAll(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n            }\n            else {\n                //\t\t\t\tSystem.out.println(\"adding \"+ t);\n                let set = t.label;\n                if (set != null) {\n                    if (t instanceof NotSetTransition_1.NotSetTransition) {\n                        set = set.complement(IntervalSet_1.IntervalSet.of(Token_1.Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n                    }\n                    look.addAll(set);\n                }\n            }\n        }\n    }\n};\n/** Special value added to the lookahead sets to indicate that we hit\n *  a predicate during analysis if `seeThruPreds==false`.\n */\nLL1Analyzer.HIT_PRED = Token_1.Token.INVALID_TYPE;\n__decorate([\n    Decorators_1.NotNull\n], LL1Analyzer.prototype, \"atn\", void 0);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], LL1Analyzer.prototype, \"LOOK\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull),\n    __param(4, Decorators_1.NotNull),\n    __param(5, Decorators_1.NotNull)\n], LL1Analyzer.prototype, \"_LOOK\", null);\nLL1Analyzer = __decorate([\n    __param(0, Decorators_1.NotNull)\n], LL1Analyzer);\nexports.LL1Analyzer = LL1Analyzer;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:30.4445360-07:00\n\nimport { AbstractPredicateTransition } from \"./AbstractPredicateTransition\";\nimport { Array2DHashSet } from \"../misc/Array2DHashSet\";\nimport { ATN } from \"./ATN\";\nimport { ATNConfig } from \"./ATNConfig\";\nimport { ATNState } from \"./ATNState\";\nimport { BitSet } from \"../misc/BitSet\";\nimport { IntervalSet } from \"../misc/IntervalSet\";\nimport { NotNull } from \"../Decorators\";\nimport { NotSetTransition } from \"./NotSetTransition\";\nimport { ObjectEqualityComparator } from \"../misc/ObjectEqualityComparator\";\nimport { PredictionContext } from \"./PredictionContext\";\nimport { RuleStopState } from \"./RuleStopState\";\nimport { RuleTransition } from \"./RuleTransition\";\nimport { SetTransition } from \"./SetTransition\";\nimport { Token } from \"../Token\";\nimport { Transition } from \"./Transition\";\nimport { WildcardTransition } from \"./WildcardTransition\";\n\nexport class LL1Analyzer {\n\t/** Special value added to the lookahead sets to indicate that we hit\n\t *  a predicate during analysis if `seeThruPreds==false`.\n\t */\n\tpublic static readonly HIT_PRED: number = Token.INVALID_TYPE;\n\n\t@NotNull\n\tpublic atn: ATN;\n\n\tconstructor(@NotNull atn: ATN) { this.atn = atn; }\n\n\t/**\n\t * Calculates the SLL(1) expected lookahead set for each outgoing transition\n\t * of an {@link ATNState}. The returned array has one element for each\n\t * outgoing transition in `s`. If the closure from transition\n\t * *i* leads to a semantic predicate before matching a symbol, the\n\t * element at index *i* of the result will be `undefined`.\n\t *\n\t * @param s the ATN state\n\t * @returns the expected symbols for each outgoing transition of `s`.\n\t */\n\tpublic getDecisionLookahead(s: ATNState | undefined): Array<IntervalSet | undefined> | undefined {\n//\t\tSystem.out.println(\"LOOK(\"+s.stateNumber+\")\");\n\t\tif (s == null) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet look: Array<IntervalSet | undefined> = new Array<IntervalSet>(s.numberOfTransitions);\n\t\tfor (let alt = 0; alt < s.numberOfTransitions; alt++) {\n\t\t\tlet current: IntervalSet | undefined = new IntervalSet();\n\t\t\tlook[alt] = current;\n\t\t\tlet lookBusy: Array2DHashSet<ATNConfig> = new Array2DHashSet<ATNConfig>(ObjectEqualityComparator.INSTANCE);\n\t\t\tlet seeThruPreds: boolean = false; // fail to get lookahead upon pred\n\t\t\tthis._LOOK(s.transition(alt).target, undefined, PredictionContext.EMPTY_LOCAL,\n\t\t\t\tcurrent, lookBusy, new BitSet(), seeThruPreds, false);\n\t\t\t// Wipe out lookahead for this alternative if we found nothing\n\t\t\t// or we had a predicate when we !seeThruPreds\n\t\t\tif (current.size === 0 || current.contains(LL1Analyzer.HIT_PRED)) {\n\t\t\t\tcurrent = undefined;\n\t\t\t\tlook[alt] = current;\n\t\t\t}\n\t\t}\n\t\treturn look;\n\t}\n\n\t/**\n\t * Compute set of tokens that can follow `s` in the ATN in the\n\t * specified `ctx`.\n\t *\n\t * If `ctx` is `undefined` and the end of the rule containing\n\t * `s` is reached, {@link Token#EPSILON} is added to the result set.\n\t * If `ctx` is not `undefined` and the end of the outermost rule is\n\t * reached, {@link Token#EOF} is added to the result set.\n\t *\n\t * @param s the ATN state\n\t * @param ctx the complete parser context, or `undefined` if the context\n\t * should be ignored\n\t *\n\t * @returns The set of tokens that can follow `s` in the ATN in the\n\t * specified `ctx`.\n\t */\n\t// @NotNull\n\tpublic LOOK(/*@NotNull*/ s: ATNState, /*@NotNull*/ ctx: PredictionContext): IntervalSet;\n\n\t/**\n\t * Compute set of tokens that can follow `s` in the ATN in the\n\t * specified `ctx`.\n\t *\n\t * If `ctx` is `undefined` and the end of the rule containing\n\t * `s` is reached, {@link Token#EPSILON} is added to the result set.\n\t * If `ctx` is not `PredictionContext#EMPTY_LOCAL` and the end of the outermost rule is\n\t * reached, {@link Token#EOF} is added to the result set.\n\t *\n\t * @param s the ATN state\n\t * @param stopState the ATN state to stop at. This can be a\n\t * {@link BlockEndState} to detect epsilon paths through a closure.\n\t * @param ctx the complete parser context, or `undefined` if the context\n\t * should be ignored\n\t *\n\t * @returns The set of tokens that can follow `s` in the ATN in the\n\t * specified `ctx`.\n\t */\n\t// @NotNull\n\tpublic LOOK(/*@NotNull*/ s: ATNState, /*@NotNull*/ ctx: PredictionContext, stopState: ATNState | null): IntervalSet;\n\n\t@NotNull\n\tpublic LOOK(@NotNull s: ATNState, @NotNull ctx: PredictionContext, stopState?: ATNState | null): IntervalSet {\n\t\tif (stopState === undefined) {\n\t\t\tif (s.atn == null) {\n\t\t\t\tthrow new Error(\"Illegal state\");\n\t\t\t}\n\n\t\t\tstopState = s.atn.ruleToStopState[s.ruleIndex];\n\t\t} else if (stopState === null) {\n\t\t\t// This is an explicit request to pass undefined as the stopState to _LOOK. Used to distinguish an overload\n\t\t\t// from the method which simply omits the stopState parameter.\n\t\t\tstopState = undefined;\n\t\t}\n\n\t\tlet r: IntervalSet = new IntervalSet();\n\t\tlet seeThruPreds: boolean = true; // ignore preds; get all lookahead\n\t\tlet addEOF: boolean = true;\n\t\tthis._LOOK(s, stopState, ctx, r, new Array2DHashSet<ATNConfig>(), new BitSet(), seeThruPreds, addEOF);\n\t\treturn r;\n\t}\n\n\t/**\n\t * Compute set of tokens that can follow `s` in the ATN in the\n\t * specified `ctx`.\n\t * <p/>\n\t * If `ctx` is {@link PredictionContext#EMPTY_LOCAL} and\n\t * `stopState` or the end of the rule containing `s` is reached,\n\t * {@link Token#EPSILON} is added to the result set. If `ctx` is not\n\t * {@link PredictionContext#EMPTY_LOCAL} and `addEOF` is `true`\n\t * and `stopState` or the end of the outermost rule is reached,\n\t * {@link Token#EOF} is added to the result set.\n\t *\n\t * @param s the ATN state.\n\t * @param stopState the ATN state to stop at. This can be a\n\t * {@link BlockEndState} to detect epsilon paths through a closure.\n\t * @param ctx The outer context, or {@link PredictionContext#EMPTY_LOCAL} if\n\t * the outer context should not be used.\n\t * @param look The result lookahead set.\n\t * @param lookBusy A set used for preventing epsilon closures in the ATN\n\t * from causing a stack overflow. Outside code should pass\n\t * `new HashSet<ATNConfig>` for this argument.\n\t * @param calledRuleStack A set used for preventing left recursion in the\n\t * ATN from causing a stack overflow. Outside code should pass\n\t * `new BitSet()` for this argument.\n\t * @param seeThruPreds `true` to true semantic predicates as\n\t * implicitly `true` and \"see through them\", otherwise `false`\n\t * to treat semantic predicates as opaque and add {@link #HIT_PRED} to the\n\t * result if one is encountered.\n\t * @param addEOF Add {@link Token#EOF} to the result if the end of the\n\t * outermost context is reached. This parameter has no effect if `ctx`\n\t * is {@link PredictionContext#EMPTY_LOCAL}.\n\t */\n\tprotected _LOOK(\n\t\t@NotNull s: ATNState,\n\t\tstopState: ATNState | undefined,\n\t\t@NotNull ctx: PredictionContext,\n\t\t@NotNull look: IntervalSet,\n\t\t@NotNull lookBusy: Array2DHashSet<ATNConfig>,\n\t\t@NotNull calledRuleStack: BitSet,\n\t\tseeThruPreds: boolean,\n\t\taddEOF: boolean): void {\n//\t\tSystem.out.println(\"_LOOK(\"+s.stateNumber+\", ctx=\"+ctx);\n\t\tlet c: ATNConfig = ATNConfig.create(s, 0, ctx);\n\t\tif (!lookBusy.add(c)) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (s === stopState) {\n\t\t\tif (PredictionContext.isEmptyLocal(ctx)) {\n\t\t\t\tlook.add(Token.EPSILON);\n\t\t\t\treturn;\n\t\t\t} else if (ctx.isEmpty) {\n\t\t\t\tif (addEOF) {\n\t\t\t\t\tlook.add(Token.EOF);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (s instanceof RuleStopState) {\n\t\t\tif (ctx.isEmpty && !PredictionContext.isEmptyLocal(ctx)) {\n\t\t\t\tif (addEOF) {\n\t\t\t\t\tlook.add(Token.EOF);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tlet removed: boolean = calledRuleStack.get(s.ruleIndex);\n\t\t\ttry {\n\t\t\t\tcalledRuleStack.clear(s.ruleIndex);\n\t\t\t\tfor (let i = 0; i < ctx.size; i++) {\n\t\t\t\t\tif (ctx.getReturnState(i) === PredictionContext.EMPTY_FULL_STATE_KEY) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet returnState: ATNState = this.atn.states[ctx.getReturnState(i)];\n//\t\t\t\t\tSystem.out.println(\"popping back to \"+retState);\n\t\t\t\t\tthis._LOOK(returnState, stopState, ctx.getParent(i), look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfinally {\n\t\t\t\tif (removed) {\n\t\t\t\t\tcalledRuleStack.set(s.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet n: number = s.numberOfTransitions;\n\t\tfor (let i = 0; i < n; i++) {\n\t\t\tlet t: Transition = s.transition(i);\n\t\t\tif (t instanceof RuleTransition) {\n\t\t\t\tif (calledRuleStack.get(t.ruleIndex)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet newContext: PredictionContext = ctx.getChild(t.followState.stateNumber);\n\n\t\t\t\ttry {\n\t\t\t\t\tcalledRuleStack.set(t.ruleIndex);\n\t\t\t\t\tthis._LOOK(t.target, stopState, newContext, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\tfinally {\n\t\t\t\t\tcalledRuleStack.clear(t.ruleIndex);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (t instanceof AbstractPredicateTransition) {\n\t\t\t\tif (seeThruPreds) {\n\t\t\t\t\tthis._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlook.add(LL1Analyzer.HIT_PRED);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (t.isEpsilon) {\n\t\t\t\tthis._LOOK(t.target, stopState, ctx, look, lookBusy, calledRuleStack, seeThruPreds, addEOF);\n\t\t\t}\n\t\t\telse if (t instanceof WildcardTransition) {\n\t\t\t\tlook.addAll(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n\t\t\t}\n\t\t\telse {\n//\t\t\t\tSystem.out.println(\"adding \"+ t);\n\t\t\t\tlet set: IntervalSet | undefined = t.label;\n\t\t\t\tif (set != null) {\n\t\t\t\t\tif (t instanceof NotSetTransition) {\n\t\t\t\t\t\tset = set.complement(IntervalSet.of(Token.MIN_USER_TOKEN_TYPE, this.atn.maxTokenType));\n\t\t\t\t\t}\n\t\t\t\t\tlook.addAll(set);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]}