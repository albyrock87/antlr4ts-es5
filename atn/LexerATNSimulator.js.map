{"version":3,"sources":["atn/LexerATNSimulator.js","../src/atn/LexerATNSimulator.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","AcceptStateInfo_1","require","ATN_1","ATNConfig_1","ATNConfigSet_1","ATNSimulator_1","DFAState_1","Interval_1","IntStream_1","Lexer_1","LexerActionExecutor_1","LexerNoViableAltException_1","Decorators_1","OrderedATNConfigSet_1","PredictionContext_1","RuleStopState_1","Token_1","assert","LexerATNSimulator","atn","recog","optimize_tail_calls","startIndex","_line","_charPositionInLine","mode","Lexer","DEFAULT_MODE","prevAccept","SimState","simulator","charPositionInLine","input","match_calls","mark","index","reset","s0","modeToDFA","matchATN","execATN","release","startState","modeToStartState","debug","console","log","old_mode","s0_closure","computeStartState","suppressEdge","hasSemanticContext","next","addDFAState","dfa","predict","toLexerString","ds0","configs","isAcceptState","captureSimState","t","LA","s","getExistingTargetState","computeTargetState","ATNSimulator","ERROR","IntStream","EOF","consume","failOrAccept","getTarget","stateNumber","reach","OrderedATNConfigSet","getReachableConfigSet","isEmpty","addDFAEdge","dfaState","lexerActionExecutor","accept","line","charPos","prediction","Token","LexerNoViableAltException","closure","skipAlt","ATN","INVALID_ALT_NUMBER","currentAltReachedAcceptState","alt","hasPassedThroughNonGreedyDecision","getTokenName","toString","n","state","numberOfOptimizedTransitions","ti","trans","getOptimizedTransition","getReachableTarget","config","fixOffsetBeforeMatch","transform","treatEofAsEpsilon","seek","execute","matches","MIN_CHAR_VALUE","MAX_CHAR_VALUE","undefined","p","initialContext","PredictionContext","EMPTY_FULL","numberOfTransitions","transition","ATNConfig","create","speculative","RuleStopState","ruleNames","ruleIndex","context","add","hasEmpty","size","returnStateNumber","getReturnState","EMPTY_FULL_STATE_KEY","newContext","getParent","returnState","states","onlyHasEpsilonTransitions","getEpsilonTarget","serializationType","ruleTransition","optimizedTailCall","getChild","followState","Error","pt","predIndex","evaluatePredicate","LexerActionExecutor","append","lexerActions","actionIndex","sempred","savedCharPositionInLine","savedLine","marker","settings","q","ATNConfigSet","to","String","fromCharCode","setTarget","proposed","DFAState","existing","get","optimizeConfigs","newState","clone","firstConfigWithRuleStopState","ruleToTokenType","acceptStateInfo","AcceptStateInfo","addState","getText","Interval","of","curChar","charCodeAt","NotNull","prototype","Override","dfa_debug"],"mappings":"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","file":"LexerATNSimulator.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:29.1083066-07:00\nconst AcceptStateInfo_1 = require(\"../dfa/AcceptStateInfo\");\nconst ATN_1 = require(\"./ATN\");\nconst ATNConfig_1 = require(\"./ATNConfig\");\nconst ATNConfigSet_1 = require(\"./ATNConfigSet\");\nconst ATNSimulator_1 = require(\"./ATNSimulator\");\nconst DFAState_1 = require(\"../dfa/DFAState\");\nconst Interval_1 = require(\"../misc/Interval\");\nconst IntStream_1 = require(\"../IntStream\");\nconst Lexer_1 = require(\"../Lexer\");\nconst LexerActionExecutor_1 = require(\"./LexerActionExecutor\");\nconst LexerNoViableAltException_1 = require(\"../LexerNoViableAltException\");\nconst Decorators_1 = require(\"../Decorators\");\nconst OrderedATNConfigSet_1 = require(\"./OrderedATNConfigSet\");\nconst PredictionContext_1 = require(\"./PredictionContext\");\nconst RuleStopState_1 = require(\"./RuleStopState\");\nconst Token_1 = require(\"../Token\");\nconst assert = require(\"assert\");\n/** \"dup\" of ParserInterpreter */\nlet LexerATNSimulator = class LexerATNSimulator extends ATNSimulator_1.ATNSimulator {\n    constructor(atn, recog) {\n        super(atn);\n        this.optimize_tail_calls = true;\n        /** The current token's starting index into the character stream.\n         *  Shared across DFA to ATN simulation in case the ATN fails and the\n         *  DFA did not have a previous accept state. In this case, we use the\n         *  ATN-generated exception object.\n         */\n        this.startIndex = -1;\n        /** line number 1..n within the input */\n        this._line = 1;\n        /** The index of the character relative to the beginning of the line 0..n-1 */\n        this._charPositionInLine = 0;\n        this.mode = Lexer_1.Lexer.DEFAULT_MODE;\n        /** Used during DFA/ATN exec to record the most recent accept configuration info */\n        this.prevAccept = new LexerATNSimulator.SimState();\n        this.recog = recog;\n    }\n    copyState(simulator) {\n        this._charPositionInLine = simulator.charPositionInLine;\n        this._line = simulator._line;\n        this.mode = simulator.mode;\n        this.startIndex = simulator.startIndex;\n    }\n    match(input, mode) {\n        LexerATNSimulator.match_calls++;\n        this.mode = mode;\n        let mark = input.mark();\n        try {\n            this.startIndex = input.index;\n            this.prevAccept.reset();\n            let s0 = this.atn.modeToDFA[mode].s0;\n            if (s0 == null) {\n                return this.matchATN(input);\n            }\n            else {\n                return this.execATN(input, s0);\n            }\n        }\n        finally {\n            input.release(mark);\n        }\n    }\n    reset() {\n        this.prevAccept.reset();\n        this.startIndex = -1;\n        this._line = 1;\n        this._charPositionInLine = 0;\n        this.mode = Lexer_1.Lexer.DEFAULT_MODE;\n    }\n    matchATN(input) {\n        let startState = this.atn.modeToStartState[this.mode];\n        if (LexerATNSimulator.debug) {\n            console.log(`matchATN mode ${this.mode} start: ${startState}`);\n        }\n        let old_mode = this.mode;\n        let s0_closure = this.computeStartState(input, startState);\n        let suppressEdge = s0_closure.hasSemanticContext;\n        if (suppressEdge) {\n            s0_closure.hasSemanticContext = false;\n        }\n        let next = this.addDFAState(s0_closure);\n        if (!suppressEdge) {\n            let dfa = this.atn.modeToDFA[this.mode];\n            if (!dfa.s0) {\n                dfa.s0 = next;\n            }\n            else {\n                next = dfa.s0;\n            }\n        }\n        let predict = this.execATN(input, next);\n        if (LexerATNSimulator.debug) {\n            console.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);\n        }\n        return predict;\n    }\n    execATN(input, ds0) {\n        // console.log(\"enter exec index \"+input.index+\" from \"+ds0.configs);\n        if (LexerATNSimulator.debug) {\n            console.log(`start state closure=${ds0.configs}`);\n        }\n        if (ds0.isAcceptState) {\n            // allow zero-length tokens\n            this.captureSimState(this.prevAccept, input, ds0);\n        }\n        let t = input.LA(1);\n        // @NotNull\n        let s = ds0; // s is current/from DFA state\n        while (true) { // while more work\n            if (LexerATNSimulator.debug) {\n                console.log(`execATN loop starting closure: ${s.configs}`);\n            }\n            // As we move src->trg, src->trg, we keep track of the previous trg to\n            // avoid looking up the DFA state again, which is expensive.\n            // If the previous target was already part of the DFA, we might\n            // be able to avoid doing a reach operation upon t. If s!=null,\n            // it means that semantic predicates didn't prevent us from\n            // creating a DFA state. Once we know s!=null, we check to see if\n            // the DFA state has an edge already for t. If so, we can just reuse\n            // it's configuration set; there's no point in re-computing it.\n            // This is kind of like doing DFA simulation within the ATN\n            // simulation because DFA simulation is really just a way to avoid\n            // computing reach/closure sets. Technically, once we know that\n            // we have a previously added DFA state, we could jump over to\n            // the DFA simulator. But, that would mean popping back and forth\n            // a lot and making things more complicated algorithmically.\n            // This optimization makes a lot of sense for loops within DFA.\n            // A character will take us back to an existing DFA state\n            // that already has lots of edges out of it. e.g., .* in comments.\n            let target = this.getExistingTargetState(s, t);\n            if (target == null) {\n                target = this.computeTargetState(input, s, t);\n            }\n            if (target === ATNSimulator_1.ATNSimulator.ERROR) {\n                break;\n            }\n            // If this is a consumable input element, make sure to consume before\n            // capturing the accept state so the input index, line, and char\n            // position accurately reflect the state of the interpreter at the\n            // end of the token.\n            if (t !== IntStream_1.IntStream.EOF) {\n                this.consume(input);\n            }\n            if (target.isAcceptState) {\n                this.captureSimState(this.prevAccept, input, target);\n                if (t === IntStream_1.IntStream.EOF) {\n                    break;\n                }\n            }\n            t = input.LA(1);\n            s = target; // flip; current DFA target becomes new src/from state\n        }\n        return this.failOrAccept(this.prevAccept, input, s.configs, t);\n    }\n    /**\n     * Get an existing target state for an edge in the DFA. If the target state\n     * for the edge has not yet been computed or is otherwise not available,\n     * this method returns `undefined`.\n     *\n     * @param s The current DFA state\n     * @param t The next input symbol\n     * @returns The existing target DFA state for the given input symbol\n     * `t`, or `undefined` if the target state for this edge is not\n     * already cached\n     */\n    getExistingTargetState(s, t) {\n        let target = s.getTarget(t);\n        if (LexerATNSimulator.debug && target != null) {\n            console.log(\"reuse state \" + s.stateNumber +\n                \" edge to \" + target.stateNumber);\n        }\n        return target;\n    }\n    /**\n     * Compute a target state for an edge in the DFA, and attempt to add the\n     * computed state and corresponding edge to the DFA.\n     *\n     * @param input The input stream\n     * @param s The current DFA state\n     * @param t The next input symbol\n     *\n     * @returns The computed target DFA state for the given input symbol\n     * `t`. If `t` does not lead to a valid DFA state, this method\n     * returns {@link #ERROR}.\n     */\n    computeTargetState(input, s, t) {\n        let reach = new OrderedATNConfigSet_1.OrderedATNConfigSet();\n        // if we don't find an existing DFA state\n        // Fill reach starting from closure, following t transitions\n        this.getReachableConfigSet(input, s.configs, reach, t);\n        if (reach.isEmpty) { // we got nowhere on t from s\n            if (!reach.hasSemanticContext) {\n                // we got nowhere on t, don't throw out this knowledge; it'd\n                // cause a failover from DFA later.\n                this.addDFAEdge(s, t, ATNSimulator_1.ATNSimulator.ERROR);\n            }\n            // stop when we can't match any more char\n            return ATNSimulator_1.ATNSimulator.ERROR;\n        }\n        // Add an edge from s to target DFA found/created for reach\n        return this.addDFAEdge(s, t, reach);\n    }\n    failOrAccept(prevAccept, input, reach, t) {\n        if (prevAccept.dfaState != null) {\n            let lexerActionExecutor = prevAccept.dfaState.lexerActionExecutor;\n            this.accept(input, lexerActionExecutor, this.startIndex, prevAccept.index, prevAccept.line, prevAccept.charPos);\n            return prevAccept.dfaState.prediction;\n        }\n        else {\n            // if no accept and EOF is first char, return EOF\n            if (t === IntStream_1.IntStream.EOF && input.index === this.startIndex) {\n                return Token_1.Token.EOF;\n            }\n            throw new LexerNoViableAltException_1.LexerNoViableAltException(this.recog, input, this.startIndex, reach);\n        }\n    }\n    /** Given a starting configuration set, figure out all ATN configurations\n     *  we can reach upon input `t`. Parameter `reach` is a return\n     *  parameter.\n     */\n    getReachableConfigSet(input, closure, reach, t) {\n        // this is used to skip processing for configs which have a lower priority\n        // than a config that already reached an accept state for the same rule\n        let skipAlt = ATN_1.ATN.INVALID_ALT_NUMBER;\n        for (let c of closure) {\n            let currentAltReachedAcceptState = c.alt === skipAlt;\n            if (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {\n                continue;\n            }\n            if (LexerATNSimulator.debug) {\n                console.log(`testing ${this.getTokenName(t)} at ${c.toString(this.recog, true)}`);\n            }\n            let n = c.state.numberOfOptimizedTransitions;\n            for (let ti = 0; ti < n; ti++) { // for each optimized transition\n                let trans = c.state.getOptimizedTransition(ti);\n                let target = this.getReachableTarget(trans, t);\n                if (target != null) {\n                    let lexerActionExecutor = c.lexerActionExecutor;\n                    let config;\n                    if (lexerActionExecutor != null) {\n                        lexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n                        config = c.transform(target, true, lexerActionExecutor);\n                    }\n                    else {\n                        assert(c.lexerActionExecutor == null);\n                        config = c.transform(target, true);\n                    }\n                    let treatEofAsEpsilon = t === IntStream_1.IntStream.EOF;\n                    if (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n                        // any remaining configs for this alt have a lower priority than\n                        // the one that just reached an accept state.\n                        skipAlt = c.alt;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    accept(input, lexerActionExecutor, startIndex, index, line, charPos) {\n        if (LexerATNSimulator.debug) {\n            console.log(`ACTION ${lexerActionExecutor}`);\n        }\n        // seek to after last char in token\n        input.seek(index);\n        this._line = line;\n        this._charPositionInLine = charPos;\n        if (lexerActionExecutor != null && this.recog != null) {\n            lexerActionExecutor.execute(this.recog, input, startIndex);\n        }\n    }\n    getReachableTarget(trans, t) {\n        if (trans.matches(t, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {\n            return trans.target;\n        }\n        return undefined;\n    }\n    computeStartState(input, p) {\n        let initialContext = PredictionContext_1.PredictionContext.EMPTY_FULL;\n        let configs = new OrderedATNConfigSet_1.OrderedATNConfigSet();\n        for (let i = 0; i < p.numberOfTransitions; i++) {\n            let target = p.transition(i).target;\n            let c = ATNConfig_1.ATNConfig.create(target, i + 1, initialContext);\n            this.closure(input, c, configs, false, false, false);\n        }\n        return configs;\n    }\n    /**\n     * Since the alternatives within any lexer decision are ordered by\n     * preference, this method stops pursuing the closure as soon as an accept\n     * state is reached. After the first accept state is reached by depth-first\n     * search from `config`, all other (potentially reachable) states for\n     * this rule would have a lower priority.\n     *\n     * @returns `true` if an accept state is reached, otherwise\n     * `false`.\n     */\n    closure(input, config, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon) {\n        if (LexerATNSimulator.debug) {\n            console.log(\"closure(\" + config.toString(this.recog, true) + \")\");\n        }\n        if (config.state instanceof RuleStopState_1.RuleStopState) {\n            if (LexerATNSimulator.debug) {\n                if (this.recog != null) {\n                    console.log(`closure at ${this.recog.ruleNames[config.state.ruleIndex]} rule stop ${config}`);\n                }\n                else {\n                    console.log(`closure at rule stop ${config}`);\n                }\n            }\n            let context = config.context;\n            if (context.isEmpty) {\n                configs.add(config);\n                return true;\n            }\n            else if (context.hasEmpty) {\n                configs.add(config.transform(config.state, true, PredictionContext_1.PredictionContext.EMPTY_FULL));\n                currentAltReachedAcceptState = true;\n            }\n            for (let i = 0; i < context.size; i++) {\n                let returnStateNumber = context.getReturnState(i);\n                if (returnStateNumber === PredictionContext_1.PredictionContext.EMPTY_FULL_STATE_KEY) {\n                    continue;\n                }\n                let newContext = context.getParent(i); // \"pop\" return state\n                let returnState = this.atn.states[returnStateNumber];\n                let c = config.transform(returnState, false, newContext);\n                currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n            }\n            return currentAltReachedAcceptState;\n        }\n        // optimization\n        if (!config.state.onlyHasEpsilonTransitions) {\n            if (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision) {\n                configs.add(config);\n            }\n        }\n        let p = config.state;\n        for (let i = 0; i < p.numberOfOptimizedTransitions; i++) {\n            let t = p.getOptimizedTransition(i);\n            let c = this.getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon);\n            if (c != null) {\n                currentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n            }\n        }\n        return currentAltReachedAcceptState;\n    }\n    // side-effect: can alter configs.hasSemanticContext\n    getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon) {\n        let c;\n        switch (t.serializationType) {\n            case 3 /* RULE */:\n                let ruleTransition = t;\n                if (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config.context.hasEmpty) {\n                    c = config.transform(t.target, true);\n                }\n                else {\n                    let newContext = config.context.getChild(ruleTransition.followState.stateNumber);\n                    c = config.transform(t.target, true, newContext);\n                }\n                break;\n            case 10 /* PRECEDENCE */:\n                throw new Error(\"Precedence predicates are not supported in lexers.\");\n            case 4 /* PREDICATE */:\n                /*  Track traversing semantic predicates. If we traverse,\n                    we cannot add a DFA state for this \"reach\" computation\n                    because the DFA would not test the predicate again in the\n                    future. Rather than creating collections of semantic predicates\n                    like v3 and testing them on prediction, v4 will test them on the\n                    fly all the time using the ATN not the DFA. This is slower but\n                    semantically it's not used that often. One of the key elements to\n                    this predicate mechanism is not adding DFA states that see\n                    predicates immediately afterwards in the ATN. For example,\n    \n                    a : ID {p1}? | ID {p2}? ;\n    \n                    should create the start state for rule 'a' (to save start state\n                    competition), but should not create target of ID state. The\n                    collection of ATN states the following ID references includes\n                    states reached by traversing predicates. Since this is when we\n                    test them, we cannot cash the DFA state target of ID.\n                */\n                let pt = t;\n                if (LexerATNSimulator.debug) {\n                    console.log(\"EVAL rule \" + pt.ruleIndex + \":\" + pt.predIndex);\n                }\n                configs.hasSemanticContext = true;\n                if (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {\n                    c = config.transform(t.target, true);\n                }\n                else {\n                    c = undefined;\n                }\n                break;\n            case 6 /* ACTION */:\n                if (config.context.hasEmpty) {\n                    // execute actions anywhere in the start rule for a token.\n                    //\n                    // TODO: if the entry rule is invoked recursively, some\n                    // actions may be executed during the recursive call. The\n                    // problem can appear when hasEmpty is true but\n                    // isEmpty is false. In this case, the config needs to be\n                    // split into two contexts - one with just the empty path\n                    // and another with everything but the empty path.\n                    // Unfortunately, the current algorithm does not allow\n                    // getEpsilonTarget to return two configurations, so\n                    // additional modifications are needed before we can support\n                    // the split operation.\n                    let lexerActionExecutor = LexerActionExecutor_1.LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[t.actionIndex]);\n                    c = config.transform(t.target, true, lexerActionExecutor);\n                    break;\n                }\n                else {\n                    // ignore actions in referenced rules\n                    c = config.transform(t.target, true);\n                    break;\n                }\n            case 1 /* EPSILON */:\n                c = config.transform(t.target, true);\n                break;\n            case 5 /* ATOM */:\n            case 2 /* RANGE */:\n            case 7 /* SET */:\n                if (treatEofAsEpsilon) {\n                    if (t.matches(IntStream_1.IntStream.EOF, Lexer_1.Lexer.MIN_CHAR_VALUE, Lexer_1.Lexer.MAX_CHAR_VALUE)) {\n                        c = config.transform(t.target, false);\n                        break;\n                    }\n                }\n                c = undefined;\n                break;\n            default:\n                c = undefined;\n                break;\n        }\n        return c;\n    }\n    /**\n     * Evaluate a predicate specified in the lexer.\n     *\n     * If `speculative` is `true`, this method was called before\n     * {@link #consume} for the matched character. This method should call\n     * {@link #consume} before evaluating the predicate to ensure position\n     * sensitive values, including {@link Lexer#getText}, {@link Lexer#getLine},\n     * and {@link Lexer#getCharPositionInLine}, properly reflect the current\n     * lexer state. This method should restore `input` and the simulator\n     * to the original state before returning (i.e. undo the actions made by the\n     * call to {@link #consume}.\n     *\n     * @param input The input stream.\n     * @param ruleIndex The rule containing the predicate.\n     * @param predIndex The index of the predicate within the rule.\n     * @param speculative `true` if the current index in `input` is\n     * one character before the predicate's location.\n     *\n     * @returns `true` if the specified predicate evaluates to\n     * `true`.\n     */\n    evaluatePredicate(input, ruleIndex, predIndex, speculative) {\n        // assume true if no recognizer was provided\n        if (this.recog == null) {\n            return true;\n        }\n        if (!speculative) {\n            return this.recog.sempred(undefined, ruleIndex, predIndex);\n        }\n        let savedCharPositionInLine = this._charPositionInLine;\n        let savedLine = this._line;\n        let index = input.index;\n        let marker = input.mark();\n        try {\n            this.consume(input);\n            return this.recog.sempred(undefined, ruleIndex, predIndex);\n        }\n        finally {\n            this._charPositionInLine = savedCharPositionInLine;\n            this._line = savedLine;\n            input.seek(index);\n            input.release(marker);\n        }\n    }\n    captureSimState(settings, input, dfaState) {\n        settings.index = input.index;\n        settings.line = this._line;\n        settings.charPos = this._charPositionInLine;\n        settings.dfaState = dfaState;\n    }\n    addDFAEdge(p, t, q) {\n        if (q instanceof ATNConfigSet_1.ATNConfigSet) {\n            /* leading to this call, ATNConfigSet.hasSemanticContext is used as a\n            * marker indicating dynamic predicate evaluation makes this edge\n            * dependent on the specific input sequence, so the static edge in the\n            * DFA should be omitted. The target DFAState is still created since\n            * execATN has the ability to resynchronize with the DFA state cache\n            * following the predicate evaluation step.\n            *\n            * TJP notes: next time through the DFA, we see a pred again and eval.\n            * If that gets us to a previously created (but dangling) DFA\n            * state, we can continue in pure DFA mode from there.\n            */\n            let suppressEdge = q.hasSemanticContext;\n            if (suppressEdge) {\n                q.hasSemanticContext = false;\n            }\n            // @NotNull\n            let to = this.addDFAState(q);\n            if (suppressEdge) {\n                return to;\n            }\n            this.addDFAEdge(p, t, to);\n            return to;\n        }\n        else {\n            if (LexerATNSimulator.debug) {\n                console.log(\"EDGE \" + p + \" -> \" + q + \" upon \" + String.fromCharCode(t));\n            }\n            if (p != null) {\n                p.setTarget(t, q);\n            }\n        }\n    }\n    /** Add a new DFA state if there isn't one with this set of\n     * \tconfigurations already. This method also detects the first\n     * \tconfiguration containing an ATN rule stop state. Later, when\n     * \ttraversing the DFA, we will know which rule to accept.\n     */\n    addDFAState(configs) {\n        /* the lexer evaluates predicates on-the-fly; by this point configs\n         * should not contain any configurations with unevaluated predicates.\n         */\n        assert(!configs.hasSemanticContext);\n        let proposed = new DFAState_1.DFAState(configs);\n        let existing = this.atn.modeToDFA[this.mode].states.get(proposed);\n        if (existing != null) {\n            return existing;\n        }\n        configs.optimizeConfigs(this);\n        let newState = new DFAState_1.DFAState(configs.clone(true));\n        let firstConfigWithRuleStopState;\n        for (let c of configs) {\n            if (c.state instanceof RuleStopState_1.RuleStopState) {\n                firstConfigWithRuleStopState = c;\n                break;\n            }\n        }\n        if (firstConfigWithRuleStopState != null) {\n            let prediction = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n            let lexerActionExecutor = firstConfigWithRuleStopState.lexerActionExecutor;\n            newState.acceptStateInfo = new AcceptStateInfo_1.AcceptStateInfo(prediction, lexerActionExecutor);\n        }\n        return this.atn.modeToDFA[this.mode].addState(newState);\n    }\n    getDFA(mode) {\n        return this.atn.modeToDFA[mode];\n    }\n    /** Get the text matched so far for the current token.\n     */\n    getText(input) {\n        // index is first lookahead char, don't include.\n        return input.getText(Interval_1.Interval.of(this.startIndex, input.index - 1));\n    }\n    get line() {\n        return this._line;\n    }\n    set line(line) {\n        this._line = line;\n    }\n    get charPositionInLine() {\n        return this._charPositionInLine;\n    }\n    set charPositionInLine(charPositionInLine) {\n        this._charPositionInLine = charPositionInLine;\n    }\n    consume(input) {\n        let curChar = input.LA(1);\n        if (curChar === \"\\n\".charCodeAt(0)) {\n            this._line++;\n            this._charPositionInLine = 0;\n        }\n        else {\n            this._charPositionInLine++;\n        }\n        input.consume();\n    }\n    getTokenName(t) {\n        if (t === -1) {\n            return \"EOF\";\n        }\n        //if ( atn.g!=null ) return atn.g.getTokenDisplayName(t);\n        return \"'\" + String.fromCharCode(t) + \"'\";\n    }\n};\nLexerATNSimulator.match_calls = 0;\n__decorate([\n    Decorators_1.NotNull\n], LexerATNSimulator.prototype, \"prevAccept\", void 0);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"copyState\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"match\", null);\n__decorate([\n    Decorators_1.Override\n], LexerATNSimulator.prototype, \"reset\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"matchATN\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"execATN\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"getExistingTargetState\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"computeTargetState\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"getReachableConfigSet\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"accept\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"computeStartState\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull), __param(1, Decorators_1.NotNull), __param(2, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"closure\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull),\n    __param(3, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"getEpsilonTarget\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"evaluatePredicate\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(2, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"captureSimState\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"addDFAState\", null);\n__decorate([\n    Decorators_1.NotNull\n], LexerATNSimulator.prototype, \"getDFA\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(0, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"getText\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], LexerATNSimulator.prototype, \"consume\", null);\n__decorate([\n    Decorators_1.NotNull\n], LexerATNSimulator.prototype, \"getTokenName\", null);\nLexerATNSimulator = __decorate([\n    __param(0, Decorators_1.NotNull)\n], LexerATNSimulator);\nexports.LexerATNSimulator = LexerATNSimulator;\n(function (LexerATNSimulator) {\n    LexerATNSimulator.debug = false;\n    LexerATNSimulator.dfa_debug = false;\n    /** When we hit an accept state in either the DFA or the ATN, we\n     *  have to notify the character stream to start buffering characters\n     *  via {@link IntStream#mark} and record the current state. The current sim state\n     *  includes the current index into the input, the current line,\n     *  and current character position in that line. Note that the Lexer is\n     *  tracking the starting line and characterization of the token. These\n     *  variables track the \"state\" of the simulator when it hits an accept state.\n     *\n     *  We track these variables separately for the DFA and ATN simulation\n     *  because the DFA simulation often has to fail over to the ATN\n     *  simulation. If the ATN simulation fails, we need the DFA to fall\n     *  back to its previously accepted state, if any. If the ATN succeeds,\n     *  then the ATN does the accept and the DFA simulator that invoked it\n     *  can simply return the predicted token type.\n     */\n    class SimState {\n        constructor() {\n            this.index = -1;\n            this.line = 0;\n            this.charPos = -1;\n        }\n        reset() {\n            this.index = -1;\n            this.line = 0;\n            this.charPos = -1;\n            this.dfaState = undefined;\n        }\n    }\n    LexerATNSimulator.SimState = SimState;\n})(LexerATNSimulator = exports.LexerATNSimulator || (exports.LexerATNSimulator = {}));\nexports.LexerATNSimulator = LexerATNSimulator;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:29.1083066-07:00\n\nimport { AcceptStateInfo } from \"../dfa/AcceptStateInfo\";\nimport { ActionTransition } from \"./ActionTransition\";\nimport { ATN } from \"./ATN\";\nimport { ATNConfig } from \"./ATNConfig\";\nimport { ATNConfigSet } from \"./ATNConfigSet\";\nimport { ATNSimulator } from \"./ATNSimulator\";\nimport { ATNState } from \"./ATNState\";\nimport { CharStream } from \"../CharStream\";\nimport { DFA } from \"../dfa/DFA\";\nimport { DFAState } from \"../dfa/DFAState\";\nimport { Interval } from \"../misc/Interval\";\nimport { IntStream } from \"../IntStream\";\nimport { Lexer } from \"../Lexer\";\nimport { LexerActionExecutor } from \"./LexerActionExecutor\";\nimport { LexerNoViableAltException } from \"../LexerNoViableAltException\";\nimport { NotNull, Override } from \"../Decorators\";\nimport { OrderedATNConfigSet } from \"./OrderedATNConfigSet\";\nimport { PredictionContext } from \"./PredictionContext\";\nimport { PredicateTransition } from \"./PredicateTransition\";\nimport { RuleStopState } from \"./RuleStopState\";\nimport { RuleTransition } from \"./RuleTransition\";\nimport { Token } from \"../Token\";\nimport { Transition } from \"./Transition\";\nimport { TransitionType } from \"./TransitionType\";\nimport * as assert from \"assert\";\n\n/** \"dup\" of ParserInterpreter */\nexport class LexerATNSimulator extends ATNSimulator {\n\tpublic optimize_tail_calls: boolean = true;\n\n\tprotected recog: Lexer | undefined;\n\n\t/** The current token's starting index into the character stream.\n\t *  Shared across DFA to ATN simulation in case the ATN fails and the\n\t *  DFA did not have a previous accept state. In this case, we use the\n\t *  ATN-generated exception object.\n\t */\n\tprotected startIndex: number = -1;\n\n\t/** line number 1..n within the input */\n\tprivate _line: number = 1;\n\n\t/** The index of the character relative to the beginning of the line 0..n-1 */\n\tprivate _charPositionInLine: number = 0;\n\n\tprotected mode: number = Lexer.DEFAULT_MODE;\n\n\t/** Used during DFA/ATN exec to record the most recent accept configuration info */\n\t@NotNull\n\tprotected prevAccept: LexerATNSimulator.SimState = new LexerATNSimulator.SimState();\n\n\tpublic static match_calls: number = 0;\n\n\tconstructor(/*@NotNull*/ atn: ATN);\n\tconstructor(/*@NotNull*/ atn: ATN, recog: Lexer | undefined);\n\tconstructor(@NotNull atn: ATN, recog?: Lexer) {\n\t\tsuper(atn);\n\t\tthis.recog = recog;\n\t}\n\n\tpublic copyState(@NotNull simulator: LexerATNSimulator): void {\n\t\tthis._charPositionInLine = simulator.charPositionInLine;\n\t\tthis._line = simulator._line;\n\t\tthis.mode = simulator.mode;\n\t\tthis.startIndex = simulator.startIndex;\n\t}\n\n\tpublic match(@NotNull input: CharStream, mode: number): number {\n\t\tLexerATNSimulator.match_calls++;\n\t\tthis.mode = mode;\n\t\tlet mark: number = input.mark();\n\t\ttry {\n\t\t\tthis.startIndex = input.index;\n\t\t\tthis.prevAccept.reset();\n\t\t\tlet s0: DFAState | undefined = this.atn.modeToDFA[mode].s0;\n\t\t\tif (s0 == null) {\n\t\t\t\treturn this.matchATN(input);\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn this.execATN(input, s0);\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tinput.release(mark);\n\t\t}\n\t}\n\n\t@Override\n\tpublic reset(): void {\n\t\tthis.prevAccept.reset();\n\t\tthis.startIndex = -1;\n\t\tthis._line = 1;\n\t\tthis._charPositionInLine = 0;\n\t\tthis.mode = Lexer.DEFAULT_MODE;\n\t}\n\n\tprotected matchATN(@NotNull input: CharStream): number {\n\t\tlet startState: ATNState = this.atn.modeToStartState[this.mode];\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(`matchATN mode ${this.mode} start: ${startState}`);\n\t\t}\n\n\t\tlet old_mode: number = this.mode;\n\n\t\tlet s0_closure: ATNConfigSet = this.computeStartState(input, startState);\n\t\tlet suppressEdge: boolean = s0_closure.hasSemanticContext;\n\t\tif (suppressEdge) {\n\t\t\ts0_closure.hasSemanticContext = false;\n\t\t}\n\n\t\tlet next: DFAState = this.addDFAState(s0_closure);\n\t\tif (!suppressEdge) {\n\t\t\tlet dfa = this.atn.modeToDFA[this.mode];\n\t\t\tif (!dfa.s0) {\n\t\t\t\tdfa.s0 = next;\n\t\t\t} else {\n\t\t\t\tnext = dfa.s0;\n\t\t\t}\n\t\t}\n\n\t\tlet predict: number = this.execATN(input, next);\n\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(`DFA after matchATN: ${this.atn.modeToDFA[old_mode].toLexerString()}`);\n\t\t}\n\n\t\treturn predict;\n\t}\n\n\tprotected execATN(@NotNull input: CharStream, @NotNull ds0: DFAState): number {\n\t\t// console.log(\"enter exec index \"+input.index+\" from \"+ds0.configs);\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(`start state closure=${ds0.configs}`);\n\t\t}\n\n\t\tif (ds0.isAcceptState) {\n\t\t\t// allow zero-length tokens\n\t\t\tthis.captureSimState(this.prevAccept, input, ds0);\n\t\t}\n\n\t\tlet t: number = input.LA(1);\n\t\t// @NotNull\n\t\tlet s: DFAState = ds0; // s is current/from DFA state\n\n\t\twhile (true) { // while more work\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(`execATN loop starting closure: ${s.configs}`);\n\t\t\t}\n\n\t\t\t// As we move src->trg, src->trg, we keep track of the previous trg to\n\t\t\t// avoid looking up the DFA state again, which is expensive.\n\t\t\t// If the previous target was already part of the DFA, we might\n\t\t\t// be able to avoid doing a reach operation upon t. If s!=null,\n\t\t\t// it means that semantic predicates didn't prevent us from\n\t\t\t// creating a DFA state. Once we know s!=null, we check to see if\n\t\t\t// the DFA state has an edge already for t. If so, we can just reuse\n\t\t\t// it's configuration set; there's no point in re-computing it.\n\t\t\t// This is kind of like doing DFA simulation within the ATN\n\t\t\t// simulation because DFA simulation is really just a way to avoid\n\t\t\t// computing reach/closure sets. Technically, once we know that\n\t\t\t// we have a previously added DFA state, we could jump over to\n\t\t\t// the DFA simulator. But, that would mean popping back and forth\n\t\t\t// a lot and making things more complicated algorithmically.\n\t\t\t// This optimization makes a lot of sense for loops within DFA.\n\t\t\t// A character will take us back to an existing DFA state\n\t\t\t// that already has lots of edges out of it. e.g., .* in comments.\n\t\t\tlet target: DFAState | undefined = this.getExistingTargetState(s, t);\n\t\t\tif (target == null) {\n\t\t\t\ttarget = this.computeTargetState(input, s, t);\n\t\t\t}\n\n\t\t\tif (target === ATNSimulator.ERROR) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// If this is a consumable input element, make sure to consume before\n\t\t\t// capturing the accept state so the input index, line, and char\n\t\t\t// position accurately reflect the state of the interpreter at the\n\t\t\t// end of the token.\n\t\t\tif (t !== IntStream.EOF) {\n\t\t\t\tthis.consume(input);\n\t\t\t}\n\n\t\t\tif (target.isAcceptState) {\n\t\t\t\tthis.captureSimState(this.prevAccept, input, target);\n\t\t\t\tif (t === IntStream.EOF) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tt = input.LA(1);\n\t\t\ts = target; // flip; current DFA target becomes new src/from state\n\t\t}\n\n\t\treturn this.failOrAccept(this.prevAccept, input, s.configs, t);\n\t}\n\n\t/**\n\t * Get an existing target state for an edge in the DFA. If the target state\n\t * for the edge has not yet been computed or is otherwise not available,\n\t * this method returns `undefined`.\n\t *\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t * @returns The existing target DFA state for the given input symbol\n\t * `t`, or `undefined` if the target state for this edge is not\n\t * already cached\n\t */\n\tprotected getExistingTargetState(@NotNull s: DFAState, t: number): DFAState | undefined {\n\t\tlet target: DFAState | undefined = s.getTarget(t);\n\t\tif (LexerATNSimulator.debug && target != null) {\n\t\t\tconsole.log(\"reuse state \" + s.stateNumber +\n\t\t\t\t\" edge to \" + target.stateNumber);\n\t\t}\n\n\t\treturn target;\n\t}\n\n\t/**\n\t * Compute a target state for an edge in the DFA, and attempt to add the\n\t * computed state and corresponding edge to the DFA.\n\t *\n\t * @param input The input stream\n\t * @param s The current DFA state\n\t * @param t The next input symbol\n\t *\n\t * @returns The computed target DFA state for the given input symbol\n\t * `t`. If `t` does not lead to a valid DFA state, this method\n\t * returns {@link #ERROR}.\n\t */\n\t@NotNull\n\tprotected computeTargetState(@NotNull input: CharStream, @NotNull s: DFAState, t: number): DFAState {\n\t\tlet reach: ATNConfigSet = new OrderedATNConfigSet();\n\n\t\t// if we don't find an existing DFA state\n\t\t// Fill reach starting from closure, following t transitions\n\t\tthis.getReachableConfigSet(input, s.configs, reach, t);\n\n\t\tif (reach.isEmpty) { // we got nowhere on t from s\n\t\t\tif (!reach.hasSemanticContext) {\n\t\t\t\t// we got nowhere on t, don't throw out this knowledge; it'd\n\t\t\t\t// cause a failover from DFA later.\n\t\t\t\tthis.addDFAEdge(s, t, ATNSimulator.ERROR);\n\t\t\t}\n\n\t\t\t// stop when we can't match any more char\n\t\t\treturn ATNSimulator.ERROR;\n\t\t}\n\n\t\t// Add an edge from s to target DFA found/created for reach\n\t\treturn this.addDFAEdge(s, t, reach);\n\t}\n\n\tprotected failOrAccept(\n\t\tprevAccept: LexerATNSimulator.SimState, input: CharStream,\n\t\treach: ATNConfigSet, t: number): number {\n\t\tif (prevAccept.dfaState != null) {\n\t\t\tlet lexerActionExecutor: LexerActionExecutor | undefined = prevAccept.dfaState.lexerActionExecutor;\n\t\t\tthis.accept(input, lexerActionExecutor, this.startIndex,\n\t\t\t\tprevAccept.index, prevAccept.line, prevAccept.charPos);\n\t\t\treturn prevAccept.dfaState.prediction;\n\t\t}\n\t\telse {\n\t\t\t// if no accept and EOF is first char, return EOF\n\t\t\tif (t === IntStream.EOF && input.index === this.startIndex) {\n\t\t\t\treturn Token.EOF;\n\t\t\t}\n\n\t\t\tthrow new LexerNoViableAltException(this.recog, input, this.startIndex, reach);\n\t\t}\n\t}\n\n\t/** Given a starting configuration set, figure out all ATN configurations\n\t *  we can reach upon input `t`. Parameter `reach` is a return\n\t *  parameter.\n\t */\n\tprotected getReachableConfigSet(@NotNull input: CharStream, @NotNull closure: ATNConfigSet, @NotNull reach: ATNConfigSet, t: number): void {\n\t\t// this is used to skip processing for configs which have a lower priority\n\t\t// than a config that already reached an accept state for the same rule\n\t\tlet skipAlt: number = ATN.INVALID_ALT_NUMBER;\n\t\tfor (let c of closure) {\n\t\t\tlet currentAltReachedAcceptState: boolean = c.alt === skipAlt;\n\t\t\tif (currentAltReachedAcceptState && c.hasPassedThroughNonGreedyDecision) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(`testing ${this.getTokenName(t)} at ${c.toString(this.recog, true)}`);\n\t\t\t}\n\n\t\t\tlet n: number = c.state.numberOfOptimizedTransitions;\n\t\t\tfor (let ti = 0; ti < n; ti++) {               // for each optimized transition\n\t\t\t\tlet trans: Transition = c.state.getOptimizedTransition(ti);\n\t\t\t\tlet target: ATNState | undefined = this.getReachableTarget(trans, t);\n\t\t\t\tif (target != null) {\n\t\t\t\t\tlet lexerActionExecutor: LexerActionExecutor | undefined = c.lexerActionExecutor;\n\t\t\t\t\tlet config: ATNConfig;\n\t\t\t\t\tif (lexerActionExecutor != null) {\n\t\t\t\t\t\tlexerActionExecutor = lexerActionExecutor.fixOffsetBeforeMatch(input.index - this.startIndex);\n\t\t\t\t\t\tconfig = c.transform(target, true, lexerActionExecutor);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(c.lexerActionExecutor == null);\n\t\t\t\t\t\tconfig = c.transform(target, true);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet treatEofAsEpsilon: boolean = t === IntStream.EOF;\n\t\t\t\t\tif (this.closure(input, config, reach, currentAltReachedAcceptState, true, treatEofAsEpsilon)) {\n\t\t\t\t\t\t// any remaining configs for this alt have a lower priority than\n\t\t\t\t\t\t// the one that just reached an accept state.\n\t\t\t\t\t\tskipAlt = c.alt;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprotected accept(\n\t\t@NotNull input: CharStream, lexerActionExecutor: LexerActionExecutor | undefined,\n\t\tstartIndex: number, index: number, line: number, charPos: number): void {\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(`ACTION ${lexerActionExecutor}`);\n\t\t}\n\n\t\t// seek to after last char in token\n\t\tinput.seek(index);\n\t\tthis._line = line;\n\t\tthis._charPositionInLine = charPos;\n\n\t\tif (lexerActionExecutor != null && this.recog != null) {\n\t\t\tlexerActionExecutor.execute(this.recog, input, startIndex);\n\t\t}\n\t}\n\n\tprotected getReachableTarget(trans: Transition, t: number): ATNState | undefined {\n\t\tif (trans.matches(t, Lexer.MIN_CHAR_VALUE, Lexer.MAX_CHAR_VALUE)) {\n\t\t\treturn trans.target;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\t@NotNull\n\tprotected computeStartState(\n\t\t@NotNull input: CharStream,\n\t\t@NotNull p: ATNState): ATNConfigSet {\n\t\tlet initialContext: PredictionContext = PredictionContext.EMPTY_FULL;\n\t\tlet configs: ATNConfigSet = new OrderedATNConfigSet();\n\t\tfor (let i = 0; i < p.numberOfTransitions; i++) {\n\t\t\tlet target: ATNState = p.transition(i).target;\n\t\t\tlet c: ATNConfig = ATNConfig.create(target, i + 1, initialContext);\n\t\t\tthis.closure(input, c, configs, false, false, false);\n\t\t}\n\t\treturn configs;\n\t}\n\n\t/**\n\t * Since the alternatives within any lexer decision are ordered by\n\t * preference, this method stops pursuing the closure as soon as an accept\n\t * state is reached. After the first accept state is reached by depth-first\n\t * search from `config`, all other (potentially reachable) states for\n\t * this rule would have a lower priority.\n\t *\n\t * @returns `true` if an accept state is reached, otherwise\n\t * `false`.\n\t */\n\tprotected closure(@NotNull input: CharStream, @NotNull config: ATNConfig, @NotNull configs: ATNConfigSet, currentAltReachedAcceptState: boolean, speculative: boolean, treatEofAsEpsilon: boolean): boolean {\n\t\tif (LexerATNSimulator.debug) {\n\t\t\tconsole.log(\"closure(\" + config.toString(this.recog, true) + \")\");\n\t\t}\n\n\t\tif (config.state instanceof RuleStopState) {\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tif (this.recog != null) {\n\t\t\t\t\tconsole.log(`closure at ${this.recog.ruleNames[config.state.ruleIndex]} rule stop ${config}`);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconsole.log(`closure at rule stop ${config}`);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet context: PredictionContext = config.context;\n\t\t\tif (context.isEmpty) {\n\t\t\t\tconfigs.add(config);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (context.hasEmpty) {\n\t\t\t\tconfigs.add(config.transform(config.state, true, PredictionContext.EMPTY_FULL));\n\t\t\t\tcurrentAltReachedAcceptState = true;\n\t\t\t}\n\n\t\t\tfor (let i = 0; i < context.size; i++) {\n\t\t\t\tlet returnStateNumber: number = context.getReturnState(i);\n\t\t\t\tif (returnStateNumber === PredictionContext.EMPTY_FULL_STATE_KEY) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet newContext: PredictionContext = context.getParent(i); // \"pop\" return state\n\t\t\t\tlet returnState: ATNState = this.atn.states[returnStateNumber];\n\t\t\t\tlet c: ATNConfig = config.transform(returnState, false, newContext);\n\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n\t\t\t}\n\n\t\t\treturn currentAltReachedAcceptState;\n\t\t}\n\n\t\t// optimization\n\t\tif (!config.state.onlyHasEpsilonTransitions) {\n\t\t\tif (!currentAltReachedAcceptState || !config.hasPassedThroughNonGreedyDecision) {\n\t\t\t\tconfigs.add(config);\n\t\t\t}\n\t\t}\n\n\t\tlet p: ATNState = config.state;\n\t\tfor (let i = 0; i < p.numberOfOptimizedTransitions; i++) {\n\t\t\tlet t: Transition = p.getOptimizedTransition(i);\n\t\t\tlet c: ATNConfig | undefined = this.getEpsilonTarget(input, config, t, configs, speculative, treatEofAsEpsilon);\n\t\t\tif (c != null) {\n\t\t\t\tcurrentAltReachedAcceptState = this.closure(input, c, configs, currentAltReachedAcceptState, speculative, treatEofAsEpsilon);\n\t\t\t}\n\t\t}\n\n\t\treturn currentAltReachedAcceptState;\n\t}\n\n\t// side-effect: can alter configs.hasSemanticContext\n\tprotected getEpsilonTarget(\n\t\t@NotNull input: CharStream,\n\t\t@NotNull config: ATNConfig,\n\t\t@NotNull t: Transition,\n\t\t@NotNull configs: ATNConfigSet,\n\t\tspeculative: boolean,\n\t\ttreatEofAsEpsilon: boolean): ATNConfig | undefined {\n\t\tlet c: ATNConfig | undefined;\n\n\t\tswitch (t.serializationType) {\n\t\tcase TransitionType.RULE:\n\t\t\tlet ruleTransition: RuleTransition = t as RuleTransition;\n\t\t\tif (this.optimize_tail_calls && ruleTransition.optimizedTailCall && !config.context.hasEmpty) {\n\t\t\t\tc = config.transform(t.target, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlet newContext: PredictionContext = config.context.getChild(ruleTransition.followState.stateNumber);\n\t\t\t\tc = config.transform(t.target, true, newContext);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase TransitionType.PRECEDENCE:\n\t\t\tthrow new Error(\"Precedence predicates are not supported in lexers.\");\n\n\t\tcase TransitionType.PREDICATE:\n\t\t\t/*  Track traversing semantic predicates. If we traverse,\n\t\t\t\twe cannot add a DFA state for this \"reach\" computation\n\t\t\t\tbecause the DFA would not test the predicate again in the\n\t\t\t\tfuture. Rather than creating collections of semantic predicates\n\t\t\t\tlike v3 and testing them on prediction, v4 will test them on the\n\t\t\t\tfly all the time using the ATN not the DFA. This is slower but\n\t\t\t\tsemantically it's not used that often. One of the key elements to\n\t\t\t\tthis predicate mechanism is not adding DFA states that see\n\t\t\t\tpredicates immediately afterwards in the ATN. For example,\n\n\t\t\t\ta : ID {p1}? | ID {p2}? ;\n\n\t\t\t\tshould create the start state for rule 'a' (to save start state\n\t\t\t\tcompetition), but should not create target of ID state. The\n\t\t\t\tcollection of ATN states the following ID references includes\n\t\t\t\tstates reached by traversing predicates. Since this is when we\n\t\t\t\ttest them, we cannot cash the DFA state target of ID.\n\t\t\t*/\n\t\t\tlet pt: PredicateTransition = t as PredicateTransition;\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"EVAL rule \" + pt.ruleIndex + \":\" + pt.predIndex);\n\t\t\t}\n\t\t\tconfigs.hasSemanticContext = true;\n\t\t\tif (this.evaluatePredicate(input, pt.ruleIndex, pt.predIndex, speculative)) {\n\t\t\t\tc = config.transform(t.target, true);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tc = undefined;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase TransitionType.ACTION:\n\t\t\tif (config.context.hasEmpty) {\n\t\t\t\t// execute actions anywhere in the start rule for a token.\n\t\t\t\t//\n\t\t\t\t// TODO: if the entry rule is invoked recursively, some\n\t\t\t\t// actions may be executed during the recursive call. The\n\t\t\t\t// problem can appear when hasEmpty is true but\n\t\t\t\t// isEmpty is false. In this case, the config needs to be\n\t\t\t\t// split into two contexts - one with just the empty path\n\t\t\t\t// and another with everything but the empty path.\n\t\t\t\t// Unfortunately, the current algorithm does not allow\n\t\t\t\t// getEpsilonTarget to return two configurations, so\n\t\t\t\t// additional modifications are needed before we can support\n\t\t\t\t// the split operation.\n\t\t\t\tlet lexerActionExecutor: LexerActionExecutor = LexerActionExecutor.append(config.lexerActionExecutor, this.atn.lexerActions[(t as ActionTransition).actionIndex]);\n\t\t\t\tc = config.transform(t.target, true, lexerActionExecutor);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// ignore actions in referenced rules\n\t\t\t\tc = config.transform(t.target, true);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\tcase TransitionType.EPSILON:\n\t\t\tc = config.transform(t.target, true);\n\t\t\tbreak;\n\n\t\tcase TransitionType.ATOM:\n\t\tcase TransitionType.RANGE:\n\t\tcase TransitionType.SET:\n\t\t\tif (treatEofAsEpsilon) {\n\t\t\t\tif (t.matches(IntStream.EOF, Lexer.MIN_CHAR_VALUE, Lexer.MAX_CHAR_VALUE)) {\n\t\t\t\t\tc = config.transform(t.target, false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tc = undefined;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tc = undefined;\n\t\t\tbreak;\n\t\t}\n\n\t\treturn c;\n\t}\n\n\t/**\n\t * Evaluate a predicate specified in the lexer.\n\t *\n\t * If `speculative` is `true`, this method was called before\n\t * {@link #consume} for the matched character. This method should call\n\t * {@link #consume} before evaluating the predicate to ensure position\n\t * sensitive values, including {@link Lexer#getText}, {@link Lexer#getLine},\n\t * and {@link Lexer#getCharPositionInLine}, properly reflect the current\n\t * lexer state. This method should restore `input` and the simulator\n\t * to the original state before returning (i.e. undo the actions made by the\n\t * call to {@link #consume}.\n\t *\n\t * @param input The input stream.\n\t * @param ruleIndex The rule containing the predicate.\n\t * @param predIndex The index of the predicate within the rule.\n\t * @param speculative `true` if the current index in `input` is\n\t * one character before the predicate's location.\n\t *\n\t * @returns `true` if the specified predicate evaluates to\n\t * `true`.\n\t */\n\tprotected evaluatePredicate(@NotNull input: CharStream, ruleIndex: number, predIndex: number, speculative: boolean): boolean {\n\t\t// assume true if no recognizer was provided\n\t\tif (this.recog == null) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (!speculative) {\n\t\t\treturn this.recog.sempred(undefined, ruleIndex, predIndex);\n\t\t}\n\n\t\tlet savedCharPositionInLine: number = this._charPositionInLine;\n\t\tlet savedLine: number = this._line;\n\t\tlet index: number = input.index;\n\t\tlet marker: number = input.mark();\n\t\ttry {\n\t\t\tthis.consume(input);\n\t\t\treturn this.recog.sempred(undefined, ruleIndex, predIndex);\n\t\t}\n\t\tfinally {\n\t\t\tthis._charPositionInLine = savedCharPositionInLine;\n\t\t\tthis._line = savedLine;\n\t\t\tinput.seek(index);\n\t\t\tinput.release(marker);\n\t\t}\n\t}\n\n\tprotected captureSimState(\n\t\t@NotNull settings: LexerATNSimulator.SimState,\n\t\t@NotNull input: CharStream,\n\t\t@NotNull dfaState: DFAState): void {\n\t\tsettings.index = input.index;\n\t\tsettings.line = this._line;\n\t\tsettings.charPos = this._charPositionInLine;\n\t\tsettings.dfaState = dfaState;\n\t}\n\n\t// @NotNull\n\tprotected addDFAEdge(/*@NotNull*/ p: DFAState, t: number, /*@NotNull*/ q: ATNConfigSet): DFAState;\n\tprotected addDFAEdge(/*@NotNull*/ p: DFAState, t: number, /*@NotNull*/ q: DFAState): void;\n\tprotected addDFAEdge(p: DFAState, t: number, q: ATNConfigSet | DFAState): DFAState | void {\n\t\tif (q instanceof ATNConfigSet) {\n\t\t\t/* leading to this call, ATNConfigSet.hasSemanticContext is used as a\n\t\t\t* marker indicating dynamic predicate evaluation makes this edge\n\t\t\t* dependent on the specific input sequence, so the static edge in the\n\t\t\t* DFA should be omitted. The target DFAState is still created since\n\t\t\t* execATN has the ability to resynchronize with the DFA state cache\n\t\t\t* following the predicate evaluation step.\n\t\t\t*\n\t\t\t* TJP notes: next time through the DFA, we see a pred again and eval.\n\t\t\t* If that gets us to a previously created (but dangling) DFA\n\t\t\t* state, we can continue in pure DFA mode from there.\n\t\t\t*/\n\t\t\tlet suppressEdge: boolean = q.hasSemanticContext;\n\t\t\tif (suppressEdge) {\n\t\t\t\tq.hasSemanticContext = false;\n\t\t\t}\n\n\t\t\t// @NotNull\n\t\t\tlet to: DFAState = this.addDFAState(q);\n\n\t\t\tif (suppressEdge) {\n\t\t\t\treturn to;\n\t\t\t}\n\n\t\t\tthis.addDFAEdge(p, t, to);\n\t\t\treturn to;\n\t\t} else {\n\t\t\tif (LexerATNSimulator.debug) {\n\t\t\t\tconsole.log(\"EDGE \" + p + \" -> \" + q + \" upon \" + String.fromCharCode(t));\n\t\t\t}\n\n\t\t\tif (p != null) {\n\t\t\t\tp.setTarget(t, q);\n\t\t\t}\n\t\t}\n\t}\n\n\t/** Add a new DFA state if there isn't one with this set of\n\t * \tconfigurations already. This method also detects the first\n\t * \tconfiguration containing an ATN rule stop state. Later, when\n\t * \ttraversing the DFA, we will know which rule to accept.\n\t */\n\t@NotNull\n\tprotected addDFAState(@NotNull configs: ATNConfigSet): DFAState {\n\t\t/* the lexer evaluates predicates on-the-fly; by this point configs\n\t\t * should not contain any configurations with unevaluated predicates.\n\t\t */\n\t\tassert(!configs.hasSemanticContext);\n\n\t\tlet proposed: DFAState = new DFAState(configs);\n\t\tlet existing: DFAState | undefined = this.atn.modeToDFA[this.mode].states.get(proposed);\n\t\tif (existing != null) {\n\t\t\treturn existing;\n\t\t}\n\n\t\tconfigs.optimizeConfigs(this);\n\t\tlet newState: DFAState = new DFAState(configs.clone(true));\n\n\t\tlet firstConfigWithRuleStopState: ATNConfig | undefined;\n\t\tfor (let c of configs) {\n\t\t\tif (c.state instanceof RuleStopState) {\n\t\t\t\tfirstConfigWithRuleStopState = c;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (firstConfigWithRuleStopState != null) {\n\t\t\tlet prediction: number = this.atn.ruleToTokenType[firstConfigWithRuleStopState.state.ruleIndex];\n\t\t\tlet lexerActionExecutor: LexerActionExecutor | undefined = firstConfigWithRuleStopState.lexerActionExecutor;\n\t\t\tnewState.acceptStateInfo = new AcceptStateInfo(prediction, lexerActionExecutor);\n\t\t}\n\n\t\treturn this.atn.modeToDFA[this.mode].addState(newState);\n\t}\n\n\t@NotNull\n\tpublic getDFA(mode: number): DFA {\n\t\treturn this.atn.modeToDFA[mode];\n\t}\n\n\t/** Get the text matched so far for the current token.\n\t */\n\t@NotNull\n\tpublic getText(@NotNull input: CharStream): string {\n\t\t// index is first lookahead char, don't include.\n\t\treturn input.getText(Interval.of(this.startIndex, input.index - 1));\n\t}\n\n\tget line(): number {\n\t\treturn this._line;\n\t}\n\n\tset line(line: number) {\n\t\tthis._line = line;\n\t}\n\n\tget charPositionInLine(): number {\n\t\treturn this._charPositionInLine;\n\t}\n\n\tset charPositionInLine(charPositionInLine: number) {\n\t\tthis._charPositionInLine = charPositionInLine;\n\t}\n\n\tpublic consume(@NotNull input: CharStream): void {\n\t\tlet curChar: number = input.LA(1);\n\t\tif (curChar === \"\\n\".charCodeAt(0)) {\n\t\t\tthis._line++;\n\t\t\tthis._charPositionInLine = 0;\n\t\t} else {\n\t\t\tthis._charPositionInLine++;\n\t\t}\n\t\tinput.consume();\n\t}\n\n\t@NotNull\n\tpublic getTokenName(t: number): string {\n\t\tif (t === -1) {\n\t\t\treturn \"EOF\";\n\t\t}\n\t\t//if ( atn.g!=null ) return atn.g.getTokenDisplayName(t);\n\t\treturn \"'\" + String.fromCharCode(t) + \"'\";\n\t}\n}\n\nexport namespace LexerATNSimulator {\n\texport const debug: boolean = false;\n\texport const dfa_debug: boolean = false;\n\n\t/** When we hit an accept state in either the DFA or the ATN, we\n\t *  have to notify the character stream to start buffering characters\n\t *  via {@link IntStream#mark} and record the current state. The current sim state\n\t *  includes the current index into the input, the current line,\n\t *  and current character position in that line. Note that the Lexer is\n\t *  tracking the starting line and characterization of the token. These\n\t *  variables track the \"state\" of the simulator when it hits an accept state.\n\t *\n\t *  We track these variables separately for the DFA and ATN simulation\n\t *  because the DFA simulation often has to fail over to the ATN\n\t *  simulation. If the ATN simulation fails, we need the DFA to fall\n\t *  back to its previously accepted state, if any. If the ATN succeeds,\n\t *  then the ATN does the accept and the DFA simulator that invoked it\n\t *  can simply return the predicted token type.\n\t */\n\texport class SimState {\n\t\tpublic index: number = -1;\n\t\tpublic line: number = 0;\n\t\tpublic charPos: number = -1;\n\t\tpublic dfaState?: DFAState;\n\n\t\tpublic reset(): void {\n\t\t\tthis.index = -1;\n\t\t\tthis.line = 0;\n\t\t\tthis.charPos = -1;\n\t\t\tthis.dfaState = undefined;\n\t\t}\n\t}\n}\n"]}