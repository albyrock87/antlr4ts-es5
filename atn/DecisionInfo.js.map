{"version":3,"sources":["atn/DecisionInfo.js","../src/atn/DecisionInfo.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","Decorators_1","require","DecisionInfo","decision","invocations","timeInPrediction","SLL_TotalLook","SLL_MinLook","SLL_MaxLook","LL_TotalLook","LL_MinLook","LL_MaxLook","contextSensitivities","errors","ambiguities","predicateEvals","SLL_ATNTransitions","SLL_DFATransitions","LL_Fallback","LL_ATNTransitions","LL_DFATransitions","Override","prototype"],"mappings":"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","file":"DecisionInfo.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Decorators_1 = require(\"../Decorators\");\n/**\n * This class contains profiling gathered for a particular decision.\n *\n * Parsing performance in ANTLR 4 is heavily influenced by both static factors\n * (e.g. the form of the rules in the grammar) and dynamic factors (e.g. the\n * choice of input and the state of the DFA cache at the time profiling\n * operations are started). For best results, gather and use aggregate\n * statistics from a large sample of inputs representing the inputs expected in\n * production before using the results to make changes in the grammar.\n *\n * @since 4.3\n */\nclass DecisionInfo {\n    /**\n     * Constructs a new instance of the {@link DecisionInfo} class to contain\n     * statistics for a particular decision.\n     *\n     * @param decision The decision number\n     */\n    constructor(decision) {\n        /**\n         * The total number of times {@link ParserATNSimulator#adaptivePredict} was\n         * invoked for this decision.\n         */\n        this.invocations = 0;\n        /**\n         * The total time spent in {@link ParserATNSimulator#adaptivePredict} for\n         * this decision, in nanoseconds.\n         *\n         * The value of this field contains the sum of differential results obtained\n         * by {@link System#nanoTime()}, and is not adjusted to compensate for JIT\n         * and/or garbage collection overhead. For best accuracy, use a modern JVM\n         * implementation that provides precise results from\n         * {@link System#nanoTime()}, and perform profiling in a separate process\n         * which is warmed up by parsing the input prior to profiling. If desired,\n         * call {@link ATNSimulator#clearDFA} to reset the DFA cache to its initial\n         * state before starting the profiling measurement pass.\n         */\n        this.timeInPrediction = 0;\n        /**\n         * The sum of the lookahead required for SLL prediction for this decision.\n         * Note that SLL prediction is used before LL prediction for performance\n         * reasons even when {@link PredictionMode#LL} or\n         * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.\n         */\n        this.SLL_TotalLook = 0;\n        /**\n         * Gets the minimum lookahead required for any single SLL prediction to\n         * complete for this decision, by reaching a unique prediction, reaching an\n         * SLL conflict state, or encountering a syntax error.\n         */\n        this.SLL_MinLook = 0;\n        /**\n         * Gets the maximum lookahead required for any single SLL prediction to\n         * complete for this decision, by reaching a unique prediction, reaching an\n         * SLL conflict state, or encountering a syntax error.\n         */\n        this.SLL_MaxLook = 0;\n        /**\n         * The sum of the lookahead required for LL prediction for this decision.\n         * Note that LL prediction is only used when SLL prediction reaches a\n         * conflict state.\n         */\n        this.LL_TotalLook = 0;\n        /**\n         * Gets the minimum lookahead required for any single LL prediction to\n         * complete for this decision. An LL prediction completes when the algorithm\n         * reaches a unique prediction, a conflict state (for\n         * {@link PredictionMode#LL}, an ambiguity state (for\n         * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n         */\n        this.LL_MinLook = 0;\n        /**\n         * Gets the maximum lookahead required for any single LL prediction to\n         * complete for this decision. An LL prediction completes when the algorithm\n         * reaches a unique prediction, a conflict state (for\n         * {@link PredictionMode#LL}, an ambiguity state (for\n         * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n         */\n        this.LL_MaxLook = 0;\n        /**\n         * A collection of {@link ContextSensitivityInfo} instances describing the\n         * context sensitivities encountered during LL prediction for this decision.\n         *\n         * @see ContextSensitivityInfo\n         */\n        this.contextSensitivities = [];\n        /**\n         * A collection of {@link ErrorInfo} instances describing the parse errors\n         * identified during calls to {@link ParserATNSimulator#adaptivePredict} for\n         * this decision.\n         *\n         * @see ErrorInfo\n         */\n        this.errors = [];\n        /**\n         * A collection of {@link AmbiguityInfo} instances describing the\n         * ambiguities encountered during LL prediction for this decision.\n         *\n         * @see AmbiguityInfo\n         */\n        this.ambiguities = [];\n        /**\n         * A collection of {@link PredicateEvalInfo} instances describing the\n         * results of evaluating individual predicates during prediction for this\n         * decision.\n         *\n         * @see PredicateEvalInfo\n         */\n        this.predicateEvals = [];\n        /**\n         * The total number of ATN transitions required during SLL prediction for\n         * this decision. An ATN transition is determined by the number of times the\n         * DFA does not contain an edge that is required for prediction, resulting\n         * in on-the-fly computation of that edge.\n         *\n         * If DFA caching of SLL transitions is employed by the implementation, ATN\n         * computation may cache the computed edge for efficient lookup during\n         * future parsing of this decision. Otherwise, the SLL parsing algorithm\n         * will use ATN transitions exclusively.\n         *\n         * @see #SLL_ATNTransitions\n         * @see ParserATNSimulator#computeTargetState\n         * @see LexerATNSimulator#computeTargetState\n         */\n        this.SLL_ATNTransitions = 0;\n        /**\n         * The total number of DFA transitions required during SLL prediction for\n         * this decision.\n         *\n         * If the ATN simulator implementation does not use DFA caching for SLL\n         * transitions, this value will be 0.\n         *\n         * @see ParserATNSimulator#getExistingTargetState\n         * @see LexerATNSimulator#getExistingTargetState\n         */\n        this.SLL_DFATransitions = 0;\n        /**\n         * Gets the total number of times SLL prediction completed in a conflict\n         * state, resulting in fallback to LL prediction.\n         *\n         * Note that this value is not related to whether or not\n         * {@link PredictionMode#SLL} may be used successfully with a particular\n         * grammar. If the ambiguity resolution algorithm applied to the SLL\n         * conflicts for this decision produce the same result as LL prediction for\n         * this decision, {@link PredictionMode#SLL} would produce the same overall\n         * parsing result as {@link PredictionMode#LL}.\n         */\n        this.LL_Fallback = 0;\n        /**\n         * The total number of ATN transitions required during LL prediction for\n         * this decision. An ATN transition is determined by the number of times the\n         * DFA does not contain an edge that is required for prediction, resulting\n         * in on-the-fly computation of that edge.\n         *\n         * If DFA caching of LL transitions is employed by the implementation, ATN\n         * computation may cache the computed edge for efficient lookup during\n         * future parsing of this decision. Otherwise, the LL parsing algorithm will\n         * use ATN transitions exclusively.\n         *\n         * @see #LL_DFATransitions\n         * @see ParserATNSimulator#computeTargetState\n         * @see LexerATNSimulator#computeTargetState\n         */\n        this.LL_ATNTransitions = 0;\n        /**\n         * The total number of DFA transitions required during LL prediction for\n         * this decision.\n         *\n         * If the ATN simulator implementation does not use DFA caching for LL\n         * transitions, this value will be 0.\n         *\n         * @see ParserATNSimulator#getExistingTargetState\n         * @see LexerATNSimulator#getExistingTargetState\n         */\n        this.LL_DFATransitions = 0;\n        this.decision = decision;\n    }\n    toString() {\n        return \"{\" +\n            \"decision=\" + this.decision +\n            \", contextSensitivities=\" + this.contextSensitivities.length +\n            \", errors=\" + this.errors.length +\n            \", ambiguities=\" + this.ambiguities.length +\n            \", SLL_lookahead=\" + this.SLL_TotalLook +\n            \", SLL_ATNTransitions=\" + this.SLL_ATNTransitions +\n            \", SLL_DFATransitions=\" + this.SLL_DFATransitions +\n            \", LL_Fallback=\" + this.LL_Fallback +\n            \", LL_lookahead=\" + this.LL_TotalLook +\n            \", LL_ATNTransitions=\" + this.LL_ATNTransitions +\n            \"}\";\n    }\n}\n__decorate([\n    Decorators_1.Override\n], DecisionInfo.prototype, \"toString\", null);\nexports.DecisionInfo = DecisionInfo;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:28.3330673-07:00\n\nimport { AmbiguityInfo } from \"./AmbiguityInfo\";\nimport { ContextSensitivityInfo } from \"./ContextSensitivityInfo\";\nimport { ErrorInfo } from \"./ErrorInfo\";\nimport { LookaheadEventInfo } from \"./LookaheadEventInfo\";\nimport { Override } from \"../Decorators\";\nimport { PredicateEvalInfo } from \"./PredicateEvalInfo\";\n\n/**\n * This class contains profiling gathered for a particular decision.\n *\n * Parsing performance in ANTLR 4 is heavily influenced by both static factors\n * (e.g. the form of the rules in the grammar) and dynamic factors (e.g. the\n * choice of input and the state of the DFA cache at the time profiling\n * operations are started). For best results, gather and use aggregate\n * statistics from a large sample of inputs representing the inputs expected in\n * production before using the results to make changes in the grammar.\n *\n * @since 4.3\n */\nexport class DecisionInfo {\n\t/**\n\t * The decision number, which is an index into {@link ATN#decisionToState}.\n\t */\n\tpublic decision: number;\n\n\t/**\n\t * The total number of times {@link ParserATNSimulator#adaptivePredict} was\n\t * invoked for this decision.\n\t */\n\tpublic invocations: number = 0;\n\n\t/**\n\t * The total time spent in {@link ParserATNSimulator#adaptivePredict} for\n\t * this decision, in nanoseconds.\n\t *\n\t * The value of this field contains the sum of differential results obtained\n\t * by {@link System#nanoTime()}, and is not adjusted to compensate for JIT\n\t * and/or garbage collection overhead. For best accuracy, use a modern JVM\n\t * implementation that provides precise results from\n\t * {@link System#nanoTime()}, and perform profiling in a separate process\n\t * which is warmed up by parsing the input prior to profiling. If desired,\n\t * call {@link ATNSimulator#clearDFA} to reset the DFA cache to its initial\n\t * state before starting the profiling measurement pass.\n\t */\n\tpublic timeInPrediction: number = 0;\n\n\t/**\n\t * The sum of the lookahead required for SLL prediction for this decision.\n\t * Note that SLL prediction is used before LL prediction for performance\n\t * reasons even when {@link PredictionMode#LL} or\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION} is used.\n\t */\n\tpublic SLL_TotalLook: number = 0;\n\n\t/**\n\t * Gets the minimum lookahead required for any single SLL prediction to\n\t * complete for this decision, by reaching a unique prediction, reaching an\n\t * SLL conflict state, or encountering a syntax error.\n\t */\n\tpublic SLL_MinLook: number = 0;\n\n\t/**\n\t * Gets the maximum lookahead required for any single SLL prediction to\n\t * complete for this decision, by reaching a unique prediction, reaching an\n\t * SLL conflict state, or encountering a syntax error.\n\t */\n\tpublic SLL_MaxLook: number = 0;\n\n\t/**\n\t * Gets the {@link LookaheadEventInfo} associated with the event where the\n\t * {@link #SLL_MaxLook} value was set.\n\t */\n\tpublic SLL_MaxLookEvent?: LookaheadEventInfo;\n\n\t/**\n\t * The sum of the lookahead required for LL prediction for this decision.\n\t * Note that LL prediction is only used when SLL prediction reaches a\n\t * conflict state.\n\t */\n\tpublic LL_TotalLook: number = 0;\n\n\t/**\n\t * Gets the minimum lookahead required for any single LL prediction to\n\t * complete for this decision. An LL prediction completes when the algorithm\n\t * reaches a unique prediction, a conflict state (for\n\t * {@link PredictionMode#LL}, an ambiguity state (for\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n\t */\n\tpublic LL_MinLook: number = 0;\n\n\t/**\n\t * Gets the maximum lookahead required for any single LL prediction to\n\t * complete for this decision. An LL prediction completes when the algorithm\n\t * reaches a unique prediction, a conflict state (for\n\t * {@link PredictionMode#LL}, an ambiguity state (for\n\t * {@link PredictionMode#LL_EXACT_AMBIG_DETECTION}, or a syntax error.\n\t */\n\tpublic LL_MaxLook: number = 0;\n\n\t/**\n\t * Gets the {@link LookaheadEventInfo} associated with the event where the\n\t * {@link #LL_MaxLook} value was set.\n\t */\n\tpublic LL_MaxLookEvent?: LookaheadEventInfo;\n\n\t/**\n\t * A collection of {@link ContextSensitivityInfo} instances describing the\n\t * context sensitivities encountered during LL prediction for this decision.\n\t *\n\t * @see ContextSensitivityInfo\n\t */\n\tpublic contextSensitivities: ContextSensitivityInfo[] = [];\n\n\t/**\n\t * A collection of {@link ErrorInfo} instances describing the parse errors\n\t * identified during calls to {@link ParserATNSimulator#adaptivePredict} for\n\t * this decision.\n\t *\n\t * @see ErrorInfo\n\t */\n\tpublic errors: ErrorInfo[] = [];\n\n\t/**\n\t * A collection of {@link AmbiguityInfo} instances describing the\n\t * ambiguities encountered during LL prediction for this decision.\n\t *\n\t * @see AmbiguityInfo\n\t */\n\tpublic ambiguities: AmbiguityInfo[] = [];\n\n\t/**\n\t * A collection of {@link PredicateEvalInfo} instances describing the\n\t * results of evaluating individual predicates during prediction for this\n\t * decision.\n\t *\n\t * @see PredicateEvalInfo\n\t */\n\tpublic predicateEvals: PredicateEvalInfo[] = [];\n\n\t/**\n\t * The total number of ATN transitions required during SLL prediction for\n\t * this decision. An ATN transition is determined by the number of times the\n\t * DFA does not contain an edge that is required for prediction, resulting\n\t * in on-the-fly computation of that edge.\n\t *\n\t * If DFA caching of SLL transitions is employed by the implementation, ATN\n\t * computation may cache the computed edge for efficient lookup during\n\t * future parsing of this decision. Otherwise, the SLL parsing algorithm\n\t * will use ATN transitions exclusively.\n\t *\n\t * @see #SLL_ATNTransitions\n\t * @see ParserATNSimulator#computeTargetState\n\t * @see LexerATNSimulator#computeTargetState\n\t */\n\tpublic SLL_ATNTransitions: number = 0;\n\n\t/**\n\t * The total number of DFA transitions required during SLL prediction for\n\t * this decision.\n\t *\n\t * If the ATN simulator implementation does not use DFA caching for SLL\n\t * transitions, this value will be 0.\n\t *\n\t * @see ParserATNSimulator#getExistingTargetState\n\t * @see LexerATNSimulator#getExistingTargetState\n\t */\n\tpublic SLL_DFATransitions: number = 0;\n\n\t/**\n\t * Gets the total number of times SLL prediction completed in a conflict\n\t * state, resulting in fallback to LL prediction.\n\t *\n\t * Note that this value is not related to whether or not\n\t * {@link PredictionMode#SLL} may be used successfully with a particular\n\t * grammar. If the ambiguity resolution algorithm applied to the SLL\n\t * conflicts for this decision produce the same result as LL prediction for\n\t * this decision, {@link PredictionMode#SLL} would produce the same overall\n\t * parsing result as {@link PredictionMode#LL}.\n\t */\n\tpublic LL_Fallback: number = 0;\n\n\t/**\n\t * The total number of ATN transitions required during LL prediction for\n\t * this decision. An ATN transition is determined by the number of times the\n\t * DFA does not contain an edge that is required for prediction, resulting\n\t * in on-the-fly computation of that edge.\n\t *\n\t * If DFA caching of LL transitions is employed by the implementation, ATN\n\t * computation may cache the computed edge for efficient lookup during\n\t * future parsing of this decision. Otherwise, the LL parsing algorithm will\n\t * use ATN transitions exclusively.\n\t *\n\t * @see #LL_DFATransitions\n\t * @see ParserATNSimulator#computeTargetState\n\t * @see LexerATNSimulator#computeTargetState\n\t */\n\tpublic LL_ATNTransitions: number = 0;\n\n\t/**\n\t * The total number of DFA transitions required during LL prediction for\n\t * this decision.\n\t *\n\t * If the ATN simulator implementation does not use DFA caching for LL\n\t * transitions, this value will be 0.\n\t *\n\t * @see ParserATNSimulator#getExistingTargetState\n\t * @see LexerATNSimulator#getExistingTargetState\n\t */\n\tpublic LL_DFATransitions: number = 0;\n\n\t/**\n\t * Constructs a new instance of the {@link DecisionInfo} class to contain\n\t * statistics for a particular decision.\n\t *\n\t * @param decision The decision number\n\t */\n\tconstructor(decision: number) {\n\t\tthis.decision = decision;\n\t}\n\n\t@Override\n\tpublic toString(): string {\n\t\treturn \"{\" +\n\t\t\t\"decision=\" + this.decision +\n\t\t\t\", contextSensitivities=\" + this.contextSensitivities.length +\n\t\t\t\", errors=\" + this.errors.length +\n\t\t\t\", ambiguities=\" + this.ambiguities.length +\n\t\t\t\", SLL_lookahead=\" + this.SLL_TotalLook +\n\t\t\t\", SLL_ATNTransitions=\" + this.SLL_ATNTransitions +\n\t\t\t\", SLL_DFATransitions=\" + this.SLL_DFATransitions +\n\t\t\t\", LL_Fallback=\" + this.LL_Fallback +\n\t\t\t\", LL_lookahead=\" + this.LL_TotalLook +\n\t\t\t\", LL_ATNTransitions=\" + this.LL_ATNTransitions +\n\t\t\t\"}\";\n\t}\n}\n"]}