{"version":3,"sources":["atn/CodePointTransitions.js","../src/atn/CodePointTransitions.ts"],"names":["Object","defineProperty","exports","value","Character","require","AtomTransition_1","IntervalSet_1","RangeTransition_1","SetTransition_1","createWithCodePoint","target","codePoint","isSupplementaryCodePoint","SetTransition","IntervalSet","of","AtomTransition","createWithCodePointRange","codePointFrom","codePointTo","RangeTransition"],"mappings":"AAAA;ACAA;;;;;ADKAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;ACAA,IAAAC,SAAA,GAAAC,OAAA,CAAA,mBAAA,CAAA;;AAEA,IAAAC,gBAAA,GAAAD,OAAA,CAAA,kBAAA,CAAA;;AACA,IAAAE,aAAA,GAAAF,OAAA,CAAA,qBAAA,CAAA;;AACA,IAAAG,iBAAA,GAAAH,OAAA,CAAA,mBAAA,CAAA;;AACA,IAAAI,eAAA,GAAAJ,OAAA,CAAA,iBAAA,CAAA;AAGA;;;;;;;;;;;AAWA;;;;;;AAIA,SAAAK,mBAAA,CAAoCC,MAApC,EAAsDC,SAAtD,EAAuE;AACtE,MAAIR,SAAS,CAACS,wBAAV,CAAmCD,SAAnC,CAAJ,EAAmD;AAClD,WAAO,IAAIH,eAAA,CAAAK,aAAJ,CAAkBH,MAAlB,EAA0BJ,aAAA,CAAAQ,WAAA,CAAYC,EAAZ,CAAeJ,SAAf,CAA1B,CAAP;AACA,GAFD,MAGK;AACJ,WAAO,IAAIN,gBAAA,CAAAW,cAAJ,CAAmBN,MAAnB,EAA2BC,SAA3B,CAAP;AACA;AACD;;AAPDV,OAAA,CAAAQ,mBAAA,GAAAA,mBAAA;AASA;;;;;;AAKA,SAAAQ,wBAAA,CAAyCP,MAAzC,EAA2DQ,aAA3D,EAAkFC,WAAlF,EAAqG;AACpG,MAAIhB,SAAS,CAACS,wBAAV,CAAmCM,aAAnC,KAAqDf,SAAS,CAACS,wBAAV,CAAmCO,WAAnC,CAAzD,EAA0G;AACzG,WAAO,IAAIX,eAAA,CAAAK,aAAJ,CAAkBH,MAAlB,EAA0BJ,aAAA,CAAAQ,WAAA,CAAYC,EAAZ,CAAeG,aAAf,EAA8BC,WAA9B,CAA1B,CAAP;AACA,GAFD,MAGK;AACJ,WAAO,IAAIZ,iBAAA,CAAAa,eAAJ,CAAoBV,MAApB,EAA4BQ,aAA5B,EAA2CC,WAA3C,CAAP;AACA;AACD;;AAPDlB,OAAA,CAAAgB,wBAAA,GAAAA,wBAAA","file":"CodePointTransitions.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Character = require(\"../misc/Character\");\nconst AtomTransition_1 = require(\"./AtomTransition\");\nconst IntervalSet_1 = require(\"../misc/IntervalSet\");\nconst RangeTransition_1 = require(\"./RangeTransition\");\nconst SetTransition_1 = require(\"./SetTransition\");\n/**\n * Utility functions to create {@link AtomTransition}, {@link RangeTransition},\n * and {@link SetTransition} appropriately based on the range of the input.\n *\n * To keep the serialized ATN size small, we only inline atom and\n * range transitions for Unicode code points <= U+FFFF.\n *\n * Whenever we encounter a Unicode code point > U+FFFF, we represent that\n * as a set transition (even if it is logically an atom or a range).\n */\n/**\n * If {@code codePoint} is <= U+FFFF, returns a new {@link AtomTransition}.\n * Otherwise, returns a new {@link SetTransition}.\n */\nfunction createWithCodePoint(target, codePoint) {\n    if (Character.isSupplementaryCodePoint(codePoint)) {\n        return new SetTransition_1.SetTransition(target, IntervalSet_1.IntervalSet.of(codePoint));\n    }\n    else {\n        return new AtomTransition_1.AtomTransition(target, codePoint);\n    }\n}\nexports.createWithCodePoint = createWithCodePoint;\n/**\n * If {@code codePointFrom} and {@code codePointTo} are both\n * <= U+FFFF, returns a new {@link RangeTransition}.\n * Otherwise, returns a new {@link SetTransition}.\n */\nfunction createWithCodePointRange(target, codePointFrom, codePointTo) {\n    if (Character.isSupplementaryCodePoint(codePointFrom) || Character.isSupplementaryCodePoint(codePointTo)) {\n        return new SetTransition_1.SetTransition(target, IntervalSet_1.IntervalSet.of(codePointFrom, codePointTo));\n    }\n    else {\n        return new RangeTransition_1.RangeTransition(target, codePointFrom, codePointTo);\n    }\n}\nexports.createWithCodePointRange = createWithCodePointRange;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\nimport * as Character from \"../misc/Character\";\nimport { ATNState } from \"./ATNState\";\nimport { AtomTransition } from \"./AtomTransition\";\nimport { IntervalSet } from \"../misc/IntervalSet\";\nimport { RangeTransition } from \"./RangeTransition\";\nimport { SetTransition } from \"./SetTransition\";\nimport { Transition } from \"./Transition\";\n\n/**\n * Utility functions to create {@link AtomTransition}, {@link RangeTransition},\n * and {@link SetTransition} appropriately based on the range of the input.\n *\n * To keep the serialized ATN size small, we only inline atom and\n * range transitions for Unicode code points <= U+FFFF.\n *\n * Whenever we encounter a Unicode code point > U+FFFF, we represent that\n * as a set transition (even if it is logically an atom or a range).\n */\n\n/**\n * If {@code codePoint} is <= U+FFFF, returns a new {@link AtomTransition}.\n * Otherwise, returns a new {@link SetTransition}.\n */\nexport function createWithCodePoint(target: ATNState, codePoint: number): Transition {\n\tif (Character.isSupplementaryCodePoint(codePoint)) {\n\t\treturn new SetTransition(target, IntervalSet.of(codePoint));\n\t}\n\telse {\n\t\treturn new AtomTransition(target, codePoint);\n\t}\n}\n\n/**\n * If {@code codePointFrom} and {@code codePointTo} are both\n * <= U+FFFF, returns a new {@link RangeTransition}.\n * Otherwise, returns a new {@link SetTransition}.\n */\nexport function createWithCodePointRange(target: ATNState, codePointFrom: number, codePointTo: number): Transition {\n\tif (Character.isSupplementaryCodePoint(codePointFrom) || Character.isSupplementaryCodePoint(codePointTo)) {\n\t\treturn new SetTransition(target, IntervalSet.of(codePointFrom, codePointTo));\n\t}\n\telse {\n\t\treturn new RangeTransition(target, codePointFrom, codePointTo);\n\t}\n}\n"]}