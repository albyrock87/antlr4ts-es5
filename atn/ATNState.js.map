{"version":3,"sources":["atn/ATNState.js","../src/atn/ATNState.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","Decorators_1","require","INITIAL_NUM_TRANSITIONS","ATNState","stateNumber","INVALID_STATE_NUMBER","ruleIndex","epsilonOnlyTransitions","transitions","optimizedTransitions","o","String","slice","e","index","isEpsilon","Error","splice","undefined","isOptimized","Array","push","getStateNumber","Override","prototype"],"mappings":"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","file":"ATNState.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Decorators_1 = require(\"../Decorators\");\nconst INITIAL_NUM_TRANSITIONS = 4;\n/**\n * The following images show the relation of states and\n * {@link ATNState#transitions} for various grammar constructs.\n *\n * * Solid edges marked with an &#0949; indicate a required\n *   {@link EpsilonTransition}.\n *\n * * Dashed edges indicate locations where any transition derived from\n *   {@link Transition} might appear.\n *\n * * Dashed nodes are place holders for either a sequence of linked\n *   {@link BasicState} states or the inclusion of a block representing a nested\n *   construct in one of the forms below.\n *\n * * Nodes showing multiple outgoing alternatives with a `...` support\n *   any number of alternatives (one or more). Nodes without the `...` only\n *   support the exact number of alternatives shown in the diagram.\n *\n * <h2>Basic Blocks</h2>\n *\n * <h3>Rule</h3>\n *\n * <embed src=\"images/Rule.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Block of 1 or more alternatives</h3>\n *\n * <embed src=\"images/Block.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Greedy Loops</h2>\n *\n * <h3>Greedy Closure: `(...)*`</h3>\n *\n * <embed src=\"images/ClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Positive Closure: `(...)+`</h3>\n *\n * <embed src=\"images/PositiveClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Optional: `(...)?`</h3>\n *\n * <embed src=\"images/OptionalGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Non-Greedy Loops</h2>\n *\n * <h3>Non-Greedy Closure: `(...)*?`</h3>\n *\n * <embed src=\"images/ClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Positive Closure: `(...)+?`</h3>\n *\n * <embed src=\"images/PositiveClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Optional: `(...)??`</h3>\n *\n * <embed src=\"images/OptionalNonGreedy.svg\" type=\"image/svg+xml\"/>\n */\nclass ATNState {\n    constructor() {\n        this.stateNumber = ATNState.INVALID_STATE_NUMBER;\n        this.ruleIndex = 0; // at runtime, we don't have Rule objects\n        this.epsilonOnlyTransitions = false;\n        /** Track the transitions emanating from this ATN state. */\n        this.transitions = [];\n        this.optimizedTransitions = this.transitions;\n    }\n    /**\n     * Gets the state number.\n     *\n     * @returns the state number\n     */\n    getStateNumber() {\n        return this.stateNumber;\n    }\n    /**\n     * For all states except {@link RuleStopState}, this returns the state\n     * number. Returns -1 for stop states.\n     *\n     * @returns -1 for {@link RuleStopState}, otherwise the state number\n     */\n    get nonStopStateNumber() {\n        return this.getStateNumber();\n    }\n    hashCode() {\n        return this.stateNumber;\n    }\n    equals(o) {\n        // are these states same object?\n        if (o instanceof ATNState) {\n            return this.stateNumber === o.stateNumber;\n        }\n        return false;\n    }\n    get isNonGreedyExitState() {\n        return false;\n    }\n    toString() {\n        return String(this.stateNumber);\n    }\n    getTransitions() {\n        return this.transitions.slice(0);\n    }\n    get numberOfTransitions() {\n        return this.transitions.length;\n    }\n    addTransition(e, index) {\n        if (this.transitions.length === 0) {\n            this.epsilonOnlyTransitions = e.isEpsilon;\n        }\n        else if (this.epsilonOnlyTransitions !== e.isEpsilon) {\n            this.epsilonOnlyTransitions = false;\n            throw new Error(\"ATN state \" + this.stateNumber + \" has both epsilon and non-epsilon transitions.\");\n        }\n        this.transitions.splice(index !== undefined ? index : this.transitions.length, 0, e);\n    }\n    transition(i) {\n        return this.transitions[i];\n    }\n    setTransition(i, e) {\n        this.transitions[i] = e;\n    }\n    removeTransition(index) {\n        return this.transitions.splice(index, 1)[0];\n    }\n    get onlyHasEpsilonTransitions() {\n        return this.epsilonOnlyTransitions;\n    }\n    setRuleIndex(ruleIndex) {\n        this.ruleIndex = ruleIndex;\n    }\n    get isOptimized() {\n        return this.optimizedTransitions !== this.transitions;\n    }\n    get numberOfOptimizedTransitions() {\n        return this.optimizedTransitions.length;\n    }\n    getOptimizedTransition(i) {\n        return this.optimizedTransitions[i];\n    }\n    addOptimizedTransition(e) {\n        if (!this.isOptimized) {\n            this.optimizedTransitions = new Array();\n        }\n        this.optimizedTransitions.push(e);\n    }\n    setOptimizedTransition(i, e) {\n        if (!this.isOptimized) {\n            throw new Error(\"This ATNState is not optimized.\");\n        }\n        this.optimizedTransitions[i] = e;\n    }\n    removeOptimizedTransition(i) {\n        if (!this.isOptimized) {\n            throw new Error(\"This ATNState is not optimized.\");\n        }\n        this.optimizedTransitions.splice(i, 1);\n    }\n}\n__decorate([\n    Decorators_1.Override\n], ATNState.prototype, \"hashCode\", null);\n__decorate([\n    Decorators_1.Override\n], ATNState.prototype, \"equals\", null);\n__decorate([\n    Decorators_1.Override\n], ATNState.prototype, \"toString\", null);\nexports.ATNState = ATNState;\n(function (ATNState) {\n    ATNState.INVALID_STATE_NUMBER = -1;\n})(ATNState = exports.ATNState || (exports.ATNState = {}));\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:27.4734328-07:00\n\nimport { ATN } from \"./ATN\";\nimport { ATNStateType } from \"./ATNStateType\";\nimport { IntervalSet } from \"../misc/IntervalSet\";\nimport { Override } from \"../Decorators\";\nimport { Transition } from \"./Transition\";\n\nconst INITIAL_NUM_TRANSITIONS: number = 4;\n\n/**\n * The following images show the relation of states and\n * {@link ATNState#transitions} for various grammar constructs.\n *\n * * Solid edges marked with an &#0949; indicate a required\n *   {@link EpsilonTransition}.\n *\n * * Dashed edges indicate locations where any transition derived from\n *   {@link Transition} might appear.\n *\n * * Dashed nodes are place holders for either a sequence of linked\n *   {@link BasicState} states or the inclusion of a block representing a nested\n *   construct in one of the forms below.\n *\n * * Nodes showing multiple outgoing alternatives with a `...` support\n *   any number of alternatives (one or more). Nodes without the `...` only\n *   support the exact number of alternatives shown in the diagram.\n *\n * <h2>Basic Blocks</h2>\n *\n * <h3>Rule</h3>\n *\n * <embed src=\"images/Rule.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Block of 1 or more alternatives</h3>\n *\n * <embed src=\"images/Block.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Greedy Loops</h2>\n *\n * <h3>Greedy Closure: `(...)*`</h3>\n *\n * <embed src=\"images/ClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Positive Closure: `(...)+`</h3>\n *\n * <embed src=\"images/PositiveClosureGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Greedy Optional: `(...)?`</h3>\n *\n * <embed src=\"images/OptionalGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h2>Non-Greedy Loops</h2>\n *\n * <h3>Non-Greedy Closure: `(...)*?`</h3>\n *\n * <embed src=\"images/ClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Positive Closure: `(...)+?`</h3>\n *\n * <embed src=\"images/PositiveClosureNonGreedy.svg\" type=\"image/svg+xml\"/>\n *\n * <h3>Non-Greedy Optional: `(...)??`</h3>\n *\n * <embed src=\"images/OptionalNonGreedy.svg\" type=\"image/svg+xml\"/>\n */\nexport abstract class ATNState {\n\n\t/** Which ATN are we in? */\n\tpublic atn?: ATN;\n\n\tpublic stateNumber: number = ATNState.INVALID_STATE_NUMBER;\n\n\tpublic ruleIndex: number = 0;  // at runtime, we don't have Rule objects\n\n\tpublic epsilonOnlyTransitions: boolean = false;\n\n\t/** Track the transitions emanating from this ATN state. */\n\tprotected transitions: Transition[] = [];\n\n\tprotected optimizedTransitions: Transition[] = this.transitions;\n\n\t/** Used to cache lookahead during parsing, not used during construction */\n\tpublic nextTokenWithinRule?: IntervalSet;\n\n\t/**\n\t * Gets the state number.\n\t *\n\t * @returns the state number\n\t */\n\tpublic getStateNumber(): number {\n\t\treturn this.stateNumber;\n\t}\n\n\t/**\n\t * For all states except {@link RuleStopState}, this returns the state\n\t * number. Returns -1 for stop states.\n\t *\n\t * @returns -1 for {@link RuleStopState}, otherwise the state number\n\t */\n\tget nonStopStateNumber(): number {\n\t\treturn this.getStateNumber();\n\t}\n\n\t@Override\n\tpublic hashCode(): number {\n\t\treturn this.stateNumber;\n\t}\n\n\t@Override\n\tpublic equals(o: any): boolean {\n\t\t// are these states same object?\n\t\tif (o instanceof ATNState) {\n\t\t\treturn this.stateNumber === o.stateNumber;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tget isNonGreedyExitState(): boolean {\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic toString(): string {\n\t\treturn String(this.stateNumber);\n\t}\n\n\tpublic getTransitions(): Transition[] {\n\t\treturn this.transitions.slice(0);\n\t}\n\n\tget numberOfTransitions(): number {\n\t\treturn this.transitions.length;\n\t}\n\n\tpublic addTransition(e: Transition, index?: number): void {\n\t\tif (this.transitions.length === 0) {\n\t\t\tthis.epsilonOnlyTransitions = e.isEpsilon;\n\t\t}\n\t\telse if (this.epsilonOnlyTransitions !== e.isEpsilon) {\n\t\t\tthis.epsilonOnlyTransitions = false;\n\t\t\tthrow new Error(\"ATN state \" + this.stateNumber + \" has both epsilon and non-epsilon transitions.\");\n\t\t}\n\n\t\tthis.transitions.splice(index !== undefined ? index : this.transitions.length, 0, e);\n\t}\n\n\tpublic transition(i: number): Transition {\n\t\treturn this.transitions[i];\n\t}\n\n\tpublic setTransition(i: number, e: Transition): void {\n\t\tthis.transitions[i] = e;\n\t}\n\n\tpublic removeTransition(index: number): Transition {\n\t\treturn this.transitions.splice(index, 1)[0];\n\t}\n\n\tpublic abstract readonly stateType: ATNStateType;\n\n\tget onlyHasEpsilonTransitions(): boolean {\n\t\treturn this.epsilonOnlyTransitions;\n\t}\n\n\tpublic setRuleIndex(ruleIndex: number): void {\n\t\tthis.ruleIndex = ruleIndex;\n\t}\n\n\tget isOptimized(): boolean {\n\t\treturn this.optimizedTransitions !== this.transitions;\n\t}\n\n\tget numberOfOptimizedTransitions(): number {\n\t\treturn this.optimizedTransitions.length;\n\t}\n\n\tpublic getOptimizedTransition(i: number): Transition {\n\t\treturn this.optimizedTransitions[i];\n\t}\n\n\tpublic addOptimizedTransition(e: Transition): void {\n\t\tif (!this.isOptimized) {\n\t\t\tthis.optimizedTransitions = new Array<Transition>();\n\t\t}\n\n\t\tthis.optimizedTransitions.push(e);\n\t}\n\n\tpublic setOptimizedTransition(i: number, e: Transition): void {\n\t\tif (!this.isOptimized) {\n\t\t\tthrow new Error(\"This ATNState is not optimized.\");\n\t\t}\n\n\t\tthis.optimizedTransitions[i] = e;\n\t}\n\n\tpublic removeOptimizedTransition(i: number): void {\n\t\tif (!this.isOptimized) {\n\t\t\tthrow new Error(\"This ATNState is not optimized.\");\n\t\t}\n\n\t\tthis.optimizedTransitions.splice(i, 1);\n\t}\n}\n\nexport namespace ATNState {\n\texport const INVALID_STATE_NUMBER: number = -1;\n}\n"]}