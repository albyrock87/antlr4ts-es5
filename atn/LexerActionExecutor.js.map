{"version":3,"sources":["atn/LexerActionExecutor.js","../src/atn/LexerActionExecutor.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","ArrayEqualityComparator_1","require","LexerIndexedCustomAction_1","MurmurHash_1","Decorators_1","LexerActionExecutor","lexerActions","_lexerActions","hash","MurmurHash","initialize","lexerAction","update","cachedHashCode","finish","offset","updatedLexerActions","isPositionDependent","LexerIndexedCustomAction","slice","lexer","input","startIndex","requiresSeek","stopIndex","index","seek","action","execute","obj","ArrayEqualityComparator","INSTANCE","equals","lexerActionExecutor","push","NotNull","prototype","Override"],"mappings":"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","file":"LexerActionExecutor.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:28.8810453-07:00\nconst ArrayEqualityComparator_1 = require(\"../misc/ArrayEqualityComparator\");\nconst LexerIndexedCustomAction_1 = require(\"./LexerIndexedCustomAction\");\nconst MurmurHash_1 = require(\"../misc/MurmurHash\");\nconst Decorators_1 = require(\"../Decorators\");\n/**\n * Represents an executor for a sequence of lexer actions which traversed during\n * the matching operation of a lexer rule (token).\n *\n * The executor tracks position information for position-dependent lexer actions\n * efficiently, ensuring that actions appearing only at the end of the rule do\n * not cause bloating of the {@link DFA} created for the lexer.\n *\n * @author Sam Harwell\n * @since 4.2\n */\nlet LexerActionExecutor = class LexerActionExecutor {\n    /**\n     * Constructs an executor for a sequence of {@link LexerAction} actions.\n     * @param lexerActions The lexer actions to execute.\n     */\n    constructor(lexerActions) {\n        this._lexerActions = lexerActions;\n        let hash = MurmurHash_1.MurmurHash.initialize();\n        for (let lexerAction of lexerActions) {\n            hash = MurmurHash_1.MurmurHash.update(hash, lexerAction);\n        }\n        this.cachedHashCode = MurmurHash_1.MurmurHash.finish(hash, lexerActions.length);\n    }\n    /**\n     * Creates a {@link LexerActionExecutor} which executes the actions for\n     * the input `lexerActionExecutor` followed by a specified\n     * `lexerAction`.\n     *\n     * @param lexerActionExecutor The executor for actions already traversed by\n     * the lexer while matching a token within a particular\n     * {@link ATNConfig}. If this is `undefined`, the method behaves as though\n     * it were an empty executor.\n     * @param lexerAction The lexer action to execute after the actions\n     * specified in `lexerActionExecutor`.\n     *\n     * @returns A {@link LexerActionExecutor} for executing the combine actions\n     * of `lexerActionExecutor` and `lexerAction`.\n     */\n    static append(lexerActionExecutor, lexerAction) {\n        if (!lexerActionExecutor) {\n            return new LexerActionExecutor([lexerAction]);\n        }\n        let lexerActions = lexerActionExecutor._lexerActions.slice(0);\n        lexerActions.push(lexerAction);\n        return new LexerActionExecutor(lexerActions);\n    }\n    /**\n     * Creates a {@link LexerActionExecutor} which encodes the current offset\n     * for position-dependent lexer actions.\n     *\n     * Normally, when the executor encounters lexer actions where\n     * {@link LexerAction#isPositionDependent} returns `true`, it calls\n     * {@link IntStream#seek} on the input {@link CharStream} to set the input\n     * position to the *end* of the current token. This behavior provides\n     * for efficient DFA representation of lexer actions which appear at the end\n     * of a lexer rule, even when the lexer rule matches a variable number of\n     * characters.\n     *\n     * Prior to traversing a match transition in the ATN, the current offset\n     * from the token start index is assigned to all position-dependent lexer\n     * actions which have not already been assigned a fixed offset. By storing\n     * the offsets relative to the token start index, the DFA representation of\n     * lexer actions which appear in the middle of tokens remains efficient due\n     * to sharing among tokens of the same length, regardless of their absolute\n     * position in the input stream.\n     *\n     * If the current executor already has offsets assigned to all\n     * position-dependent lexer actions, the method returns `this`.\n     *\n     * @param offset The current offset to assign to all position-dependent\n     * lexer actions which do not already have offsets assigned.\n     *\n     * @returns A {@link LexerActionExecutor} which stores input stream offsets\n     * for all position-dependent lexer actions.\n     */\n    fixOffsetBeforeMatch(offset) {\n        let updatedLexerActions;\n        for (let i = 0; i < this._lexerActions.length; i++) {\n            if (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction)) {\n                if (!updatedLexerActions) {\n                    updatedLexerActions = this._lexerActions.slice(0);\n                }\n                updatedLexerActions[i] = new LexerIndexedCustomAction_1.LexerIndexedCustomAction(offset, this._lexerActions[i]);\n            }\n        }\n        if (!updatedLexerActions) {\n            return this;\n        }\n        return new LexerActionExecutor(updatedLexerActions);\n    }\n    /**\n     * Gets the lexer actions to be executed by this executor.\n     * @returns The lexer actions to be executed by this executor.\n     */\n    get lexerActions() {\n        return this._lexerActions;\n    }\n    /**\n     * Execute the actions encapsulated by this executor within the context of a\n     * particular {@link Lexer}.\n     *\n     * This method calls {@link IntStream#seek} to set the position of the\n     * `input` {@link CharStream} prior to calling\n     * {@link LexerAction#execute} on a position-dependent action. Before the\n     * method returns, the input position will be restored to the same position\n     * it was in when the method was invoked.\n     *\n     * @param lexer The lexer instance.\n     * @param input The input stream which is the source for the current token.\n     * When this method is called, the current {@link IntStream#index} for\n     * `input` should be the start of the following token, i.e. 1\n     * character past the end of the current token.\n     * @param startIndex The token start index. This value may be passed to\n     * {@link IntStream#seek} to set the `input` position to the beginning\n     * of the token.\n     */\n    execute(lexer, input, startIndex) {\n        let requiresSeek = false;\n        let stopIndex = input.index;\n        try {\n            for (let lexerAction of this._lexerActions) {\n                if (lexerAction instanceof LexerIndexedCustomAction_1.LexerIndexedCustomAction) {\n                    let offset = lexerAction.offset;\n                    input.seek(startIndex + offset);\n                    lexerAction = lexerAction.action;\n                    requiresSeek = (startIndex + offset) !== stopIndex;\n                }\n                else if (lexerAction.isPositionDependent) {\n                    input.seek(stopIndex);\n                    requiresSeek = false;\n                }\n                lexerAction.execute(lexer);\n            }\n        }\n        finally {\n            if (requiresSeek) {\n                input.seek(stopIndex);\n            }\n        }\n    }\n    hashCode() {\n        return this.cachedHashCode;\n    }\n    equals(obj) {\n        if (obj === this) {\n            return true;\n        }\n        else if (!(obj instanceof LexerActionExecutor)) {\n            return false;\n        }\n        return this.cachedHashCode === obj.cachedHashCode\n            && ArrayEqualityComparator_1.ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);\n    }\n};\n__decorate([\n    Decorators_1.NotNull\n], LexerActionExecutor.prototype, \"_lexerActions\", void 0);\n__decorate([\n    Decorators_1.NotNull\n], LexerActionExecutor.prototype, \"lexerActions\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull)\n], LexerActionExecutor.prototype, \"execute\", null);\n__decorate([\n    Decorators_1.Override\n], LexerActionExecutor.prototype, \"hashCode\", null);\n__decorate([\n    Decorators_1.Override\n], LexerActionExecutor.prototype, \"equals\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(1, Decorators_1.NotNull)\n], LexerActionExecutor, \"append\", null);\nLexerActionExecutor = __decorate([\n    __param(0, Decorators_1.NotNull)\n], LexerActionExecutor);\nexports.LexerActionExecutor = LexerActionExecutor;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:28.8810453-07:00\n\nimport { ArrayEqualityComparator } from \"../misc/ArrayEqualityComparator\";\nimport { CharStream } from \"../CharStream\";\nimport { Lexer } from \"../Lexer\";\nimport { LexerAction } from \"./LexerAction\";\nimport { LexerIndexedCustomAction } from \"./LexerIndexedCustomAction\";\nimport { MurmurHash } from \"../misc/MurmurHash\";\nimport { NotNull, Override } from \"../Decorators\";\n\n/**\n * Represents an executor for a sequence of lexer actions which traversed during\n * the matching operation of a lexer rule (token).\n *\n * The executor tracks position information for position-dependent lexer actions\n * efficiently, ensuring that actions appearing only at the end of the rule do\n * not cause bloating of the {@link DFA} created for the lexer.\n *\n * @author Sam Harwell\n * @since 4.2\n */\nexport class LexerActionExecutor {\n\t@NotNull\n\tprivate _lexerActions: LexerAction[];\n\n\t/**\n\t * Caches the result of {@link #hashCode} since the hash code is an element\n\t * of the performance-critical {@link LexerATNConfig#hashCode} operation.\n\t */\n\tprivate cachedHashCode: number;\n\n\t/**\n\t * Constructs an executor for a sequence of {@link LexerAction} actions.\n\t * @param lexerActions The lexer actions to execute.\n\t */\n\tconstructor(@NotNull lexerActions: LexerAction[]) {\n\t\tthis._lexerActions = lexerActions;\n\n\t\tlet hash: number = MurmurHash.initialize();\n\t\tfor (let lexerAction of lexerActions) {\n\t\t\thash = MurmurHash.update(hash, lexerAction);\n\t\t}\n\n\t\tthis.cachedHashCode = MurmurHash.finish(hash, lexerActions.length);\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which executes the actions for\n\t * the input `lexerActionExecutor` followed by a specified\n\t * `lexerAction`.\n\t *\n\t * @param lexerActionExecutor The executor for actions already traversed by\n\t * the lexer while matching a token within a particular\n\t * {@link ATNConfig}. If this is `undefined`, the method behaves as though\n\t * it were an empty executor.\n\t * @param lexerAction The lexer action to execute after the actions\n\t * specified in `lexerActionExecutor`.\n\t *\n\t * @returns A {@link LexerActionExecutor} for executing the combine actions\n\t * of `lexerActionExecutor` and `lexerAction`.\n\t */\n\t@NotNull\n\tpublic static append(lexerActionExecutor: LexerActionExecutor | undefined, @NotNull lexerAction: LexerAction): LexerActionExecutor {\n\t\tif (!lexerActionExecutor) {\n\t\t\treturn new LexerActionExecutor([lexerAction]);\n\t\t}\n\n\t\tlet lexerActions = lexerActionExecutor._lexerActions.slice(0);\n\t\tlexerActions.push(lexerAction);\n\t\treturn new LexerActionExecutor(lexerActions);\n\t}\n\n\t/**\n\t * Creates a {@link LexerActionExecutor} which encodes the current offset\n\t * for position-dependent lexer actions.\n\t *\n\t * Normally, when the executor encounters lexer actions where\n\t * {@link LexerAction#isPositionDependent} returns `true`, it calls\n\t * {@link IntStream#seek} on the input {@link CharStream} to set the input\n\t * position to the *end* of the current token. This behavior provides\n\t * for efficient DFA representation of lexer actions which appear at the end\n\t * of a lexer rule, even when the lexer rule matches a variable number of\n\t * characters.\n\t *\n\t * Prior to traversing a match transition in the ATN, the current offset\n\t * from the token start index is assigned to all position-dependent lexer\n\t * actions which have not already been assigned a fixed offset. By storing\n\t * the offsets relative to the token start index, the DFA representation of\n\t * lexer actions which appear in the middle of tokens remains efficient due\n\t * to sharing among tokens of the same length, regardless of their absolute\n\t * position in the input stream.\n\t *\n\t * If the current executor already has offsets assigned to all\n\t * position-dependent lexer actions, the method returns `this`.\n\t *\n\t * @param offset The current offset to assign to all position-dependent\n\t * lexer actions which do not already have offsets assigned.\n\t *\n\t * @returns A {@link LexerActionExecutor} which stores input stream offsets\n\t * for all position-dependent lexer actions.\n\t */\n\tpublic fixOffsetBeforeMatch(offset: number): LexerActionExecutor {\n\t\tlet updatedLexerActions: LexerAction[] | undefined;\n\t\tfor (let i = 0; i < this._lexerActions.length; i++) {\n\t\t\tif (this._lexerActions[i].isPositionDependent && !(this._lexerActions[i] instanceof LexerIndexedCustomAction)) {\n\t\t\t\tif (!updatedLexerActions) {\n\t\t\t\t\tupdatedLexerActions = this._lexerActions.slice(0);\n\t\t\t\t}\n\n\t\t\t\tupdatedLexerActions[i] = new LexerIndexedCustomAction(offset, this._lexerActions[i]);\n\t\t\t}\n\t\t}\n\n\t\tif (!updatedLexerActions) {\n\t\t\treturn this;\n\t\t}\n\n\t\treturn new LexerActionExecutor(updatedLexerActions);\n\t}\n\n\t/**\n\t * Gets the lexer actions to be executed by this executor.\n\t * @returns The lexer actions to be executed by this executor.\n\t */\n\t@NotNull\n\tget lexerActions(): LexerAction[] {\n\t\treturn this._lexerActions;\n\t}\n\n\t/**\n\t * Execute the actions encapsulated by this executor within the context of a\n\t * particular {@link Lexer}.\n\t *\n\t * This method calls {@link IntStream#seek} to set the position of the\n\t * `input` {@link CharStream} prior to calling\n\t * {@link LexerAction#execute} on a position-dependent action. Before the\n\t * method returns, the input position will be restored to the same position\n\t * it was in when the method was invoked.\n\t *\n\t * @param lexer The lexer instance.\n\t * @param input The input stream which is the source for the current token.\n\t * When this method is called, the current {@link IntStream#index} for\n\t * `input` should be the start of the following token, i.e. 1\n\t * character past the end of the current token.\n\t * @param startIndex The token start index. This value may be passed to\n\t * {@link IntStream#seek} to set the `input` position to the beginning\n\t * of the token.\n\t */\n\tpublic execute(@NotNull lexer: Lexer, input: CharStream, startIndex: number): void {\n\t\tlet requiresSeek: boolean = false;\n\t\tlet stopIndex: number = input.index;\n\t\ttry {\n\t\t\tfor (let lexerAction of this._lexerActions) {\n\t\t\t\tif (lexerAction instanceof LexerIndexedCustomAction) {\n\t\t\t\t\tlet offset: number = lexerAction.offset;\n\t\t\t\t\tinput.seek(startIndex + offset);\n\t\t\t\t\tlexerAction = lexerAction.action;\n\t\t\t\t\trequiresSeek = (startIndex + offset) !== stopIndex;\n\t\t\t\t} else if (lexerAction.isPositionDependent) {\n\t\t\t\t\tinput.seek(stopIndex);\n\t\t\t\t\trequiresSeek = false;\n\t\t\t\t}\n\n\t\t\t\tlexerAction.execute(lexer);\n\t\t\t}\n\t\t} finally {\n\t\t\tif (requiresSeek) {\n\t\t\t\tinput.seek(stopIndex);\n\t\t\t}\n\t\t}\n\t}\n\n\t@Override\n\tpublic hashCode(): number {\n\t\treturn this.cachedHashCode;\n\t}\n\n\t@Override\n\tpublic equals(obj: any): boolean {\n\t\tif (obj === this) {\n\t\t\treturn true;\n\t\t} else if (!(obj instanceof LexerActionExecutor)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this.cachedHashCode === obj.cachedHashCode\n\t\t\t&& ArrayEqualityComparator.INSTANCE.equals(this._lexerActions, obj._lexerActions);\n\t}\n}\n"]}