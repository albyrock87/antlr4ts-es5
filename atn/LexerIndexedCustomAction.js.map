{"version":3,"sources":["atn/LexerIndexedCustomAction.js","../src/atn/LexerIndexedCustomAction.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","MurmurHash_1","require","Decorators_1","LexerIndexedCustomAction","offset","action","_offset","_action","lexer","execute","hash","MurmurHash","initialize","update","finish","obj","equals","actionType","NotNull","prototype","Override"],"mappings":"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","file":"LexerIndexedCustomAction.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst MurmurHash_1 = require(\"../misc/MurmurHash\");\nconst Decorators_1 = require(\"../Decorators\");\n/**\n * This implementation of {@link LexerAction} is used for tracking input offsets\n * for position-dependent actions within a {@link LexerActionExecutor}.\n *\n * This action is not serialized as part of the ATN, and is only required for\n * position-dependent lexer actions which appear at a location other than the\n * end of a rule. For more information about DFA optimizations employed for\n * lexer actions, see {@link LexerActionExecutor#append} and\n * {@link LexerActionExecutor#fixOffsetBeforeMatch}.\n *\n * @author Sam Harwell\n * @since 4.2\n */\nlet LexerIndexedCustomAction = class LexerIndexedCustomAction {\n    /**\n     * Constructs a new indexed custom action by associating a character offset\n     * with a {@link LexerAction}.\n     *\n     * Note: This class is only required for lexer actions for which\n     * {@link LexerAction#isPositionDependent} returns `true`.\n     *\n     * @param offset The offset into the input {@link CharStream}, relative to\n     * the token start index, at which the specified lexer action should be\n     * executed.\n     * @param action The lexer action to execute at a particular offset in the\n     * input {@link CharStream}.\n     */\n    constructor(offset, action) {\n        this._offset = offset;\n        this._action = action;\n    }\n    /**\n     * Gets the location in the input {@link CharStream} at which the lexer\n     * action should be executed. The value is interpreted as an offset relative\n     * to the token start index.\n     *\n     * @returns The location in the input {@link CharStream} at which the lexer\n     * action should be executed.\n     */\n    get offset() {\n        return this._offset;\n    }\n    /**\n     * Gets the lexer action to execute.\n     *\n     * @returns A {@link LexerAction} object which executes the lexer action.\n     */\n    get action() {\n        return this._action;\n    }\n    /**\n     * {@inheritDoc}\n     *\n     * @returns This method returns the result of calling {@link #getActionType}\n     * on the {@link LexerAction} returned by {@link #getAction}.\n     */\n    get actionType() {\n        return this._action.actionType;\n    }\n    /**\n     * {@inheritDoc}\n     * @returns This method returns `true`.\n     */\n    get isPositionDependent() {\n        return true;\n    }\n    /**\n     * {@inheritDoc}\n     *\n     * This method calls {@link #execute} on the result of {@link #getAction}\n     * using the provided `lexer`.\n     */\n    execute(lexer) {\n        // assume the input stream position was properly set by the calling code\n        this._action.execute(lexer);\n    }\n    hashCode() {\n        let hash = MurmurHash_1.MurmurHash.initialize();\n        hash = MurmurHash_1.MurmurHash.update(hash, this._offset);\n        hash = MurmurHash_1.MurmurHash.update(hash, this._action);\n        return MurmurHash_1.MurmurHash.finish(hash, 2);\n    }\n    equals(obj) {\n        if (obj === this) {\n            return true;\n        }\n        else if (!(obj instanceof LexerIndexedCustomAction)) {\n            return false;\n        }\n        return this._offset === obj._offset\n            && this._action.equals(obj._action);\n    }\n};\n__decorate([\n    Decorators_1.NotNull\n], LexerIndexedCustomAction.prototype, \"action\", null);\n__decorate([\n    Decorators_1.Override\n], LexerIndexedCustomAction.prototype, \"actionType\", null);\n__decorate([\n    Decorators_1.Override\n], LexerIndexedCustomAction.prototype, \"isPositionDependent\", null);\n__decorate([\n    Decorators_1.Override\n], LexerIndexedCustomAction.prototype, \"execute\", null);\n__decorate([\n    Decorators_1.Override\n], LexerIndexedCustomAction.prototype, \"hashCode\", null);\n__decorate([\n    Decorators_1.Override\n], LexerIndexedCustomAction.prototype, \"equals\", null);\nLexerIndexedCustomAction = __decorate([\n    __param(1, Decorators_1.NotNull)\n], LexerIndexedCustomAction);\nexports.LexerIndexedCustomAction = LexerIndexedCustomAction;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:29.7613038-07:00\n\nimport { Lexer } from \"../Lexer\";\nimport { LexerAction } from \"./LexerAction\";\nimport { LexerActionType } from \"./LexerActionType\";\nimport { MurmurHash } from \"../misc/MurmurHash\";\nimport { NotNull, Override } from \"../Decorators\";\n\n/**\n * This implementation of {@link LexerAction} is used for tracking input offsets\n * for position-dependent actions within a {@link LexerActionExecutor}.\n *\n * This action is not serialized as part of the ATN, and is only required for\n * position-dependent lexer actions which appear at a location other than the\n * end of a rule. For more information about DFA optimizations employed for\n * lexer actions, see {@link LexerActionExecutor#append} and\n * {@link LexerActionExecutor#fixOffsetBeforeMatch}.\n *\n * @author Sam Harwell\n * @since 4.2\n */\nexport class LexerIndexedCustomAction implements LexerAction {\n\tprivate readonly _offset: number;\n\tprivate readonly _action: LexerAction;\n\n\t/**\n\t * Constructs a new indexed custom action by associating a character offset\n\t * with a {@link LexerAction}.\n\t *\n\t * Note: This class is only required for lexer actions for which\n\t * {@link LexerAction#isPositionDependent} returns `true`.\n\t *\n\t * @param offset The offset into the input {@link CharStream}, relative to\n\t * the token start index, at which the specified lexer action should be\n\t * executed.\n\t * @param action The lexer action to execute at a particular offset in the\n\t * input {@link CharStream}.\n\t */\n\tconstructor(offset: number, @NotNull action: LexerAction) {\n\t\tthis._offset = offset;\n\t\tthis._action = action;\n\t}\n\n\t/**\n\t * Gets the location in the input {@link CharStream} at which the lexer\n\t * action should be executed. The value is interpreted as an offset relative\n\t * to the token start index.\n\t *\n\t * @returns The location in the input {@link CharStream} at which the lexer\n\t * action should be executed.\n\t */\n\tget offset(): number {\n\t\treturn this._offset;\n\t}\n\n\t/**\n\t * Gets the lexer action to execute.\n\t *\n\t * @returns A {@link LexerAction} object which executes the lexer action.\n\t */\n\t@NotNull\n\tget action(): LexerAction {\n\t\treturn this._action;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * @returns This method returns the result of calling {@link #getActionType}\n\t * on the {@link LexerAction} returned by {@link #getAction}.\n\t */\n\t@Override\n\tget actionType(): LexerActionType {\n\t\treturn this._action.actionType;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t * @returns This method returns `true`.\n\t */\n\t@Override\n\tget isPositionDependent(): boolean {\n\t\treturn true;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t *\n\t * This method calls {@link #execute} on the result of {@link #getAction}\n\t * using the provided `lexer`.\n\t */\n\t@Override\n\tpublic execute(lexer: Lexer): void {\n\t\t// assume the input stream position was properly set by the calling code\n\t\tthis._action.execute(lexer);\n\t}\n\n\t@Override\n\tpublic hashCode(): number {\n\t\tlet hash: number = MurmurHash.initialize();\n\t\thash = MurmurHash.update(hash, this._offset);\n\t\thash = MurmurHash.update(hash, this._action);\n\t\treturn MurmurHash.finish(hash, 2);\n\t}\n\n\t@Override\n\tpublic equals(obj: any): boolean {\n\t\tif (obj === this) {\n\t\t\treturn true;\n\t\t} else if (!(obj instanceof LexerIndexedCustomAction)) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this._offset === obj._offset\n\t\t\t&& this._action.equals(obj._action);\n\t}\n}\n"]}