{"version":3,"sources":["CodePointBuffer.js","../src/CodePointBuffer.ts"],"names":["Object","defineProperty","exports","value","assert","require","Character","CodePointBuffer","buffer","size","_position","_size","offset","slice","newPosition","RangeError","position","length","initialBufferSize","Builder","Type","type","Uint8Array","prevHighSurrogate","remainingNeeded","newCapacity","roundUpToNextPowerOfTwo","newBuffer","set","subarray","Uint16Array","Int32Array","utf16In","ensureRemaining","appendArray","appendArrayByte","appendArrayChar","appendArrayInt","input","inOffset","inLimit","outByte","outOffset","c","isHighSurrogate","byteToCharBuffer","byteToIntBuffer","outChar","charToIntBuffer","outInt","isLowSurrogate","String","fromCharCode","codePointAt","toAppend","Math","max","i","nextPowerOfTwo","clz32","pow"],"mappings":"AAAA;ACAA;;;;;;;;;;;ADKAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;ACAA,IAAAC,MAAA,GAAAC,OAAA,CAAA,QAAA,CAAA;;AACA,IAAAC,SAAA,GAAAD,OAAA,CAAA,kBAAA,CAAA;AAEA;;;;;IAGAE,e;;;AAKC,2BAAYC,MAAZ,EAA2DC,IAA3D,EAAuE;AAAA;AACtE,SAAKD,MAAL,GAAcA,MAAd;AACA,SAAKE,SAAL,GAAiB,CAAjB;AACA,SAAKC,KAAL,GAAaF,IAAb;AACA;;;;wBAsBUG,M,EAAc;AACxB,aAAO,KAAKJ,MAAL,CAAYI,MAAZ,CAAP;AACA;;;4BAEW;AACX,aAAO,KAAKJ,MAAL,CAAYK,KAAZ,CAAkB,CAAlB,EAAqB,KAAKF,KAA1B,CAAP;AACA;;;wBAtBkB;AAClB,aAAO,KAAKD,SAAZ;AACA,K;sBAEmBI,W,EAAmB;AACtC,UAAIA,WAAW,GAAG,CAAd,IAAmBA,WAAW,GAAG,KAAKH,KAA1C,EAAiD;AAChD,cAAM,IAAII,UAAJ,EAAN;AACA;;AAED,WAAKL,SAAL,GAAiBI,WAAjB;AACA;;;wBAEmB;AACnB,aAAO,KAAKH,KAAL,GAAa,KAAKK,QAAzB;AACA;;;8BAlBuBR,M,EAA6C;AACpE,aAAO,IAAID,eAAJ,CAAoBC,MAApB,EAA4BA,MAAM,CAACS,MAAnC,CAAP;AACA;;;4BA0BqBC,iB,EAAyB;AAC9C,aAAO,IAAIX,eAAe,CAACY,OAApB,CAA4BD,iBAA5B,CAAP;AACA;;;;;AAzCFhB,OAAA,CAAAK,eAAA,GAAAA,eAAA;;AA4CA,CAAA,UAAiBA,eAAjB,EAAgC;AAC/B,MAAWa,IAAX;;AAAA,GAAA,UAAWA,IAAX,EAAe;AACdA,IAAAA,IAAA,CAAAA,IAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACAA,IAAAA,IAAA,CAAAA,IAAA,CAAA,MAAA,CAAA,GAAA,CAAA,CAAA,GAAA,MAAA;AACAA,IAAAA,IAAA,CAAAA,IAAA,CAAA,KAAA,CAAA,GAAA,CAAA,CAAA,GAAA,KAAA;AACA,GAJD,EAAWA,IAAI,KAAJA,IAAI,GAAA,EAAA,CAAf;;AAD+B,MAO/BD,OAP+B;AAAA;AAAA;AAa9B,qBAAYD,iBAAZ,EAAqC;AAAA;AACpC,WAAKG,IAAL,GAAS;AAAA;AAAT;AACA,WAAKb,MAAL,GAAc,IAAIc,UAAJ,CAAeJ,iBAAf,CAAd;AACA,WAAKK,iBAAL,GAAyB,CAAC,CAA1B;AACA,WAAKP,QAAL,GAAgB,CAAhB;AACA;;AAlB6B;AAAA;AAAA,8BAoBlB;AACX,eAAO,IAAIT,eAAJ,CAAoB,KAAKC,MAAzB,EAAiC,KAAKQ,QAAtC,CAAP;AACA;AAtB6B;AAAA;AAAA,sCA6BPQ,eA7BO,EA6BgB;AAC7C,gBAAQ,KAAKH,IAAb;AACC,eAAA;AAAA;AAAA;AACC,gBAAI,KAAKb,MAAL,CAAYS,MAAZ,GAAqB,KAAKD,QAA1B,GAAqCQ,eAAzC,EAA0D;AACzD,kBAAIC,WAAW,GAAWN,OAAO,CAACO,uBAAR,CAAgC,KAAKlB,MAAL,CAAYS,MAAZ,GAAqBO,eAArD,CAA1B;AACA,kBAAIG,SAAS,GAAe,IAAIL,UAAJ,CAAeG,WAAf,CAA5B;AACAE,cAAAA,SAAS,CAACC,GAAV,CAAc,KAAKpB,MAAL,CAAYqB,QAAZ,CAAqB,CAArB,EAAwB,KAAKb,QAA7B,CAAd,EAAsD,CAAtD;AACA,mBAAKR,MAAL,GAAcmB,SAAd;AACA;;AACD;;AACD,eAAA;AAAA;AAAA;AACC,gBAAI,KAAKnB,MAAL,CAAYS,MAAZ,GAAqB,KAAKD,QAA1B,GAAqCQ,eAAzC,EAA0D;AACzD,kBAAIC,YAAW,GAAWN,OAAO,CAACO,uBAAR,CAAgC,KAAKlB,MAAL,CAAYS,MAAZ,GAAqBO,eAArD,CAA1B;;AACA,kBAAIG,UAAS,GAAgB,IAAIG,WAAJ,CAAgBL,YAAhB,CAA7B;;AACAE,cAAAA,UAAS,CAACC,GAAV,CAAc,KAAKpB,MAAL,CAAYqB,QAAZ,CAAqB,CAArB,EAAwB,KAAKb,QAA7B,CAAd,EAAsD,CAAtD;;AACA,mBAAKR,MAAL,GAAcmB,UAAd;AACA;;AACD;;AACD,eAAA;AAAA;AAAA;AACC,gBAAI,KAAKnB,MAAL,CAAYS,MAAZ,GAAqB,KAAKD,QAA1B,GAAqCQ,eAAzC,EAA0D;AACzD,kBAAIC,aAAW,GAAWN,OAAO,CAACO,uBAAR,CAAgC,KAAKlB,MAAL,CAAYS,MAAZ,GAAqBO,eAArD,CAA1B;;AACA,kBAAIG,WAAS,GAAe,IAAII,UAAJ,CAAeN,aAAf,CAA5B;;AACAE,cAAAA,WAAS,CAACC,GAAV,CAAc,KAAKpB,MAAL,CAAYqB,QAAZ,CAAqB,CAArB,EAAwB,KAAKb,QAA7B,CAAd,EAAsD,CAAtD;;AACA,mBAAKR,MAAL,GAAcmB,WAAd;AACA;;AACD;AAxBF;AA0BA;AAxD6B;AAAA;AAAA,6BA0DhBK,OA1DgB,EA0DI;AACjC,aAAKC,eAAL,CAAqBD,OAAO,CAACf,MAA7B;AACA,aAAKiB,WAAL,CAAiBF,OAAjB;AACA;AA7D6B;AAAA;AAAA,kCA+DVA,OA/DU,EA+DU;AACvC,gBAAQ,KAAKX,IAAb;AACC,eAAA;AAAA;AAAA;AACC,iBAAKc,eAAL,CAAqBH,OAArB;AACA;;AACD,eAAA;AAAA;AAAA;AACC,iBAAKI,eAAL,CAAqBJ,OAArB;AACA;;AACD,eAAA;AAAA;AAAA;AACC,iBAAKK,cAAL,CAAoBL,OAApB;AACA;AATF;AAWA;AA3E6B;AAAA;AAAA,sCA6ENA,OA7EM,EA6Ec;AAC3C5B,QAAAA,MAAM,CAAC,KAAKmB,iBAAL,KAA2B,CAAC,CAA7B,CAAN;AAEA,YAAIe,KAAK,GAAgBN,OAAzB;AACA,YAAIO,QAAQ,GAAW,CAAvB;AACA,YAAIC,OAAO,GAAWR,OAAO,CAACf,MAA9B;AAEA,YAAIwB,OAAO,GAAG,KAAKjC,MAAnB;AACA,YAAIkC,SAAS,GAAW,KAAK1B,QAA7B;;AAEA,eAAOuB,QAAQ,GAAGC,OAAlB,EAA2B;AAC1B,cAAIG,CAAC,GAAWL,KAAK,CAACC,QAAD,CAArB;;AACA,cAAII,CAAC,IAAI,IAAT,EAAe;AACdF,YAAAA,OAAO,CAACC,SAAD,CAAP,GAAqBC,CAArB;AACA,WAFD,MAEO;AACNX,YAAAA,OAAO,GAAGA,OAAO,CAACH,QAAR,CAAiBU,QAAjB,EAA2BC,OAA3B,CAAV;AACA,iBAAKxB,QAAL,GAAgB0B,SAAhB;;AACA,gBAAI,CAACpC,SAAS,CAACsC,eAAV,CAA0BD,CAA1B,CAAL,EAAmC;AAClC,mBAAKE,gBAAL,CAAsBb,OAAO,CAACf,MAA9B;AACA,mBAAKmB,eAAL,CAAqBJ,OAArB;AACA;AACA,aAJD,MAIO;AACN,mBAAKc,eAAL,CAAqBd,OAAO,CAACf,MAA7B;AACA,mBAAKoB,cAAL,CAAoBL,OAApB;AACA;AACA;AACD;;AAEDO,UAAAA,QAAQ;AACRG,UAAAA,SAAS;AACT;;AAED,aAAK1B,QAAL,GAAgB0B,SAAhB;AACA;AA9G6B;AAAA;AAAA,sCAgHNV,OAhHM,EAgHc;AAC3C5B,QAAAA,MAAM,CAAC,KAAKmB,iBAAL,KAA2B,CAAC,CAA7B,CAAN;AAEA,YAAIe,KAAK,GAAgBN,OAAzB;AACA,YAAIO,QAAQ,GAAW,CAAvB;AACA,YAAIC,OAAO,GAAWR,OAAO,CAACf,MAA9B;AAEA,YAAI8B,OAAO,GAAG,KAAKvC,MAAnB;AACA,YAAIkC,SAAS,GAAW,KAAK1B,QAA7B;;AAEA,eAAOuB,QAAQ,GAAGC,OAAlB,EAA2B;AAC1B,cAAIG,CAAC,GAAWL,KAAK,CAACC,QAAD,CAArB;;AACA,cAAI,CAACjC,SAAS,CAACsC,eAAV,CAA0BD,CAA1B,CAAL,EAAmC;AAClCI,YAAAA,OAAO,CAACL,SAAD,CAAP,GAAqBC,CAArB;AACA,WAFD,MAEO;AACNX,YAAAA,OAAO,GAAGA,OAAO,CAACH,QAAR,CAAiBU,QAAjB,EAA2BC,OAA3B,CAAV;AACA,iBAAKxB,QAAL,GAAgB0B,SAAhB;AACA,iBAAKM,eAAL,CAAqBhB,OAAO,CAACf,MAA7B;AACA,iBAAKoB,cAAL,CAAoBL,OAApB;AACA;AACA;;AAEDO,UAAAA,QAAQ;AACRG,UAAAA,SAAS;AACT;;AAED,aAAK1B,QAAL,GAAgB0B,SAAhB;AACA;AA3I6B;AAAA;AAAA,qCA6IPV,OA7IO,EA6Ia;AAC1C,YAAIM,KAAK,GAAgBN,OAAzB;AACA,YAAIO,QAAQ,GAAW,CAAvB;AACA,YAAIC,OAAO,GAAWR,OAAO,CAACf,MAA9B;AAEA,YAAIgC,MAAM,GAAG,KAAKzC,MAAlB;AACA,YAAIkC,SAAS,GAAG,KAAK1B,QAArB;;AAEA,eAAOuB,QAAQ,GAAGC,OAAlB,EAA2B;AAC1B,cAAIG,CAAC,GAAWL,KAAK,CAACC,QAAD,CAArB;AACAA,UAAAA,QAAQ;;AACR,cAAI,KAAKhB,iBAAL,KAA2B,CAAC,CAAhC,EAAmC;AAClC,gBAAIjB,SAAS,CAAC4C,cAAV,CAAyBP,CAAzB,CAAJ,EAAiC;AAChCM,cAAAA,MAAM,CAACP,SAAD,CAAN,GAAoBS,MAAM,CAACC,YAAP,CAAoB,KAAK7B,iBAAzB,EAA4CoB,CAA5C,EAA+CU,WAA/C,CAA2D,CAA3D,CAApB;AACAX,cAAAA,SAAS;AACT,mBAAKnB,iBAAL,GAAyB,CAAC,CAA1B;AACA,aAJD,MAIO;AACN;AACA0B,cAAAA,MAAM,CAACP,SAAD,CAAN,GAAoB,KAAKnB,iBAAzB;AACAmB,cAAAA,SAAS;;AACT,kBAAIpC,SAAS,CAACsC,eAAV,CAA0BD,CAA1B,CAAJ,EAAkC;AACjC,qBAAKpB,iBAAL,GAAyBoB,CAAzB;AACA,eAFD,MAEO;AACNM,gBAAAA,MAAM,CAACP,SAAD,CAAN,GAAoBC,CAApB;AACAD,gBAAAA,SAAS;AACT,qBAAKnB,iBAAL,GAAyB,CAAC,CAA1B;AACA;AACD;AACD,WAjBD,MAiBO,IAAIjB,SAAS,CAACsC,eAAV,CAA0BD,CAA1B,CAAJ,EAAkC;AACxC,iBAAKpB,iBAAL,GAAyBoB,CAAzB;AACA,WAFM,MAEA;AACNM,YAAAA,MAAM,CAACP,SAAD,CAAN,GAAoBC,CAApB;AACAD,YAAAA,SAAS;AACT;AACD;;AAED,YAAI,KAAKnB,iBAAL,KAA2B,CAAC,CAAhC,EAAmC;AAClC;AACA0B,UAAAA,MAAM,CAACP,SAAD,CAAN,GAAoB,KAAKnB,iBAAzB;AACAmB,UAAAA,SAAS;AACT;;AAED,aAAK1B,QAAL,GAAgB0B,SAAhB;AACA;AAxL6B;AAAA;AAAA,uCA0LLY,QA1LK,EA0LW;AACxC;AACA,YAAI3B,SAAS,GAAgB,IAAIG,WAAJ,CAAgByB,IAAI,CAACC,GAAL,CAAS,KAAKxC,QAAL,GAAgBsC,QAAzB,EAAmC,KAAK9C,MAAL,CAAYS,MAAZ,IAAsB,CAAzD,CAAhB,CAA7B;AACAU,QAAAA,SAAS,CAACC,GAAV,CAAc,KAAKpB,MAAL,CAAYqB,QAAZ,CAAqB,CAArB,EAAwB,KAAKb,QAA7B,CAAd,EAAsD,CAAtD;AAEA,aAAKK,IAAL,GAAS;AAAA;AAAT;AACA,aAAKb,MAAL,GAAcmB,SAAd;AACA;AAjM6B;AAAA;AAAA,sCAmMN2B,QAnMM,EAmMU;AACvC;AACA,YAAI3B,SAAS,GAAe,IAAII,UAAJ,CAAewB,IAAI,CAACC,GAAL,CAAS,KAAKxC,QAAL,GAAgBsC,QAAzB,EAAmC,KAAK9C,MAAL,CAAYS,MAAZ,IAAsB,CAAzD,CAAf,CAA5B;AACAU,QAAAA,SAAS,CAACC,GAAV,CAAc,KAAKpB,MAAL,CAAYqB,QAAZ,CAAqB,CAArB,EAAwB,KAAKb,QAA7B,CAAd,EAAsD,CAAtD;AAEA,aAAKK,IAAL,GAAS;AAAA;AAAT;AACA,aAAKb,MAAL,GAAcmB,SAAd;AACA;AA1M6B;AAAA;AAAA,sCA4MN2B,QA5MM,EA4MU;AACvC;AACA,YAAI3B,SAAS,GAAe,IAAII,UAAJ,CAAewB,IAAI,CAACC,GAAL,CAAS,KAAKxC,QAAL,GAAgBsC,QAAzB,EAAmC,KAAK9C,MAAL,CAAYS,MAAZ,IAAsB,CAAzD,CAAf,CAA5B;AACAU,QAAAA,SAAS,CAACC,GAAV,CAAc,KAAKpB,MAAL,CAAYqB,QAAZ,CAAqB,CAArB,EAAwB,KAAKb,QAA7B,CAAd,EAAsD,CAAtD;AAEA,aAAKK,IAAL,GAAS;AAAA;AAAT;AACA,aAAKb,MAAL,GAAcmB,SAAd;AACA;AAnN6B;AAAA;AAAA,8CAwBS8B,CAxBT,EAwBkB;AAC/C,YAAIC,cAAc,GAAW,KAAKH,IAAI,CAACI,KAAL,CAAWF,CAAC,GAAG,CAAf,CAAlC;AACA,eAAOF,IAAI,CAACK,GAAL,CAAS,CAAT,EAAYF,cAAZ,CAAP;AACA;AA3B6B;AAAA;AAAA;;AAOlBnD,EAAAA,eAAA,CAAAY,OAAA,GAAOA,OAAP;AA8Mb,CArND,EAAiBZ,eAAe,GAAfL,OAAA,CAAAK,eAAA,KAAAL,OAAA,CAAAK,eAAA,GAAe,EAAf,CAAjB","file":"CodePointBuffer.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst Character = require(\"./misc/Character\");\n/**\n * Wrapper for `Uint8Array` / `Uint16Array` / `Int32Array`.\n */\nclass CodePointBuffer {\n    constructor(buffer, size) {\n        this.buffer = buffer;\n        this._position = 0;\n        this._size = size;\n    }\n    static withArray(buffer) {\n        return new CodePointBuffer(buffer, buffer.length);\n    }\n    get position() {\n        return this._position;\n    }\n    set position(newPosition) {\n        if (newPosition < 0 || newPosition > this._size) {\n            throw new RangeError();\n        }\n        this._position = newPosition;\n    }\n    get remaining() {\n        return this._size - this.position;\n    }\n    get(offset) {\n        return this.buffer[offset];\n    }\n    array() {\n        return this.buffer.slice(0, this._size);\n    }\n    static builder(initialBufferSize) {\n        return new CodePointBuffer.Builder(initialBufferSize);\n    }\n}\nexports.CodePointBuffer = CodePointBuffer;\n(function (CodePointBuffer) {\n    let Type;\n    (function (Type) {\n        Type[Type[\"BYTE\"] = 0] = \"BYTE\";\n        Type[Type[\"CHAR\"] = 1] = \"CHAR\";\n        Type[Type[\"INT\"] = 2] = \"INT\";\n    })(Type || (Type = {}));\n    class Builder {\n        constructor(initialBufferSize) {\n            this.type = 0 /* BYTE */;\n            this.buffer = new Uint8Array(initialBufferSize);\n            this.prevHighSurrogate = -1;\n            this.position = 0;\n        }\n        build() {\n            return new CodePointBuffer(this.buffer, this.position);\n        }\n        static roundUpToNextPowerOfTwo(i) {\n            let nextPowerOfTwo = 32 - Math.clz32(i - 1);\n            return Math.pow(2, nextPowerOfTwo);\n        }\n        ensureRemaining(remainingNeeded) {\n            switch (this.type) {\n                case 0 /* BYTE */:\n                    if (this.buffer.length - this.position < remainingNeeded) {\n                        let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\n                        let newBuffer = new Uint8Array(newCapacity);\n                        newBuffer.set(this.buffer.subarray(0, this.position), 0);\n                        this.buffer = newBuffer;\n                    }\n                    break;\n                case 1 /* CHAR */:\n                    if (this.buffer.length - this.position < remainingNeeded) {\n                        let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\n                        let newBuffer = new Uint16Array(newCapacity);\n                        newBuffer.set(this.buffer.subarray(0, this.position), 0);\n                        this.buffer = newBuffer;\n                    }\n                    break;\n                case 2 /* INT */:\n                    if (this.buffer.length - this.position < remainingNeeded) {\n                        let newCapacity = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\n                        let newBuffer = new Int32Array(newCapacity);\n                        newBuffer.set(this.buffer.subarray(0, this.position), 0);\n                        this.buffer = newBuffer;\n                    }\n                    break;\n            }\n        }\n        append(utf16In) {\n            this.ensureRemaining(utf16In.length);\n            this.appendArray(utf16In);\n        }\n        appendArray(utf16In) {\n            switch (this.type) {\n                case 0 /* BYTE */:\n                    this.appendArrayByte(utf16In);\n                    break;\n                case 1 /* CHAR */:\n                    this.appendArrayChar(utf16In);\n                    break;\n                case 2 /* INT */:\n                    this.appendArrayInt(utf16In);\n                    break;\n            }\n        }\n        appendArrayByte(utf16In) {\n            assert(this.prevHighSurrogate === -1);\n            let input = utf16In;\n            let inOffset = 0;\n            let inLimit = utf16In.length;\n            let outByte = this.buffer;\n            let outOffset = this.position;\n            while (inOffset < inLimit) {\n                let c = input[inOffset];\n                if (c <= 0xFF) {\n                    outByte[outOffset] = c;\n                }\n                else {\n                    utf16In = utf16In.subarray(inOffset, inLimit);\n                    this.position = outOffset;\n                    if (!Character.isHighSurrogate(c)) {\n                        this.byteToCharBuffer(utf16In.length);\n                        this.appendArrayChar(utf16In);\n                        return;\n                    }\n                    else {\n                        this.byteToIntBuffer(utf16In.length);\n                        this.appendArrayInt(utf16In);\n                        return;\n                    }\n                }\n                inOffset++;\n                outOffset++;\n            }\n            this.position = outOffset;\n        }\n        appendArrayChar(utf16In) {\n            assert(this.prevHighSurrogate === -1);\n            let input = utf16In;\n            let inOffset = 0;\n            let inLimit = utf16In.length;\n            let outChar = this.buffer;\n            let outOffset = this.position;\n            while (inOffset < inLimit) {\n                let c = input[inOffset];\n                if (!Character.isHighSurrogate(c)) {\n                    outChar[outOffset] = c;\n                }\n                else {\n                    utf16In = utf16In.subarray(inOffset, inLimit);\n                    this.position = outOffset;\n                    this.charToIntBuffer(utf16In.length);\n                    this.appendArrayInt(utf16In);\n                    return;\n                }\n                inOffset++;\n                outOffset++;\n            }\n            this.position = outOffset;\n        }\n        appendArrayInt(utf16In) {\n            let input = utf16In;\n            let inOffset = 0;\n            let inLimit = utf16In.length;\n            let outInt = this.buffer;\n            let outOffset = this.position;\n            while (inOffset < inLimit) {\n                let c = input[inOffset];\n                inOffset++;\n                if (this.prevHighSurrogate !== -1) {\n                    if (Character.isLowSurrogate(c)) {\n                        outInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0);\n                        outOffset++;\n                        this.prevHighSurrogate = -1;\n                    }\n                    else {\n                        // Dangling high surrogate\n                        outInt[outOffset] = this.prevHighSurrogate;\n                        outOffset++;\n                        if (Character.isHighSurrogate(c)) {\n                            this.prevHighSurrogate = c;\n                        }\n                        else {\n                            outInt[outOffset] = c;\n                            outOffset++;\n                            this.prevHighSurrogate = -1;\n                        }\n                    }\n                }\n                else if (Character.isHighSurrogate(c)) {\n                    this.prevHighSurrogate = c;\n                }\n                else {\n                    outInt[outOffset] = c;\n                    outOffset++;\n                }\n            }\n            if (this.prevHighSurrogate !== -1) {\n                // Dangling high surrogate\n                outInt[outOffset] = this.prevHighSurrogate;\n                outOffset++;\n            }\n            this.position = outOffset;\n        }\n        byteToCharBuffer(toAppend) {\n            // CharBuffers hold twice as much per unit as ByteBuffers, so start with half the capacity.\n            let newBuffer = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));\n            newBuffer.set(this.buffer.subarray(0, this.position), 0);\n            this.type = 1 /* CHAR */;\n            this.buffer = newBuffer;\n        }\n        byteToIntBuffer(toAppend) {\n            // IntBuffers hold four times as much per unit as ByteBuffers, so start with one quarter the capacity.\n            let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));\n            newBuffer.set(this.buffer.subarray(0, this.position), 0);\n            this.type = 2 /* INT */;\n            this.buffer = newBuffer;\n        }\n        charToIntBuffer(toAppend) {\n            // IntBuffers hold two times as much per unit as ByteBuffers, so start with one half the capacity.\n            let newBuffer = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));\n            newBuffer.set(this.buffer.subarray(0, this.position), 0);\n            this.type = 2 /* INT */;\n            this.buffer = newBuffer;\n        }\n    }\n    CodePointBuffer.Builder = Builder;\n})(CodePointBuffer = exports.CodePointBuffer || (exports.CodePointBuffer = {}));\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\nimport * as assert from \"assert\";\nimport * as Character from \"./misc/Character\";\n\n/**\n * Wrapper for `Uint8Array` / `Uint16Array` / `Int32Array`.\n */\nexport class CodePointBuffer {\n\tprivate readonly buffer: Uint8Array | Uint16Array | Int32Array;\n\tprivate _position: number;\n\tprivate _size: number;\n\n\tconstructor(buffer: Uint8Array | Uint16Array | Int32Array, size: number) {\n\t\tthis.buffer = buffer;\n\t\tthis._position = 0;\n\t\tthis._size = size;\n\t}\n\n\tpublic static withArray(buffer: Uint8Array | Uint16Array | Int32Array): CodePointBuffer {\n\t\treturn new CodePointBuffer(buffer, buffer.length);\n\t}\n\n\tpublic get position(): number {\n\t\treturn this._position;\n\t}\n\n\tpublic set position(newPosition: number) {\n\t\tif (newPosition < 0 || newPosition > this._size) {\n\t\t\tthrow new RangeError();\n\t\t}\n\n\t\tthis._position = newPosition;\n\t}\n\n\tpublic get remaining(): number {\n\t\treturn this._size - this.position;\n\t}\n\n\tpublic get(offset: number): number {\n\t\treturn this.buffer[offset];\n\t}\n\n\tpublic array(): Uint8Array | Uint16Array | Int32Array {\n\t\treturn this.buffer.slice(0, this._size);\n\t}\n\n\tpublic static builder(initialBufferSize: number): CodePointBuffer.Builder {\n\t\treturn new CodePointBuffer.Builder(initialBufferSize);\n\t}\n}\n\nexport namespace CodePointBuffer {\n\tconst enum Type {\n\t\tBYTE,\n\t\tCHAR,\n\t\tINT,\n\t}\n\n\texport class Builder {\n\t\tprivate type: Type;\n\t\tprivate buffer: Uint8Array | Uint16Array | Int32Array;\n\t\tprivate prevHighSurrogate: number;\n\t\tprivate position: number;\n\n\t\tconstructor(initialBufferSize: number) {\n\t\t\tthis.type = Type.BYTE;\n\t\t\tthis.buffer = new Uint8Array(initialBufferSize);\n\t\t\tthis.prevHighSurrogate = -1;\n\t\t\tthis.position = 0;\n\t\t}\n\n\t\tpublic build(): CodePointBuffer {\n\t\t\treturn new CodePointBuffer(this.buffer, this.position);\n\t\t}\n\n\t\tprivate static roundUpToNextPowerOfTwo(i: number): number {\n\t\t\tlet nextPowerOfTwo: number = 32 - Math.clz32(i - 1);\n\t\t\treturn Math.pow(2, nextPowerOfTwo);\n\t\t}\n\n\t\tpublic ensureRemaining(remainingNeeded: number): void {\n\t\t\tswitch (this.type) {\n\t\t\t\tcase Type.BYTE:\n\t\t\t\t\tif (this.buffer.length - this.position < remainingNeeded) {\n\t\t\t\t\t\tlet newCapacity: number = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\n\t\t\t\t\t\tlet newBuffer: Uint8Array = new Uint8Array(newCapacity);\n\t\t\t\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\n\t\t\t\t\t\tthis.buffer = newBuffer;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Type.CHAR:\n\t\t\t\t\tif (this.buffer.length - this.position < remainingNeeded) {\n\t\t\t\t\t\tlet newCapacity: number = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\n\t\t\t\t\t\tlet newBuffer: Uint16Array = new Uint16Array(newCapacity);\n\t\t\t\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\n\t\t\t\t\t\tthis.buffer = newBuffer;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase Type.INT:\n\t\t\t\t\tif (this.buffer.length - this.position < remainingNeeded) {\n\t\t\t\t\t\tlet newCapacity: number = Builder.roundUpToNextPowerOfTwo(this.buffer.length + remainingNeeded);\n\t\t\t\t\t\tlet newBuffer: Int32Array = new Int32Array(newCapacity);\n\t\t\t\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\n\t\t\t\t\t\tthis.buffer = newBuffer;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tpublic append(utf16In: Uint16Array): void {\n\t\t\tthis.ensureRemaining(utf16In.length);\n\t\t\tthis.appendArray(utf16In);\n\t\t}\n\n\t\tprivate appendArray(utf16In: Uint16Array): void {\n\t\t\tswitch (this.type) {\n\t\t\t\tcase Type.BYTE:\n\t\t\t\t\tthis.appendArrayByte(utf16In);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Type.CHAR:\n\t\t\t\t\tthis.appendArrayChar(utf16In);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Type.INT:\n\t\t\t\t\tthis.appendArrayInt(utf16In);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tprivate appendArrayByte(utf16In: Uint16Array): void {\n\t\t\tassert(this.prevHighSurrogate === -1);\n\n\t\t\tlet input: Uint16Array = utf16In;\n\t\t\tlet inOffset: number = 0;\n\t\t\tlet inLimit: number = utf16In.length;\n\n\t\t\tlet outByte = this.buffer;\n\t\t\tlet outOffset: number = this.position;\n\n\t\t\twhile (inOffset < inLimit) {\n\t\t\t\tlet c: number = input[inOffset];\n\t\t\t\tif (c <= 0xFF) {\n\t\t\t\t\toutByte[outOffset] = c;\n\t\t\t\t} else {\n\t\t\t\t\tutf16In = utf16In.subarray(inOffset, inLimit);\n\t\t\t\t\tthis.position = outOffset;\n\t\t\t\t\tif (!Character.isHighSurrogate(c)) {\n\t\t\t\t\t\tthis.byteToCharBuffer(utf16In.length);\n\t\t\t\t\t\tthis.appendArrayChar(utf16In);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.byteToIntBuffer(utf16In.length);\n\t\t\t\t\t\tthis.appendArrayInt(utf16In);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tinOffset++;\n\t\t\t\toutOffset++;\n\t\t\t}\n\n\t\t\tthis.position = outOffset;\n\t\t}\n\n\t\tprivate appendArrayChar(utf16In: Uint16Array): void {\n\t\t\tassert(this.prevHighSurrogate === -1);\n\n\t\t\tlet input: Uint16Array = utf16In;\n\t\t\tlet inOffset: number = 0;\n\t\t\tlet inLimit: number = utf16In.length;\n\n\t\t\tlet outChar = this.buffer;\n\t\t\tlet outOffset: number = this.position;\n\n\t\t\twhile (inOffset < inLimit) {\n\t\t\t\tlet c: number = input[inOffset];\n\t\t\t\tif (!Character.isHighSurrogate(c)) {\n\t\t\t\t\toutChar[outOffset] = c;\n\t\t\t\t} else {\n\t\t\t\t\tutf16In = utf16In.subarray(inOffset, inLimit);\n\t\t\t\t\tthis.position = outOffset;\n\t\t\t\t\tthis.charToIntBuffer(utf16In.length);\n\t\t\t\t\tthis.appendArrayInt(utf16In);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tinOffset++;\n\t\t\t\toutOffset++;\n\t\t\t}\n\n\t\t\tthis.position = outOffset;\n\t\t}\n\n\t\tprivate appendArrayInt(utf16In: Uint16Array): void {\n\t\t\tlet input: Uint16Array = utf16In;\n\t\t\tlet inOffset: number = 0;\n\t\t\tlet inLimit: number = utf16In.length;\n\n\t\t\tlet outInt = this.buffer;\n\t\t\tlet outOffset = this.position;\n\n\t\t\twhile (inOffset < inLimit) {\n\t\t\t\tlet c: number = input[inOffset];\n\t\t\t\tinOffset++;\n\t\t\t\tif (this.prevHighSurrogate !== -1) {\n\t\t\t\t\tif (Character.isLowSurrogate(c)) {\n\t\t\t\t\t\toutInt[outOffset] = String.fromCharCode(this.prevHighSurrogate, c).codePointAt(0)!;\n\t\t\t\t\t\toutOffset++;\n\t\t\t\t\t\tthis.prevHighSurrogate = -1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Dangling high surrogate\n\t\t\t\t\t\toutInt[outOffset] = this.prevHighSurrogate;\n\t\t\t\t\t\toutOffset++;\n\t\t\t\t\t\tif (Character.isHighSurrogate(c)) {\n\t\t\t\t\t\t\tthis.prevHighSurrogate = c;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\toutInt[outOffset] = c;\n\t\t\t\t\t\t\toutOffset++;\n\t\t\t\t\t\t\tthis.prevHighSurrogate = -1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (Character.isHighSurrogate(c)) {\n\t\t\t\t\tthis.prevHighSurrogate = c;\n\t\t\t\t} else {\n\t\t\t\t\toutInt[outOffset] = c;\n\t\t\t\t\toutOffset++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (this.prevHighSurrogate !== -1) {\n\t\t\t\t// Dangling high surrogate\n\t\t\t\toutInt[outOffset] = this.prevHighSurrogate;\n\t\t\t\toutOffset++;\n\t\t\t}\n\n\t\t\tthis.position = outOffset;\n\t\t}\n\n\t\tprivate byteToCharBuffer(toAppend: number): void {\n\t\t\t// CharBuffers hold twice as much per unit as ByteBuffers, so start with half the capacity.\n\t\t\tlet newBuffer: Uint16Array = new Uint16Array(Math.max(this.position + toAppend, this.buffer.length >> 1));\n\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\n\n\t\t\tthis.type = Type.CHAR;\n\t\t\tthis.buffer = newBuffer;\n\t\t}\n\n\t\tprivate byteToIntBuffer(toAppend: number): void {\n\t\t\t// IntBuffers hold four times as much per unit as ByteBuffers, so start with one quarter the capacity.\n\t\t\tlet newBuffer: Int32Array = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 2));\n\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\n\n\t\t\tthis.type = Type.INT;\n\t\t\tthis.buffer = newBuffer;\n\t\t}\n\n\t\tprivate charToIntBuffer(toAppend: number): void {\n\t\t\t// IntBuffers hold two times as much per unit as ByteBuffers, so start with one half the capacity.\n\t\t\tlet newBuffer: Int32Array = new Int32Array(Math.max(this.position + toAppend, this.buffer.length >> 1));\n\t\t\tnewBuffer.set(this.buffer.subarray(0, this.position), 0);\n\n\t\t\tthis.type = Type.INT;\n\t\t\tthis.buffer = newBuffer;\n\t\t}\n\t}\n}\n"]}