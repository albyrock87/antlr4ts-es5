{"version":3,"sources":["ParserRuleContext.js","../src/ParserRuleContext.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","exports","value","ErrorNode_1","require","Interval_1","Decorators_1","RuleContext_1","TerminalNode_1","ParserRuleContext","parent","invokingStateNumber","ctx","_parent","invokingState","_start","_stop","children","child","ErrorNode","addChild","listener","t","push","result","TerminalNode","setParent","addAnyChild","RuleContext","node","errorNode","badToken","pop","ctxType","RangeError","tryGetChild","undefined","Error","j","o","ttype","tryGetToken","symbol","type","tokens","getChild","contexts","recognizer","rules","getRuleInvocationStack","reverse","TypeError","Interval","INVALID","tokenIndex","of","EMPTY","Override","prototype"],"mappings":"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","file":"ParserRuleContext.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// ConvertTo-TS run at 2016-10-04T11:26:56.6285494-07:00\nconst ErrorNode_1 = require(\"./tree/ErrorNode\");\nconst Interval_1 = require(\"./misc/Interval\");\nconst Decorators_1 = require(\"./Decorators\");\nconst RuleContext_1 = require(\"./RuleContext\");\nconst TerminalNode_1 = require(\"./tree/TerminalNode\");\n/** A rule invocation record for parsing.\n *\n *  Contains all of the information about the current rule not stored in the\n *  RuleContext. It handles parse tree children list, Any ATN state\n *  tracing, and the default values available for rule invocations:\n *  start, stop, rule index, current alt number.\n *\n *  Subclasses made for each rule and grammar track the parameters,\n *  return values, locals, and labels specific to that rule. These\n *  are the objects that are returned from rules.\n *\n *  Note text is not an actual field of a rule return value; it is computed\n *  from start and stop using the input stream's toString() method.  I\n *  could add a ctor to this so that we can pass in and store the input\n *  stream, but I'm not sure we want to do that.  It would seem to be undefined\n *  to get the .text property anyway if the rule matches tokens from multiple\n *  input streams.\n *\n *  I do not use getters for fields of objects that are used simply to\n *  group values such as this aggregate.  The getters/setters are there to\n *  satisfy the superclass interface.\n */\nclass ParserRuleContext extends RuleContext_1.RuleContext {\n    constructor(parent, invokingStateNumber) {\n        if (invokingStateNumber == null) {\n            super();\n        }\n        else {\n            super(parent, invokingStateNumber);\n        }\n    }\n    static emptyContext() {\n        return ParserRuleContext.EMPTY;\n    }\n    /**\n     * COPY a ctx (I'm deliberately not using copy constructor) to avoid\n     * confusion with creating node with parent. Does not copy children\n     * (except error leaves).\n     *\n     * This is used in the generated parser code to flip a generic XContext\n     * node for rule X to a YContext for alt label Y. In that sense, it is not\n     * really a generic copy function.\n     *\n     * If we do an error sync() at start of a rule, we might add error nodes\n     * to the generic XContext so this function must copy those nodes to the\n     * YContext as well else they are lost!\n     */\n    copyFrom(ctx) {\n        this._parent = ctx._parent;\n        this.invokingState = ctx.invokingState;\n        this._start = ctx._start;\n        this._stop = ctx._stop;\n        // copy any error nodes to alt label node\n        if (ctx.children) {\n            this.children = [];\n            // reset parent pointer for any error nodes\n            for (let child of ctx.children) {\n                if (child instanceof ErrorNode_1.ErrorNode) {\n                    this.addChild(child);\n                }\n            }\n        }\n    }\n    // Double dispatch methods for listeners\n    enterRule(listener) {\n        // intentionally empty\n    }\n    exitRule(listener) {\n        // intentionally empty\n    }\n    /** Add a parse tree node to this as a child.  Works for\n     *  internal and leaf nodes. Does not set parent link;\n     *  other add methods must do that. Other addChild methods\n     *  call this.\n     *\n     *  We cannot set the parent pointer of the incoming node\n     *  because the existing interfaces do not have a setParent()\n     *  method and I don't want to break backward compatibility for this.\n     *\n     *  @since 4.7\n     */\n    addAnyChild(t) {\n        if (!this.children) {\n            this.children = [t];\n        }\n        else {\n            this.children.push(t);\n        }\n        return t;\n    }\n    addChild(t) {\n        let result;\n        if (t instanceof TerminalNode_1.TerminalNode) {\n            t.setParent(this);\n            this.addAnyChild(t);\n            return;\n        }\n        else if (t instanceof RuleContext_1.RuleContext) {\n            // Does not set parent link\n            this.addAnyChild(t);\n            return;\n        }\n        else {\n            // Deprecated code path\n            t = new TerminalNode_1.TerminalNode(t);\n            this.addAnyChild(t);\n            t.setParent(this);\n            return t;\n        }\n    }\n    addErrorNode(node) {\n        if (node instanceof ErrorNode_1.ErrorNode) {\n            const errorNode = node;\n            errorNode.setParent(this);\n            return this.addAnyChild(errorNode);\n        }\n        else {\n            // deprecated path\n            const badToken = node;\n            let t = new ErrorNode_1.ErrorNode(badToken);\n            this.addAnyChild(t);\n            t.setParent(this);\n            return t;\n        }\n    }\n    //\tpublic void trace(int s) {\n    //\t\tif ( states==null ) states = new ArrayList<Integer>();\n    //\t\tstates.add(s);\n    //\t}\n    /** Used by enterOuterAlt to toss out a RuleContext previously added as\n     *  we entered a rule. If we have # label, we will need to remove\n     *  generic ruleContext object.\n     */\n    removeLastChild() {\n        if (this.children) {\n            this.children.pop();\n        }\n    }\n    get parent() {\n        let parent = super.parent;\n        if (parent === undefined || parent instanceof ParserRuleContext) {\n            return parent;\n        }\n        throw new TypeError(\"Invalid parent type for ParserRuleContext\");\n    }\n    // Note: in TypeScript, order or arguments reversed\n    getChild(i, ctxType) {\n        if (!this.children || i < 0 || i >= this.children.length) {\n            throw new RangeError(\"index parameter must be between >= 0 and <= number of children.\");\n        }\n        if (ctxType == null) {\n            return this.children[i];\n        }\n        let result = this.tryGetChild(i, ctxType);\n        if (result === undefined) {\n            throw new Error(\"The specified node does not exist\");\n        }\n        return result;\n    }\n    tryGetChild(i, ctxType) {\n        if (!this.children || i < 0 || i >= this.children.length) {\n            return undefined;\n        }\n        let j = -1; // what node with ctxType have we found?\n        for (let o of this.children) {\n            if (o instanceof ctxType) {\n                j++;\n                if (j === i) {\n                    return o;\n                }\n            }\n        }\n        return undefined;\n    }\n    getToken(ttype, i) {\n        let result = this.tryGetToken(ttype, i);\n        if (result === undefined) {\n            throw new Error(\"The specified token does not exist\");\n        }\n        return result;\n    }\n    tryGetToken(ttype, i) {\n        if (!this.children || i < 0 || i >= this.children.length) {\n            return undefined;\n        }\n        let j = -1; // what token with ttype have we found?\n        for (let o of this.children) {\n            if (o instanceof TerminalNode_1.TerminalNode) {\n                let symbol = o.symbol;\n                if (symbol.type === ttype) {\n                    j++;\n                    if (j === i) {\n                        return o;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n    getTokens(ttype) {\n        let tokens = [];\n        if (!this.children) {\n            return tokens;\n        }\n        for (let o of this.children) {\n            if (o instanceof TerminalNode_1.TerminalNode) {\n                let symbol = o.symbol;\n                if (symbol.type === ttype) {\n                    tokens.push(o);\n                }\n            }\n        }\n        return tokens;\n    }\n    get ruleContext() {\n        return this;\n    }\n    // NOTE: argument order change from Java version\n    getRuleContext(i, ctxType) {\n        return this.getChild(i, ctxType);\n    }\n    tryGetRuleContext(i, ctxType) {\n        return this.tryGetChild(i, ctxType);\n    }\n    getRuleContexts(ctxType) {\n        let contexts = [];\n        if (!this.children) {\n            return contexts;\n        }\n        for (let o of this.children) {\n            if (o instanceof ctxType) {\n                contexts.push(o);\n            }\n        }\n        return contexts;\n    }\n    get childCount() {\n        return this.children ? this.children.length : 0;\n    }\n    get sourceInterval() {\n        if (!this._start) {\n            return Interval_1.Interval.INVALID;\n        }\n        if (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {\n            return Interval_1.Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1); // empty\n        }\n        return Interval_1.Interval.of(this._start.tokenIndex, this._stop.tokenIndex);\n    }\n    /**\n     * Get the initial token in this context.\n     * Note that the range from start to stop is inclusive, so for rules that do not consume anything\n     * (for example, zero length or error productions) this token may exceed stop.\n     */\n    get start() { return this._start; }\n    /**\n     * Get the final token in this context.\n     * Note that the range from start to stop is inclusive, so for rules that do not consume anything\n     * (for example, zero length or error productions) this token may precede start.\n     */\n    get stop() { return this._stop; }\n    /** Used for rule context info debugging during parse-time, not so much for ATN debugging */\n    toInfoString(recognizer) {\n        let rules = recognizer.getRuleInvocationStack(this).reverse();\n        return \"ParserRuleContext\" + rules + \"{\" +\n            \"start=\" + this._start +\n            \", stop=\" + this._stop +\n            \"}\";\n    }\n}\nParserRuleContext.EMPTY = new ParserRuleContext();\n__decorate([\n    Decorators_1.Override\n    /** Override to make type more specific */\n], ParserRuleContext.prototype, \"parent\", null);\n__decorate([\n    Decorators_1.Override\n], ParserRuleContext.prototype, \"childCount\", null);\n__decorate([\n    Decorators_1.Override\n], ParserRuleContext.prototype, \"sourceInterval\", null);\nexports.ParserRuleContext = ParserRuleContext;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:56.6285494-07:00\nimport { ErrorNode } from \"./tree/ErrorNode\";\nimport { Interval } from \"./misc/Interval\";\nimport { Override } from \"./Decorators\";\nimport { Parser } from \"./Parser\";\nimport { ParseTree } from \"./tree/ParseTree\";\nimport { ParseTreeListener } from \"./tree/ParseTreeListener\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { RuleContext } from \"./RuleContext\";\nimport { TerminalNode } from \"./tree/TerminalNode\";\nimport { Token } from \"./Token\";\n\n/** A rule invocation record for parsing.\n *\n *  Contains all of the information about the current rule not stored in the\n *  RuleContext. It handles parse tree children list, Any ATN state\n *  tracing, and the default values available for rule invocations:\n *  start, stop, rule index, current alt number.\n *\n *  Subclasses made for each rule and grammar track the parameters,\n *  return values, locals, and labels specific to that rule. These\n *  are the objects that are returned from rules.\n *\n *  Note text is not an actual field of a rule return value; it is computed\n *  from start and stop using the input stream's toString() method.  I\n *  could add a ctor to this so that we can pass in and store the input\n *  stream, but I'm not sure we want to do that.  It would seem to be undefined\n *  to get the .text property anyway if the rule matches tokens from multiple\n *  input streams.\n *\n *  I do not use getters for fields of objects that are used simply to\n *  group values such as this aggregate.  The getters/setters are there to\n *  satisfy the superclass interface.\n */\nexport class ParserRuleContext extends RuleContext {\n\tprivate static readonly EMPTY: ParserRuleContext = new ParserRuleContext();\n\n\t/** If we are debugging or building a parse tree for a visitor,\n\t *  we need to track all of the tokens and rule invocations associated\n\t *  with this rule's context. This is empty for parsing w/o tree constr.\n\t *  operation because we don't the need to track the details about\n\t *  how we parse this rule.\n\t */\n\tpublic children?: ParseTree[];\n\n\t/** For debugging/tracing purposes, we want to track all of the nodes in\n\t *  the ATN traversed by the parser for a particular rule.\n\t *  This list indicates the sequence of ATN nodes used to match\n\t *  the elements of the children list. This list does not include\n\t *  ATN nodes and other rules used to match rule invocations. It\n\t *  traces the rule invocation node itself but nothing inside that\n\t *  other rule's ATN submachine.\n\t *\n\t *  There is NOT a one-to-one correspondence between the children and\n\t *  states list. There are typically many nodes in the ATN traversed\n\t *  for each element in the children list. For example, for a rule\n\t *  invocation there is the invoking state and the following state.\n\t *\n\t *  The parser state property updates field s and adds it to this list\n\t *  if we are debugging/tracing.\n\t *\n\t *  This does not trace states visited during prediction.\n\t */\n//\tpublic Array<number> states;\n\n\tpublic _start: Token;\n\tpublic _stop: Token | undefined;\n\n\t/**\n\t * The exception that forced this rule to return. If the rule successfully\n\t * completed, this is `undefined`.\n\t */\n\tpublic exception?: RecognitionException;\n\n\tconstructor();\n\tconstructor(parent: ParserRuleContext | undefined, invokingStateNumber: number);\n\tconstructor(parent?: ParserRuleContext, invokingStateNumber?: number) {\n\t\tif (invokingStateNumber == null) {\n\t\t\tsuper();\n\t\t} else {\n\t\t\tsuper(parent, invokingStateNumber);\n\t\t}\n\t}\n\n\tpublic static emptyContext(): ParserRuleContext {\n\t\treturn ParserRuleContext.EMPTY;\n\t}\n\n\t/**\n\t * COPY a ctx (I'm deliberately not using copy constructor) to avoid\n\t * confusion with creating node with parent. Does not copy children\n\t * (except error leaves).\n\t *\n\t * This is used in the generated parser code to flip a generic XContext\n\t * node for rule X to a YContext for alt label Y. In that sense, it is not\n\t * really a generic copy function.\n\t *\n\t * If we do an error sync() at start of a rule, we might add error nodes\n\t * to the generic XContext so this function must copy those nodes to the\n\t * YContext as well else they are lost!\n\t */\n\tpublic copyFrom(ctx: ParserRuleContext): void {\n\t\tthis._parent = ctx._parent;\n\t\tthis.invokingState = ctx.invokingState;\n\n\t\tthis._start = ctx._start;\n\t\tthis._stop = ctx._stop;\n\n\t\t// copy any error nodes to alt label node\n\t\tif (ctx.children) {\n\t\t\tthis.children = [];\n\t\t\t// reset parent pointer for any error nodes\n\t\t\tfor (let child of ctx.children) {\n\t\t\t\tif (child instanceof ErrorNode) {\n\t\t\t\t\tthis.addChild(child);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Double dispatch methods for listeners\n\n\tpublic enterRule(listener: ParseTreeListener): void {\n\t\t// intentionally empty\n\t}\n\tpublic exitRule(listener: ParseTreeListener): void {\n\t\t// intentionally empty\n\t}\n\n\t/** Add a parse tree node to this as a child.  Works for\n\t *  internal and leaf nodes. Does not set parent link;\n\t *  other add methods must do that. Other addChild methods\n\t *  call this.\n\t *\n\t *  We cannot set the parent pointer of the incoming node\n\t *  because the existing interfaces do not have a setParent()\n\t *  method and I don't want to break backward compatibility for this.\n\t *\n\t *  @since 4.7\n\t */\n\tpublic addAnyChild<T extends ParseTree>(t: T): T {\n\t\tif (!this.children) {\n\t\t\tthis.children = [t];\n\t\t} else {\n\t\t\tthis.children.push(t);\n\t\t}\n\n\t\treturn t;\n\t}\n\n\t/** Add a token leaf node child and force its parent to be this node. */\n\tpublic addChild(t: TerminalNode): void;\n\tpublic addChild(ruleInvocation: RuleContext): void;\n\t/**\n\t * Add a child to this node based upon matchedToken. It\n\t * creates a TerminalNodeImpl rather than using\n\t * {@link Parser#createTerminalNode(ParserRuleContext, Token)}. I'm leaving this\n\t * in for compatibility but the parser doesn't use this anymore.\n\t *\n\t * @deprecated Use another overload instead.\n\t */\n\tpublic addChild(matchedToken: Token): TerminalNode;\n\tpublic addChild(t: TerminalNode | RuleContext | Token): TerminalNode | void {\n\t\tlet result: TerminalNode | void;\n\t\tif (t instanceof TerminalNode) {\n\t\t\tt.setParent(this);\n\t\t\tthis.addAnyChild(t);\n\t\t\treturn;\n\t\t} else if (t instanceof RuleContext) {\n\t\t\t// Does not set parent link\n\t\t\tthis.addAnyChild(t);\n\t\t\treturn;\n\t\t} else {\n\t\t\t// Deprecated code path\n\t\t\tt = new TerminalNode(t);\n\t\t\tthis.addAnyChild(t);\n\t\t\tt.setParent(this);\n\t\t\treturn t;\n\t\t}\n\t}\n\n\t/** Add an error node child and force its parent to be this node.\n\t *\n\t * @since 4.7\n\t */\n\tpublic addErrorNode(errorNode: ErrorNode): ErrorNode;\n\n\t/**\n\t * Add a child to this node based upon badToken. It\n\t * creates a ErrorNode rather than using\n\t * {@link Parser#createErrorNode(ParserRuleContext, Token)}. I'm leaving this\n\t * in for compatibility but the parser doesn't use this anymore.\n\t *\n\t * @deprecated Use another overload instead.\n\t */\n\tpublic addErrorNode(badToken: Token): ErrorNode;\n\tpublic addErrorNode(node: ErrorNode | Token): ErrorNode {\n\t\tif (node instanceof ErrorNode) {\n\t\t\tconst errorNode: ErrorNode = node;\n\t\t\terrorNode.setParent(this);\n\t\t\treturn this.addAnyChild(errorNode);\n\t\t} else {\n\t\t\t// deprecated path\n\t\t\tconst badToken: Token = node;\n\t\t\tlet t = new ErrorNode(badToken);\n\t\t\tthis.addAnyChild(t);\n\t\t\tt.setParent(this);\n\t\t\treturn t;\n\t\t}\n\t}\n\n//\tpublic void trace(int s) {\n//\t\tif ( states==null ) states = new ArrayList<Integer>();\n//\t\tstates.add(s);\n//\t}\n\n\t/** Used by enterOuterAlt to toss out a RuleContext previously added as\n\t *  we entered a rule. If we have # label, we will need to remove\n\t *  generic ruleContext object.\n\t */\n\tpublic removeLastChild(): void {\n\t\tif (this.children) {\n\t\t\tthis.children.pop();\n\t\t}\n\t}\n\n\t@Override\n\t/** Override to make type more specific */\n\tget parent(): ParserRuleContext | undefined {\n\t\tlet parent = super.parent;\n\t\tif (parent === undefined || parent instanceof ParserRuleContext) {\n\t\t\treturn parent;\n\t\t}\n\n\t\tthrow new TypeError(\"Invalid parent type for ParserRuleContext\");\n\t}\n\n\tpublic getChild(i: number): ParseTree;\n\tpublic getChild<T extends ParseTree>(i: number, ctxType: { new (...args: any[]): T; }): T;\n\t// Note: in TypeScript, order or arguments reversed\n\tpublic getChild<T extends ParseTree>(i: number, ctxType?: { new (...args: any[]): T; }): ParseTree {\n\t\tif (!this.children || i < 0 || i >= this.children.length) {\n\t\t\tthrow new RangeError(\"index parameter must be between >= 0 and <= number of children.\");\n\t\t}\n\n\t\tif (ctxType == null) {\n\t\t\treturn this.children[i];\n\t\t}\n\n\t\tlet result = this.tryGetChild(i, ctxType);\n\t\tif (result === undefined) {\n\t\t\tthrow new Error(\"The specified node does not exist\");\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic tryGetChild<T extends ParseTree>(i: number, ctxType: { new (...args: any[]): T; }): T | undefined {\n\t\tif (!this.children || i < 0 || i >= this.children.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet j: number = -1; // what node with ctxType have we found?\n\t\tfor (let o of this.children) {\n\t\t\tif (o instanceof ctxType) {\n\t\t\t\tj++;\n\t\t\t\tif (j === i) {\n\t\t\t\t\treturn o;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tpublic getToken(ttype: number, i: number): TerminalNode {\n\t\tlet result = this.tryGetToken(ttype, i);\n\t\tif (result === undefined) {\n\t\t\tthrow new Error(\"The specified token does not exist\");\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tpublic tryGetToken(ttype: number, i: number): TerminalNode | undefined {\n\t\tif (!this.children || i < 0 || i >= this.children.length) {\n\t\t\treturn undefined;\n\t\t}\n\n\t\tlet j: number = -1; // what token with ttype have we found?\n\t\tfor (let o of this.children) {\n\t\t\tif (o instanceof TerminalNode) {\n\t\t\t\tlet symbol: Token = o.symbol;\n\t\t\t\tif (symbol.type === ttype) {\n\t\t\t\t\tj++;\n\t\t\t\t\tif (j === i) {\n\t\t\t\t\t\treturn o;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tpublic getTokens(ttype: number): TerminalNode[] {\n\t\tlet tokens: TerminalNode[] = [];\n\n\t\tif (!this.children) {\n\t\t\treturn tokens;\n\t\t}\n\n\t\tfor (let o of this.children) {\n\t\t\tif (o instanceof TerminalNode) {\n\t\t\t\tlet symbol = o.symbol;\n\t\t\t\tif (symbol.type === ttype) {\n\t\t\t\t\ttokens.push(o);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn tokens;\n\t}\n\n\tget ruleContext(): this {\n\t\treturn this;\n\t}\n\n\t// NOTE: argument order change from Java version\n\tpublic getRuleContext<T extends ParserRuleContext>(i: number, ctxType: { new (...args: any[]): T; }): T {\n\t\treturn this.getChild(i, ctxType);\n\t}\n\n\tpublic tryGetRuleContext<T extends ParserRuleContext>(i: number, ctxType: { new (...args: any[]): T; }): T | undefined {\n\t\treturn this.tryGetChild(i, ctxType);\n\t}\n\n\tpublic getRuleContexts<T extends ParserRuleContext>(ctxType: { new (...args: any[]): T; }): T[] {\n\t\tlet contexts: T[] = [];\n\t\tif (!this.children) {\n\t\t\treturn contexts;\n\t\t}\n\n\t\tfor (let o of this.children) {\n\t\t\tif (o instanceof ctxType) {\n\t\t\t\tcontexts.push(o);\n\t\t\t}\n\t\t}\n\n\t\treturn contexts;\n\t}\n\n\t@Override\n\tget childCount() {\n\t\treturn this.children ? this.children.length : 0;\n\t}\n\n\t@Override\n\tget sourceInterval(): Interval {\n\t\tif (!this._start) {\n\t\t\treturn Interval.INVALID;\n\t\t}\n\t\tif (!this._stop || this._stop.tokenIndex < this._start.tokenIndex) {\n\t\t\treturn Interval.of(this._start.tokenIndex, this._start.tokenIndex - 1); // empty\n\t\t}\n\t\treturn Interval.of(this._start.tokenIndex, this._stop.tokenIndex);\n\t}\n\n\t/**\n\t * Get the initial token in this context.\n\t * Note that the range from start to stop is inclusive, so for rules that do not consume anything\n\t * (for example, zero length or error productions) this token may exceed stop.\n\t */\n\tget start(): Token { return this._start; }\n\t/**\n\t * Get the final token in this context.\n\t * Note that the range from start to stop is inclusive, so for rules that do not consume anything\n\t * (for example, zero length or error productions) this token may precede start.\n\t */\n\tget stop(): Token | undefined { return this._stop; }\n\n\t/** Used for rule context info debugging during parse-time, not so much for ATN debugging */\n\tpublic toInfoString(recognizer: Parser): string {\n\t\tlet rules: string[] =\n\t\t\trecognizer.getRuleInvocationStack(this).reverse();\n\t\treturn \"ParserRuleContext\" + rules + \"{\" +\n\t\t\t\"start=\" + this._start +\n\t\t\t\", stop=\" + this._stop +\n\t\t\t\"}\";\n\t}\n}\n"]}