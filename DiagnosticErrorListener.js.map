{"version":3,"sources":["DiagnosticErrorListener.js","../src/DiagnosticErrorListener.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","exports","value","BitSet_1","require","Decorators_1","Interval_1","DiagnosticErrorListener","exactOnly","recognizer","offendingSymbol","line","charPositionInLine","msg","e","dfa","startIndex","stopIndex","exact","ambigAlts","configs","decision","getDecisionDescription","conflictingAlts","getConflictingAlts","text","inputStream","getText","Interval","of","message","notifyErrorListeners","conflictState","format","prediction","acceptState","ruleIndex","atnStartState","ruleNames","toString","ruleName","reportedAlts","result","BitSet","config","set","alt","Override","prototype","NotNull"],"mappings":"AAAA;ACAA;;;;;;;;;;;;;ADKA,IAAIA,UAAU,GAAI,UAAQ,SAAKA,UAAd,IAA6B,UAAUC,UAAV,EAAsBC,MAAtB,EAA8BC,GAA9B,EAAmCC,IAAnC,EAAyC;AACnF,MAAIC,CAAC,GAAGC,SAAS,CAACC,MAAlB;AAAA,MAA0BC,CAAC,GAAGH,CAAC,GAAG,CAAJ,GAAQH,MAAR,GAAiBE,IAAI,KAAK,IAAT,GAAgBA,IAAI,GAAGK,MAAM,CAACC,wBAAP,CAAgCR,MAAhC,EAAwCC,GAAxC,CAAvB,GAAsEC,IAArH;AAAA,MAA2HO,CAA3H;AACA,MAAI,QAAOC,OAAP,0DAAOA,OAAP,OAAmB,QAAnB,IAA+B,OAAOA,OAAO,CAACC,QAAf,KAA4B,UAA/D,EAA2EL,CAAC,GAAGI,OAAO,CAACC,QAAR,CAAiBZ,UAAjB,EAA6BC,MAA7B,EAAqCC,GAArC,EAA0CC,IAA1C,CAAJ,CAA3E,KACK,KAAK,IAAIU,CAAC,GAAGb,UAAU,CAACM,MAAX,GAAoB,CAAjC,EAAoCO,CAAC,IAAI,CAAzC,EAA4CA,CAAC,EAA7C;AAAiD,QAAIH,CAAC,GAAGV,UAAU,CAACa,CAAD,CAAlB,EAAuBN,CAAC,GAAG,CAACH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACH,CAAD,CAAT,GAAeH,CAAC,GAAG,CAAJ,GAAQM,CAAC,CAACT,MAAD,EAASC,GAAT,EAAcK,CAAd,CAAT,GAA4BG,CAAC,CAACT,MAAD,EAASC,GAAT,CAA7C,KAA+DK,CAAnE;AAAxE;AACL,SAAOH,CAAC,GAAG,CAAJ,IAASG,CAAT,IAAcC,MAAM,CAACM,cAAP,CAAsBb,MAAtB,EAA8BC,GAA9B,EAAmCK,CAAnC,CAAd,EAAqDA,CAA5D;AACH,CALD;;AAMA,IAAIQ,OAAO,GAAI,UAAQ,SAAKA,OAAd,IAA0B,UAAUC,UAAV,EAAsBC,SAAtB,EAAiC;AACrE,SAAO,UAAUhB,MAAV,EAAkBC,GAAlB,EAAuB;AAAEe,IAAAA,SAAS,CAAChB,MAAD,EAASC,GAAT,EAAcc,UAAd,CAAT;AAAqC,GAArE;AACH,CAFD;;AAGAR,MAAM,CAACM,cAAP,CAAsBI,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;ACLA,IAAAC,QAAA,GAAAC,OAAA,CAAA,eAAA,CAAA;;AAQA,IAAAC,YAAA,GAAAD,OAAA,CAAA,cAAA,CAAA;;AACA,IAAAE,UAAA,GAAAF,OAAA,CAAA,iBAAA,CAAA;AAEA;;;;;;;;;;;;;;;;;;;;;IAmBAG,uB;;;AAEC;;;;;;;AAOA,qCAA+C;AAAA,QAAzBC,SAAyB,uEAAJ,IAAI;AAAA;AAAzB,SAAAA,SAAA,GAAAA,SAAA;AACrB,SAAKA,SAAL,GAAiBA,SAAjB;AACA;;;;;AAIA;AACAC,IAAAA,U,EACAC,e,EACAC,I,EACAC,kB;AACA;AACAC,IAAAA,G,EACAC,C,EAAmC,CAEnC;AACA;;;oCAISL,U,EACAM,G,EACTC,U,EACAC,S,EACAC,K,EACAC,S,EACSC,O,EAAqB;AAC9B,UAAI,KAAKZ,SAAL,IAAkB,CAACU,KAAvB,EAA8B;AAC7B;AACA;;AAED,UAAIG,QAAQ,GAAW,KAAKC,sBAAL,CAA4Bb,UAA5B,EAAwCM,GAAxC,CAAvB;AACA,UAAIQ,eAAe,GAAW,KAAKC,kBAAL,CAAwBL,SAAxB,EAAmCC,OAAnC,CAA9B;AACA,UAAIK,IAAI,GAAWhB,UAAU,CAACiB,WAAX,CAAuBC,OAAvB,CAA+BrB,UAAA,CAAAsB,QAAA,CAASC,EAAT,CAAYb,UAAZ,EAAwBC,SAAxB,CAA/B,CAAnB;AACA,UAAIa,OAAO,+BAAgCT,QAAhC,yBAAuDE,eAAvD,sBAAkFE,IAAlF,MAAX;AACAhB,MAAAA,UAAU,CAACsB,oBAAX,CAAgCD,OAAhC;AACA;;;gDAISrB,U,EACAM,G,EACTC,U,EACAC,S,EACAM,e,EACSS,a,EAA6B;AACtC,UAAIC,MAAM,GAAW,8CAArB;AACA,UAAIZ,QAAQ,GAAW,KAAKC,sBAAL,CAA4Bb,UAA5B,EAAwCM,GAAxC,CAAvB;AACA,UAAIU,IAAI,GAAWhB,UAAU,CAACiB,WAAX,CAAuBC,OAAvB,CAA+BrB,UAAA,CAAAsB,QAAA,CAASC,EAAT,CAAYb,UAAZ,EAAwBC,SAAxB,CAA/B,CAAnB;AACA,UAAIa,OAAO,2CAA4CT,QAA5C,sBAAgEI,IAAhE,MAAX;AACAhB,MAAAA,UAAU,CAACsB,oBAAX,CAAgCD,OAAhC;AACA;;;6CAISrB,U,EACAM,G,EACTC,U,EACAC,S,EACAiB,U,EACSC,W,EAA2B;AACpC,UAAIF,MAAM,GAAW,2CAArB;AACA,UAAIZ,QAAQ,GAAW,KAAKC,sBAAL,CAA4Bb,UAA5B,EAAwCM,GAAxC,CAAvB;AACA,UAAIU,IAAI,GAAWhB,UAAU,CAACiB,WAAX,CAAuBC,OAAvB,CAA+BrB,UAAA,CAAAsB,QAAA,CAASC,EAAT,CAAYb,UAAZ,EAAwBC,SAAxB,CAA/B,CAAnB;AACA,UAAIa,OAAO,wCAAyCT,QAAzC,sBAA6DI,IAA7D,MAAX;AACAhB,MAAAA,UAAU,CAACsB,oBAAX,CAAgCD,OAAhC;AACA;;;2CAGSrB,U,EACAM,G,EAAQ;AACjB,UAAIM,QAAQ,GAAWN,GAAG,CAACM,QAA3B;AACA,UAAIe,SAAS,GAAWrB,GAAG,CAACsB,aAAJ,CAAkBD,SAA1C;AAEA,UAAIE,SAAS,GAAa7B,UAAU,CAAC6B,SAArC;;AACA,UAAIF,SAAS,GAAG,CAAZ,IAAiBA,SAAS,IAAIE,SAAS,CAACjD,MAA5C,EAAoD;AACnD,eAAOgC,QAAQ,CAACkB,QAAT,EAAP;AACA;;AAED,UAAIC,QAAQ,GAAWF,SAAS,CAACF,SAAD,CAAhC;;AACA,UAAI,CAACI,QAAL,EAAe;AACd,eAAOnB,QAAQ,CAACkB,QAAT,EAAP;AACA;;AAED,uBAAUlB,QAAV,eAAuBmB,QAAvB;AACA;AAED;;;;;;;;;;;;;;uCAY6BC,Y,EAA2CrB,O,EAAqB;AAC5F,UAAIqB,YAAY,IAAI,IAApB,EAA0B;AACzB,eAAOA,YAAP;AACA;;AAED,UAAIC,MAAM,GAAW,IAAIvC,QAAA,CAAAwC,MAAJ,EAArB;AAL4F;AAAA;AAAA;;AAAA;AAM5F,6BAAmBvB,OAAnB,8HAA4B;AAAA,cAAnBwB,MAAmB;AAC3BF,UAAAA,MAAM,CAACG,GAAP,CAAWD,MAAM,CAACE,GAAlB;AACA;AAR2F;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAU5F,aAAOJ,MAAP;AACA;;;;;AAzGD5D,UAAA,CAAA,CADCuB,YAAA,CAAA0C,QACD,CAAA,EDgEExC,uBAAuB,CAACyC,SChE1B,EDgEqC,aChErC,EDgEoD,IChEpD,CAAA;;AAcAlE,UAAA,CAAA,CADCuB,YAAA,CAAA0C,QACD,EACEjD,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CADF,EAEEnD,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CAFF,EAOEnD,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CAPF,CAAA,EDwDE1C,uBAAuB,CAACyC,SCxD1B,EDwDqC,iBCxDrC,EDwDwD,ICxDxD,CAAA;;AAoBAlE,UAAA,CAAA,CADCuB,YAAA,CAAA0C,QACD,EACEjD,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CADF,EAEEnD,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CAFF,EAMEnD,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CANF,CAAA,ED0CE1C,uBAAuB,CAACyC,SC1C1B,ED0CqC,6BC1CrC,ED0CoE,IC1CpE,CAAA;;AAeAlE,UAAA,CAAA,CADCuB,YAAA,CAAA0C,QACD,EACEjD,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CADF,EAEEnD,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CAFF,EAMEnD,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CANF,CAAA,EDiCE1C,uBAAuB,CAACyC,SCjC1B,EDiCqC,0BCjCrC,EDiCiE,ICjCjE,CAAA;;AAcAlE,UAAA,CAAA,CACEgB,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CADF,EAEEnD,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CAFF,CAAA,EDuBE1C,uBAAuB,CAACyC,SCvB1B,EDuBqC,wBCvBrC,EDuB+D,ICvB/D,CAAA;;AA+BAlE,UAAA,CAAA,CADCuB,YAAA,CAAA4C,OACD,EAAgEnD,OAAA,CAAA,CAAA,EAAAO,YAAA,CAAA4C,OAAA,CAAhE,CAAA,EDJE1C,uBAAuB,CAACyC,SCI1B,EDJqC,oBCIrC,EDJ2D,ICI3D,CAAA;;AA5GD/C,OAAA,CAAAM,uBAAA,GAAAA,uBAAA","file":"DiagnosticErrorListener.js","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst BitSet_1 = require(\"./misc/BitSet\");\nconst Decorators_1 = require(\"./Decorators\");\nconst Interval_1 = require(\"./misc/Interval\");\n/**\n * This implementation of {@link ANTLRErrorListener} can be used to identify\n * certain potential correctness and performance problems in grammars. \"Reports\"\n * are made by calling {@link Parser#notifyErrorListeners} with the appropriate\n * message.\n *\n * * **Ambiguities**: These are cases where more than one path through the\n *   grammar can match the input.\n * * **Weak context sensitivity**: These are cases where full-context\n *   prediction resolved an SLL conflict to a unique alternative which equaled the\n *   minimum alternative of the SLL conflict.\n * * **Strong (forced) context sensitivity**: These are cases where the\n *   full-context prediction resolved an SLL conflict to a unique alternative,\n *   *and* the minimum alternative of the SLL conflict was found to not be\n *   a truly viable alternative. Two-stage parsing cannot be used for inputs where\n *   this situation occurs.\n *\n * @author Sam Harwell\n */\nclass DiagnosticErrorListener {\n    /**\n     * Initializes a new instance of {@link DiagnosticErrorListener}, specifying\n     * whether all ambiguities or only exact ambiguities are reported.\n     *\n     * @param exactOnly `true` to report only exact ambiguities, otherwise\n     * `false` to report all ambiguities.  Defaults to true.\n     */\n    constructor(exactOnly = true) {\n        this.exactOnly = exactOnly;\n        this.exactOnly = exactOnly;\n    }\n    syntaxError(\n    /*@NotNull*/\n    recognizer, offendingSymbol, line, charPositionInLine, \n    /*@NotNull*/\n    msg, e) {\n        // intentionally empty\n    }\n    reportAmbiguity(recognizer, dfa, startIndex, stopIndex, exact, ambigAlts, configs) {\n        if (this.exactOnly && !exact) {\n            return;\n        }\n        let decision = this.getDecisionDescription(recognizer, dfa);\n        let conflictingAlts = this.getConflictingAlts(ambigAlts, configs);\n        let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));\n        let message = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;\n        recognizer.notifyErrorListeners(message);\n    }\n    reportAttemptingFullContext(recognizer, dfa, startIndex, stopIndex, conflictingAlts, conflictState) {\n        let format = \"reportAttemptingFullContext d=%s, input='%s'\";\n        let decision = this.getDecisionDescription(recognizer, dfa);\n        let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));\n        let message = `reportAttemptingFullContext d=${decision}, input='${text}'`;\n        recognizer.notifyErrorListeners(message);\n    }\n    reportContextSensitivity(recognizer, dfa, startIndex, stopIndex, prediction, acceptState) {\n        let format = \"reportContextSensitivity d=%s, input='%s'\";\n        let decision = this.getDecisionDescription(recognizer, dfa);\n        let text = recognizer.inputStream.getText(Interval_1.Interval.of(startIndex, stopIndex));\n        let message = `reportContextSensitivity d=${decision}, input='${text}'`;\n        recognizer.notifyErrorListeners(message);\n    }\n    getDecisionDescription(recognizer, dfa) {\n        let decision = dfa.decision;\n        let ruleIndex = dfa.atnStartState.ruleIndex;\n        let ruleNames = recognizer.ruleNames;\n        if (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n            return decision.toString();\n        }\n        let ruleName = ruleNames[ruleIndex];\n        if (!ruleName) {\n            return decision.toString();\n        }\n        return `${decision} (${ruleName})`;\n    }\n    /**\n     * Computes the set of conflicting or ambiguous alternatives from a\n     * configuration set, if that information was not already provided by the\n     * parser.\n     *\n     * @param reportedAlts The set of conflicting or ambiguous alternatives, as\n     * reported by the parser.\n     * @param configs The conflicting or ambiguous configuration set.\n     * @returns Returns `reportedAlts` if it is not `undefined`, otherwise\n     * returns the set of alternatives represented in `configs`.\n     */\n    getConflictingAlts(reportedAlts, configs) {\n        if (reportedAlts != null) {\n            return reportedAlts;\n        }\n        let result = new BitSet_1.BitSet();\n        for (let config of configs) {\n            result.set(config.alt);\n        }\n        return result;\n    }\n}\n__decorate([\n    Decorators_1.Override\n], DiagnosticErrorListener.prototype, \"syntaxError\", null);\n__decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(6, Decorators_1.NotNull)\n], DiagnosticErrorListener.prototype, \"reportAmbiguity\", null);\n__decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(5, Decorators_1.NotNull)\n], DiagnosticErrorListener.prototype, \"reportAttemptingFullContext\", null);\n__decorate([\n    Decorators_1.Override,\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull),\n    __param(5, Decorators_1.NotNull)\n], DiagnosticErrorListener.prototype, \"reportContextSensitivity\", null);\n__decorate([\n    __param(0, Decorators_1.NotNull),\n    __param(1, Decorators_1.NotNull)\n], DiagnosticErrorListener.prototype, \"getDecisionDescription\", null);\n__decorate([\n    Decorators_1.NotNull,\n    __param(1, Decorators_1.NotNull)\n], DiagnosticErrorListener.prototype, \"getConflictingAlts\", null);\nexports.DiagnosticErrorListener = DiagnosticErrorListener;\n","/*!\n * Copyright 2016 The ANTLR Project. All rights reserved.\n * Licensed under the BSD-3-Clause license. See LICENSE file in the project root for license information.\n */\n\n// ConvertTo-TS run at 2016-10-04T11:26:51.2133685-07:00\n\nimport { ATNConfig } from \"./atn/ATNConfig\";\nimport { ATNConfigSet } from \"./atn/ATNConfigSet\";\nimport { BitSet } from \"./misc/BitSet\";\nimport { DFA } from \"./dfa/DFA\";\nimport { Parser } from \"./Parser\";\nimport { ParserErrorListener } from \"./ParserErrorListener\";\nimport { RecognitionException } from \"./RecognitionException\";\nimport { Recognizer } from \"./Recognizer\";\nimport { SimulatorState } from \"./atn/SimulatorState\";\nimport { Token } from \"./Token\";\nimport { Override, NotNull } from \"./Decorators\";\nimport { Interval } from \"./misc/Interval\";\n\n/**\n * This implementation of {@link ANTLRErrorListener} can be used to identify\n * certain potential correctness and performance problems in grammars. \"Reports\"\n * are made by calling {@link Parser#notifyErrorListeners} with the appropriate\n * message.\n *\n * * **Ambiguities**: These are cases where more than one path through the\n *   grammar can match the input.\n * * **Weak context sensitivity**: These are cases where full-context\n *   prediction resolved an SLL conflict to a unique alternative which equaled the\n *   minimum alternative of the SLL conflict.\n * * **Strong (forced) context sensitivity**: These are cases where the\n *   full-context prediction resolved an SLL conflict to a unique alternative,\n *   *and* the minimum alternative of the SLL conflict was found to not be\n *   a truly viable alternative. Two-stage parsing cannot be used for inputs where\n *   this situation occurs.\n *\n * @author Sam Harwell\n */\nexport class DiagnosticErrorListener implements ParserErrorListener {\n\n\t/**\n\t * Initializes a new instance of {@link DiagnosticErrorListener}, specifying\n\t * whether all ambiguities or only exact ambiguities are reported.\n\t *\n\t * @param exactOnly `true` to report only exact ambiguities, otherwise\n\t * `false` to report all ambiguities.  Defaults to true.\n\t */\n\tconstructor(protected exactOnly: boolean = true) {\n\t\tthis.exactOnly = exactOnly;\n\t}\n\n\t@Override\n\tpublic syntaxError<T extends Token>(\n\t\t/*@NotNull*/\n\t\trecognizer: Recognizer<T, any>,\n\t\toffendingSymbol: T | undefined,\n\t\tline: number,\n\t\tcharPositionInLine: number,\n\t\t/*@NotNull*/\n\t\tmsg: string,\n\t\te: RecognitionException | undefined): void\n\t{\n\t\t// intentionally empty\n\t}\n\n\t@Override\n\tpublic reportAmbiguity(\n\t\t@NotNull recognizer: Parser,\n\t\t@NotNull dfa: DFA,\n\t\tstartIndex: number,\n\t\tstopIndex: number,\n\t\texact: boolean,\n\t\tambigAlts: BitSet | undefined,\n\t\t@NotNull configs: ATNConfigSet): void {\n\t\tif (this.exactOnly && !exact) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet decision: string = this.getDecisionDescription(recognizer, dfa);\n\t\tlet conflictingAlts: BitSet = this.getConflictingAlts(ambigAlts, configs);\n\t\tlet text: string = recognizer.inputStream.getText(Interval.of(startIndex, stopIndex));\n\t\tlet message: string = `reportAmbiguity d=${decision}: ambigAlts=${conflictingAlts}, input='${text}'`;\n\t\trecognizer.notifyErrorListeners(message);\n\t}\n\n\t@Override\n\tpublic reportAttemptingFullContext(\n\t\t@NotNull recognizer: Parser,\n\t\t@NotNull dfa: DFA,\n\t\tstartIndex: number,\n\t\tstopIndex: number,\n\t\tconflictingAlts: BitSet | undefined,\n\t\t@NotNull conflictState: SimulatorState): void {\n\t\tlet format: string = \"reportAttemptingFullContext d=%s, input='%s'\";\n\t\tlet decision: string = this.getDecisionDescription(recognizer, dfa);\n\t\tlet text: string = recognizer.inputStream.getText(Interval.of(startIndex, stopIndex));\n\t\tlet message: string = `reportAttemptingFullContext d=${decision}, input='${text}'`;\n\t\trecognizer.notifyErrorListeners(message);\n\t}\n\n\t@Override\n\tpublic reportContextSensitivity(\n\t\t@NotNull recognizer: Parser,\n\t\t@NotNull dfa: DFA,\n\t\tstartIndex: number,\n\t\tstopIndex: number,\n\t\tprediction: number,\n\t\t@NotNull acceptState: SimulatorState): void {\n\t\tlet format: string = \"reportContextSensitivity d=%s, input='%s'\";\n\t\tlet decision: string = this.getDecisionDescription(recognizer, dfa);\n\t\tlet text: string = recognizer.inputStream.getText(Interval.of(startIndex, stopIndex));\n\t\tlet message: string = `reportContextSensitivity d=${decision}, input='${text}'`;\n\t\trecognizer.notifyErrorListeners(message);\n\t}\n\n\tprotected getDecisionDescription(\n\t\t@NotNull recognizer: Parser,\n\t\t@NotNull dfa: DFA): string {\n\t\tlet decision: number = dfa.decision;\n\t\tlet ruleIndex: number = dfa.atnStartState.ruleIndex;\n\n\t\tlet ruleNames: string[] = recognizer.ruleNames;\n\t\tif (ruleIndex < 0 || ruleIndex >= ruleNames.length) {\n\t\t\treturn decision.toString();\n\t\t}\n\n\t\tlet ruleName: string = ruleNames[ruleIndex];\n\t\tif (!ruleName) {\n\t\t\treturn decision.toString();\n\t\t}\n\n\t\treturn `${decision} (${ruleName})`;\n\t}\n\n\t/**\n\t * Computes the set of conflicting or ambiguous alternatives from a\n\t * configuration set, if that information was not already provided by the\n\t * parser.\n\t *\n\t * @param reportedAlts The set of conflicting or ambiguous alternatives, as\n\t * reported by the parser.\n\t * @param configs The conflicting or ambiguous configuration set.\n\t * @returns Returns `reportedAlts` if it is not `undefined`, otherwise\n\t * returns the set of alternatives represented in `configs`.\n\t */\n\t@NotNull\n\tprotected getConflictingAlts(reportedAlts: BitSet | undefined, @NotNull configs: ATNConfigSet): BitSet {\n\t\tif (reportedAlts != null) {\n\t\t\treturn reportedAlts;\n\t\t}\n\n\t\tlet result: BitSet = new BitSet();\n\t\tfor (let config of configs) {\n\t\t\tresult.set(config.alt);\n\t\t}\n\n\t\treturn result;\n\t}\n}\n"]}